(function(){const E=document.createElement("link").relList;if(E&&E.supports&&E.supports("modulepreload"))return;for(const re of document.querySelectorAll('link[rel="modulepreload"]'))te(re);new MutationObserver(re=>{for(const ne of re)if(ne.type==="childList")for(const ie of ne.addedNodes)ie.tagName==="LINK"&&ie.rel==="modulepreload"&&te(ie)}).observe(document,{childList:!0,subtree:!0});function ee(re){const ne={};return re.integrity&&(ne.integrity=re.integrity),re.referrerPolicy&&(ne.referrerPolicy=re.referrerPolicy),re.crossOrigin==="use-credentials"?ne.credentials="include":re.crossOrigin==="anonymous"?ne.credentials="omit":ne.credentials="same-origin",ne}function te(re){if(re.ep)return;re.ep=!0;const ne=ee(re);fetch(re.href,ne)}})();var n$1,l$3,u$2,t$2,o$3,r$2,f$2,e$2,c$2={},s$5=[],a$2=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,v$3=Array.isArray;function h$2(J,E){for(var ee in E)J[ee]=E[ee];return J}function p$3(J){var E=J.parentNode;E&&E.removeChild(J)}function y$2(J,E,ee){var te,re,ne,ie={};for(ne in E)ne=="key"?te=E[ne]:ne=="ref"?re=E[ne]:ie[ne]=E[ne];if(arguments.length>2&&(ie.children=arguments.length>3?n$1.call(arguments,2):ee),typeof J=="function"&&J.defaultProps!=null)for(ne in J.defaultProps)ie[ne]===void 0&&(ie[ne]=J.defaultProps[ne]);return d$4(J,ie,te,re,null)}function d$4(J,E,ee,te,re){var ne={type:J,props:E,key:ee,ref:te,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:re??++u$2};return re==null&&l$3.vnode!=null&&l$3.vnode(ne),ne}function k$1(J){return J.children}function b$2(J,E){this.props=J,this.context=E}function g$2(J,E){if(E==null)return J.__?g$2(J.__,J.__.__k.indexOf(J)+1):null;for(var ee;E<J.__k.length;E++)if((ee=J.__k[E])!=null&&ee.__e!=null)return ee.__e;return typeof J.type=="function"?g$2(J):null}function m$2(J){var E,ee;if((J=J.__)!=null&&J.__c!=null){for(J.__e=J.__c.base=null,E=0;E<J.__k.length;E++)if((ee=J.__k[E])!=null&&ee.__e!=null){J.__e=J.__c.base=ee.__e;break}return m$2(J)}}function w$4(J){(!J.__d&&(J.__d=!0)&&t$2.push(J)&&!x.__r++||o$3!==l$3.debounceRendering)&&((o$3=l$3.debounceRendering)||r$2)(x)}function x(){var J,E,ee,te,re,ne,ie,se;for(t$2.sort(f$2);J=t$2.shift();)J.__d&&(E=t$2.length,te=void 0,re=void 0,ie=(ne=(ee=J).__v).__e,(se=ee.__P)&&(te=[],(re=h$2({},ne)).__v=ne.__v+1,L$1(se,ne,re,ee.__n,se.ownerSVGElement!==void 0,ne.__h!=null?[ie]:null,te,ie??g$2(ne),ne.__h),M$1(te,ne),ne.__e!=ie&&m$2(ne)),t$2.length>E&&t$2.sort(f$2));x.__r=0}function P$2(J,E,ee,te,re,ne,ie,se,oe,ae){var ce,le,he,de,ue,pe,ye,me=te&&te.__k||s$5,be=me.length;for(ee.__k=[],ce=0;ce<E.length;ce++)if((de=ee.__k[ce]=(de=E[ce])==null||typeof de=="boolean"||typeof de=="function"?null:typeof de=="string"||typeof de=="number"||typeof de=="bigint"?d$4(null,de,null,null,de):v$3(de)?d$4(k$1,{children:de},null,null,null):de.__b>0?d$4(de.type,de.props,de.key,de.ref?de.ref:null,de.__v):de)!=null){if(de.__=ee,de.__b=ee.__b+1,(he=me[ce])===null||he&&de.key==he.key&&de.type===he.type)me[ce]=void 0;else for(le=0;le<be;le++){if((he=me[le])&&de.key==he.key&&de.type===he.type){me[le]=void 0;break}he=null}L$1(J,de,he=he||c$2,re,ne,ie,se,oe,ae),ue=de.__e,(le=de.ref)&&he.ref!=le&&(ye||(ye=[]),he.ref&&ye.push(he.ref,null,de),ye.push(le,de.__c||ue,de)),ue!=null?(pe==null&&(pe=ue),typeof de.type=="function"&&de.__k===he.__k?de.__d=oe=C$1(de,oe,J):oe=$$1(J,de,he,me,ue,oe),typeof ee.type=="function"&&(ee.__d=oe)):oe&&he.__e==oe&&oe.parentNode!=J&&(oe=g$2(he))}for(ee.__e=pe,ce=be;ce--;)me[ce]!=null&&(typeof ee.type=="function"&&me[ce].__e!=null&&me[ce].__e==ee.__d&&(ee.__d=A(te).nextSibling),q$2(me[ce],me[ce]));if(ye)for(ce=0;ce<ye.length;ce++)O(ye[ce],ye[++ce],ye[++ce])}function C$1(J,E,ee){for(var te,re=J.__k,ne=0;re&&ne<re.length;ne++)(te=re[ne])&&(te.__=J,E=typeof te.type=="function"?C$1(te,E,ee):$$1(ee,te,te,re,te.__e,E));return E}function S$1(J,E){return E=E||[],J==null||typeof J=="boolean"||(v$3(J)?J.some(function(ee){S$1(ee,E)}):E.push(J)),E}function $$1(J,E,ee,te,re,ne){var ie,se,oe;if(E.__d!==void 0)ie=E.__d,E.__d=void 0;else if(ee==null||re!=ne||re.parentNode==null)e:if(ne==null||ne.parentNode!==J)J.appendChild(re),ie=null;else{for(se=ne,oe=0;(se=se.nextSibling)&&oe<te.length;oe+=1)if(se==re)break e;J.insertBefore(re,ne),ie=ne}return ie!==void 0?ie:re.nextSibling}function A(J){var E,ee,te;if(J.type==null||typeof J.type=="string")return J.__e;if(J.__k){for(E=J.__k.length-1;E>=0;E--)if((ee=J.__k[E])&&(te=A(ee)))return te}return null}function H$1(J,E,ee,te,re){var ne;for(ne in ee)ne==="children"||ne==="key"||ne in E||T$2(J,ne,null,ee[ne],te);for(ne in E)re&&typeof E[ne]!="function"||ne==="children"||ne==="key"||ne==="value"||ne==="checked"||ee[ne]===E[ne]||T$2(J,ne,E[ne],ee[ne],te)}function I$1(J,E,ee){E[0]==="-"?J.setProperty(E,ee??""):J[E]=ee==null?"":typeof ee!="number"||a$2.test(E)?ee:ee+"px"}function T$2(J,E,ee,te,re){var ne;e:if(E==="style")if(typeof ee=="string")J.style.cssText=ee;else{if(typeof te=="string"&&(J.style.cssText=te=""),te)for(E in te)ee&&E in ee||I$1(J.style,E,"");if(ee)for(E in ee)te&&ee[E]===te[E]||I$1(J.style,E,ee[E])}else if(E[0]==="o"&&E[1]==="n")ne=E!==(E=E.replace(/Capture$/,"")),E=E.toLowerCase()in J?E.toLowerCase().slice(2):E.slice(2),J.l||(J.l={}),J.l[E+ne]=ee,ee?te||J.addEventListener(E,ne?z$2:j$2,ne):J.removeEventListener(E,ne?z$2:j$2,ne);else if(E!=="dangerouslySetInnerHTML"){if(re)E=E.replace(/xlink(H|:h)/,"h").replace(/sName$/,"s");else if(E!=="width"&&E!=="height"&&E!=="href"&&E!=="list"&&E!=="form"&&E!=="tabIndex"&&E!=="download"&&E!=="rowSpan"&&E!=="colSpan"&&E in J)try{J[E]=ee??"";break e}catch{}typeof ee=="function"||(ee==null||ee===!1&&E[4]!=="-"?J.removeAttribute(E):J.setAttribute(E,ee))}}function j$2(J){return this.l[J.type+!1](l$3.event?l$3.event(J):J)}function z$2(J){return this.l[J.type+!0](l$3.event?l$3.event(J):J)}function L$1(J,E,ee,te,re,ne,ie,se,oe){var ae,ce,le,he,de,ue,pe,ye,me,be,_e,we,$e,ve,fe,Ee=E.type;if(E.constructor!==void 0)return null;ee.__h!=null&&(oe=ee.__h,se=E.__e=ee.__e,E.__h=null,ne=[se]),(ae=l$3.__b)&&ae(E);try{e:if(typeof Ee=="function"){if(ye=E.props,me=(ae=Ee.contextType)&&te[ae.__c],be=ae?me?me.props.value:ae.__:te,ee.__c?pe=(ce=E.__c=ee.__c).__=ce.__E:("prototype"in Ee&&Ee.prototype.render?E.__c=ce=new Ee(ye,be):(E.__c=ce=new b$2(ye,be),ce.constructor=Ee,ce.render=B$2),me&&me.sub(ce),ce.props=ye,ce.state||(ce.state={}),ce.context=be,ce.__n=te,le=ce.__d=!0,ce.__h=[],ce._sb=[]),ce.__s==null&&(ce.__s=ce.state),Ee.getDerivedStateFromProps!=null&&(ce.__s==ce.state&&(ce.__s=h$2({},ce.__s)),h$2(ce.__s,Ee.getDerivedStateFromProps(ye,ce.__s))),he=ce.props,de=ce.state,ce.__v=E,le)Ee.getDerivedStateFromProps==null&&ce.componentWillMount!=null&&ce.componentWillMount(),ce.componentDidMount!=null&&ce.__h.push(ce.componentDidMount);else{if(Ee.getDerivedStateFromProps==null&&ye!==he&&ce.componentWillReceiveProps!=null&&ce.componentWillReceiveProps(ye,be),!ce.__e&&ce.shouldComponentUpdate!=null&&ce.shouldComponentUpdate(ye,ce.__s,be)===!1||E.__v===ee.__v){for(E.__v!==ee.__v&&(ce.props=ye,ce.state=ce.__s,ce.__d=!1),ce.__e=!1,E.__e=ee.__e,E.__k=ee.__k,E.__k.forEach(function(ke){ke&&(ke.__=E)}),_e=0;_e<ce._sb.length;_e++)ce.__h.push(ce._sb[_e]);ce._sb=[],ce.__h.length&&ie.push(ce);break e}ce.componentWillUpdate!=null&&ce.componentWillUpdate(ye,ce.__s,be),ce.componentDidUpdate!=null&&ce.__h.push(function(){ce.componentDidUpdate(he,de,ue)})}if(ce.context=be,ce.props=ye,ce.__P=J,we=l$3.__r,$e=0,"prototype"in Ee&&Ee.prototype.render){for(ce.state=ce.__s,ce.__d=!1,we&&we(E),ae=ce.render(ce.props,ce.state,ce.context),ve=0;ve<ce._sb.length;ve++)ce.__h.push(ce._sb[ve]);ce._sb=[]}else do ce.__d=!1,we&&we(E),ae=ce.render(ce.props,ce.state,ce.context),ce.state=ce.__s;while(ce.__d&&++$e<25);ce.state=ce.__s,ce.getChildContext!=null&&(te=h$2(h$2({},te),ce.getChildContext())),le||ce.getSnapshotBeforeUpdate==null||(ue=ce.getSnapshotBeforeUpdate(he,de)),P$2(J,v$3(fe=ae!=null&&ae.type===k$1&&ae.key==null?ae.props.children:ae)?fe:[fe],E,ee,te,re,ne,ie,se,oe),ce.base=E.__e,E.__h=null,ce.__h.length&&ie.push(ce),pe&&(ce.__E=ce.__=null),ce.__e=!1}else ne==null&&E.__v===ee.__v?(E.__k=ee.__k,E.__e=ee.__e):E.__e=N(ee.__e,E,ee,te,re,ne,ie,oe);(ae=l$3.diffed)&&ae(E)}catch(ke){E.__v=null,(oe||ne!=null)&&(E.__e=se,E.__h=!!oe,ne[ne.indexOf(se)]=null),l$3.__e(ke,E,ee)}}function M$1(J,E){l$3.__c&&l$3.__c(E,J),J.some(function(ee){try{J=ee.__h,ee.__h=[],J.some(function(te){te.call(ee)})}catch(te){l$3.__e(te,ee.__v)}})}function N(J,E,ee,te,re,ne,ie,se){var oe,ae,ce,le=ee.props,he=E.props,de=E.type,ue=0;if(de==="svg"&&(re=!0),ne!=null){for(;ue<ne.length;ue++)if((oe=ne[ue])&&"setAttribute"in oe==!!de&&(de?oe.localName===de:oe.nodeType===3)){J=oe,ne[ue]=null;break}}if(J==null){if(de===null)return document.createTextNode(he);J=re?document.createElementNS("http://www.w3.org/2000/svg",de):document.createElement(de,he.is&&he),ne=null,se=!1}if(de===null)le===he||se&&J.data===he||(J.data=he);else{if(ne=ne&&n$1.call(J.childNodes),ae=(le=ee.props||c$2).dangerouslySetInnerHTML,ce=he.dangerouslySetInnerHTML,!se){if(ne!=null)for(le={},ue=0;ue<J.attributes.length;ue++)le[J.attributes[ue].name]=J.attributes[ue].value;(ce||ae)&&(ce&&(ae&&ce.__html==ae.__html||ce.__html===J.innerHTML)||(J.innerHTML=ce&&ce.__html||""))}if(H$1(J,he,le,re,se),ce)E.__k=[];else if(P$2(J,v$3(ue=E.props.children)?ue:[ue],E,ee,te,re&&de!=="foreignObject",ne,ie,ne?ne[0]:ee.__k&&g$2(ee,0),se),ne!=null)for(ue=ne.length;ue--;)ne[ue]!=null&&p$3(ne[ue]);se||("value"in he&&(ue=he.value)!==void 0&&(ue!==J.value||de==="progress"&&!ue||de==="option"&&ue!==le.value)&&T$2(J,"value",ue,le.value,!1),"checked"in he&&(ue=he.checked)!==void 0&&ue!==J.checked&&T$2(J,"checked",ue,le.checked,!1))}return J}function O(J,E,ee){try{typeof J=="function"?J(E):J.current=E}catch(te){l$3.__e(te,ee)}}function q$2(J,E,ee){var te,re;if(l$3.unmount&&l$3.unmount(J),(te=J.ref)&&(te.current&&te.current!==J.__e||O(te,null,E)),(te=J.__c)!=null){if(te.componentWillUnmount)try{te.componentWillUnmount()}catch(ne){l$3.__e(ne,E)}te.base=te.__P=null,J.__c=void 0}if(te=J.__k)for(re=0;re<te.length;re++)te[re]&&q$2(te[re],E,ee||typeof J.type!="function");ee||J.__e==null||p$3(J.__e),J.__=J.__e=J.__d=void 0}function B$2(J,E,ee){return this.constructor(J,ee)}function D$1(J,E,ee){var te,re,ne;l$3.__&&l$3.__(J,E),re=(te=typeof ee=="function")?null:ee&&ee.__k||E.__k,ne=[],L$1(E,J=(!te&&ee||E).__k=y$2(k$1,null,[J]),re||c$2,c$2,E.ownerSVGElement!==void 0,!te&&ee?[ee]:re?null:E.firstChild?n$1.call(E.childNodes):null,ne,!te&&ee?ee:re?re.__e:E.firstChild,te),M$1(ne,J)}function G(J,E){var ee={__c:E="__cC"+e$2++,__:J,Consumer:function(te,re){return te.children(re)},Provider:function(te){var re,ne;return this.getChildContext||(re=[],(ne={})[E]=this,this.getChildContext=function(){return ne},this.shouldComponentUpdate=function(ie){this.props.value!==ie.value&&re.some(function(se){se.__e=!0,w$4(se)})},this.sub=function(ie){re.push(ie);var se=ie.componentWillUnmount;ie.componentWillUnmount=function(){re.splice(re.indexOf(ie),1),se&&se.call(ie)}}),te.children}};return ee.Provider.__=ee.Consumer.contextType=ee}n$1=s$5.slice,l$3={__e:function(J,E,ee,te){for(var re,ne,ie;E=E.__;)if((re=E.__c)&&!re.__)try{if((ne=re.constructor)&&ne.getDerivedStateFromError!=null&&(re.setState(ne.getDerivedStateFromError(J)),ie=re.__d),re.componentDidCatch!=null&&(re.componentDidCatch(J,te||{}),ie=re.__d),ie)return re.__E=re}catch(se){J=se}throw J}},u$2=0,b$2.prototype.setState=function(J,E){var ee;ee=this.__s!=null&&this.__s!==this.state?this.__s:this.__s=h$2({},this.state),typeof J=="function"&&(J=J(h$2({},ee),this.props)),J&&h$2(ee,J),J!=null&&this.__v&&(E&&this._sb.push(E),w$4(this))},b$2.prototype.forceUpdate=function(J){this.__v&&(this.__e=!0,J&&this.__h.push(J),w$4(this))},b$2.prototype.render=k$1,t$2=[],r$2=typeof Promise=="function"?Promise.prototype.then.bind(Promise.resolve()):setTimeout,f$2=function(J,E){return J.__v.__b-E.__v.__b},x.__r=0,e$2=0;var t$1,r$1,u$1,i$1,o$2=0,f$1=[],c$1=[],e$1=l$3.__b,a$1=l$3.__r,v$2=l$3.diffed,l$2=l$3.__c,m$1=l$3.unmount;function d$3(J,E){l$3.__h&&l$3.__h(r$1,J,o$2||E),o$2=0;var ee=r$1.__H||(r$1.__H={__:[],__h:[]});return J>=ee.__.length&&ee.__.push({__V:c$1}),ee.__[J]}function h$1(J){return o$2=1,s$4(B$1,J)}function s$4(J,E,ee){var te=d$3(t$1++,2);if(te.t=J,!te.__c&&(te.__=[ee?ee(E):B$1(void 0,E),function(se){var oe=te.__N?te.__N[0]:te.__[0],ae=te.t(oe,se);oe!==ae&&(te.__N=[ae,te.__[1]],te.__c.setState({}))}],te.__c=r$1,!r$1.u)){var re=function(se,oe,ae){if(!te.__c.__H)return!0;var ce=te.__c.__H.__.filter(function(he){return he.__c});if(ce.every(function(he){return!he.__N}))return!ne||ne.call(this,se,oe,ae);var le=!1;return ce.forEach(function(he){if(he.__N){var de=he.__[0];he.__=he.__N,he.__N=void 0,de!==he.__[0]&&(le=!0)}}),!(!le&&te.__c.props===se)&&(!ne||ne.call(this,se,oe,ae))};r$1.u=!0;var ne=r$1.shouldComponentUpdate,ie=r$1.componentWillUpdate;r$1.componentWillUpdate=function(se,oe,ae){if(this.__e){var ce=ne;ne=void 0,re(se,oe,ae),ne=ce}ie&&ie.call(this,se,oe,ae)},r$1.shouldComponentUpdate=re}return te.__N||te.__}function p$2(J,E){var ee=d$3(t$1++,3);!l$3.__s&&z$1(ee.__H,E)&&(ee.__=J,ee.i=E,r$1.__H.__h.push(ee))}function _$2(J){return o$2=5,F(function(){return{current:J}},[])}function F(J,E){var ee=d$3(t$1++,7);return z$1(ee.__H,E)?(ee.__V=J(),ee.i=E,ee.__h=J,ee.__V):ee.__}function T$1(J,E){return o$2=8,F(function(){return J},E)}function q$1(J){var E=r$1.context[J.__c],ee=d$3(t$1++,9);return ee.c=J,E?(ee.__==null&&(ee.__=!0,E.sub(r$1)),E.props.value):J.__}function b$1(){for(var J;J=f$1.shift();)if(J.__P&&J.__H)try{J.__H.__h.forEach(k),J.__H.__h.forEach(w$3),J.__H.__h=[]}catch(E){J.__H.__h=[],l$3.__e(E,J.__v)}}l$3.__b=function(J){r$1=null,e$1&&e$1(J)},l$3.__r=function(J){a$1&&a$1(J),t$1=0;var E=(r$1=J.__c).__H;E&&(u$1===r$1?(E.__h=[],r$1.__h=[],E.__.forEach(function(ee){ee.__N&&(ee.__=ee.__N),ee.__V=c$1,ee.__N=ee.i=void 0})):(E.__h.forEach(k),E.__h.forEach(w$3),E.__h=[])),u$1=r$1},l$3.diffed=function(J){v$2&&v$2(J);var E=J.__c;E&&E.__H&&(E.__H.__h.length&&(f$1.push(E)!==1&&i$1===l$3.requestAnimationFrame||((i$1=l$3.requestAnimationFrame)||j$1)(b$1)),E.__H.__.forEach(function(ee){ee.i&&(ee.__H=ee.i),ee.__V!==c$1&&(ee.__=ee.__V),ee.i=void 0,ee.__V=c$1})),u$1=r$1=null},l$3.__c=function(J,E){E.some(function(ee){try{ee.__h.forEach(k),ee.__h=ee.__h.filter(function(te){return!te.__||w$3(te)})}catch(te){E.some(function(re){re.__h&&(re.__h=[])}),E=[],l$3.__e(te,ee.__v)}}),l$2&&l$2(J,E)},l$3.unmount=function(J){m$1&&m$1(J);var E,ee=J.__c;ee&&ee.__H&&(ee.__H.__.forEach(function(te){try{k(te)}catch(re){E=re}}),ee.__H=void 0,E&&l$3.__e(E,ee.__v))};var g$1=typeof requestAnimationFrame=="function";function j$1(J){var E,ee=function(){clearTimeout(te),g$1&&cancelAnimationFrame(E),setTimeout(J)},te=setTimeout(ee,100);g$1&&(E=requestAnimationFrame(ee))}function k(J){var E=r$1,ee=J.__c;typeof ee=="function"&&(J.__c=void 0,ee()),r$1=E}function w$3(J){var E=r$1;J.__c=J.__(),r$1=E}function z$1(J,E){return!J||J.length!==E.length||E.some(function(ee,te){return ee!==J[te]})}function B$1(J,E){return typeof E=="function"?E(J):E}function S(J,E){for(var ee in E)J[ee]=E[ee];return J}function C(J,E){for(var ee in J)if(ee!=="__source"&&!(ee in E))return!0;for(var te in E)if(te!=="__source"&&J[te]!==E[te])return!0;return!1}function w$2(J){this.props=J}(w$2.prototype=new b$2).isPureReactComponent=!0,w$2.prototype.shouldComponentUpdate=function(J,E){return C(this.props,J)||C(this.state,E)};var R=l$3.__b;l$3.__b=function(J){J.type&&J.type.__f&&J.ref&&(J.props.ref=J.ref,J.ref=null),R&&R(J)};var T=l$3.__e;l$3.__e=function(J,E,ee,te){if(J.then){for(var re,ne=E;ne=ne.__;)if((re=ne.__c)&&re.__c)return E.__e==null&&(E.__e=ee.__e,E.__k=ee.__k),re.__c(J,E)}T(J,E,ee,te)};var I=l$3.unmount;function L(J,E,ee){return J&&(J.__c&&J.__c.__H&&(J.__c.__H.__.forEach(function(te){typeof te.__c=="function"&&te.__c()}),J.__c.__H=null),(J=S({},J)).__c!=null&&(J.__c.__P===ee&&(J.__c.__P=E),J.__c=null),J.__k=J.__k&&J.__k.map(function(te){return L(te,E,ee)})),J}function P$1(J,E,ee){return J&&(J.__v=null,J.__k=J.__k&&J.__k.map(function(te){return P$1(te,E,ee)}),J.__c&&J.__c.__P===E&&(J.__e&&ee.insertBefore(J.__e,J.__d),J.__c.__e=!0,J.__c.__P=ee)),J}function U(){this.__u=0,this.t=null,this.__b=null}function D(J){var E=J.__.__c;return E&&E.__a&&E.__a(J)}function M(){this.u=null,this.o=null}l$3.unmount=function(J){var E=J.__c;E&&E.__R&&E.__R(),E&&J.__h===!0&&(J.type=null),I&&I(J)},(U.prototype=new b$2).__c=function(J,E){var ee=E.__c,te=this;te.t==null&&(te.t=[]),te.t.push(ee);var re=D(te.__v),ne=!1,ie=function(){ne||(ne=!0,ee.__R=null,re?re(se):se())};ee.__R=ie;var se=function(){if(!--te.__u){if(te.state.__a){var ae=te.state.__a;te.__v.__k[0]=P$1(ae,ae.__c.__P,ae.__c.__O)}var ce;for(te.setState({__a:te.__b=null});ce=te.t.pop();)ce.forceUpdate()}},oe=E.__h===!0;te.__u++||oe||te.setState({__a:te.__b=te.__v.__k[0]}),J.then(ie,ie)},U.prototype.componentWillUnmount=function(){this.t=[]},U.prototype.render=function(J,E){if(this.__b){if(this.__v.__k){var ee=document.createElement("div"),te=this.__v.__k[0].__c;this.__v.__k[0]=L(this.__b,ee,te.__O=te.__P)}this.__b=null}var re=E.__a&&y$2(k$1,null,J.fallback);return re&&(re.__h=null),[y$2(k$1,null,E.__a?null:J.children),re]};var V$1=function(J,E,ee){if(++ee[1]===ee[0]&&J.o.delete(E),J.props.revealOrder&&(J.props.revealOrder[0]!=="t"||!J.o.size))for(ee=J.u;ee;){for(;ee.length>3;)ee.pop()();if(ee[1]<ee[0])break;J.u=ee=ee[2]}};function W(J){return this.getChildContext=function(){return J.context},J.children}function j(J){var E=this,ee=J.i;E.componentWillUnmount=function(){D$1(null,E.l),E.l=null,E.i=null},E.i&&E.i!==ee&&E.componentWillUnmount(),J.__v?(E.l||(E.i=ee,E.l={nodeType:1,parentNode:ee,childNodes:[],appendChild:function(te){this.childNodes.push(te),E.i.appendChild(te)},insertBefore:function(te,re){this.childNodes.push(te),E.i.appendChild(te)},removeChild:function(te){this.childNodes.splice(this.childNodes.indexOf(te)>>>1,1),E.i.removeChild(te)}}),D$1(y$2(W,{context:E.context},J.__v),E.l)):E.l&&E.componentWillUnmount()}function z(J,E){var ee=y$2(j,{__v:J,i:E});return ee.containerInfo=E,ee}(M.prototype=new b$2).__a=function(J){var E=this,ee=D(E.__v),te=E.o.get(J);return te[0]++,function(re){var ne=function(){E.props.revealOrder?(te.push(re),V$1(E,J,te)):re()};ee?ee(ne):ne()}},M.prototype.render=function(J){this.u=null,this.o=new Map;var E=S$1(J.children);J.revealOrder&&J.revealOrder[0]==="b"&&E.reverse();for(var ee=E.length;ee--;)this.o.set(E[ee],this.u=[1,0,this.u]);return J.children},M.prototype.componentDidUpdate=M.prototype.componentDidMount=function(){var J=this;this.o.forEach(function(E,ee){V$1(J,ee,E)})};var B=typeof Symbol<"u"&&Symbol.for&&Symbol.for("react.element")||60103,H=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,Z=/^on(Ani|Tra|Tou|BeforeInp|Compo)/,Y=/[A-Z0-9]/g,$=typeof document<"u",q=function(J){return(typeof Symbol<"u"&&typeof Symbol()=="symbol"?/fil|che|rad/:/fil|che|ra/).test(J)};b$2.prototype.isReactComponent={},["componentWillMount","componentWillReceiveProps","componentWillUpdate"].forEach(function(J){Object.defineProperty(b$2.prototype,J,{configurable:!0,get:function(){return this["UNSAFE_"+J]},set:function(E){Object.defineProperty(this,J,{configurable:!0,writable:!0,value:E})}})});var K=l$3.event;function Q(){}function X(){return this.cancelBubble}function nn(){return this.defaultPrevented}l$3.event=function(J){K&&(J=K(J));var E=J.currentTarget,ee=J.type;return ee!=="input"&&ee!=="change"||!E.h||Promise.resolve().then(function(){return function(te,re){re.value!=null&&Promise.resolve().then(function(){return re.value=re.v}),te==="change"&&re.checked!=null&&Promise.resolve().then(function(){return re.checked=re.v})}(ee,E)}),J.persist=Q,J.isPropagationStopped=X,J.isDefaultPrevented=nn,J.nativeEvent=J};var en={enumerable:!1,configurable:!0,get:function(){return this.class}},rn=l$3.vnode;l$3.vnode=function(J){typeof J.type=="string"&&function(E){var ee=E.props,te=E.type,re={};for(var ne in ee){var ie=ee[ne];if(!(ne==="value"&&"defaultValue"in ee&&ie==null||$&&ne==="children"&&te==="noscript"||ne==="class"||ne==="className")){var se=ne.toLowerCase();ne==="defaultValue"&&"value"in ee&&ee.value==null?ne="value":ne==="download"&&ie===!0?ie="":se==="ondoubleclick"?ne="ondblclick":se!=="onchange"||te!=="input"&&te!=="textarea"||q(ee.type)?se==="onfocus"?ne="onfocusin":se==="onblur"?ne="onfocusout":Z.test(ne)?ne=se:te.indexOf("-")===-1&&H.test(ne)?ne=ne.replace(Y,"-$&").toLowerCase():ie===null&&(ie=void 0):se=ne="oninput",se==="oninput"&&re[ne=se]&&(ne="oninputCapture"),re[ne]=ie}}te=="select"&&re.multiple&&Array.isArray(re.value)&&(re.value=S$1(ee.children).forEach(function(oe){oe.props.selected=re.value.indexOf(oe.props.value)!=-1})),te=="select"&&re.defaultValue!=null&&(re.value=S$1(ee.children).forEach(function(oe){oe.props.selected=re.multiple?re.defaultValue.indexOf(oe.props.value)!=-1:re.defaultValue==oe.props.value})),ee.class&&!ee.className?(re.class=ee.class,Object.defineProperty(re,"className",en)):(ee.className&&!ee.class||ee.class&&ee.className)&&(re.class=re.className=ee.className),E.props=re}(J),J.$$typeof=B,rn&&rn(J)};var un=l$3.__r;l$3.__r=function(J){un&&un(J),J.__c};var on=l$3.diffed;l$3.diffed=function(J){on&&on(J);var E=J.type,ee=J.props,te=J.__e,re=te&&te.h;te==null||E!=="input"&&E!=="textarea"&&E!=="select"||re===!1||(re||ee.oninput||ee.onchange||ee.onChange)&&(ee.value!=null?(te.h=!0,te.v=ee.value):ee.checked!=null?(te.h=!0,te.v=ee.checked):te.h=!1),te!=null&&J.type==="textarea"&&"value"in ee&&ee.value!==te.value&&(te.value=ee.value==null?"":ee.value)};var _$1=0;function o$1(J,E,ee,te,re,ne){var ie,se,oe={};for(se in E)se=="ref"?ie=E[se]:oe[se]=E[se];var ae={type:J,props:oe,key:ee,ref:ie,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:--_$1,__source:re,__self:ne};if(typeof J=="function"&&(ie=J.defaultProps))for(se in ie)oe[se]===void 0&&(oe[se]=ie[se]);return l$3.vnode&&l$3.vnode(ae),ae}const Head=({children:J})=>{const E=document.head;return z(o$1(k$1,{children:J}),E)},Layout=({children:J})=>o$1(k$1,{children:[o$1(Head,{children:[o$1("meta",{name:"apple-mobile-web-app-capable",content:"yes"}),o$1("link",{rel:"manifest",href:"/manifest.json"}),o$1("link",{rel:"icon",type:"image/png",href:"/favicon.png"})]}),o$1("main",{className:"h-full",children:J})]});function Link({href:J,children:E}){return o$1("a",{href:J,className:"font-semibold inline-flex items-center gap-1",children:E})}function AboutDialog(){return o$1(k$1,{children:[o$1("input",{type:"checkbox",id:"about-modal",className:"modal-toggle"}),o$1("label",{htmlFor:"about-modal",className:"modal cursor-pointer",children:o$1("label",{className:"modal-box relative",htmlFor:"",children:[o$1("div",{className:"relative h-12 flex place-content-center mb-4",children:o$1("img",{src:"/ipdm-logo.png",className:"md:w-12 md:h-12"})}),o$1("div",{className:"alert p-1 pl-2",children:o$1("div",{children:[o$1("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",className:"stroke-current flex-shrink-0 w-6 h-6",children:o$1("path",{"stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"2",d:"M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"})}),o$1("span",{className:"text-xs py-1",children:["This app is demo-tier! Use"," ",o$1(Link,{href:"https://signal.org/",children:"Signal"})," if you need the real deal."]})]})}),o$1("div",{className:"mt-4 text-sm",children:[o$1("p",{className:"text-center",children:"This is a work-in-progress decentralized secure messaging platform. For more information visit the source repository."}),o$1("p",{className:"text-center mt-4 inline-flex items-center gap-2 w-full justify-center",children:o$1(Link,{href:"https://github.com/zaach/ipdm",children:["Source"," ",o$1("svg",{id:"i-github",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 64 64",width:"16",height:"16",className:"inline-block",children:o$1("path",{"stroke-width":"0",fill:"currentColor",d:"M32 0 C14 0 0 14 0 32 0 53 19 62 22 62 24 62 24 61 24 60 L24 55 C17 57 14 53 13 50 13 50 13 49 11 47 10 46 6 44 10 44 13 44 15 48 15 48 18 52 22 51 24 50 24 48 26 46 26 46 18 45 12 42 12 31 12 27 13 24 15 22 15 22 13 18 15 13 15 13 20 13 24 17 27 15 37 15 40 17 44 13 49 13 49 13 51 20 49 22 49 22 51 24 52 27 52 31 52 42 45 45 38 46 39 47 40 49 40 52 L40 60 C40 61 40 62 42 62 45 62 64 53 64 32 64 14 50 0 32 0 Z"})})]})})]}),o$1("div",{className:"modal-action justify-center",children:o$1("label",{htmlFor:"about-modal",className:"btn btn-wide",children:"okay"})})]})})]})}function i(){throw new Error("Cycle detected")}function t(){if(n>1)n--;else{for(var J,E=!1;r!==void 0;){var ee=r;for(r=void 0,s$3++;ee!==void 0;){var te=ee.o;if(ee.o=void 0,ee.f&=-3,!(8&ee.f)&&d$2(ee))try{ee.c()}catch(re){E||(J=re,E=!0)}ee=te}}if(s$3=0,n--,E)throw J}}var o=void 0,r=void 0,n=0,s$3=0,f=0;function v$1(J){if(o!==void 0){var E=J.n;if(E===void 0||E.t!==o)return o.s=E={i:0,S:J,p:void 0,n:o.s,t:o,e:void 0,x:void 0,r:E},J.n=E,32&o.f&&J.S(E),E;if(E.i===-1)return E.i=0,E.p!==void 0&&(E.p.n=E.n,E.n!==void 0&&(E.n.p=E.p),E.p=void 0,E.n=o.s,o.s.p=E,o.s=E),E}}function e(J){this.v=J,this.i=0,this.n=void 0,this.t=void 0}e.prototype.h=function(){return!0};e.prototype.S=function(J){this.t!==J&&J.e===void 0&&(J.x=this.t,this.t!==void 0&&(this.t.e=J),this.t=J)};e.prototype.U=function(J){var E=J.e,ee=J.x;E!==void 0&&(E.x=ee,J.e=void 0),ee!==void 0&&(ee.e=E,J.x=void 0),J===this.t&&(this.t=ee)};e.prototype.subscribe=function(J){var E=this;return b(function(){var ee=E.value,te=32&this.f;this.f&=-33;try{J(ee)}finally{this.f|=te}})};e.prototype.valueOf=function(){return this.value};e.prototype.toString=function(){return this.value+""};e.prototype.peek=function(){return this.v};Object.defineProperty(e.prototype,"value",{get:function(){var J=v$1(this);return J!==void 0&&(J.i=this.i),this.v},set:function(J){if(J!==this.v){s$3>100&&i(),this.v=J,this.i++,f++,n++;try{for(var E=this.t;E!==void 0;E=E.x)E.t.N()}finally{t()}}}});function u(J){return new e(J)}function d$2(J){for(var E=J.s;E!==void 0;E=E.n)if(E.S.i!==E.i||!E.S.h()||E.S.i!==E.i)return!0;return!1}function c(J){for(var E=J.s;E!==void 0;E=E.n){var ee=E.S.n;ee!==void 0&&(E.r=ee),E.S.n=E,E.i=-1}}function a(J){for(var E=J.s,ee=void 0;E!==void 0;){var te=E.n;E.i===-1?(E.S.U(E),E.n=void 0):(ee!==void 0&&(ee.p=E),E.p=void 0,E.n=ee,ee=E),E.S.n=E.r,E.r!==void 0&&(E.r=void 0),E=te}J.s=ee}function l$1(J){e.call(this,void 0),this.x=J,this.s=void 0,this.g=f-1,this.f=4}(l$1.prototype=new e).h=function(){if(this.f&=-3,1&this.f)return!1;if((36&this.f)==32||(this.f&=-5,this.g===f))return!0;if(this.g=f,this.f|=1,this.i>0&&!d$2(this))return this.f&=-2,!0;var J=o;try{c(this),o=this;var E=this.x();(16&this.f||this.v!==E||this.i===0)&&(this.v=E,this.f&=-17,this.i++)}catch(ee){this.v=ee,this.f|=16,this.i++}return o=J,a(this),this.f&=-2,!0};l$1.prototype.S=function(J){if(this.t===void 0){this.f|=36;for(var E=this.s;E!==void 0;E=E.n)E.S.S(E)}e.prototype.S.call(this,J)};l$1.prototype.U=function(J){if(e.prototype.U.call(this,J),this.t===void 0){this.f&=-33;for(var E=this.s;E!==void 0;E=E.n)E.S.U(E)}};l$1.prototype.N=function(){if(!(2&this.f)){this.f|=6;for(var J=this.t;J!==void 0;J=J.x)J.t.N()}};l$1.prototype.peek=function(){if(this.h()||i(),16&this.f)throw this.v;return this.v};Object.defineProperty(l$1.prototype,"value",{get:function(){1&this.f&&i();var J=v$1(this);if(this.h(),J!==void 0&&(J.i=this.i),16&this.f)throw this.v;return this.v}});function w$1(J){return new l$1(J)}function y$1(J){var E=J.u;if(J.u=void 0,typeof E=="function"){n++;var ee=o;o=void 0;try{E()}catch(te){throw J.f&=-2,J.f|=8,_(J),te}finally{o=ee,t()}}}function _(J){for(var E=J.s;E!==void 0;E=E.n)E.S.U(E);J.x=void 0,J.s=void 0,y$1(J)}function g(J){if(o!==this)throw new Error("Out-of-order effect");a(this),o=J,this.f&=-2,8&this.f&&_(this),t()}function p$1(J){this.x=J,this.u=void 0,this.s=void 0,this.o=void 0,this.f=32}p$1.prototype.c=function(){var J=this.S();try{!(8&this.f)&&this.x!==void 0&&(this.u=this.x())}finally{J()}};p$1.prototype.S=function(){1&this.f&&i(),this.f|=1,this.f&=-9,y$1(this),c(this),n++;var J=o;return o=this,g.bind(this,J)};p$1.prototype.N=function(){2&this.f||(this.f|=2,this.o=r,r=this)};p$1.prototype.d=function(){this.f|=8,1&this.f||_(this)};function b(J){var E=new p$1(J);return E.c(),E.d.bind(E)}var v;function s$2(J,E){l$3[J]=E.bind(null,l$3[J]||function(){})}function l(J){v&&v(),v=J&&J.S()}function p(J){var E=this,ee=J.data,te=useSignal(ee);te.value=ee;var re=F(function(){for(var ne=E.__v;ne=ne.__;)if(ne.__c){ne.__c.__$f|=4;break}return E.__$u.c=function(){E.base.data=re.peek()},w$1(function(){var ie=te.value.value;return ie===0?0:ie===!0?"":ie||""})},[]);return re.value}p.displayName="_st";Object.defineProperties(e.prototype,{constructor:{configurable:!0},type:{configurable:!0,value:p},props:{configurable:!0,get:function(){return{data:this}}},__b:{configurable:!0,value:1}});s$2("__b",function(J,E){if(typeof E.type=="string"){var ee,te=E.props;for(var re in te)if(re!=="children"){var ne=te[re];ne instanceof e&&(ee||(E.__np=ee={}),ee[re]=ne,te[re]=ne.peek())}}J(E)});s$2("__r",function(J,E){l();var ee,te=E.__c;te&&(te.__$f&=-2,(ee=te.__$u)===void 0&&(te.__$u=ee=function(re){var ne;return b(function(){ne=this}),ne.c=function(){te.__$f|=1,te.setState({})},ne}())),l(ee),J(E)});s$2("__e",function(J,E,ee,te){l(),J(E,ee,te)});s$2("diffed",function(J,E){l();var ee;if(typeof E.type=="string"&&(ee=E.__e)){var te=E.__np,re=E.props;if(te){var ne=ee.U;if(ne)for(var ie in ne){var se=ne[ie];se!==void 0&&!(ie in te)&&(se.d(),ne[ie]=void 0)}else ee.U=ne={};for(var oe in te){var ae=ne[oe],ce=te[oe];ae===void 0?(ae=d$1(ee,oe,ce,re),ne[oe]=ae):ae.o(ce,re)}}}J(E)});function d$1(J,E,ee,te){var re=E in J&&J.ownerSVGElement===void 0,ne=u(ee);return{o:function(ie,se){ne.value=ie,te=se},d:b(function(){var ie=ne.value.value;te[E]!==ie&&(te[E]=ie,re?J[E]=ie:ie?J.setAttribute(E,ie):J.removeAttribute(E))})}}s$2("unmount",function(J,E){if(typeof E.type=="string"){var ee=E.__e;if(ee){var te=ee.U;if(te){ee.U=void 0;for(var re in te){var ne=te[re];ne&&ne.d()}}}}else{var ie=E.__c;if(ie){var se=ie.__$u;se&&(ie.__$u=void 0,se.d())}}J(E)});s$2("__h",function(J,E,ee,te){te<3&&(E.__$f|=2),J(E,ee,te)});b$2.prototype.shouldComponentUpdate=function(J,E){var ee=this.__$u;if(!(ee&&ee.s!==void 0||4&this.__$f)||3&this.__$f)return!0;for(var te in E)return!0;for(var re in J)if(re!=="__source"&&J[re]!==this.props[re])return!0;for(var ne in this.props)if(!(ne in J))return!0;return!1};function useSignal(J){return F(function(){return u(J)},[])}const scriptRel="modulepreload",assetsURL=function(J){return"/"+J},seen={},__vitePreload=function(E,ee,te){if(!ee||ee.length===0)return E();const re=document.getElementsByTagName("link");return Promise.all(ee.map(ne=>{if(ne=assetsURL(ne),ne in seen)return;seen[ne]=!0;const ie=ne.endsWith(".css"),se=ie?'[rel="stylesheet"]':"";if(!!te)for(let ce=re.length-1;ce>=0;ce--){const le=re[ce];if(le.href===ne&&(!ie||le.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${ne}"]${se}`))return;const ae=document.createElement("link");if(ae.rel=ie?"stylesheet":scriptRel,ie||(ae.as="script",ae.crossOrigin=""),ae.href=ne,document.head.appendChild(ae),ie)return new Promise((ce,le)=>{ae.addEventListener("load",ce),ae.addEventListener("error",()=>le(new Error(`Unable to preload CSS for ${ne}`)))})})).then(()=>E())};var commonjsGlobal=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function getDefaultExportFromCjs(J){return J&&J.__esModule&&Object.prototype.hasOwnProperty.call(J,"default")?J.default:J}function getAugmentedNamespace(J){if(J.__esModule)return J;var E=J.default;if(typeof E=="function"){var ee=function te(){if(this instanceof te){var re=[null];re.push.apply(re,arguments);var ne=Function.bind.apply(E,re);return new ne}return E.apply(this,arguments)};ee.prototype=E.prototype}else ee={};return Object.defineProperty(ee,"__esModule",{value:!0}),Object.keys(J).forEach(function(te){var re=Object.getOwnPropertyDescriptor(J,te);Object.defineProperty(ee,te,re.get?re:{enumerable:!0,get:function(){return J[te]}})}),ee}var base64$8={},__extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var J=function(E,ee){return J=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(te,re){te.__proto__=re}||function(te,re){for(var ne in re)re.hasOwnProperty(ne)&&(te[ne]=re[ne])},J(E,ee)};return function(E,ee){J(E,ee);function te(){this.constructor=E}E.prototype=ee===null?Object.create(ee):(te.prototype=ee.prototype,new te)}}();Object.defineProperty(base64$8,"__esModule",{value:!0});var INVALID_BYTE=256,Coder=function(){function J(E){E===void 0&&(E="="),this._paddingCharacter=E}return J.prototype.encodedLength=function(E){return this._paddingCharacter?(E+2)/3*4|0:(E*8+5)/6|0},J.prototype.encode=function(E){for(var ee="",te=0;te<E.length-2;te+=3){var re=E[te]<<16|E[te+1]<<8|E[te+2];ee+=this._encodeByte(re>>>3*6&63),ee+=this._encodeByte(re>>>2*6&63),ee+=this._encodeByte(re>>>1*6&63),ee+=this._encodeByte(re>>>0*6&63)}var ne=E.length-te;if(ne>0){var re=E[te]<<16|(ne===2?E[te+1]<<8:0);ee+=this._encodeByte(re>>>3*6&63),ee+=this._encodeByte(re>>>2*6&63),ne===2?ee+=this._encodeByte(re>>>1*6&63):ee+=this._paddingCharacter||"",ee+=this._paddingCharacter||""}return ee},J.prototype.maxDecodedLength=function(E){return this._paddingCharacter?E/4*3|0:(E*6+7)/8|0},J.prototype.decodedLength=function(E){return this.maxDecodedLength(E.length-this._getPaddingLength(E))},J.prototype.decode=function(E){if(E.length===0)return new Uint8Array(0);for(var ee=this._getPaddingLength(E),te=E.length-ee,re=new Uint8Array(this.maxDecodedLength(te)),ne=0,ie=0,se=0,oe=0,ae=0,ce=0,le=0;ie<te-4;ie+=4)oe=this._decodeChar(E.charCodeAt(ie+0)),ae=this._decodeChar(E.charCodeAt(ie+1)),ce=this._decodeChar(E.charCodeAt(ie+2)),le=this._decodeChar(E.charCodeAt(ie+3)),re[ne++]=oe<<2|ae>>>4,re[ne++]=ae<<4|ce>>>2,re[ne++]=ce<<6|le,se|=oe&INVALID_BYTE,se|=ae&INVALID_BYTE,se|=ce&INVALID_BYTE,se|=le&INVALID_BYTE;if(ie<te-1&&(oe=this._decodeChar(E.charCodeAt(ie)),ae=this._decodeChar(E.charCodeAt(ie+1)),re[ne++]=oe<<2|ae>>>4,se|=oe&INVALID_BYTE,se|=ae&INVALID_BYTE),ie<te-2&&(ce=this._decodeChar(E.charCodeAt(ie+2)),re[ne++]=ae<<4|ce>>>2,se|=ce&INVALID_BYTE),ie<te-3&&(le=this._decodeChar(E.charCodeAt(ie+3)),re[ne++]=ce<<6|le,se|=le&INVALID_BYTE),se!==0)throw new Error("Base64Coder: incorrect characters for decoding");return re},J.prototype._encodeByte=function(E){var ee=E;return ee+=65,ee+=25-E>>>8&0-65-26+97,ee+=51-E>>>8&26-97-52+48,ee+=61-E>>>8&52-48-62+43,ee+=62-E>>>8&62-43-63+47,String.fromCharCode(ee)},J.prototype._decodeChar=function(E){var ee=INVALID_BYTE;return ee+=(42-E&E-44)>>>8&-INVALID_BYTE+E-43+62,ee+=(46-E&E-48)>>>8&-INVALID_BYTE+E-47+63,ee+=(47-E&E-58)>>>8&-INVALID_BYTE+E-48+52,ee+=(64-E&E-91)>>>8&-INVALID_BYTE+E-65+0,ee+=(96-E&E-123)>>>8&-INVALID_BYTE+E-97+26,ee},J.prototype._getPaddingLength=function(E){var ee=0;if(this._paddingCharacter){for(var te=E.length-1;te>=0&&E[te]===this._paddingCharacter;te--)ee++;if(E.length<4||ee>2)throw new Error("Base64Coder: incorrect padding")}return ee},J}();base64$8.Coder=Coder;var stdCoder=new Coder;function encode$g(J){return stdCoder.encode(J)}base64$8.encode=encode$g;function decode$f(J){return stdCoder.decode(J)}base64$8.decode=decode$f;var URLSafeCoder=function(J){__extends(E,J);function E(){return J!==null&&J.apply(this,arguments)||this}return E.prototype._encodeByte=function(ee){var te=ee;return te+=65,te+=25-ee>>>8&0-65-26+97,te+=51-ee>>>8&26-97-52+48,te+=61-ee>>>8&52-48-62+45,te+=62-ee>>>8&62-45-63+95,String.fromCharCode(te)},E.prototype._decodeChar=function(ee){var te=INVALID_BYTE;return te+=(44-ee&ee-46)>>>8&-INVALID_BYTE+ee-45+62,te+=(94-ee&ee-96)>>>8&-INVALID_BYTE+ee-95+63,te+=(47-ee&ee-58)>>>8&-INVALID_BYTE+ee-48+52,te+=(64-ee&ee-91)>>>8&-INVALID_BYTE+ee-65+0,te+=(96-ee&ee-123)>>>8&-INVALID_BYTE+ee-97+26,te},E}(Coder);base64$8.URLSafeCoder=URLSafeCoder;var urlSafeCoder=new URLSafeCoder;function encodeURLSafe(J){return urlSafeCoder.encode(J)}base64$8.encodeURLSafe=encodeURLSafe;function decodeURLSafe(J){return urlSafeCoder.decode(J)}base64$8.decodeURLSafe=decodeURLSafe;base64$8.encodedLength=function(J){return stdCoder.encodedLength(J)};base64$8.maxDecodedLength=function(J){return stdCoder.maxDecodedLength(J)};base64$8.decodedLength=function(J){return stdCoder.decodedLength(J)};class Base64EnvelopeEncoding{INTER_SPLIT=":";INTRA_SPLIT=".";encodeHandshakeEnvelope(E){const ee=E.header.map(re=>base64$8.encode(new Uint8Array(re))),te=E.payload.map(re=>base64$8.encode(new Uint8Array(re)));return[ee.join(this.INTER_SPLIT),te.join(this.INTER_SPLIT)].join(this.INTRA_SPLIT)}decodeHandshakeEnvelope(E){const[ee,te]=E.split(this.INTRA_SPLIT),re=ee.split(this.INTER_SPLIT),ne=te.split(this.INTER_SPLIT),ie=[base64$8.decode(re[0]),base64$8.decode(re[1])],se=[base64$8.decode(ne[0]),base64$8.decode(ne[1])];return{header:ie,payload:se}}encodeEnvelope(E){const ee=base64$8.encode(new Uint8Array(E.header)),te=base64$8.encode(new Uint8Array(E.payload));return[ee,te].join(this.INTRA_SPLIT)}decodeEnvelope(E){const[ee,te]=E.split(this.INTRA_SPLIT),re=base64$8.decode(ee),ne=base64$8.decode(te);return{header:re,payload:ne}}}class InternalFormatJson{encode(E){const ee=JSON.stringify(E);return new TextEncoder().encode(ee)}decode(E){return JSON.parse(new TextDecoder().decode(E))}}var ChatEventType=(J=>(J.channel_open="channel_open",J.channel_error="channel_error",J.invite="invite",J.initiated="initiated",J.message="message",J.queued="queued",J.sent="sent",J.failed="failed",J.idle="idle",J.active="active",J.disconnected="disconnected",J.dead_session="dead_session",J))(ChatEventType||{});class ChatEvent extends CustomEvent{constructor(E,ee){super(E,ee)}static addTypedListener(E,ee,te){E.addEventListener(ee,re=>{eventTypeGuard(re,ee,ChatEvent)&&te(re)})}}function eventTypeGuard(J,E,ee){return J instanceof ee&&J.type===E}var MessageType=(J=>(J[J.message=0]="message",J[J.ack=1]="ack",J[J.disconnect=2]="disconnect",J[J.meta=3]="meta",J))(MessageType||{});class HpkeError extends Error{constructor(E){let ee;E instanceof Error?ee=E.message:typeof E=="string"?ee=E:ee="",super(ee),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name,this.message===""?this.message=this.name:this.message=this.name+": "+this.message}}class InvalidParamError extends HpkeError{}class ValidationError extends HpkeError{}class SerializeError extends HpkeError{}class DeserializeError extends HpkeError{}class EncapError extends HpkeError{}class DecapError extends HpkeError{}class ExportError extends HpkeError{}class SealError extends HpkeError{}class OpenError extends HpkeError{}class MessageLimitReachedError extends HpkeError{}class DeriveKeyPairError extends HpkeError{}class NotSupportedError extends HpkeError{}var Mode$5;(function(J){J[J.Base=0]="Base",J[J.Psk=1]="Psk",J[J.Auth=2]="Auth",J[J.AuthPsk=3]="AuthPsk"})(Mode$5||(Mode$5={}));var Kem$1;(function(J){J[J.DhkemP256HkdfSha256=16]="DhkemP256HkdfSha256",J[J.DhkemP384HkdfSha384=17]="DhkemP384HkdfSha384",J[J.DhkemP521HkdfSha512=18]="DhkemP521HkdfSha512",J[J.DhkemX25519HkdfSha256=32]="DhkemX25519HkdfSha256",J[J.DhkemX448HkdfSha512=33]="DhkemX448HkdfSha512"})(Kem$1||(Kem$1={}));var Kdf$1;(function(J){J[J.HkdfSha256=1]="HkdfSha256",J[J.HkdfSha384=2]="HkdfSha384",J[J.HkdfSha512=3]="HkdfSha512"})(Kdf$1||(Kdf$1={}));var Aead$1;(function(J){J[J.Aes128Gcm=1]="Aes128Gcm",J[J.Aes256Gcm=2]="Aes256Gcm",J[J.Chacha20Poly1305=3]="Chacha20Poly1305",J[J.ExportOnly=65535]="ExportOnly"})(Aead$1||(Aead$1={}));const dntGlobals={},dntGlobalThis=createMergeProxy(globalThis,dntGlobals);function createMergeProxy(J,E){return new Proxy(J,{get(ee,te,re){return te in E?E[te]:J[te]},set(ee,te,re){return te in E&&delete E[te],J[te]=re,!0},deleteProperty(ee,te){let re=!1;return te in E&&(delete E[te],re=!0),te in J&&(delete J[te],re=!0),re},ownKeys(ee){const te=Reflect.ownKeys(J),re=Reflect.ownKeys(E),ne=new Set(re);return[...te.filter(ie=>!ne.has(ie)),...re]},defineProperty(ee,te,re){return te in E&&delete E[te],Reflect.defineProperty(J,te,re),!0},getOwnPropertyDescriptor(ee,te){return te in E?Reflect.getOwnPropertyDescriptor(E,te):Reflect.getOwnPropertyDescriptor(J,te)},has(ee,te){return te in E||te in J}})}const isBrowser$1=()=>typeof dntGlobalThis<"u",isCloudflareWorkers=()=>typeof caches<"u",isCryptoKeyPair=J=>typeof J=="object"&&J!==null&&typeof J.privateKey=="object"&&typeof J.publicKey=="object";function i2Osp(J,E){if(E<=0)throw new Error("i2Osp: too small size");if(J>=256**E)throw new Error("i2Osp: too large integer");const ee=new Uint8Array(E);for(let te=0;te<E&&J;te++)ee[E-(te+1)]=J%256,J=J>>8;return ee}function xor(J,E){if(J.byteLength!==E.byteLength)throw new Error("xor: different length inputs");const ee=new Uint8Array(J.byteLength);for(let te=0;te<J.byteLength;te++)ee[te]=J[te]^E[te];return ee}function concat$5(J,E){const ee=new Uint8Array(J.length+E.length);return ee.set(J,0),ee.set(E,J.length),ee}function concat3(J,E,ee){const te=new Uint8Array(J.length+E.length+ee.length);return te.set(J,0),te.set(E,J.length),te.set(ee,J.length+E.length),te}class WebCrypto{constructor(E){Object.defineProperty(this,"_api",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._api=E}}async function loadCrypto(){if((isBrowser$1()||isCloudflareWorkers())&&globalThis.crypto!==void 0)return globalThis.crypto;try{const{webcrypto:J}=await Promise.resolve().then(()=>nodeCrypto);return J}catch{throw new NotSupportedError("Web Cryptograph API not supported")}}async function loadSubtleCrypto(){if((isBrowser$1()||isCloudflareWorkers())&&globalThis.crypto!==void 0)return globalThis.crypto.subtle;try{const{webcrypto:J}=await Promise.resolve().then(()=>nodeCrypto);return J.subtle}catch{throw new NotSupportedError("Web Cryptograph API not supported")}}const KEM_USAGES=["deriveBits"],AEAD_USAGES=["encrypt","decrypt"],INPUT_LENGTH_LIMIT=128,MINIMUM_PSK_LENGTH=32,EMPTY=new Uint8Array(0),HPKE_VERSION=new Uint8Array([72,80,75,69,45,118,49]),SUITE_ID_HEADER_HPKE=new Uint8Array([72,80,75,69,0,0,0,0,0,0]),SUITE_ID_HEADER_KEM=new Uint8Array([75,69,77,0,0]),LABEL_DKP_PRK=new Uint8Array([100,107,112,95,112,114,107]),LABEL_EAE_PRK=new Uint8Array([101,97,101,95,112,114,107]),LABEL_INFO_HASH=new Uint8Array([105,110,102,111,95,104,97,115,104]),LABEL_PSK_ID_HASH=new Uint8Array([112,115,107,95,105,100,95,104,97,115,104]),LABEL_SECRET=new Uint8Array([115,101,99,114,101,116]),LABEL_SHARED_SECRET=new Uint8Array([115,104,97,114,101,100,95,115,101,99,114,101,116]),LABEL_KEY=new Uint8Array([107,101,121]),LABEL_BASE_NONCE=new Uint8Array([98,97,115,101,95,110,111,110,99,101]),LABEL_EXP=new Uint8Array([101,120,112]),LABEL_SEC=new Uint8Array([115,101,99]),LABEL_CANDIDATE=new Uint8Array([99,97,110,100,105,100,97,116,101]),LABEL_SK=new Uint8Array([115,107]),ORDER_P_256=new Uint8Array([255,255,255,255,0,0,0,0,255,255,255,255,255,255,255,255,188,230,250,173,167,23,158,132,243,185,202,194,252,99,37,81]),ORDER_P_384=new Uint8Array([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,199,99,77,129,244,55,45,223,88,26,13,178,72,176,167,122,236,236,25,106,204,197,41,115]),ORDER_P_521=new Uint8Array([1,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,250,81,134,135,131,191,47,150,107,127,204,1,72,247,9,165,208,59,181,201,184,137,156,71,174,187,111,183,30,145,56,100,9]);class ExporterContext extends WebCrypto{constructor(E,ee,te){super(E),Object.defineProperty(this,"exporterSecret",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_kdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._kdf=ee,this.exporterSecret=te}async seal(E,ee){return await this._emitError1()}async open(E,ee){return await this._emitError1()}async setupBidirectional(E,ee){return await this._emitError2()}async export(E,ee){if(E.byteLength>INPUT_LENGTH_LIMIT)throw new InvalidParamError("Too long exporter context");try{return await this._kdf.labeledExpand(this.exporterSecret,LABEL_SEC,new Uint8Array(E),ee)}catch(te){throw new ExportError(te)}}_emitError1(){return new Promise((E,ee)=>{ee(new NotSupportedError("Not available on export-only mode"))})}_emitError2(){return new Promise((E,ee)=>{ee(new NotSupportedError("Not available on export-only mode"))})}}class RecipientExporterContext extends ExporterContext{}class SenderExporterContext extends ExporterContext{constructor(E,ee,te,re){super(E,ee,te),Object.defineProperty(this,"enc",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.enc=re}}class AesGcmKey{constructor(E,ee){Object.defineProperty(this,"_rawKey",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_key",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_api",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._rawKey=E,this._api=ee}async seal(E,ee,te){this._key===void 0&&(this._key=await this.importKey(this._rawKey),new Uint8Array(this._rawKey).fill(0));const re={name:"AES-GCM",iv:E,additionalData:te};return await this._api.encrypt(re,this._key,ee)}async open(E,ee,te){this._key===void 0&&(this._key=await this.importKey(this._rawKey),new Uint8Array(this._rawKey).fill(0));const re={name:"AES-GCM",iv:E,additionalData:te};return await this._api.decrypt(re,this._key,ee)}async importKey(E){return await this._api.importKey("raw",E,{name:"AES-GCM"},!0,AEAD_USAGES)}}function writeUint32LE$1(J,E=new Uint8Array(4),ee=0){return E[ee+0]=J>>>0,E[ee+1]=J>>>8,E[ee+2]=J>>>16,E[ee+3]=J>>>24,E}function writeUint64LE$1(J,E=new Uint8Array(8),ee=0){return writeUint32LE$1(J>>>0,E,ee),writeUint32LE$1(J/4294967296>>>0,E,ee+4),E}function wipe$2(J){for(let E=0;E<J.length;E++)J[E]=0;return J}const ROUNDS$1=20;function core$1(J,E,ee){const te=ee[3]<<24|ee[2]<<16|ee[1]<<8|ee[0],re=ee[7]<<24|ee[6]<<16|ee[5]<<8|ee[4],ne=ee[11]<<24|ee[10]<<16|ee[9]<<8|ee[8],ie=ee[15]<<24|ee[14]<<16|ee[13]<<8|ee[12],se=ee[19]<<24|ee[18]<<16|ee[17]<<8|ee[16],oe=ee[23]<<24|ee[22]<<16|ee[21]<<8|ee[20],ae=ee[27]<<24|ee[26]<<16|ee[25]<<8|ee[24],ce=ee[31]<<24|ee[30]<<16|ee[29]<<8|ee[28],le=E[3]<<24|E[2]<<16|E[1]<<8|E[0],he=E[7]<<24|E[6]<<16|E[5]<<8|E[4],de=E[11]<<24|E[10]<<16|E[9]<<8|E[8],ue=E[15]<<24|E[14]<<16|E[13]<<8|E[12];let pe=1634760805,ye=857760878,me=2036477234,be=1797285236,_e=te,we=re,$e=ne,ve=ie,fe=se,Ee=oe,ke=ae,Ne=ce,xe=le,Ue=he,Ke=de,Te=ue;for(let Ce=0;Ce<ROUNDS$1;Ce+=2)pe=pe+_e|0,xe^=pe,xe=xe>>>32-16|xe<<16,fe=fe+xe|0,_e^=fe,_e=_e>>>32-12|_e<<12,ye=ye+we|0,Ue^=ye,Ue=Ue>>>32-16|Ue<<16,Ee=Ee+Ue|0,we^=Ee,we=we>>>32-12|we<<12,me=me+$e|0,Ke^=me,Ke=Ke>>>32-16|Ke<<16,ke=ke+Ke|0,$e^=ke,$e=$e>>>32-12|$e<<12,be=be+ve|0,Te^=be,Te=Te>>>32-16|Te<<16,Ne=Ne+Te|0,ve^=Ne,ve=ve>>>32-12|ve<<12,me=me+$e|0,Ke^=me,Ke=Ke>>>32-8|Ke<<8,ke=ke+Ke|0,$e^=ke,$e=$e>>>32-7|$e<<7,be=be+ve|0,Te^=be,Te=Te>>>32-8|Te<<8,Ne=Ne+Te|0,ve^=Ne,ve=ve>>>32-7|ve<<7,ye=ye+we|0,Ue^=ye,Ue=Ue>>>32-8|Ue<<8,Ee=Ee+Ue|0,we^=Ee,we=we>>>32-7|we<<7,pe=pe+_e|0,xe^=pe,xe=xe>>>32-8|xe<<8,fe=fe+xe|0,_e^=fe,_e=_e>>>32-7|_e<<7,pe=pe+we|0,Te^=pe,Te=Te>>>32-16|Te<<16,ke=ke+Te|0,we^=ke,we=we>>>32-12|we<<12,ye=ye+$e|0,xe^=ye,xe=xe>>>32-16|xe<<16,Ne=Ne+xe|0,$e^=Ne,$e=$e>>>32-12|$e<<12,me=me+ve|0,Ue^=me,Ue=Ue>>>32-16|Ue<<16,fe=fe+Ue|0,ve^=fe,ve=ve>>>32-12|ve<<12,be=be+_e|0,Ke^=be,Ke=Ke>>>32-16|Ke<<16,Ee=Ee+Ke|0,_e^=Ee,_e=_e>>>32-12|_e<<12,me=me+ve|0,Ue^=me,Ue=Ue>>>32-8|Ue<<8,fe=fe+Ue|0,ve^=fe,ve=ve>>>32-7|ve<<7,be=be+_e|0,Ke^=be,Ke=Ke>>>32-8|Ke<<8,Ee=Ee+Ke|0,_e^=Ee,_e=_e>>>32-7|_e<<7,ye=ye+$e|0,xe^=ye,xe=xe>>>32-8|xe<<8,Ne=Ne+xe|0,$e^=Ne,$e=$e>>>32-7|$e<<7,pe=pe+we|0,Te^=pe,Te=Te>>>32-8|Te<<8,ke=ke+Te|0,we^=ke,we=we>>>32-7|we<<7;writeUint32LE$1(pe+1634760805|0,J,0),writeUint32LE$1(ye+857760878|0,J,4),writeUint32LE$1(me+2036477234|0,J,8),writeUint32LE$1(be+1797285236|0,J,12),writeUint32LE$1(_e+te|0,J,16),writeUint32LE$1(we+re|0,J,20),writeUint32LE$1($e+ne|0,J,24),writeUint32LE$1(ve+ie|0,J,28),writeUint32LE$1(fe+se|0,J,32),writeUint32LE$1(Ee+oe|0,J,36),writeUint32LE$1(ke+ae|0,J,40),writeUint32LE$1(Ne+ce|0,J,44),writeUint32LE$1(xe+le|0,J,48),writeUint32LE$1(Ue+he|0,J,52),writeUint32LE$1(Ke+de|0,J,56),writeUint32LE$1(Te+ue|0,J,60)}function streamXOR$1(J,E,ee,te,re=0){if(J.length!==32)throw new Error("ChaCha: key size must be 32 bytes");if(te.length<ee.length)throw new Error("ChaCha: destination is shorter than source");let ne,ie;if(re===0){if(E.length!==8&&E.length!==12)throw new Error("ChaCha nonce must be 8 or 12 bytes");ne=new Uint8Array(16),ie=ne.length-E.length,ne.set(E,ie)}else{if(E.length!==16)throw new Error("ChaCha nonce with counter must be 16 bytes");ne=E,ie=re}const se=new Uint8Array(64);for(let oe=0;oe<ee.length;oe+=64){core$1(se,ne,J);for(let ae=oe;ae<oe+64&&ae<ee.length;ae++)te[ae]=ee[ae]^se[ae-oe];incrementCounter$1(ne,0,ie)}return wipe$2(se),re===0&&wipe$2(ne),te}function stream$1(J,E,ee,te=0){return wipe$2(ee),streamXOR$1(J,E,ee,ee,te)}function incrementCounter$1(J,E,ee){let te=1;for(;ee--;)te=te+(J[E]&255)|0,J[E]=te&255,te>>>=8,E++;if(te>0)throw new Error("ChaCha: counter overflow")}function compare$1(J,E){if(J.length!==E.length)return 0;let ee=0;for(let te=0;te<J.length;te++)ee|=J[te]^E[te];return 1&ee-1>>>8}function equal$1(J,E){return J.length===0||E.length===0?!1:compare$1(J,E)!==0}const DIGEST_LENGTH=16;class Poly1305{constructor(E){Object.defineProperty(this,"digestLength",{enumerable:!0,configurable:!0,writable:!0,value:DIGEST_LENGTH}),Object.defineProperty(this,"_buffer",{enumerable:!0,configurable:!0,writable:!0,value:new Uint8Array(16)}),Object.defineProperty(this,"_r",{enumerable:!0,configurable:!0,writable:!0,value:new Uint16Array(10)}),Object.defineProperty(this,"_h",{enumerable:!0,configurable:!0,writable:!0,value:new Uint16Array(10)}),Object.defineProperty(this,"_pad",{enumerable:!0,configurable:!0,writable:!0,value:new Uint16Array(8)}),Object.defineProperty(this,"_leftover",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_fin",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_finished",{enumerable:!0,configurable:!0,writable:!0,value:!1});let ee=E[0]|E[1]<<8;this._r[0]=ee&8191;let te=E[2]|E[3]<<8;this._r[1]=(ee>>>13|te<<3)&8191;let re=E[4]|E[5]<<8;this._r[2]=(te>>>10|re<<6)&7939;let ne=E[6]|E[7]<<8;this._r[3]=(re>>>7|ne<<9)&8191;let ie=E[8]|E[9]<<8;this._r[4]=(ne>>>4|ie<<12)&255,this._r[5]=ie>>>1&8190;let se=E[10]|E[11]<<8;this._r[6]=(ie>>>14|se<<2)&8191;let oe=E[12]|E[13]<<8;this._r[7]=(se>>>11|oe<<5)&8065;let ae=E[14]|E[15]<<8;this._r[8]=(oe>>>8|ae<<8)&8191,this._r[9]=ae>>>5&127,this._pad[0]=E[16]|E[17]<<8,this._pad[1]=E[18]|E[19]<<8,this._pad[2]=E[20]|E[21]<<8,this._pad[3]=E[22]|E[23]<<8,this._pad[4]=E[24]|E[25]<<8,this._pad[5]=E[26]|E[27]<<8,this._pad[6]=E[28]|E[29]<<8,this._pad[7]=E[30]|E[31]<<8}_blocks(E,ee,te){let re=this._fin?0:2048,ne=this._h[0],ie=this._h[1],se=this._h[2],oe=this._h[3],ae=this._h[4],ce=this._h[5],le=this._h[6],he=this._h[7],de=this._h[8],ue=this._h[9],pe=this._r[0],ye=this._r[1],me=this._r[2],be=this._r[3],_e=this._r[4],we=this._r[5],$e=this._r[6],ve=this._r[7],fe=this._r[8],Ee=this._r[9];for(;te>=16;){let ke=E[ee+0]|E[ee+1]<<8;ne+=ke&8191;let Ne=E[ee+2]|E[ee+3]<<8;ie+=(ke>>>13|Ne<<3)&8191;let xe=E[ee+4]|E[ee+5]<<8;se+=(Ne>>>10|xe<<6)&8191;let Ue=E[ee+6]|E[ee+7]<<8;oe+=(xe>>>7|Ue<<9)&8191;let Ke=E[ee+8]|E[ee+9]<<8;ae+=(Ue>>>4|Ke<<12)&8191,ce+=Ke>>>1&8191;let Te=E[ee+10]|E[ee+11]<<8;le+=(Ke>>>14|Te<<2)&8191;let Ce=E[ee+12]|E[ee+13]<<8;he+=(Te>>>11|Ce<<5)&8191;let Ve=E[ee+14]|E[ee+15]<<8;de+=(Ce>>>8|Ve<<8)&8191,ue+=Ve>>>5|re;let Re=0,Le=Re;Le+=ne*pe,Le+=ie*(5*Ee),Le+=se*(5*fe),Le+=oe*(5*ve),Le+=ae*(5*$e),Re=Le>>>13,Le&=8191,Le+=ce*(5*we),Le+=le*(5*_e),Le+=he*(5*be),Le+=de*(5*me),Le+=ue*(5*ye),Re+=Le>>>13,Le&=8191;let De=Re;De+=ne*ye,De+=ie*pe,De+=se*(5*Ee),De+=oe*(5*fe),De+=ae*(5*ve),Re=De>>>13,De&=8191,De+=ce*(5*$e),De+=le*(5*we),De+=he*(5*_e),De+=de*(5*be),De+=ue*(5*me),Re+=De>>>13,De&=8191;let Be=Re;Be+=ne*me,Be+=ie*ye,Be+=se*pe,Be+=oe*(5*Ee),Be+=ae*(5*fe),Re=Be>>>13,Be&=8191,Be+=ce*(5*ve),Be+=le*(5*$e),Be+=he*(5*we),Be+=de*(5*_e),Be+=ue*(5*be),Re+=Be>>>13,Be&=8191;let Oe=Re;Oe+=ne*be,Oe+=ie*me,Oe+=se*ye,Oe+=oe*pe,Oe+=ae*(5*Ee),Re=Oe>>>13,Oe&=8191,Oe+=ce*(5*fe),Oe+=le*(5*ve),Oe+=he*(5*$e),Oe+=de*(5*we),Oe+=ue*(5*_e),Re+=Oe>>>13,Oe&=8191;let Ge=Re;Ge+=ne*_e,Ge+=ie*be,Ge+=se*me,Ge+=oe*ye,Ge+=ae*pe,Re=Ge>>>13,Ge&=8191,Ge+=ce*(5*Ee),Ge+=le*(5*fe),Ge+=he*(5*ve),Ge+=de*(5*$e),Ge+=ue*(5*we),Re+=Ge>>>13,Ge&=8191;let Me=Re;Me+=ne*we,Me+=ie*_e,Me+=se*be,Me+=oe*me,Me+=ae*ye,Re=Me>>>13,Me&=8191,Me+=ce*pe,Me+=le*(5*Ee),Me+=he*(5*fe),Me+=de*(5*ve),Me+=ue*(5*$e),Re+=Me>>>13,Me&=8191;let je=Re;je+=ne*$e,je+=ie*we,je+=se*_e,je+=oe*be,je+=ae*me,Re=je>>>13,je&=8191,je+=ce*ye,je+=le*pe,je+=he*(5*Ee),je+=de*(5*fe),je+=ue*(5*ve),Re+=je>>>13,je&=8191;let We=Re;We+=ne*ve,We+=ie*$e,We+=se*we,We+=oe*_e,We+=ae*be,Re=We>>>13,We&=8191,We+=ce*me,We+=le*ye,We+=he*pe,We+=de*(5*Ee),We+=ue*(5*fe),Re+=We>>>13,We&=8191;let ze=Re;ze+=ne*fe,ze+=ie*ve,ze+=se*$e,ze+=oe*we,ze+=ae*_e,Re=ze>>>13,ze&=8191,ze+=ce*be,ze+=le*me,ze+=he*ye,ze+=de*pe,ze+=ue*(5*Ee),Re+=ze>>>13,ze&=8191;let Ae=Re;Ae+=ne*Ee,Ae+=ie*fe,Ae+=se*ve,Ae+=oe*$e,Ae+=ae*we,Re=Ae>>>13,Ae&=8191,Ae+=ce*_e,Ae+=le*be,Ae+=he*me,Ae+=de*ye,Ae+=ue*pe,Re+=Ae>>>13,Ae&=8191,Re=(Re<<2)+Re|0,Re=Re+Le|0,Le=Re&8191,Re=Re>>>13,De+=Re,ne=Le,ie=De,se=Be,oe=Oe,ae=Ge,ce=Me,le=je,he=We,de=ze,ue=Ae,ee+=16,te-=16}this._h[0]=ne,this._h[1]=ie,this._h[2]=se,this._h[3]=oe,this._h[4]=ae,this._h[5]=ce,this._h[6]=le,this._h[7]=he,this._h[8]=de,this._h[9]=ue}finish(E,ee=0){const te=new Uint16Array(10);let re,ne,ie,se;if(this._leftover){for(se=this._leftover,this._buffer[se++]=1;se<16;se++)this._buffer[se]=0;this._fin=1,this._blocks(this._buffer,0,16)}for(re=this._h[1]>>>13,this._h[1]&=8191,se=2;se<10;se++)this._h[se]+=re,re=this._h[se]>>>13,this._h[se]&=8191;for(this._h[0]+=re*5,re=this._h[0]>>>13,this._h[0]&=8191,this._h[1]+=re,re=this._h[1]>>>13,this._h[1]&=8191,this._h[2]+=re,te[0]=this._h[0]+5,re=te[0]>>>13,te[0]&=8191,se=1;se<10;se++)te[se]=this._h[se]+re,re=te[se]>>>13,te[se]&=8191;for(te[9]-=8192,ne=(re^1)-1,se=0;se<10;se++)te[se]&=ne;for(ne=~ne,se=0;se<10;se++)this._h[se]=this._h[se]&ne|te[se];for(this._h[0]=(this._h[0]|this._h[1]<<13)&65535,this._h[1]=(this._h[1]>>>3|this._h[2]<<10)&65535,this._h[2]=(this._h[2]>>>6|this._h[3]<<7)&65535,this._h[3]=(this._h[3]>>>9|this._h[4]<<4)&65535,this._h[4]=(this._h[4]>>>12|this._h[5]<<1|this._h[6]<<14)&65535,this._h[5]=(this._h[6]>>>2|this._h[7]<<11)&65535,this._h[6]=(this._h[7]>>>5|this._h[8]<<8)&65535,this._h[7]=(this._h[8]>>>8|this._h[9]<<5)&65535,ie=this._h[0]+this._pad[0],this._h[0]=ie&65535,se=1;se<8;se++)ie=(this._h[se]+this._pad[se]|0)+(ie>>>16)|0,this._h[se]=ie&65535;return E[ee+0]=this._h[0]>>>0,E[ee+1]=this._h[0]>>>8,E[ee+2]=this._h[1]>>>0,E[ee+3]=this._h[1]>>>8,E[ee+4]=this._h[2]>>>0,E[ee+5]=this._h[2]>>>8,E[ee+6]=this._h[3]>>>0,E[ee+7]=this._h[3]>>>8,E[ee+8]=this._h[4]>>>0,E[ee+9]=this._h[4]>>>8,E[ee+10]=this._h[5]>>>0,E[ee+11]=this._h[5]>>>8,E[ee+12]=this._h[6]>>>0,E[ee+13]=this._h[6]>>>8,E[ee+14]=this._h[7]>>>0,E[ee+15]=this._h[7]>>>8,this._finished=!0,this}update(E){let ee=0,te=E.length,re;if(this._leftover){re=16-this._leftover,re>te&&(re=te);for(let ne=0;ne<re;ne++)this._buffer[this._leftover+ne]=E[ee+ne];if(te-=re,ee+=re,this._leftover+=re,this._leftover<16)return this;this._blocks(this._buffer,0,16),this._leftover=0}if(te>=16&&(re=te-te%16,this._blocks(E,ee,re),ee+=re,te-=re),te){for(let ne=0;ne<te;ne++)this._buffer[this._leftover+ne]=E[ee+ne];this._leftover+=te}return this}digest(){if(this._finished)throw new Error("Poly1305 was finished");let E=new Uint8Array(16);return this.finish(E),E}clean(){return wipe$2(this._buffer),wipe$2(this._r),wipe$2(this._h),wipe$2(this._pad),this._leftover=0,this._fin=0,this._finished=!0,this}}const KEY_LENGTH=32,NONCE_LENGTH=12,TAG_LENGTH=16,ZEROS=new Uint8Array(16);class ChaCha20Poly1305{constructor(E){if(Object.defineProperty(this,"nonceLength",{enumerable:!0,configurable:!0,writable:!0,value:NONCE_LENGTH}),Object.defineProperty(this,"tagLength",{enumerable:!0,configurable:!0,writable:!0,value:TAG_LENGTH}),Object.defineProperty(this,"_key",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),E.length!==KEY_LENGTH)throw new Error("ChaCha20Poly1305 needs 32-byte key");this._key=new Uint8Array(E)}seal(E,ee,te,re){if(E.length>16)throw new Error("ChaCha20Poly1305: incorrect nonce length");const ne=new Uint8Array(16);ne.set(E,ne.length-E.length);const ie=new Uint8Array(32);stream$1(this._key,ne,ie,4);const se=ee.length+this.tagLength;let oe;if(re){if(re.length!==se)throw new Error("ChaCha20Poly1305: incorrect destination length");oe=re}else oe=new Uint8Array(se);return streamXOR$1(this._key,ne,ee,oe,4),this._authenticate(oe.subarray(oe.length-this.tagLength,oe.length),ie,oe.subarray(0,oe.length-this.tagLength),te),wipe$2(ne),oe}open(E,ee,te,re){if(E.length>16)throw new Error("ChaCha20Poly1305: incorrect nonce length");if(ee.length<this.tagLength)return null;const ne=new Uint8Array(16);ne.set(E,ne.length-E.length);const ie=new Uint8Array(32);stream$1(this._key,ne,ie,4);const se=new Uint8Array(this.tagLength);if(this._authenticate(se,ie,ee.subarray(0,ee.length-this.tagLength),te),!equal$1(se,ee.subarray(ee.length-this.tagLength,ee.length)))return null;const oe=ee.length-this.tagLength;let ae;if(re){if(re.length!==oe)throw new Error("ChaCha20Poly1305: incorrect destination length");ae=re}else ae=new Uint8Array(oe);return streamXOR$1(this._key,ne,ee.subarray(0,ee.length-this.tagLength),ae,4),wipe$2(ne),ae}clean(){return wipe$2(this._key),this}_authenticate(E,ee,te,re){const ne=new Poly1305(ee);re&&(ne.update(re),re.length%16>0&&ne.update(ZEROS.subarray(re.length%16))),ne.update(te),te.length%16>0&&ne.update(ZEROS.subarray(te.length%16));const ie=new Uint8Array(8);re&&writeUint64LE$1(re.length,ie),ne.update(ie),writeUint64LE$1(te.length,ie),ne.update(ie);const se=ne.digest();for(let oe=0;oe<se.length;oe++)E[oe]=se[oe];ne.clean(),wipe$2(se),wipe$2(ie)}}class Chacha20Poly1305Key{constructor(E){Object.defineProperty(this,"_key",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._key=new ChaCha20Poly1305(new Uint8Array(E))}async seal(E,ee,te){return await this._seal(E,ee,te)}async open(E,ee,te){return await this._open(E,ee,te)}_seal(E,ee,te){return new Promise(re=>{const ne=this._key.seal(new Uint8Array(E),new Uint8Array(ee),new Uint8Array(te));re(ne.buffer)})}_open(E,ee,te){return new Promise((re,ne)=>{const ie=this._key.open(new Uint8Array(E),new Uint8Array(ee),new Uint8Array(te));ie instanceof Uint8Array?re(ie.buffer):ne(new Error("failed to open."))})}}class EncryptionContext extends ExporterContext{constructor(E,ee,te){if(super(E,ee,te.exporterSecret),Object.defineProperty(this,"_aead",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nK",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nN",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nT",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_f",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_r",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),te.key===void 0||te.baseNonce===void 0||te.seq===void 0)throw new Error("Required parameters are missing");switch(this._aead=te.aead,this._aead){case Aead$1.Aes128Gcm:this._nK=16,this._nN=12,this._nT=16;break;case Aead$1.Aes256Gcm:this._nK=32,this._nN=12,this._nT=16;break;case Aead$1.Chacha20Poly1305:this._nK=32,this._nN=12,this._nT=16;break;default:this._nK=0,this._nN=0,this._nT=0;break}const re=createAeadKey(this._aead,te.key,this._api);this._f={key:re,baseNonce:te.baseNonce,seq:te.seq},this._r={key:re,baseNonce:EMPTY,seq:0}}computeNonce(E){const ee=i2Osp(E.seq,E.baseNonce.byteLength);return xor(E.baseNonce,ee)}incrementSeq(E){if(E.seq>Number.MAX_SAFE_INTEGER)throw new MessageLimitReachedError("Message limit reached");E.seq+=1}async setupBidirectional(E,ee){try{this._r.baseNonce=new Uint8Array(await this.export(ee,this._nN));const te=await this.export(E,this._nK);this._r.key=createAeadKey(this._aead,te,this._api),this._r.seq=0}catch(te){throw this._r.baseNonce=EMPTY,te}}}function createAeadKey(J,E,ee){switch(J){case Aead$1.Aes128Gcm:return new AesGcmKey(E,ee);case Aead$1.Aes256Gcm:return new AesGcmKey(E,ee);case Aead$1.Chacha20Poly1305:return new Chacha20Poly1305Key(E);default:throw new Error("Invalid or unsupported AEAD id")}}const BYTES$1=32;let SHA256$1=class{constructor(){Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:BYTES$1}),Object.defineProperty(this,"_buf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_bufIdx",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_count",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_K",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_H",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_finalized",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._buf=new Uint8Array(64),this._K=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),this.init()}init(){return this._H=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),this._bufIdx=0,this._count=new Uint32Array(2),this._buf.fill(0),this._finalized=!1,this}update(J){if(J===null)throw new TypeError("msg must be a string or Uint8Array.");for(let ee=0,te=J.length;ee<te;ee++)this._buf[this._bufIdx++]=J[ee],this._bufIdx===64&&(this._transform(),this._bufIdx=0);const E=this._count;return(E[0]+=J.length<<3)<J.length<<3&&E[1]++,E[1]+=J.length>>>29,this}digest(){if(this._finalized)throw new Error("digest has already been called.");this._finalized=!0;const J=this._buf;let E=this._bufIdx;for(J[E++]=128;E!==56;)E===64&&(this._transform(),E=0),J[E++]=0;const ee=this._count;J[56]=ee[1]>>>24&255,J[57]=ee[1]>>>16&255,J[58]=ee[1]>>>8&255,J[59]=ee[1]>>>0&255,J[60]=ee[0]>>>24&255,J[61]=ee[0]>>>16&255,J[62]=ee[0]>>>8&255,J[63]=ee[0]>>>0&255,this._transform();const te=new Uint8Array(BYTES$1);for(let re=0;re<8;re++)te[(re<<2)+0]=this._H[re]>>>24&255,te[(re<<2)+1]=this._H[re]>>>16&255,te[(re<<2)+2]=this._H[re]>>>8&255,te[(re<<2)+3]=this._H[re]>>>0&255;return this.init(),te}_transform(){const J=this._H;let E=J[0],ee=J[1],te=J[2],re=J[3],ne=J[4],ie=J[5],se=J[6],oe=J[7];const ae=new Uint32Array(16);let ce;for(ce=0;ce<16;ce++)ae[ce]=this._buf[(ce<<2)+3]|this._buf[(ce<<2)+2]<<8|this._buf[(ce<<2)+1]<<16|this._buf[ce<<2]<<24;for(ce=0;ce<64;ce++){let le;if(ce<16)le=ae[ce];else{let he=ae[ce+1&15],de=ae[ce+14&15];le=ae[ce&15]=(he>>>7^he>>>18^he>>>3^he<<25^he<<14)+(de>>>17^de>>>19^de>>>10^de<<15^de<<13)+ae[ce&15]+ae[ce+9&15]|0}le=le+oe+(ne>>>6^ne>>>11^ne>>>25^ne<<26^ne<<21^ne<<7)+(se^ne&(ie^se))+this._K[ce]|0,oe=se,se=ie,ie=ne,ne=re+le,re=te,te=ee,ee=E,E=le+(ee&te^re&(ee^te))+(ee>>>2^ee>>>13^ee>>>22^ee<<30^ee<<19^ee<<10)|0}J[0]=J[0]+E|0,J[1]=J[1]+ee|0,J[2]=J[2]+te|0,J[3]=J[3]+re|0,J[4]=J[4]+ne|0,J[5]=J[5]+ie|0,J[6]=J[6]+se|0,J[7]=J[7]+oe|0}};const BYTES=64;class SHA512{constructor(){Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:BYTES}),Object.defineProperty(this,"_buffer",{enumerable:!0,configurable:!0,writable:!0,value:new Uint8Array(128)}),Object.defineProperty(this,"_bufferIndex",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_count",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_K",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_H",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_finalized",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._K=new Uint32Array([1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591]),this.init()}init(){return this._H=new Uint32Array([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),this._bufferIndex=0,this._count=new Uint32Array(2),this._buffer.fill(0),this._finalized=!1,this}update(E){if(E===null)throw new TypeError("msg must be a string or Uint8Array.");for(let te=0;te<E.length;te++)this._buffer[this._bufferIndex++]=E[te],this._bufferIndex===128&&(this.transform(),this._bufferIndex=0);let ee=this._count;return(ee[0]+=E.length<<3)<E.length<<3&&ee[1]++,ee[1]+=E.length>>>29,this}digest(){if(this._finalized)throw new Error("digest has already been called.");this._finalized=!0;var E=this._buffer,ee=this._bufferIndex;for(E[ee++]=128;ee!==112;)ee===128&&(this.transform(),ee=0),E[ee++]=0;let te=this._count;E[112]=E[113]=E[114]=E[115]=E[116]=E[117]=E[118]=E[119]=0,E[120]=te[1]>>>24&255,E[121]=te[1]>>>16&255,E[122]=te[1]>>>8&255,E[123]=te[1]>>>0&255,E[124]=te[0]>>>24&255,E[125]=te[0]>>>16&255,E[126]=te[0]>>>8&255,E[127]=te[0]>>>0&255,this.transform();let re,ne=new Uint8Array(64);for(re=0;re<16;re++)ne[(re<<2)+0]=this._H[re]>>>24&255,ne[(re<<2)+1]=this._H[re]>>>16&255,ne[(re<<2)+2]=this._H[re]>>>8&255,ne[(re<<2)+3]=this._H[re]&255;return this.init(),ne}transform(){let E=this._H,ee=E[0],te=E[1],re=E[2],ne=E[3],ie=E[4],se=E[5],oe=E[6],ae=E[7],ce=E[8],le=E[9],he=E[10],de=E[11],ue=E[12],pe=E[13],ye=E[14],me=E[15],be=ee,_e=te,we=re,$e=ne,ve=ie,fe=se,Ee=oe,ke=ae,Ne=ce,xe=le,Ue=he,Ke=de,Te=ue,Ce=pe,Ve=ye,Re=me,Le,De=new Uint32Array(160);for(Le=0;Le<32;Le++)De[Le]=this._buffer[(Le<<2)+3]|this._buffer[(Le<<2)+2]<<8|this._buffer[(Le<<2)+1]<<16|this._buffer[Le<<2]<<24;let Be,Oe,Ge,Me,je,We,ze,Ae,Pe,Ie,ge,Se,Fe,He;for(Le=16;Le<80;Le++)Oe=De[(Le-15)*2],Be=De[(Le-15)*2+1],Me=(Be<<31|Oe>>>1)^(Be<<24|Oe>>>8)^Oe>>>7,Ge=(Oe<<31|Be>>>1)^(Oe<<24|Be>>>8)^(Oe<<25|Be>>>7),We=De[(Le-2)*2],je=De[(Le-2)*2+1],Ae=(je<<13|We>>>19)^(We<<3|je>>>29)^We>>>6,ze=(We<<13|je>>>19)^(je<<3|We>>>29)^(We<<26|je>>>6),Se=De[(Le-7)*2],ge=De[(Le-7)*2+1],He=De[(Le-16)*2],Fe=De[(Le-16)*2+1],Pe=Ge+ge,Ie=Me+Se+(Pe>>>0<Ge>>>0?1:0),Pe+=ze,Ie+=Ae+(Pe>>>0<ze>>>0?1:0),Pe+=Fe,Ie+=He+(Pe>>>0<Fe>>>0?1:0),De[Le*2]=Ie,De[Le*2+1]=Pe;let qe,Ye,rt,ot,pt,gt,it,nt,et,tt,Qe,Xe,Je,Ze;for(Le=0;Le<80;Le++)Ye=Ne&Ue^~Ne&Te,qe=xe&Ke^~xe&Ce,ot=be&we^be&ve^we&ve,rt=_e&$e^_e&fe^$e&fe,gt=(_e<<4|be>>>28)^(be<<30|_e>>>2)^(be<<25|_e>>>7),pt=(be<<4|_e>>>28)^(_e<<30|be>>>2)^(_e<<25|be>>>7),nt=(xe<<18|Ne>>>14)^(xe<<14|Ne>>>18)^(Ne<<23|xe>>>9),it=(Ne<<18|xe>>>14)^(Ne<<14|xe>>>18)^(xe<<23|Ne>>>9),tt=this._K[Le*2],et=this._K[Le*2+1],Qe=Re+it,Xe=Ve+nt+(Qe>>>0<Re>>>0?1:0),Qe+=qe,Xe+=Ye+(Qe>>>0<qe>>>0?1:0),Qe+=et,Xe+=tt+(Qe>>>0<et>>>0?1:0),Qe=Qe+De[Le*2+1],Xe+=De[Le*2]+(Qe>>>0<De[Le*2+1]>>>0?1:0),Je=pt+rt,Ze=gt+ot+(Je>>>0<pt>>>0?1:0),Ve=Te,Re=Ce,Te=Ue,Ce=Ke,Ue=Ne,Ke=xe,xe=ke+Qe|0,Ne=Ee+Xe+(xe>>>0<ke>>>0?1:0)|0,Ee=ve,ke=fe,ve=we,fe=$e,we=be,$e=_e,_e=Qe+Je|0,be=Xe+Ze+(_e>>>0<Qe>>>0?1:0)|0;te=E[1]=te+_e|0,E[0]=ee+be+(te>>>0<_e>>>0?1:0)|0,ne=E[3]=ne+$e|0,E[2]=re+we+(ne>>>0<$e>>>0?1:0)|0,se=E[5]=se+fe|0,E[4]=ie+ve+(se>>>0<fe>>>0?1:0)|0,ae=E[7]=ae+ke|0,E[6]=oe+Ee+(ae>>>0<ke>>>0?1:0)|0,le=E[9]=le+xe|0,E[8]=ce+Ne+(le>>>0<xe>>>0?1:0)|0,de=E[11]=de+Ke|0,E[10]=he+Ue+(de>>>0<Ke>>>0?1:0)|0,pe=E[13]=pe+Ce|0,E[12]=ue+Te+(pe>>>0<Ce>>>0?1:0)|0,me=E[15]=me+Re|0,E[14]=ye+Ve+(me>>>0<Re>>>0?1:0)|0}}const SHA256_REGEX=/^\s*sha-?256\s*$/i,SHA512_REGEX=/^\s*sha-?512\s*$/i;let HMAC$1=class{constructor(J,E){Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"B",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"iPad",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"oPad",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"iKeyPad",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"oKeyPad",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"hasher",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.hashSize=J.hashSize,this.hasher=J,this.B=this.hashSize<=32?64:128,this.iPad=54,this.oPad=92,E&&this.init(E)}init(J){J||(J=new Uint8Array(0));let E=new Uint8Array(J);if(E.length>this.B&&(this.hasher.init(),E=this.hasher.update(J).digest()),E.byteLength<this.B){const ee=new Uint8Array(this.B);ee.set(E,0),E=ee}this.iKeyPad=new Uint8Array(this.B),this.oKeyPad=new Uint8Array(this.B);for(let ee=0;ee<this.B;++ee)this.iKeyPad[ee]=this.iPad^E[ee],this.oKeyPad[ee]=this.oPad^E[ee];return E.fill(0),this.hasher.init(),this.hasher.update(this.iKeyPad),this}update(J=new Uint8Array(0)){return this.hasher.update(J),this}digest(){const J=this.hasher.digest();return this.hasher.init(),this.hasher.update(this.oKeyPad).update(J).digest()}};function hmac$2(J,E,ee){if(SHA256_REGEX.test(J))return new HMAC$1(new SHA256$1).init(E).update(ee).digest();if(SHA512_REGEX.test(J))return new HMAC$1(new SHA512).init(E).update(ee).digest();throw new TypeError(`Unsupported hash ${J}. Must be one of SHA(1|256|512).`)}class KdfContext extends WebCrypto{constructor(E,ee,te){switch(super(E),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"suiteId",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"algHash",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nH",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.id=ee,this.suiteId=te,ee){case Kdf$1.HkdfSha256:this.hashSize=32,this.algHash={name:"HMAC",hash:"SHA-256",length:256};break;case Kdf$1.HkdfSha384:this.hashSize=48,this.algHash={name:"HMAC",hash:"SHA-384",length:384};break;default:this.hashSize=64,this.algHash={name:"HMAC",hash:"SHA-512",length:512};break}if(this.algHash.length===void 0)throw new Error("Unknown hash size.");this._nH=this.algHash.length/8}buildLabeledIkm(E,ee){const te=new Uint8Array(7+this.suiteId.byteLength+E.byteLength+ee.byteLength);return te.set(HPKE_VERSION,0),te.set(this.suiteId,7),te.set(E,7+this.suiteId.byteLength),te.set(ee,7+this.suiteId.byteLength+E.byteLength),te}buildLabeledInfo(E,ee,te){const re=new Uint8Array(9+this.suiteId.byteLength+E.byteLength+ee.byteLength);return re.set(new Uint8Array([0,te]),0),re.set(HPKE_VERSION,2),re.set(this.suiteId,9),re.set(E,9+this.suiteId.byteLength),re.set(ee,9+this.suiteId.byteLength+E.byteLength),re}async extract(E,ee){if(E.byteLength===0&&(E=new ArrayBuffer(this._nH)),E.byteLength!==this._nH)switch(this.algHash.hash){case"SHA-256":return hmac$2("sha256",new Uint8Array(E),new Uint8Array(ee));case"SHA-512":return hmac$2("sha512",new Uint8Array(E),new Uint8Array(ee));default:throw new NotSupportedError(`${this.algHash.hash} key length should be ${this._nH}.`)}const te=await this._api.importKey("raw",E,this.algHash,!1,["sign"]);return await this._api.sign("HMAC",te,ee)}async expand(E,ee,te){const re=await this._api.importKey("raw",E,this.algHash,!1,["sign"]),ne=new ArrayBuffer(te),ie=new Uint8Array(ne);let se=EMPTY;const oe=new Uint8Array(ee),ae=new Uint8Array(1);if(te>255*this._nH)throw new Error("Entropy limit reached");const ce=new Uint8Array(this._nH+oe.length+1);for(let le=1,he=0;he<ie.length;le++)ae[0]=le,ce.set(se,0),ce.set(oe,se.length),ce.set(ae,se.length+oe.length),se=new Uint8Array(await this._api.sign("HMAC",re,ce.slice(0,se.length+oe.length+1))),ie.length-he>=se.length?(ie.set(se,he),he+=se.length):(ie.set(se.slice(0,ie.length-he),he),he+=ie.length-he);return ne}async extractAndExpand(E,ee,te,re){const ne=await this._api.importKey("raw",ee,"HKDF",!1,KEM_USAGES);return await this._api.deriveBits({name:"HKDF",hash:this.algHash.hash,salt:E,info:te},ne,re*8)}async labeledExtract(E,ee,te){return await this.extract(E,this.buildLabeledIkm(ee,te))}async labeledExpand(E,ee,te,re){return await this.expand(E,this.buildLabeledInfo(ee,te,re),re)}}class Bignum{constructor(E){Object.defineProperty(this,"_num",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._num=new Uint8Array(E)}val(){return this._num}reset(){this._num.fill(0)}set(E){if(E.length!==this._num.length)throw new Error("Bignum.set: invalid argument");this._num.set(E)}isZero(){for(let E=0;E<this._num.length;E++)if(this._num[E]!==0)return!1;return!0}lessThan(E){if(E.length!==this._num.length)throw new Error("Bignum.lessThan: invalid argument");for(let ee=0;ee<this._num.length;ee++){if(this._num[ee]<E[ee])return!0;if(this._num[ee]>E[ee])return!1}return!1}}const PKCS8_ALG_ID_P_256=new Uint8Array([48,65,2,1,0,48,19,6,7,42,134,72,206,61,2,1,6,8,42,134,72,206,61,3,1,7,4,39,48,37,2,1,1,4,32]),PKCS8_ALG_ID_P_384=new Uint8Array([48,78,2,1,0,48,16,6,7,42,134,72,206,61,2,1,6,5,43,129,4,0,34,4,55,48,53,2,1,1,4,48]),PKCS8_ALG_ID_P_521=new Uint8Array([48,96,2,1,0,48,16,6,7,42,134,72,206,61,2,1,6,5,43,129,4,0,35,4,73,48,71,2,1,1,4,66]);class Ec{constructor(E,ee,te){switch(Object.defineProperty(this,"_hkdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_api",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_alg",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nPk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nSk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nDh",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_order",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_bitmask",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_pkcs8AlgId",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._hkdf=ee,this._api=te,E){case Kem$1.DhkemP256HkdfSha256:this._alg={name:"ECDH",namedCurve:"P-256"},this._nPk=65,this._nSk=32,this._nDh=32,this._order=ORDER_P_256,this._bitmask=255,this._pkcs8AlgId=PKCS8_ALG_ID_P_256;break;case Kem$1.DhkemP384HkdfSha384:this._alg={name:"ECDH",namedCurve:"P-384"},this._nPk=97,this._nSk=48,this._nDh=48,this._order=ORDER_P_384,this._bitmask=255,this._pkcs8AlgId=PKCS8_ALG_ID_P_384;break;default:this._alg={name:"ECDH",namedCurve:"P-521"},this._nPk=133,this._nSk=66,this._nDh=66,this._order=ORDER_P_521,this._bitmask=1,this._pkcs8AlgId=PKCS8_ALG_ID_P_521;break}}async serializePublicKey(E){const ee=await this._api.exportKey("raw",E);if(ee.byteLength!==this._nPk)throw new Error("Invalid public key for the ciphersuite");return ee}async deserializePublicKey(E){if(E.byteLength!==this._nPk)throw new Error("Invalid public key for the ciphersuite");try{return await this._api.importKey("raw",E,this._alg,!0,[])}catch{throw new Error("Invalid public key for the ciphersuite")}}async importKey(E,ee,te){if(E!=="raw")throw new Error("Unsupported format");if(te&&ee.byteLength!==this._nPk)throw new Error("Invalid public key for the ciphersuite");if(!te&&ee.byteLength!==this._nSk)throw new Error("Invalid private key for the ciphersuite");try{if(te)return await this._api.importKey(E,ee,this._alg,!0,[]);const re=new Uint8Array(ee),ne=new Uint8Array(this._pkcs8AlgId.length+re.length);return ne.set(this._pkcs8AlgId,0),ne.set(re,this._pkcs8AlgId.length),await this._api.importKey("pkcs8",ne,this._alg,!0,KEM_USAGES)}catch{throw new Error("Invalid key for the ciphersuite")}}async derivePublicKey(E){const ee=await this._api.exportKey("jwk",E);return delete ee.d,delete ee.key_ops,await this._api.importKey("jwk",ee,this._alg,!0,[])}async generateKeyPair(){return await this._api.generateKey(this._alg,!0,KEM_USAGES)}async deriveKeyPair(E){const ee=await this._hkdf.labeledExtract(EMPTY,LABEL_DKP_PRK,new Uint8Array(E)),te=new Bignum(this._nSk);for(let ie=0;te.isZero()||!te.lessThan(this._order);ie++){if(ie>255)throw new Error("Faild to derive a key pair");const se=new Uint8Array(await this._hkdf.labeledExpand(ee,LABEL_CANDIDATE,i2Osp(ie,1),this._nSk));se[0]=se[0]&this._bitmask,te.set(se)}const re=new Uint8Array(this._pkcs8AlgId.length+te.val().length);re.set(this._pkcs8AlgId,0),re.set(te.val(),this._pkcs8AlgId.length);const ne=await this._api.importKey("pkcs8",re,this._alg,!0,KEM_USAGES);return te.reset(),{privateKey:ne,publicKey:await this.derivePublicKey(ne)}}async dh(E,ee){return await this._api.deriveBits({name:"ECDH",public:ee},E,this._nDh*8)}}const PUBLIC_KEY_LENGTH=32;function gf(J){const E=new Float64Array(16);if(J)for(let ee=0;ee<J.length;ee++)E[ee]=J[ee];return E}const _9=new Uint8Array(32);_9[0]=9;const _121665=gf([56129,1]);function car25519(J){let E=1;for(let ee=0;ee<16;ee++){const te=J[ee]+E+65535;E=Math.floor(te/65536),J[ee]=te-E*65536}J[0]+=E-1+37*(E-1)}function sel25519(J,E,ee){const te=~(ee-1);for(let re=0;re<16;re++){const ne=te&(J[re]^E[re]);J[re]^=ne,E[re]^=ne}}function pack25519(J,E){const ee=gf(),te=gf();for(let re=0;re<16;re++)te[re]=E[re];car25519(te),car25519(te),car25519(te);for(let re=0;re<2;re++){ee[0]=te[0]-65517;for(let ie=1;ie<15;ie++)ee[ie]=te[ie]-65535-(ee[ie-1]>>16&1),ee[ie-1]&=65535;ee[15]=te[15]-32767-(ee[14]>>16&1);const ne=ee[15]>>16&1;ee[14]&=65535,sel25519(te,ee,1-ne)}for(let re=0;re<16;re++)J[2*re]=te[re]&255,J[2*re+1]=te[re]>>8}function unpack25519(J,E){for(let ee=0;ee<16;ee++)J[ee]=E[2*ee]+(E[2*ee+1]<<8);J[15]&=32767}function add(J,E,ee){for(let te=0;te<16;te++)J[te]=E[te]+ee[te]}function sub(J,E,ee){for(let te=0;te<16;te++)J[te]=E[te]-ee[te]}function mul(J,E,ee){let te,re,ne=0,ie=0,se=0,oe=0,ae=0,ce=0,le=0,he=0,de=0,ue=0,pe=0,ye=0,me=0,be=0,_e=0,we=0,$e=0,ve=0,fe=0,Ee=0,ke=0,Ne=0,xe=0,Ue=0,Ke=0,Te=0,Ce=0,Ve=0,Re=0,Le=0,De=0;const Be=ee[0],Oe=ee[1],Ge=ee[2],Me=ee[3],je=ee[4],We=ee[5],ze=ee[6],Ae=ee[7],Pe=ee[8],Ie=ee[9],ge=ee[10],Se=ee[11],Fe=ee[12],He=ee[13],qe=ee[14],Ye=ee[15];te=E[0],ne+=te*Be,ie+=te*Oe,se+=te*Ge,oe+=te*Me,ae+=te*je,ce+=te*We,le+=te*ze,he+=te*Ae,de+=te*Pe,ue+=te*Ie,pe+=te*ge,ye+=te*Se,me+=te*Fe,be+=te*He,_e+=te*qe,we+=te*Ye,te=E[1],ie+=te*Be,se+=te*Oe,oe+=te*Ge,ae+=te*Me,ce+=te*je,le+=te*We,he+=te*ze,de+=te*Ae,ue+=te*Pe,pe+=te*Ie,ye+=te*ge,me+=te*Se,be+=te*Fe,_e+=te*He,we+=te*qe,$e+=te*Ye,te=E[2],se+=te*Be,oe+=te*Oe,ae+=te*Ge,ce+=te*Me,le+=te*je,he+=te*We,de+=te*ze,ue+=te*Ae,pe+=te*Pe,ye+=te*Ie,me+=te*ge,be+=te*Se,_e+=te*Fe,we+=te*He,$e+=te*qe,ve+=te*Ye,te=E[3],oe+=te*Be,ae+=te*Oe,ce+=te*Ge,le+=te*Me,he+=te*je,de+=te*We,ue+=te*ze,pe+=te*Ae,ye+=te*Pe,me+=te*Ie,be+=te*ge,_e+=te*Se,we+=te*Fe,$e+=te*He,ve+=te*qe,fe+=te*Ye,te=E[4],ae+=te*Be,ce+=te*Oe,le+=te*Ge,he+=te*Me,de+=te*je,ue+=te*We,pe+=te*ze,ye+=te*Ae,me+=te*Pe,be+=te*Ie,_e+=te*ge,we+=te*Se,$e+=te*Fe,ve+=te*He,fe+=te*qe,Ee+=te*Ye,te=E[5],ce+=te*Be,le+=te*Oe,he+=te*Ge,de+=te*Me,ue+=te*je,pe+=te*We,ye+=te*ze,me+=te*Ae,be+=te*Pe,_e+=te*Ie,we+=te*ge,$e+=te*Se,ve+=te*Fe,fe+=te*He,Ee+=te*qe,ke+=te*Ye,te=E[6],le+=te*Be,he+=te*Oe,de+=te*Ge,ue+=te*Me,pe+=te*je,ye+=te*We,me+=te*ze,be+=te*Ae,_e+=te*Pe,we+=te*Ie,$e+=te*ge,ve+=te*Se,fe+=te*Fe,Ee+=te*He,ke+=te*qe,Ne+=te*Ye,te=E[7],he+=te*Be,de+=te*Oe,ue+=te*Ge,pe+=te*Me,ye+=te*je,me+=te*We,be+=te*ze,_e+=te*Ae,we+=te*Pe,$e+=te*Ie,ve+=te*ge,fe+=te*Se,Ee+=te*Fe,ke+=te*He,Ne+=te*qe,xe+=te*Ye,te=E[8],de+=te*Be,ue+=te*Oe,pe+=te*Ge,ye+=te*Me,me+=te*je,be+=te*We,_e+=te*ze,we+=te*Ae,$e+=te*Pe,ve+=te*Ie,fe+=te*ge,Ee+=te*Se,ke+=te*Fe,Ne+=te*He,xe+=te*qe,Ue+=te*Ye,te=E[9],ue+=te*Be,pe+=te*Oe,ye+=te*Ge,me+=te*Me,be+=te*je,_e+=te*We,we+=te*ze,$e+=te*Ae,ve+=te*Pe,fe+=te*Ie,Ee+=te*ge,ke+=te*Se,Ne+=te*Fe,xe+=te*He,Ue+=te*qe,Ke+=te*Ye,te=E[10],pe+=te*Be,ye+=te*Oe,me+=te*Ge,be+=te*Me,_e+=te*je,we+=te*We,$e+=te*ze,ve+=te*Ae,fe+=te*Pe,Ee+=te*Ie,ke+=te*ge,Ne+=te*Se,xe+=te*Fe,Ue+=te*He,Ke+=te*qe,Te+=te*Ye,te=E[11],ye+=te*Be,me+=te*Oe,be+=te*Ge,_e+=te*Me,we+=te*je,$e+=te*We,ve+=te*ze,fe+=te*Ae,Ee+=te*Pe,ke+=te*Ie,Ne+=te*ge,xe+=te*Se,Ue+=te*Fe,Ke+=te*He,Te+=te*qe,Ce+=te*Ye,te=E[12],me+=te*Be,be+=te*Oe,_e+=te*Ge,we+=te*Me,$e+=te*je,ve+=te*We,fe+=te*ze,Ee+=te*Ae,ke+=te*Pe,Ne+=te*Ie,xe+=te*ge,Ue+=te*Se,Ke+=te*Fe,Te+=te*He,Ce+=te*qe,Ve+=te*Ye,te=E[13],be+=te*Be,_e+=te*Oe,we+=te*Ge,$e+=te*Me,ve+=te*je,fe+=te*We,Ee+=te*ze,ke+=te*Ae,Ne+=te*Pe,xe+=te*Ie,Ue+=te*ge,Ke+=te*Se,Te+=te*Fe,Ce+=te*He,Ve+=te*qe,Re+=te*Ye,te=E[14],_e+=te*Be,we+=te*Oe,$e+=te*Ge,ve+=te*Me,fe+=te*je,Ee+=te*We,ke+=te*ze,Ne+=te*Ae,xe+=te*Pe,Ue+=te*Ie,Ke+=te*ge,Te+=te*Se,Ce+=te*Fe,Ve+=te*He,Re+=te*qe,Le+=te*Ye,te=E[15],we+=te*Be,$e+=te*Oe,ve+=te*Ge,fe+=te*Me,Ee+=te*je,ke+=te*We,Ne+=te*ze,xe+=te*Ae,Ue+=te*Pe,Ke+=te*Ie,Te+=te*ge,Ce+=te*Se,Ve+=te*Fe,Re+=te*He,Le+=te*qe,De+=te*Ye,ne+=38*$e,ie+=38*ve,se+=38*fe,oe+=38*Ee,ae+=38*ke,ce+=38*Ne,le+=38*xe,he+=38*Ue,de+=38*Ke,ue+=38*Te,pe+=38*Ce,ye+=38*Ve,me+=38*Re,be+=38*Le,_e+=38*De,re=1,te=ne+re+65535,re=Math.floor(te/65536),ne=te-re*65536,te=ie+re+65535,re=Math.floor(te/65536),ie=te-re*65536,te=se+re+65535,re=Math.floor(te/65536),se=te-re*65536,te=oe+re+65535,re=Math.floor(te/65536),oe=te-re*65536,te=ae+re+65535,re=Math.floor(te/65536),ae=te-re*65536,te=ce+re+65535,re=Math.floor(te/65536),ce=te-re*65536,te=le+re+65535,re=Math.floor(te/65536),le=te-re*65536,te=he+re+65535,re=Math.floor(te/65536),he=te-re*65536,te=de+re+65535,re=Math.floor(te/65536),de=te-re*65536,te=ue+re+65535,re=Math.floor(te/65536),ue=te-re*65536,te=pe+re+65535,re=Math.floor(te/65536),pe=te-re*65536,te=ye+re+65535,re=Math.floor(te/65536),ye=te-re*65536,te=me+re+65535,re=Math.floor(te/65536),me=te-re*65536,te=be+re+65535,re=Math.floor(te/65536),be=te-re*65536,te=_e+re+65535,re=Math.floor(te/65536),_e=te-re*65536,te=we+re+65535,re=Math.floor(te/65536),we=te-re*65536,ne+=re-1+37*(re-1),re=1,te=ne+re+65535,re=Math.floor(te/65536),ne=te-re*65536,te=ie+re+65535,re=Math.floor(te/65536),ie=te-re*65536,te=se+re+65535,re=Math.floor(te/65536),se=te-re*65536,te=oe+re+65535,re=Math.floor(te/65536),oe=te-re*65536,te=ae+re+65535,re=Math.floor(te/65536),ae=te-re*65536,te=ce+re+65535,re=Math.floor(te/65536),ce=te-re*65536,te=le+re+65535,re=Math.floor(te/65536),le=te-re*65536,te=he+re+65535,re=Math.floor(te/65536),he=te-re*65536,te=de+re+65535,re=Math.floor(te/65536),de=te-re*65536,te=ue+re+65535,re=Math.floor(te/65536),ue=te-re*65536,te=pe+re+65535,re=Math.floor(te/65536),pe=te-re*65536,te=ye+re+65535,re=Math.floor(te/65536),ye=te-re*65536,te=me+re+65535,re=Math.floor(te/65536),me=te-re*65536,te=be+re+65535,re=Math.floor(te/65536),be=te-re*65536,te=_e+re+65535,re=Math.floor(te/65536),_e=te-re*65536,te=we+re+65535,re=Math.floor(te/65536),we=te-re*65536,ne+=re-1+37*(re-1),J[0]=ne,J[1]=ie,J[2]=se,J[3]=oe,J[4]=ae,J[5]=ce,J[6]=le,J[7]=he,J[8]=de,J[9]=ue,J[10]=pe,J[11]=ye,J[12]=me,J[13]=be,J[14]=_e,J[15]=we}function square(J,E){mul(J,E,E)}function inv25519(J,E){const ee=gf();for(let te=0;te<16;te++)ee[te]=E[te];for(let te=253;te>=0;te--)square(ee,ee),te!==2&&te!==4&&mul(ee,ee,E);for(let te=0;te<16;te++)J[te]=ee[te]}function scalarMult(J,E){const ee=new Uint8Array(32),te=new Float64Array(80),re=gf(),ne=gf(),ie=gf(),se=gf(),oe=gf(),ae=gf();for(let de=0;de<31;de++)ee[de]=J[de];ee[31]=J[31]&127|64,ee[0]&=248,unpack25519(te,E);for(let de=0;de<16;de++)ne[de]=te[de];re[0]=se[0]=1;for(let de=254;de>=0;--de){const ue=ee[de>>>3]>>>(de&7)&1;sel25519(re,ne,ue),sel25519(ie,se,ue),add(oe,re,ie),sub(re,re,ie),add(ie,ne,se),sub(ne,ne,se),square(se,oe),square(ae,re),mul(re,ie,re),mul(ie,ne,oe),add(oe,re,ie),sub(re,re,ie),square(ne,re),sub(ie,se,ae),mul(re,ie,_121665),add(re,re,se),mul(ie,ie,re),mul(re,se,ae),mul(se,ne,te),square(ne,oe),sel25519(re,ne,ue),sel25519(ie,se,ue)}for(let de=0;de<16;de++)te[de+16]=re[de],te[de+32]=ie[de],te[de+48]=ne[de],te[de+64]=se[de];const ce=te.subarray(32),le=te.subarray(16);inv25519(ce,ce),mul(le,le,ce);const he=new Uint8Array(32);return pack25519(he,le),he}function scalarMultBase(J){return scalarMult(J,_9)}async function generateKeyPair$4(){const J=new Uint8Array(32);return(await loadCrypto()).getRandomValues(J),{publicKey:scalarMultBase(J),secretKey:J}}function sharedKey(J,E,ee=!1){if(J.length!==PUBLIC_KEY_LENGTH)throw new Error("X25519: incorrect secret key length");if(E.length!==PUBLIC_KEY_LENGTH)throw new Error("X25519: incorrect public key length");const te=scalarMult(J,E);if(ee){let re=0;for(let ne=0;ne<te.length;ne++)re|=te[ne];if(re===0)throw new Error("X25519: invalid shared key")}return te}class XCryptoKey{constructor(E,ee,te){Object.defineProperty(this,"key",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"type",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"extractable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"algorithm",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"usages",{enumerable:!0,configurable:!0,writable:!0,value:KEM_USAGES}),this.key=ee,this.type=te,this.algorithm={name:E}}}const ALG_NAME$1="X25519";class X25519{constructor(E){Object.defineProperty(this,"_hkdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nPk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nSk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._hkdf=E,this._nPk=32,this._nSk=32}async serializePublicKey(E){return await this._serializePublicKey(E)}async deserializePublicKey(E){return await this._deserializePublicKey(E)}async importKey(E,ee,te){if(E!=="raw")throw new Error("Unsupported format");return await this._importKey(ee,te)}async derivePublicKey(E){return await this._derivePublicKey(E)}async generateKeyPair(){const E=await generateKeyPair$4();return{publicKey:new XCryptoKey(ALG_NAME$1,E.publicKey,"public"),privateKey:new XCryptoKey(ALG_NAME$1,E.secretKey,"private")}}async deriveKeyPair(E){const ee=await this._hkdf.labeledExtract(EMPTY,LABEL_DKP_PRK,new Uint8Array(E)),te=await this._hkdf.labeledExpand(ee,LABEL_SK,EMPTY,this._nSk),re=new XCryptoKey(ALG_NAME$1,new Uint8Array(te),"private");return{privateKey:re,publicKey:await this.derivePublicKey(re)}}async dh(E,ee){return await this._dh(E,ee)}_serializePublicKey(E){return new Promise(ee=>{ee(E.key.buffer)})}_deserializePublicKey(E){return new Promise((ee,te)=>{E.byteLength!==this._nPk?te(new Error("Invalid public key for the ciphersuite")):ee(new XCryptoKey(ALG_NAME$1,new Uint8Array(E),"public"))})}_importKey(E,ee){return new Promise((te,re)=>{ee&&E.byteLength!==this._nPk&&re(new Error("Invalid public key for the ciphersuite")),!ee&&E.byteLength!==this._nSk&&re(new Error("Invalid private key for the ciphersuite")),te(new XCryptoKey(ALG_NAME$1,new Uint8Array(E),ee?"public":"private"))})}_derivePublicKey(E){return new Promise(ee=>{ee(new XCryptoKey(ALG_NAME$1,scalarMultBase(E.key),"public"))})}_dh(E,ee){return new Promise((te,re)=>{try{te(sharedKey(E.key,ee.key,!0))}catch(ne){re(ne)}})}}let dbits$1;const canary=0xdeadbeefcafe,j_lm=(canary&16777215)==15715070;function BigInteger$3(J,E,ee){J!=null&&(typeof J=="number"?this.fromNumber(J,E,ee):E==null&&typeof J!="string"?this.fromString(J,256):this.fromString(J,E))}function nbi$1(){return new BigInteger$3(null)}function am1$1(J,E,ee,te,re,ne){for(;--ne>=0;){const ie=E*this[J++]+ee[te]+re;re=Math.floor(ie/67108864),ee[te++]=ie&67108863}return re}function am2$1(J,E,ee,te,re,ne){const ie=E&32767,se=E>>15;for(;--ne>=0;){let oe=this[J]&32767;const ae=this[J++]>>15,ce=se*oe+ae*ie;oe=ie*oe+((ce&32767)<<15)+ee[te]+(re&1073741823),re=(oe>>>30)+(ce>>>15)+se*ae+(re>>>30),ee[te++]=oe&1073741823}return re}function am3$1(J,E,ee,te,re,ne){const ie=E&16383,se=E>>14;for(;--ne>=0;){let oe=this[J]&16383;const ae=this[J++]>>14,ce=se*oe+ae*ie;oe=ie*oe+((ce&16383)<<14)+ee[te]+re,re=(oe>>28)+(ce>>14)+se*ae,ee[te++]=oe&268435455}return re}const inBrowser=typeof navigator<"u";inBrowser&&j_lm&&navigator.appName=="Microsoft Internet Explorer"?(BigInteger$3.prototype.am=am2$1,dbits$1=30):inBrowser&&j_lm&&navigator.appName!="Netscape"?(BigInteger$3.prototype.am=am1$1,dbits$1=26):(BigInteger$3.prototype.am=am3$1,dbits$1=28);BigInteger$3.prototype.DB=dbits$1;BigInteger$3.prototype.DM=(1<<dbits$1)-1;BigInteger$3.prototype.DV=1<<dbits$1;const BI_FP$1=52;BigInteger$3.prototype.FV=Math.pow(2,BI_FP$1);BigInteger$3.prototype.F1=BI_FP$1-dbits$1;BigInteger$3.prototype.F2=2*dbits$1-BI_FP$1;const BI_RM$1="0123456789abcdefghijklmnopqrstuvwxyz",BI_RC$1=new Array;let rr$1,vv$1;rr$1="0".charCodeAt(0);for(vv$1=0;vv$1<=9;++vv$1)BI_RC$1[rr$1++]=vv$1;rr$1="a".charCodeAt(0);for(vv$1=10;vv$1<36;++vv$1)BI_RC$1[rr$1++]=vv$1;rr$1="A".charCodeAt(0);for(vv$1=10;vv$1<36;++vv$1)BI_RC$1[rr$1++]=vv$1;function int2char$1(J){return BI_RM$1.charAt(J)}function intAt$1(J,E){return BI_RC$1[J.charCodeAt(E)]??-1}function bnpCopyTo$1(J){for(let E=this.t-1;E>=0;--E)J[E]=this[E];J.t=this.t,J.s=this.s}function bnpFromInt$1(J){this.t=1,this.s=J<0?-1:0,J>0?this[0]=J:J<-1?this[0]=J+this.DV:this.t=0}function nbv$1(J){const E=nbi$1();return E.fromInt(J),E}function bnpFromString$1(J,E){if(!E&&J.length>=2&&J[0]==="0"){let ie=!0;switch(J[1]){case"x":E=16;break;case"b":E=2;break;case"o":E=8;break;default:ie=!1}ie&&(J=J.substr(2))}let ee;if(E==16)ee=4;else if(E==8)ee=3;else if(E==256)ee=8;else if(E==2)ee=1;else if(E==32)ee=5;else if(E==4)ee=2;else{this.fromRadix(J,E);return}this.t=0,this.s=0;let te=J.length,re=!1,ne=0;for(;--te>=0;){const ie=ee==8?J[te]&255:intAt$1(J,te);if(ie<0){J.charAt(te)=="-"&&(re=!0);continue}re=!1,ne==0?this[this.t++]=ie:ne+ee>this.DB?(this[this.t-1]|=(ie&(1<<this.DB-ne)-1)<<ne,this[this.t++]=ie>>this.DB-ne):this[this.t-1]|=ie<<ne,ne+=ee,ne>=this.DB&&(ne-=this.DB)}ee==8&&J[0]&128&&(this.s=-1,ne>0&&(this[this.t-1]|=(1<<this.DB-ne)-1<<ne)),this.clamp(),re&&BigInteger$3.ZERO.subTo(this,this)}function bnpClamp$1(){const J=this.s&this.DM;for(;this.t>0&&this[this.t-1]==J;)--this.t}function bnToString$1(J){if(this.s<0)return"-"+this.negate().toString(J);let E;if(J==16)E=4;else if(J==8)E=3;else if(J==2)E=1;else if(J==32)E=5;else if(J==4)E=2;else return this.toRadix(J);let ee=(1<<E)-1,te,re=!1,ne="",ie=this.t,se=this.DB-ie*this.DB%E;if(ie-- >0)for(se<this.DB&&(te=this[ie]>>se)>0&&(re=!0,ne=int2char$1(te));ie>=0;)se<E?(te=(this[ie]&(1<<se)-1)<<E-se,te|=this[--ie]>>(se+=this.DB-E)):(te=this[ie]>>(se-=E)&ee,se<=0&&(se+=this.DB,--ie)),te>0&&(re=!0),re&&(ne+=int2char$1(te));return re?ne:"0"}function bnNegate$1(){const J=nbi$1();return BigInteger$3.ZERO.subTo(this,J),J}function bnAbs$1(){return this.s<0?this.negate():this}function bnCompareTo$1(J){let E=this.s-J.s;if(E!=0)return E;let ee=this.t;if(E=ee-J.t,E!=0)return this.s<0?-E:E;for(;--ee>=0;)if((E=this[ee]-J[ee])!=0)return E;return 0}function nbits$1(J){let E=1,ee;return(ee=J>>>16)!=0&&(J=ee,E+=16),(ee=J>>8)!=0&&(J=ee,E+=8),(ee=J>>4)!=0&&(J=ee,E+=4),(ee=J>>2)!=0&&(J=ee,E+=2),(ee=J>>1)!=0&&(J=ee,E+=1),E}function bnBitLength$1(){return this.t<=0?0:this.DB*(this.t-1)+nbits$1(this[this.t-1]^this.s&this.DM)}function bnpDLShiftTo$1(J,E){let ee;for(ee=this.t-1;ee>=0;--ee)E[ee+J]=this[ee];for(ee=J-1;ee>=0;--ee)E[ee]=0;E.t=this.t+J,E.s=this.s}function bnpDRShiftTo$1(J,E){for(let ee=J;ee<this.t;++ee)E[ee-J]=this[ee];E.t=Math.max(this.t-J,0),E.s=this.s}function bnpLShiftTo$1(J,E){const ee=J%this.DB,te=this.DB-ee,re=(1<<te)-1;let ne=Math.floor(J/this.DB),ie=this.s<<ee&this.DM,se;for(se=this.t-1;se>=0;--se)E[se+ne+1]=this[se]>>te|ie,ie=(this[se]&re)<<ee;for(se=ne-1;se>=0;--se)E[se]=0;E[ne]=ie,E.t=this.t+ne+1,E.s=this.s,E.clamp()}function bnpRShiftTo$1(J,E){E.s=this.s;const ee=Math.floor(J/this.DB);if(ee>=this.t){E.t=0;return}const te=J%this.DB,re=this.DB-te,ne=(1<<te)-1;E[0]=this[ee]>>te;for(let ie=ee+1;ie<this.t;++ie)E[ie-ee-1]|=(this[ie]&ne)<<re,E[ie-ee]=this[ie]>>te;te>0&&(E[this.t-ee-1]|=(this.s&ne)<<re),E.t=this.t-ee,E.clamp()}function bnpSubTo$1(J,E){let ee=0,te=0,re=Math.min(J.t,this.t);for(;ee<re;)te+=this[ee]-J[ee],E[ee++]=te&this.DM,te>>=this.DB;if(J.t<this.t){for(te-=J.s;ee<this.t;)te+=this[ee],E[ee++]=te&this.DM,te>>=this.DB;te+=this.s}else{for(te+=this.s;ee<J.t;)te-=J[ee],E[ee++]=te&this.DM,te>>=this.DB;te-=J.s}E.s=te<0?-1:0,te<-1?E[ee++]=this.DV+te:te>0&&(E[ee++]=te),E.t=ee,E.clamp()}function bnpMultiplyTo$1(J,E){const ee=this.abs(),te=J.abs();let re=ee.t;for(E.t=re+te.t;--re>=0;)E[re]=0;for(re=0;re<te.t;++re)E[re+ee.t]=ee.am(0,te[re],E,re,0,ee.t);E.s=0,E.clamp(),this.s!=J.s&&BigInteger$3.ZERO.subTo(E,E)}function bnpSquareTo$1(J){const E=this.abs();let ee=J.t=2*E.t;for(;--ee>=0;)J[ee]=0;for(ee=0;ee<E.t-1;++ee){const te=E.am(ee,E[ee],J,2*ee,0,1);(J[ee+E.t]+=E.am(ee+1,2*E[ee],J,2*ee+1,te,E.t-ee-1))>=E.DV&&(J[ee+E.t]-=E.DV,J[ee+E.t+1]=1)}J.t>0&&(J[J.t-1]+=E.am(ee,E[ee],J,2*ee,0,1)),J.s=0,J.clamp()}function bnpDivRemTo$1(J,E,ee){const te=J.abs();if(te.t<=0)return;const re=this.abs();if(re.t<te.t){E?.fromInt(0),ee!=null&&this.copyTo(ee);return}ee==null&&(ee=nbi$1());const ne=nbi$1(),ie=this.s,se=J.s,oe=this.DB-nbits$1(te[te.t-1]);oe>0?(te.lShiftTo(oe,ne),re.lShiftTo(oe,ee)):(te.copyTo(ne),re.copyTo(ee));const ae=ne.t,ce=ne[ae-1];if(ce==0)return;const le=ce*(1<<this.F1)+(ae>1?ne[ae-2]>>this.F2:0),he=this.FV/le,de=(1<<this.F1)/le,ue=1<<this.F2;let pe=ee.t,ye=pe-ae,me=E??nbi$1();for(ne.dlShiftTo(ye,me),ee.compareTo(me)>=0&&(ee[ee.t++]=1,ee.subTo(me,ee)),BigInteger$3.ONE.dlShiftTo(ae,me),me.subTo(ne,ne);ne.t<ae;)ne[ne.t++]=0;for(;--ye>=0;){let be=ee[--pe]==ce?this.DM:Math.floor(ee[pe]*he+(ee[pe-1]+ue)*de);if((ee[pe]+=ne.am(0,be,ee,ye,0,ae))<be)for(ne.dlShiftTo(ye,me),ee.subTo(me,ee);ee[pe]<--be;)ee.subTo(me,ee)}E!=null&&(ee.drShiftTo(ae,E),ie!=se&&BigInteger$3.ZERO.subTo(E,E)),ee.t=ae,ee.clamp(),oe>0&&ee.rShiftTo(oe,ee),ie<0&&BigInteger$3.ZERO.subTo(ee,ee)}function bnMod$1(J){const E=nbi$1();return this.abs().divRemTo(J,null,E),this.s<0&&E.compareTo(BigInteger$3.ZERO)>0&&J.subTo(E,E),E}function Classic$1(J){this.m=J}function cConvert$1(J){return J.s<0||J.compareTo(this.m)>=0?J.mod(this.m):J}function cRevert$1(J){return J}function cReduce$1(J){J.divRemTo(this.m,null,J)}function cMulTo$1(J,E,ee){J.multiplyTo(E,ee),this.reduce(ee)}function cSqrTo$1(J,E){J.squareTo(E),this.reduce(E)}Classic$1.prototype.convert=cConvert$1;Classic$1.prototype.revert=cRevert$1;Classic$1.prototype.reduce=cReduce$1;Classic$1.prototype.mulTo=cMulTo$1;Classic$1.prototype.sqrTo=cSqrTo$1;function bnpInvDigit$1(){if(this.t<1)return 0;const J=this[0];if(!(J&1))return 0;let E=J&3;return E=E*(2-(J&15)*E)&15,E=E*(2-(J&255)*E)&255,E=E*(2-((J&65535)*E&65535))&65535,E=E*(2-J*E%this.DV)%this.DV,E>0?this.DV-E:-E}function Montgomery$1(J){this.m=J,this.mp=J.invDigit(),this.mpl=this.mp&32767,this.mph=this.mp>>15,this.um=(1<<J.DB-15)-1,this.mt2=2*J.t}function montConvert$1(J){const E=nbi$1();return J.abs().dlShiftTo(this.m.t,E),E.divRemTo(this.m,null,E),J.s<0&&E.compareTo(BigInteger$3.ZERO)>0&&this.m.subTo(E,E),E}function montRevert$1(J){const E=nbi$1();return J.copyTo(E),this.reduce(E),E}function montReduce$1(J){for(;J.t<=this.mt2;)J[J.t++]=0;for(let E=0;E<this.m.t;++E){let ee=J[E]&32767;const te=ee*this.mpl+((ee*this.mph+(J[E]>>15)*this.mpl&this.um)<<15)&J.DM;for(ee=E+this.m.t,J[ee]+=this.m.am(0,te,J,E,0,this.m.t);J[ee]>=J.DV;)J[ee]-=J.DV,J[++ee]++}J.clamp(),J.drShiftTo(this.m.t,J),J.compareTo(this.m)>=0&&J.subTo(this.m,J)}function montSqrTo$1(J,E){J.squareTo(E),this.reduce(E)}function montMulTo$1(J,E,ee){J.multiplyTo(E,ee),this.reduce(ee)}Montgomery$1.prototype.convert=montConvert$1;Montgomery$1.prototype.revert=montRevert$1;Montgomery$1.prototype.reduce=montReduce$1;Montgomery$1.prototype.mulTo=montMulTo$1;Montgomery$1.prototype.sqrTo=montSqrTo$1;function bnpIsEven$1(){return(this.t>0?this[0]&1:this.s)==0}function bnpExp$1(J,E){if(J>4294967295||J<1)return BigInteger$3.ONE;let ee=nbi$1(),te=nbi$1(),re=E.convert(this),ne=nbits$1(J)-1;for(re.copyTo(ee);--ne>=0;)if(E.sqrTo(ee,te),(J&1<<ne)>0)E.mulTo(te,re,ee);else{const ie=ee;ee=te,te=ie}return E.revert(ee)}function bnModPowInt$1(J,E){let ee;return J<256||E.isEven()?ee=new Classic$1(E):ee=new Montgomery$1(E),this.exp(J,ee)}BigInteger$3.prototype.copyTo=bnpCopyTo$1;BigInteger$3.prototype.fromInt=bnpFromInt$1;BigInteger$3.prototype.fromString=bnpFromString$1;BigInteger$3.prototype.clamp=bnpClamp$1;BigInteger$3.prototype.dlShiftTo=bnpDLShiftTo$1;BigInteger$3.prototype.drShiftTo=bnpDRShiftTo$1;BigInteger$3.prototype.lShiftTo=bnpLShiftTo$1;BigInteger$3.prototype.rShiftTo=bnpRShiftTo$1;BigInteger$3.prototype.subTo=bnpSubTo$1;BigInteger$3.prototype.multiplyTo=bnpMultiplyTo$1;BigInteger$3.prototype.squareTo=bnpSquareTo$1;BigInteger$3.prototype.divRemTo=bnpDivRemTo$1;BigInteger$3.prototype.invDigit=bnpInvDigit$1;BigInteger$3.prototype.isEven=bnpIsEven$1;BigInteger$3.prototype.exp=bnpExp$1;BigInteger$3.prototype.toString=bnToString$1;BigInteger$3.prototype.negate=bnNegate$1;BigInteger$3.prototype.abs=bnAbs$1;BigInteger$3.prototype.compareTo=bnCompareTo$1;BigInteger$3.prototype.bitLength=bnBitLength$1;BigInteger$3.prototype.mod=bnMod$1;BigInteger$3.prototype.modPowInt=bnModPowInt$1;BigInteger$3.ZERO=nbv$1(0);BigInteger$3.ONE=nbv$1(1);function bnClone$1(){const J=nbi$1();return this.copyTo(J),J}function bnIntValue$1(){if(this.s<0){if(this.t==1)return this[0]-this.DV;if(this.t==0)return-1}else{if(this.t==1)return this[0];if(this.t==0)return 0}return(this[1]&(1<<32-this.DB)-1)<<this.DB|this[0]}function bnByteValue$1(){return this.t==0?this.s:this[0]<<24>>24}function bnShortValue$1(){return this.t==0?this.s:this[0]<<16>>16}function bnpChunkSize$1(J){return Math.floor(Math.LN2*this.DB/Math.log(J))}function bnSigNum$1(){return this.s<0?-1:this.t<=0||this.t==1&&this[0]<=0?0:1}function bnpToRadix$1(J){if(J==null&&(J=10),this.signum()==0||J<2||J>36)return"0";const E=this.chunkSize(J),ee=Math.pow(J,E);let te=nbv$1(ee),re=nbi$1(),ne=nbi$1(),ie="";for(this.divRemTo(te,re,ne);re.signum()>0;)ie=(ee+ne.intValue()).toString(J).substr(1)+ie,re.divRemTo(te,re,ne);return ne.intValue().toString(J)+ie}function bnpFromRadix$1(J,E){this.fromInt(0),E==null&&(E=10);const ee=this.chunkSize(E);let te=Math.pow(E,ee),re=!1,ne=0,ie=0;for(let se=0;se<J.length;++se){const oe=intAt$1(J,se);if(oe<0){J.charAt(se)=="-"&&this.signum()==0&&(re=!0);continue}ie=E*ie+oe,++ne>=ee&&(this.dMultiply(te),this.dAddOffset(ie,0),ne=0,ie=0)}ne>0&&(this.dMultiply(Math.pow(E,ne)),this.dAddOffset(ie,0)),re&&BigInteger$3.ZERO.subTo(this,this)}function bnpFromNumber$1(J,E,ee){if(typeof E=="number")if(J<2)this.fromInt(1);else for(this.fromNumber(J,ee),this.testBit(J-1)||this.bitwiseTo(BigInteger$3.ONE.shiftLeft(J-1),op_or$1,this),this.isEven()&&this.dAddOffset(1,0);!this.isProbablePrime(E);)this.dAddOffset(2,0),this.bitLength()>J&&this.subTo(BigInteger$3.ONE.shiftLeft(J-1),this);else{const te=new Array,re=J&7;te.length=(J>>3)+1,E.nextBytes(te),re>0?te[0]&=(1<<re)-1:te[0]=0,this.fromString(te,256)}}function bnToByteArray$1(){let J=this.t,E=new Array;E[0]=this.s;let ee=this.DB-J*this.DB%8,te,re=0;if(J-- >0)for(ee<this.DB&&(te=this[J]>>ee)!=(this.s&this.DM)>>ee&&(E[re++]=te|this.s<<this.DB-ee);J>=0;)ee<8?(te=(this[J]&(1<<ee)-1)<<8-ee,te|=this[--J]>>(ee+=this.DB-8)):(te=this[J]>>(ee-=8)&255,ee<=0&&(ee+=this.DB,--J)),te&128&&(te|=-256),re==0&&(this.s&128)!=(te&128)&&++re,(re>0||te!=this.s)&&(E[re++]=te);return E}function bnEquals$1(J){return this.compareTo(J)==0}function bnMin$1(J){return this.compareTo(J)<0?this:J}function bnMax$1(J){return this.compareTo(J)>0?this:J}function bnpBitwiseTo$1(J,E,ee){let te,re,ne=Math.min(J.t,this.t);for(te=0;te<ne;++te)ee[te]=E(this[te],J[te]);if(J.t<this.t){for(re=J.s&this.DM,te=ne;te<this.t;++te)ee[te]=E(this[te],re);ee.t=this.t}else{for(re=this.s&this.DM,te=ne;te<J.t;++te)ee[te]=E(re,J[te]);ee.t=J.t}ee.s=E(this.s,J.s),ee.clamp()}function op_and$1(J,E){return J&E}function bnAnd$1(J){let E=nbi$1();return this.bitwiseTo(J,op_and$1,E),E}function op_or$1(J,E){return J|E}function bnOr$1(J){let E=nbi$1();return this.bitwiseTo(J,op_or$1,E),E}function op_xor$1(J,E){return J^E}function bnXor$1(J){let E=nbi$1();return this.bitwiseTo(J,op_xor$1,E),E}function op_andnot$1(J,E){return J&~E}function bnAndNot$1(J){let E=nbi$1();return this.bitwiseTo(J,op_andnot$1,E),E}function bnNot$1(){let J=nbi$1();for(let E=0;E<this.t;++E)J[E]=this.DM&~this[E];return J.t=this.t,J.s=~this.s,J}function bnShiftLeft$1(J){let E=nbi$1();return J<0?this.rShiftTo(-J,E):this.lShiftTo(J,E),E}function bnShiftRight$1(J){let E=nbi$1();return J<0?this.lShiftTo(-J,E):this.rShiftTo(J,E),E}function lbit$1(J){if(J==0)return-1;let E=0;return J&65535||(J>>=16,E+=16),J&255||(J>>=8,E+=8),J&15||(J>>=4,E+=4),J&3||(J>>=2,E+=2),J&1||++E,E}function bnGetLowestSetBit$1(){for(let J=0;J<this.t;++J)if(this[J]!=0)return J*this.DB+lbit$1(this[J]);return this.s<0?this.t*this.DB:-1}function cbit$1(J){let E=0;for(;J!=0;)J&=J-1,++E;return E}function bnBitCount$1(){let J=0,E=this.s&this.DM;for(let ee=0;ee<this.t;++ee)J+=cbit$1(this[ee]^E);return J}function bnTestBit$1(J){let E=Math.floor(J/this.DB);return E>=this.t?this.s!=0:(this[E]&1<<J%this.DB)!=0}function bnpChangeBit$1(J,E){let ee=BigInteger$3.ONE.shiftLeft(J);return this.bitwiseTo(ee,E,ee),ee}function bnSetBit$1(J){return this.changeBit(J,op_or$1)}function bnClearBit$1(J){return this.changeBit(J,op_andnot$1)}function bnFlipBit$1(J){return this.changeBit(J,op_xor$1)}function bnpAddTo$1(J,E){let ee=0,te=0,re=Math.min(J.t,this.t);for(;ee<re;)te+=this[ee]+J[ee],E[ee++]=te&this.DM,te>>=this.DB;if(J.t<this.t){for(te+=J.s;ee<this.t;)te+=this[ee],E[ee++]=te&this.DM,te>>=this.DB;te+=this.s}else{for(te+=this.s;ee<J.t;)te+=J[ee],E[ee++]=te&this.DM,te>>=this.DB;te+=J.s}E.s=te<0?-1:0,te>0?E[ee++]=te:te<-1&&(E[ee++]=this.DV+te),E.t=ee,E.clamp()}function bnAdd$1(J){let E=nbi$1();return this.addTo(J,E),E}function bnSubtract$1(J){let E=nbi$1();return this.subTo(J,E),E}function bnMultiply$1(J){let E=nbi$1();return this.multiplyTo(J,E),E}function bnSquare(){let J=nbi$1();return this.squareTo(J),J}function bnDivide$1(J){let E=nbi$1();return this.divRemTo(J,E,null),E}function bnRemainder$1(J){let E=nbi$1();return this.divRemTo(J,null,E),E}function bnDivideAndRemainder$1(J){let E=nbi$1(),ee=nbi$1();return this.divRemTo(J,E,ee),new Array(E,ee)}function bnpDMultiply$1(J){this[this.t]=this.am(0,J-1,this,0,0,this.t),++this.t,this.clamp()}function bnpDAddOffset$1(J,E){if(J!=0){for(;this.t<=E;)this[this.t++]=0;for(this[E]+=J;this[E]>=this.DV;)this[E]-=this.DV,++E>=this.t&&(this[this.t++]=0),++this[E]}}function NullExp$1(){}function nNop$1(J){return J}function nMulTo$1(J,E,ee){J.multiplyTo(E,ee)}function nSqrTo$1(J,E){J.squareTo(E)}NullExp$1.prototype.convert=nNop$1;NullExp$1.prototype.revert=nNop$1;NullExp$1.prototype.mulTo=nMulTo$1;NullExp$1.prototype.sqrTo=nSqrTo$1;function bnPow$1(J){return this.exp(J,new NullExp$1)}function bnpMultiplyLowerTo$1(J,E,ee){let te=Math.min(this.t+J.t,E);for(ee.s=0,ee.t=te;te>0;)ee[--te]=0;let re;for(re=ee.t-this.t;te<re;++te)ee[te+this.t]=this.am(0,J[te],ee,te,0,this.t);for(re=Math.min(J.t,E);te<re;++te)this.am(0,J[te],ee,te,0,E-te);ee.clamp()}function bnpMultiplyUpperTo$1(J,E,ee){--E;let te=ee.t=this.t+J.t-E;for(ee.s=0;--te>=0;)ee[te]=0;for(te=Math.max(E-this.t,0);te<J.t;++te)ee[this.t+te-E]=this.am(E-te,J[te],ee,0,0,this.t+te-E);ee.clamp(),ee.drShiftTo(1,ee)}function Barrett$1(J){this.r2=nbi$1(),this.q3=nbi$1(),BigInteger$3.ONE.dlShiftTo(2*J.t,this.r2),this.mu=this.r2.divide(J),this.m=J}function barrettConvert$1(J){if(J.s<0||J.t>2*this.m.t)return J.mod(this.m);if(J.compareTo(this.m)<0)return J;{let E=nbi$1();return J.copyTo(E),this.reduce(E),E}}function barrettRevert$1(J){return J}function barrettReduce$1(J){for(J.drShiftTo(this.m.t-1,this.r2),J.t>this.m.t+1&&(J.t=this.m.t+1,J.clamp()),this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3),this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);J.compareTo(this.r2)<0;)J.dAddOffset(1,this.m.t+1);for(J.subTo(this.r2,J);J.compareTo(this.m)>=0;)J.subTo(this.m,J)}function barrettSqrTo$1(J,E){J.squareTo(E),this.reduce(E)}function barrettMulTo$1(J,E,ee){J.multiplyTo(E,ee),this.reduce(ee)}Barrett$1.prototype.convert=barrettConvert$1;Barrett$1.prototype.revert=barrettRevert$1;Barrett$1.prototype.reduce=barrettReduce$1;Barrett$1.prototype.mulTo=barrettMulTo$1;Barrett$1.prototype.sqrTo=barrettSqrTo$1;function bnModPow$1(J,E){let ee=J.bitLength(),te,re=nbv$1(1),ne;if(ee<=0)return re;ee<18?te=1:ee<48?te=3:ee<144?te=4:ee<768?te=5:te=6,ee<8?ne=new Classic$1(E):E.isEven()?ne=new Barrett$1(E):ne=new Montgomery$1(E);let ie=new Array,se=3,oe=te-1,ae=(1<<te)-1;if(ie[1]=ne.convert(this),te>1){let pe=nbi$1();for(ne.sqrTo(ie[1],pe);se<=ae;)ie[se]=nbi$1(),ne.mulTo(pe,ie[se-2],ie[se]),se+=2}let ce=J.t-1,le,he=!0,de=nbi$1(),ue;for(ee=nbits$1(J[ce])-1;ce>=0;){for(ee>=oe?le=J[ce]>>ee-oe&ae:(le=(J[ce]&(1<<ee+1)-1)<<oe-ee,ce>0&&(le|=J[ce-1]>>this.DB+ee-oe)),se=te;!(le&1);)le>>=1,--se;if((ee-=se)<0&&(ee+=this.DB,--ce),he)ie[le].copyTo(re),he=!1;else{for(;se>1;)ne.sqrTo(re,de),ne.sqrTo(de,re),se-=2;se>0?ne.sqrTo(re,de):(ue=re,re=de,de=ue),ne.mulTo(de,ie[le],re)}for(;ce>=0&&!(J[ce]&1<<ee);)ne.sqrTo(re,de),ue=re,re=de,de=ue,--ee<0&&(ee=this.DB-1,--ce)}return ne.revert(re)}function bnGCD$1(J){let E=this.s<0?this.negate():this.clone(),ee=J.s<0?J.negate():J.clone();if(E.compareTo(ee)<0){let ne=E;E=ee,ee=ne}let te=E.getLowestSetBit(),re=ee.getLowestSetBit();if(re<0)return E;for(te<re&&(re=te),re>0&&(E.rShiftTo(re,E),ee.rShiftTo(re,ee));E.signum()>0;)(te=E.getLowestSetBit())>0&&E.rShiftTo(te,E),(te=ee.getLowestSetBit())>0&&ee.rShiftTo(te,ee),E.compareTo(ee)>=0?(E.subTo(ee,E),E.rShiftTo(1,E)):(ee.subTo(E,ee),ee.rShiftTo(1,ee));return re>0&&ee.lShiftTo(re,ee),ee}function bnpModInt$1(J){if(J<=0)return 0;let E=this.DV%J,ee=this.s<0?J-1:0;if(this.t>0)if(E==0)ee=this[0]%J;else for(let te=this.t-1;te>=0;--te)ee=(E*ee+this[te])%J;return ee}function bnModInverse$1(J){let E=J.isEven();if(this.isEven()&&E||J.signum()==0)return BigInteger$3.ZERO;let ee=J.clone(),te=this.clone(),re=nbv$1(1),ne=nbv$1(0),ie=nbv$1(0),se=nbv$1(1);for(;ee.signum()!=0;){for(;ee.isEven();)ee.rShiftTo(1,ee),E?((!re.isEven()||!ne.isEven())&&(re.addTo(this,re),ne.subTo(J,ne)),re.rShiftTo(1,re)):ne.isEven()||ne.subTo(J,ne),ne.rShiftTo(1,ne);for(;te.isEven();)te.rShiftTo(1,te),E?((!ie.isEven()||!se.isEven())&&(ie.addTo(this,ie),se.subTo(J,se)),ie.rShiftTo(1,ie)):se.isEven()||se.subTo(J,se),se.rShiftTo(1,se);ee.compareTo(te)>=0?(ee.subTo(te,ee),E&&re.subTo(ie,re),ne.subTo(se,ne)):(te.subTo(ee,te),E&&ie.subTo(re,ie),se.subTo(ne,se))}if(te.compareTo(BigInteger$3.ONE)!=0)return BigInteger$3.ZERO;if(se.compareTo(J)>=0)return se.subtract(J);if(se.signum()<0)se.addTo(J,se);else return se;return se.signum()<0?se.add(J):se}let lowprimes$1=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997],lplim$1=(1<<26)/lowprimes$1[lowprimes$1.length-1];function bnIsProbablePrime$1(J){let E,ee=this.abs();if(ee.t==1&&ee[0]<=lowprimes$1[lowprimes$1.length-1]){for(E=0;E<lowprimes$1.length;++E)if(ee[0]==lowprimes$1[E])return!0;return!1}if(ee.isEven())return!1;for(E=1;E<lowprimes$1.length;){let te=lowprimes$1[E],re=E+1;for(;re<lowprimes$1.length&&te<lplim$1;)te*=lowprimes$1[re++];for(te=ee.modInt(te);E<re;)if(te%lowprimes$1[E++]==0)return!1}return ee.millerRabin(J)}function bnpMillerRabin$1(J){let E=this.subtract(BigInteger$3.ONE),ee=E.getLowestSetBit();if(ee<=0)return!1;let te=E.shiftRight(ee);J=J+1>>1,J>lowprimes$1.length&&(J=lowprimes$1.length);let re=nbi$1();for(let ne=0;ne<J;++ne){re.fromInt(lowprimes$1[Math.floor(Math.random()*lowprimes$1.length)]);let ie=re.modPow(te,this);if(ie.compareTo(BigInteger$3.ONE)!=0&&ie.compareTo(E)!=0){let se=1;for(;se++<ee&&ie.compareTo(E)!=0;)if(ie=ie.modPowInt(2,this),ie.compareTo(BigInteger$3.ONE)==0)return!1;if(ie.compareTo(E)!=0)return!1}}return!0}BigInteger$3.prototype.chunkSize=bnpChunkSize$1;BigInteger$3.prototype.toRadix=bnpToRadix$1;BigInteger$3.prototype.fromRadix=bnpFromRadix$1;BigInteger$3.prototype.fromNumber=bnpFromNumber$1;BigInteger$3.prototype.bitwiseTo=bnpBitwiseTo$1;BigInteger$3.prototype.changeBit=bnpChangeBit$1;BigInteger$3.prototype.addTo=bnpAddTo$1;BigInteger$3.prototype.dMultiply=bnpDMultiply$1;BigInteger$3.prototype.dAddOffset=bnpDAddOffset$1;BigInteger$3.prototype.multiplyLowerTo=bnpMultiplyLowerTo$1;BigInteger$3.prototype.multiplyUpperTo=bnpMultiplyUpperTo$1;BigInteger$3.prototype.modInt=bnpModInt$1;BigInteger$3.prototype.millerRabin=bnpMillerRabin$1;BigInteger$3.prototype.clone=bnClone$1;BigInteger$3.prototype.intValue=bnIntValue$1;BigInteger$3.prototype.byteValue=bnByteValue$1;BigInteger$3.prototype.shortValue=bnShortValue$1;BigInteger$3.prototype.signum=bnSigNum$1;BigInteger$3.prototype.toByteArray=bnToByteArray$1;BigInteger$3.prototype.equals=bnEquals$1;BigInteger$3.prototype.min=bnMin$1;BigInteger$3.prototype.max=bnMax$1;BigInteger$3.prototype.and=bnAnd$1;BigInteger$3.prototype.or=bnOr$1;BigInteger$3.prototype.xor=bnXor$1;BigInteger$3.prototype.andNot=bnAndNot$1;BigInteger$3.prototype.not=bnNot$1;BigInteger$3.prototype.shiftLeft=bnShiftLeft$1;BigInteger$3.prototype.shiftRight=bnShiftRight$1;BigInteger$3.prototype.getLowestSetBit=bnGetLowestSetBit$1;BigInteger$3.prototype.bitCount=bnBitCount$1;BigInteger$3.prototype.testBit=bnTestBit$1;BigInteger$3.prototype.setBit=bnSetBit$1;BigInteger$3.prototype.clearBit=bnClearBit$1;BigInteger$3.prototype.flipBit=bnFlipBit$1;BigInteger$3.prototype.add=bnAdd$1;BigInteger$3.prototype.subtract=bnSubtract$1;BigInteger$3.prototype.multiply=bnMultiply$1;BigInteger$3.prototype.divide=bnDivide$1;BigInteger$3.prototype.remainder=bnRemainder$1;BigInteger$3.prototype.divideAndRemainder=bnDivideAndRemainder$1;BigInteger$3.prototype.modPow=bnModPow$1;BigInteger$3.prototype.modInverse=bnModInverse$1;BigInteger$3.prototype.pow=bnPow$1;BigInteger$3.prototype.gcd=bnGCD$1;BigInteger$3.prototype.isProbablePrime=bnIsProbablePrime$1;BigInteger$3.prototype.square=bnSquare;BigInteger$3.prototype.Barrett=Barrett$1;let rng_psize=256,rng_pool,rng_pptr;function rng_seed_int(J){rng_pool[rng_pptr++]^=J&255,rng_pool[rng_pptr++]^=J>>8&255,rng_pool[rng_pptr++]^=J>>16&255,rng_pool[rng_pptr++]^=J>>24&255,rng_pptr>=rng_psize&&(rng_pptr-=rng_psize)}function rng_seed_time(){rng_seed_int(new Date().getTime())}if(rng_pool==null){rng_pool=new Array,rng_pptr=0;let J;if(typeof dntGlobalThis<"u"&&globalThis.crypto){if(globalThis.crypto.getRandomValues){let E=new Uint8Array(32);for(globalThis.crypto.getRandomValues(E),J=0;J<32;++J)rng_pool[rng_pptr++]=E[J]}else if(navigator.appName=="Netscape"&&navigator.appVersion<"5"){let E=globalThis.crypto.random(32);for(J=0;J<E.length;++J)rng_pool[rng_pptr++]=E.charCodeAt(J)&255}}for(;rng_pptr<rng_psize;)J=Math.floor(65536*Math.random()),rng_pool[rng_pptr++]=J>>>8,rng_pool[rng_pptr++]=J&255;rng_pptr=0,rng_seed_time()}function fromNumber(J){return new BigInteger$3(J.toString(10))}const N0=BigInteger$3.ZERO,N1$4=BigInteger$3.ONE,N2$4=fromNumber(2),N3$4=fromNumber(3),N5$4=fromNumber(5),N128=fromNumber(128),N255=fromNumber(255);function sqr(J){return J.multiply(J)}const P=new BigInteger$3("726838724295606890549323807888004534353641360687318060281490199180612328166730772686396383698676545930088884461843637361053498018365439"),A24=new BigInteger$3("39081");function cswap(J,E,ee){const te=J.multiply(E.subtract(ee)).mod(P);return[E.subtract(te).mod(P),ee.add(te).mod(P)]}function X448$1(J,E){const ee=E;let te=N1$4,re=N0,ne=E,ie=N1$4,se=N0;for(let ce=448-1;ce>=0;--ce){const le=J.shiftRight(ce).and(N1$4);se=se.xor(le);{const[we,$e]=cswap(se,te,ne);te=we,ne=$e}{const[we,$e]=cswap(se,re,ie);re=we,ie=$e}se=le;const he=te.add(re).mod(P),de=sqr(he).mod(P),ue=te.subtract(re).mod(P),pe=sqr(ue).mod(P),ye=de.subtract(pe).mod(P),me=ne.add(ie).mod(P),be=ne.subtract(ie).mod(P).multiply(he).mod(P),_e=me.multiply(ue).mod(P);ne=sqr(be.add(_e).mod(P)).mod(P),ie=ee.multiply(sqr(be.subtract(_e).mod(P))).mod(P),te=de.multiply(pe).mod(P),re=ye.multiply(de.add(A24.multiply(ye).mod(P)).mod(P)).mod(P)}const[oe]=cswap(se,te,ne),[ae]=cswap(se,re,ie);return oe.multiply(ae.modPow(P.subtract(N2$4),P)).mod(P)}function decodeLittleEndian(J){return J.map((E,ee)=>fromNumber(E).shiftLeft(8*ee)).reduce((E,ee)=>E.add(ee),N0)}function decodeScalar448(J){const E=[...J];return E[0]&=252,E[55]|=128,decodeLittleEndian(E)}function unpack(J){if(J.length!==56)throw new Error(`Invalid Curve448 scalar (len=${J.length})`);return J.map((E,ee)=>fromNumber(E).shiftLeft(8*ee)).reduce((E,ee)=>E.add(ee),N0)}function pack(J){return Array.from({length:56},(E,ee)=>J.shiftRight(8*ee).and(N255).intValue())}function clamp(J){return J.andNot(N3$4).or(N128.shiftLeft(8*55))}function multscalar(J,E){const ee=clamp(decodeScalar448(J)),te=unpack(E);return pack(X448$1(ee,te))}function base_point_mult(J){const E=clamp(decodeScalar448(J));return pack(X448$1(E,N5$4))}function getPublicKey$2(J){if(!J)throw new Error("Missing private key");if(J.length!==56)throw new Error(`Invalid Curve448 private key (len=${J.length})`);return base_point_mult(Array.from(J))}function getSharedSecret(J,E){if(!J)throw new Error("Missing private key");if(!E)throw new Error("Missing public key");if(J.length!==56)throw new Error(`Invalid Curve448 private key (len=${J.length})`);const ee=multscalar(Array.from(J),Array.from(E));if(!ee.some(te=>te))throw new Error("Invalid Curve448 public key");return ee}const ALG_NAME="X448";class X448{constructor(E){Object.defineProperty(this,"_hkdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nPk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nSk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._hkdf=E,this._nPk=56,this._nSk=56}async serializePublicKey(E){return await this._serializePublicKey(E)}async deserializePublicKey(E){return await this._deserializePublicKey(E)}async importKey(E,ee,te){if(E!=="raw")throw new Error("Unsupported format");return await this._importKey(ee,te)}async derivePublicKey(E){return await this._derivePublicKey(E)}async generateKeyPair(){const E=new Uint8Array(56);return(await loadCrypto()).getRandomValues(E),await this.deriveKeyPair(E)}async deriveKeyPair(E){const ee=await this._hkdf.labeledExtract(EMPTY,LABEL_DKP_PRK,new Uint8Array(E)),te=await this._hkdf.labeledExpand(ee,LABEL_SK,EMPTY,this._nSk),re=new XCryptoKey(ALG_NAME,new Uint8Array(te),"private");return{privateKey:re,publicKey:await this.derivePublicKey(re)}}async dh(E,ee){return await this._dh(E,ee)}_serializePublicKey(E){return new Promise(ee=>{ee(E.key.buffer)})}_deserializePublicKey(E){return new Promise((ee,te)=>{E.byteLength!==this._nPk?te(new Error("Invalid public key for the ciphersuite")):ee(new XCryptoKey(ALG_NAME,new Uint8Array(E),"public"))})}_importKey(E,ee){return new Promise((te,re)=>{ee&&E.byteLength!==this._nPk&&re(new Error("Invalid public key for the ciphersuite")),!ee&&E.byteLength!==this._nSk&&re(new Error("Invalid private key for the ciphersuite")),te(new XCryptoKey(ALG_NAME,new Uint8Array(E),ee?"public":"private"))})}_derivePublicKey(E){return new Promise(ee=>{ee(new XCryptoKey(ALG_NAME,Uint8Array.from(getPublicKey$2(E.key)),"public"))})}_dh(E,ee){return new Promise((te,re)=>{try{te(Uint8Array.from(getSharedSecret(E.key,ee.key)))}catch(ne){re(ne)}})}}class KemContext extends WebCrypto{constructor(E,ee){super(E),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"secretSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"encSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"publicKeySize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"privateKeySize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_prim",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_kdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.id=ee;let te=Kdf$1.HkdfSha256;switch(ee){case Kem$1.DhkemP256HkdfSha256:te=Kdf$1.HkdfSha256;break;case Kem$1.DhkemP384HkdfSha384:te=Kdf$1.HkdfSha384;break;case Kem$1.DhkemP521HkdfSha512:te=Kdf$1.HkdfSha512;break;case Kem$1.DhkemX25519HkdfSha256:te=Kdf$1.HkdfSha256;break;default:te=Kdf$1.HkdfSha512;break}const re=new Uint8Array(SUITE_ID_HEADER_KEM);switch(re.set(i2Osp(ee,2),3),this._kdf=new KdfContext(this._api,te,re),ee){case Kem$1.DhkemP256HkdfSha256:this._prim=new Ec(ee,this._kdf,this._api),this.secretSize=32,this.encSize=65,this.publicKeySize=65,this.privateKeySize=32;break;case Kem$1.DhkemP384HkdfSha384:this._prim=new Ec(ee,this._kdf,this._api),this.secretSize=48,this.encSize=97,this.publicKeySize=97,this.privateKeySize=48;break;case Kem$1.DhkemP521HkdfSha512:this._prim=new Ec(ee,this._kdf,this._api),this.secretSize=64,this.encSize=133,this.publicKeySize=133,this.privateKeySize=66;break;case Kem$1.DhkemX25519HkdfSha256:this._prim=new X25519(this._kdf),this.secretSize=32,this.encSize=32,this.publicKeySize=32,this.privateKeySize=32;break;default:this._prim=new X448(this._kdf),this.secretSize=64,this.encSize=56,this.publicKeySize=56,this.privateKeySize=56;break}}async generateKeyPair(){return await this._prim.generateKeyPair()}async deriveKeyPair(E){try{return await this._prim.deriveKeyPair(E)}catch(ee){throw new DeriveKeyPairError(ee)}}async importKey(E,ee,te){try{return await this._prim.importKey(E,ee,te)}catch(re){throw new DeserializeError(re)}}async encap(E){try{const ee=E.nonEphemeralKeyPair===void 0?await this.generateKeyPair():E.nonEphemeralKeyPair,te=await this._prim.serializePublicKey(ee.publicKey),re=await this._prim.serializePublicKey(E.recipientPublicKey);let ne;if(E.senderKey===void 0)ne=new Uint8Array(await this._prim.dh(ee.privateKey,E.recipientPublicKey));else{const oe=isCryptoKeyPair(E.senderKey)?E.senderKey.privateKey:E.senderKey,ae=new Uint8Array(await this._prim.dh(ee.privateKey,E.recipientPublicKey)),ce=new Uint8Array(await this._prim.dh(oe,E.recipientPublicKey));ne=concat$5(ae,ce)}let ie;if(E.senderKey===void 0)ie=concat$5(new Uint8Array(te),new Uint8Array(re));else{const oe=isCryptoKeyPair(E.senderKey)?E.senderKey.publicKey:await this._prim.derivePublicKey(E.senderKey),ae=await this._prim.serializePublicKey(oe);ie=concat3(new Uint8Array(te),new Uint8Array(re),new Uint8Array(ae))}const se=await this.generateSharedSecret(ne,ie);return{enc:te,sharedSecret:se}}catch(ee){throw new EncapError(ee)}}async decap(E){let ee;try{ee=await this._prim.deserializePublicKey(E.enc)}catch(te){throw new DeserializeError(te)}try{const te=isCryptoKeyPair(E.recipientKey)?E.recipientKey.privateKey:E.recipientKey,re=isCryptoKeyPair(E.recipientKey)?E.recipientKey.publicKey:await this._prim.derivePublicKey(E.recipientKey),ne=await this._prim.serializePublicKey(re);let ie;if(E.senderPublicKey===void 0)ie=new Uint8Array(await this._prim.dh(te,ee));else{const oe=new Uint8Array(await this._prim.dh(te,ee)),ae=new Uint8Array(await this._prim.dh(te,E.senderPublicKey));ie=concat$5(oe,ae)}let se;if(E.senderPublicKey===void 0)se=concat$5(new Uint8Array(E.enc),new Uint8Array(ne));else{const oe=await this._prim.serializePublicKey(E.senderPublicKey);se=new Uint8Array(E.enc.byteLength+ne.byteLength+oe.byteLength),se.set(new Uint8Array(E.enc),0),se.set(new Uint8Array(ne),E.enc.byteLength),se.set(new Uint8Array(oe),E.enc.byteLength+ne.byteLength)}return await this.generateSharedSecret(ie,se)}catch(te){throw new DecapError(te)}}async generateSharedSecret(E,ee){const te=this._kdf.buildLabeledIkm(LABEL_EAE_PRK,E),re=this._kdf.buildLabeledInfo(LABEL_SHARED_SECRET,ee,this.secretSize);return await this._kdf.extractAndExpand(EMPTY,te,re,this.secretSize)}}class RecipientContext extends EncryptionContext{async seal(E,ee=EMPTY){if(this._r.baseNonce.length===0)throw new SealError("Bidirectional encryption is not setup");let te;try{te=await this._r.key.seal(this.computeNonce(this._r),E,ee)}catch(re){throw new SealError(re)}return this.incrementSeq(this._r),te}async open(E,ee=EMPTY){let te;try{te=await this._f.key.open(this.computeNonce(this._f),E,ee)}catch(re){throw new OpenError(re)}return this.incrementSeq(this._f),te}}class SenderContext extends EncryptionContext{constructor(E,ee,te,re){super(E,ee,te),Object.defineProperty(this,"enc",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.enc=re}async seal(E,ee=EMPTY){let te;try{te=await this._f.key.seal(this.computeNonce(this._f),E,ee)}catch(re){throw new SealError(re)}return this.incrementSeq(this._f),te}async open(E,ee=EMPTY){if(this._r.baseNonce.length===0)throw new OpenError("Bidirectional encryption is not setup");let te;try{te=await this._r.key.open(this.computeNonce(this._r),E,ee)}catch(re){throw new OpenError(re)}return this.incrementSeq(this._r),te}}let CipherSuite$1=class{constructor(J){switch(Object.defineProperty(this,"kem",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"kdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"aead",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"kemSecretSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"kemEncSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"kemPublicKeySize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"kemPrivateKeySize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"aeadKeySize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"aeadNonceSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"aeadTagSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_api",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_kem",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_kdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_suiteId",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),J.kem){case Kem$1.DhkemP256HkdfSha256:this.kemSecretSize=32,this.kemEncSize=65,this.kemPublicKeySize=65,this.kemPrivateKeySize=32;break;case Kem$1.DhkemP384HkdfSha384:this.kemSecretSize=48,this.kemEncSize=97,this.kemPublicKeySize=97,this.kemPrivateKeySize=48;break;case Kem$1.DhkemP521HkdfSha512:this.kemSecretSize=64,this.kemEncSize=133,this.kemPublicKeySize=133,this.kemPrivateKeySize=66;break;case Kem$1.DhkemX25519HkdfSha256:this.kemSecretSize=32,this.kemEncSize=32,this.kemPublicKeySize=32,this.kemPrivateKeySize=32;break;case Kem$1.DhkemX448HkdfSha512:this.kemSecretSize=64,this.kemEncSize=56,this.kemPublicKeySize=56,this.kemPrivateKeySize=56;break;default:throw new InvalidParamError("Invalid KEM id")}switch(this.kem=J.kem,J.kdf){case Kdf$1.HkdfSha256:case Kdf$1.HkdfSha384:case Kdf$1.HkdfSha512:break;default:throw new InvalidParamError("Invalid KDF id")}switch(this.kdf=J.kdf,J.aead){case Aead$1.Aes128Gcm:this.aeadKeySize=16,this.aeadNonceSize=12,this.aeadTagSize=16;break;case Aead$1.Aes256Gcm:this.aeadKeySize=32,this.aeadNonceSize=12,this.aeadTagSize=16;break;case Aead$1.Chacha20Poly1305:this.aeadKeySize=32,this.aeadNonceSize=12,this.aeadTagSize=16;break;case Aead$1.ExportOnly:break;default:throw new InvalidParamError("Invalid AEAD id")}this.aead=J.aead,this._suiteId=new Uint8Array(SUITE_ID_HEADER_HPKE),this._suiteId.set(i2Osp(this.kem,2),4),this._suiteId.set(i2Osp(this.kdf,2),6),this._suiteId.set(i2Osp(this.aead,2),8)}async kemContext(){return await this.setup(),this._kem}async kdfContext(){return await this.setup(),this._kdf}async createAeadKey(J){return await this.setup(),createAeadKey(this.aead,J,this._api)}async generateKeyPair(){return await this.setup(),await this._kem.generateKeyPair()}async deriveKeyPair(J){if(J.byteLength>INPUT_LENGTH_LIMIT)throw new InvalidParamError("Too long ikm");return await this.setup(),await this._kem.deriveKeyPair(J)}async importKey(J,E,ee=!0){return await this.setup(),await this._kem.importKey(J,E,ee)}async createSenderContext(J){this.validateInputLength(J),await this.setup();const E=await this._kem.encap(J);let ee;return J.psk!==void 0?ee=J.senderKey!==void 0?Mode$5.AuthPsk:Mode$5.Psk:ee=J.senderKey!==void 0?Mode$5.Auth:Mode$5.Base,await this.keyScheduleS(ee,E.sharedSecret,E.enc,J)}async createRecipientContext(J){this.validateInputLength(J),await this.setup();const E=await this._kem.decap(J);let ee;return J.psk!==void 0?ee=J.senderPublicKey!==void 0?Mode$5.AuthPsk:Mode$5.Psk:ee=J.senderPublicKey!==void 0?Mode$5.Auth:Mode$5.Base,await this.keyScheduleR(ee,E,J)}async seal(J,E,ee=EMPTY){const te=await this.createSenderContext(J);return{ct:await te.seal(E,ee),enc:te.enc}}async open(J,E,ee=EMPTY){return await(await this.createRecipientContext(J)).open(E,ee)}async setup(){this._api=await loadSubtleCrypto(),(this._kem===void 0||this._kdf===void 0)&&(this._kem=new KemContext(this._api,this.kem),this._kdf=new KdfContext(this._api,this.kdf,this._suiteId))}async keySchedule(J,E,ee){const te=new KdfContext(this._api,this.kdf,this._suiteId),re=ee.psk===void 0?EMPTY:new Uint8Array(ee.psk.id),ne=await te.labeledExtract(EMPTY,LABEL_PSK_ID_HASH,re),ie=ee.info===void 0?EMPTY:new Uint8Array(ee.info),se=await te.labeledExtract(EMPTY,LABEL_INFO_HASH,ie),oe=new Uint8Array(1+ne.byteLength+se.byteLength);oe.set(new Uint8Array([J]),0),oe.set(new Uint8Array(ne),1),oe.set(new Uint8Array(se),1+ne.byteLength);const ae=ee.psk===void 0?EMPTY:new Uint8Array(ee.psk.key),ce=te.buildLabeledIkm(LABEL_SECRET,ae),le=te.buildLabeledInfo(LABEL_EXP,oe,te.hashSize),he=await te.extractAndExpand(E,ce,le,te.hashSize);if(this.aead===Aead$1.ExportOnly)return{params:{aead:this.aead,exporterSecret:he},kdf:te};const de=te.buildLabeledInfo(LABEL_KEY,oe,this.aeadKeySize),ue=await te.extractAndExpand(E,ce,de,this.aeadKeySize),pe=te.buildLabeledInfo(LABEL_BASE_NONCE,oe,this.aeadNonceSize),ye=await te.extractAndExpand(E,ce,pe,this.aeadNonceSize);return{params:{aead:this.aead,exporterSecret:he,key:ue,baseNonce:new Uint8Array(ye),seq:0},kdf:te}}async keyScheduleS(J,E,ee,te){const re=await this.keySchedule(J,E,te);return re.params.key===void 0?new SenderExporterContext(this._api,re.kdf,re.params.exporterSecret,ee):new SenderContext(this._api,re.kdf,re.params,ee)}async keyScheduleR(J,E,ee){const te=await this.keySchedule(J,E,ee);return te.params.key===void 0?new RecipientExporterContext(this._api,te.kdf,te.params.exporterSecret):new RecipientContext(this._api,te.kdf,te.params)}validateInputLength(J){if(J.info!==void 0&&J.info.byteLength>INPUT_LENGTH_LIMIT)throw new InvalidParamError("Too long info");if(J.psk!==void 0){if(J.psk.key.byteLength<MINIMUM_PSK_LENGTH)throw new InvalidParamError(`PSK must have at least ${MINIMUM_PSK_LENGTH} bytes`);if(J.psk.key.byteLength>INPUT_LENGTH_LIMIT)throw new InvalidParamError("Too long psk.key");if(J.psk.id.byteLength>INPUT_LENGTH_LIMIT)throw new InvalidParamError("Too long psk.id")}}};const hpke=Object.freeze(Object.defineProperty({__proto__:null,get Aead(){return Aead$1},CipherSuite:CipherSuite$1,DecapError,DeriveKeyPairError,DeserializeError,EncapError,ExportError,InvalidParamError,get Kdf(){return Kdf$1},get Kem(){return Kem$1},MessageLimitReachedError,NotSupportedError,OpenError,SealError,SerializeError,ValidationError},Symbol.toStringTag,{value:"Module"}));var ed25519$1={},random={},system={},browser$4={};Object.defineProperty(browser$4,"__esModule",{value:!0});browser$4.BrowserRandomSource=void 0;const QUOTA=65536;class BrowserRandomSource{constructor(){this.isAvailable=!1,this.isInstantiated=!1;const E=typeof self<"u"?self.crypto||self.msCrypto:null;E&&E.getRandomValues!==void 0&&(this._crypto=E,this.isAvailable=!0,this.isInstantiated=!0)}randomBytes(E){if(!this.isAvailable||!this._crypto)throw new Error("Browser random byte generator is not available.");const ee=new Uint8Array(E);for(let te=0;te<ee.length;te+=QUOTA)this._crypto.getRandomValues(ee.subarray(te,te+Math.min(ee.length-te,QUOTA)));return ee}}browser$4.BrowserRandomSource=BrowserRandomSource;function commonjsRequire(J){throw new Error('Could not dynamically require "'+J+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var node={},wipe$1={};Object.defineProperty(wipe$1,"__esModule",{value:!0});function wipe(J){for(var E=0;E<J.length;E++)J[E]=0;return J}wipe$1.wipe=wipe;const net={},nodeCrypto=Object.freeze(Object.defineProperty({__proto__:null,default:net},Symbol.toStringTag,{value:"Module"})),require$$8=getAugmentedNamespace(nodeCrypto);Object.defineProperty(node,"__esModule",{value:!0});node.NodeRandomSource=void 0;const wipe_1$1=wipe$1;class NodeRandomSource{constructor(){if(this.isAvailable=!1,this.isInstantiated=!1,typeof commonjsRequire<"u"){const E=require$$8;E&&E.randomBytes&&(this._crypto=E,this.isAvailable=!0,this.isInstantiated=!0)}}randomBytes(E){if(!this.isAvailable||!this._crypto)throw new Error("Node.js random byte generator is not available.");let ee=this._crypto.randomBytes(E);if(ee.length!==E)throw new Error("NodeRandomSource: got fewer bytes than requested");const te=new Uint8Array(E);for(let re=0;re<te.length;re++)te[re]=ee[re];return(0,wipe_1$1.wipe)(ee),te}}node.NodeRandomSource=NodeRandomSource;Object.defineProperty(system,"__esModule",{value:!0});system.SystemRandomSource=void 0;const browser_1=browser$4,node_1=node;class SystemRandomSource{constructor(){if(this.isAvailable=!1,this.name="",this._source=new browser_1.BrowserRandomSource,this._source.isAvailable){this.isAvailable=!0,this.name="Browser";return}if(this._source=new node_1.NodeRandomSource,this._source.isAvailable){this.isAvailable=!0,this.name="Node";return}}randomBytes(E){if(!this.isAvailable)throw new Error("System random byte generator is not available.");return this._source.randomBytes(E)}}system.SystemRandomSource=SystemRandomSource;var binary={},int={};(function(J){Object.defineProperty(J,"__esModule",{value:!0});function E(se,oe){var ae=se>>>16&65535,ce=se&65535,le=oe>>>16&65535,he=oe&65535;return ce*he+(ae*he+ce*le<<16>>>0)|0}J.mul=Math.imul||E;function ee(se,oe){return se+oe|0}J.add=ee;function te(se,oe){return se-oe|0}J.sub=te;function re(se,oe){return se<<oe|se>>>32-oe}J.rotl=re;function ne(se,oe){return se<<32-oe|se>>>oe}J.rotr=ne;function ie(se){return typeof se=="number"&&isFinite(se)&&Math.floor(se)===se}J.isInteger=Number.isInteger||ie,J.MAX_SAFE_INTEGER=9007199254740991,J.isSafeInteger=function(se){return J.isInteger(se)&&se>=-J.MAX_SAFE_INTEGER&&se<=J.MAX_SAFE_INTEGER}})(int);Object.defineProperty(binary,"__esModule",{value:!0});var int_1=int;function readInt16BE(J,E){return E===void 0&&(E=0),(J[E+0]<<8|J[E+1])<<16>>16}binary.readInt16BE=readInt16BE;function readUint16BE(J,E){return E===void 0&&(E=0),(J[E+0]<<8|J[E+1])>>>0}binary.readUint16BE=readUint16BE;function readInt16LE(J,E){return E===void 0&&(E=0),(J[E+1]<<8|J[E])<<16>>16}binary.readInt16LE=readInt16LE;function readUint16LE(J,E){return E===void 0&&(E=0),(J[E+1]<<8|J[E])>>>0}binary.readUint16LE=readUint16LE;function writeUint16BE(J,E,ee){return E===void 0&&(E=new Uint8Array(2)),ee===void 0&&(ee=0),E[ee+0]=J>>>8,E[ee+1]=J>>>0,E}binary.writeUint16BE=writeUint16BE;binary.writeInt16BE=writeUint16BE;function writeUint16LE(J,E,ee){return E===void 0&&(E=new Uint8Array(2)),ee===void 0&&(ee=0),E[ee+0]=J>>>0,E[ee+1]=J>>>8,E}binary.writeUint16LE=writeUint16LE;binary.writeInt16LE=writeUint16LE;function readInt32BE(J,E){return E===void 0&&(E=0),J[E]<<24|J[E+1]<<16|J[E+2]<<8|J[E+3]}binary.readInt32BE=readInt32BE;function readUint32BE(J,E){return E===void 0&&(E=0),(J[E]<<24|J[E+1]<<16|J[E+2]<<8|J[E+3])>>>0}binary.readUint32BE=readUint32BE;function readInt32LE(J,E){return E===void 0&&(E=0),J[E+3]<<24|J[E+2]<<16|J[E+1]<<8|J[E]}binary.readInt32LE=readInt32LE;function readUint32LE(J,E){return E===void 0&&(E=0),(J[E+3]<<24|J[E+2]<<16|J[E+1]<<8|J[E])>>>0}binary.readUint32LE=readUint32LE;function writeUint32BE(J,E,ee){return E===void 0&&(E=new Uint8Array(4)),ee===void 0&&(ee=0),E[ee+0]=J>>>24,E[ee+1]=J>>>16,E[ee+2]=J>>>8,E[ee+3]=J>>>0,E}binary.writeUint32BE=writeUint32BE;binary.writeInt32BE=writeUint32BE;function writeUint32LE(J,E,ee){return E===void 0&&(E=new Uint8Array(4)),ee===void 0&&(ee=0),E[ee+0]=J>>>0,E[ee+1]=J>>>8,E[ee+2]=J>>>16,E[ee+3]=J>>>24,E}binary.writeUint32LE=writeUint32LE;binary.writeInt32LE=writeUint32LE;function readInt64BE(J,E){E===void 0&&(E=0);var ee=readInt32BE(J,E),te=readInt32BE(J,E+4);return ee*4294967296+te-(te>>31)*4294967296}binary.readInt64BE=readInt64BE;function readUint64BE(J,E){E===void 0&&(E=0);var ee=readUint32BE(J,E),te=readUint32BE(J,E+4);return ee*4294967296+te}binary.readUint64BE=readUint64BE;function readInt64LE(J,E){E===void 0&&(E=0);var ee=readInt32LE(J,E),te=readInt32LE(J,E+4);return te*4294967296+ee-(ee>>31)*4294967296}binary.readInt64LE=readInt64LE;function readUint64LE(J,E){E===void 0&&(E=0);var ee=readUint32LE(J,E),te=readUint32LE(J,E+4);return te*4294967296+ee}binary.readUint64LE=readUint64LE;function writeUint64BE(J,E,ee){return E===void 0&&(E=new Uint8Array(8)),ee===void 0&&(ee=0),writeUint32BE(J/4294967296>>>0,E,ee),writeUint32BE(J>>>0,E,ee+4),E}binary.writeUint64BE=writeUint64BE;binary.writeInt64BE=writeUint64BE;function writeUint64LE(J,E,ee){return E===void 0&&(E=new Uint8Array(8)),ee===void 0&&(ee=0),writeUint32LE(J>>>0,E,ee),writeUint32LE(J/4294967296>>>0,E,ee+4),E}binary.writeUint64LE=writeUint64LE;binary.writeInt64LE=writeUint64LE;function readUintBE$1(J,E,ee){if(ee===void 0&&(ee=0),J%8!==0)throw new Error("readUintBE supports only bitLengths divisible by 8");if(J/8>E.length-ee)throw new Error("readUintBE: array is too short for the given bitLength");for(var te=0,re=1,ne=J/8+ee-1;ne>=ee;ne--)te+=E[ne]*re,re*=256;return te}binary.readUintBE=readUintBE$1;function readUintLE$1(J,E,ee){if(ee===void 0&&(ee=0),J%8!==0)throw new Error("readUintLE supports only bitLengths divisible by 8");if(J/8>E.length-ee)throw new Error("readUintLE: array is too short for the given bitLength");for(var te=0,re=1,ne=ee;ne<ee+J/8;ne++)te+=E[ne]*re,re*=256;return te}binary.readUintLE=readUintLE$1;function writeUintBE$1(J,E,ee,te){if(ee===void 0&&(ee=new Uint8Array(J/8)),te===void 0&&(te=0),J%8!==0)throw new Error("writeUintBE supports only bitLengths divisible by 8");if(!int_1.isSafeInteger(E))throw new Error("writeUintBE value must be an integer");for(var re=1,ne=J/8+te-1;ne>=te;ne--)ee[ne]=E/re&255,re*=256;return ee}binary.writeUintBE=writeUintBE$1;function writeUintLE$1(J,E,ee,te){if(ee===void 0&&(ee=new Uint8Array(J/8)),te===void 0&&(te=0),J%8!==0)throw new Error("writeUintLE supports only bitLengths divisible by 8");if(!int_1.isSafeInteger(E))throw new Error("writeUintLE value must be an integer");for(var re=1,ne=te;ne<te+J/8;ne++)ee[ne]=E/re&255,re*=256;return ee}binary.writeUintLE=writeUintLE$1;function readFloat32BE(J,E){E===void 0&&(E=0);var ee=new DataView(J.buffer,J.byteOffset,J.byteLength);return ee.getFloat32(E)}binary.readFloat32BE=readFloat32BE;function readFloat32LE(J,E){E===void 0&&(E=0);var ee=new DataView(J.buffer,J.byteOffset,J.byteLength);return ee.getFloat32(E,!0)}binary.readFloat32LE=readFloat32LE;function readFloat64BE(J,E){E===void 0&&(E=0);var ee=new DataView(J.buffer,J.byteOffset,J.byteLength);return ee.getFloat64(E)}binary.readFloat64BE=readFloat64BE;function readFloat64LE(J,E){E===void 0&&(E=0);var ee=new DataView(J.buffer,J.byteOffset,J.byteLength);return ee.getFloat64(E,!0)}binary.readFloat64LE=readFloat64LE;function writeFloat32BE(J,E,ee){E===void 0&&(E=new Uint8Array(4)),ee===void 0&&(ee=0);var te=new DataView(E.buffer,E.byteOffset,E.byteLength);return te.setFloat32(ee,J),E}binary.writeFloat32BE=writeFloat32BE;function writeFloat32LE(J,E,ee){E===void 0&&(E=new Uint8Array(4)),ee===void 0&&(ee=0);var te=new DataView(E.buffer,E.byteOffset,E.byteLength);return te.setFloat32(ee,J,!0),E}binary.writeFloat32LE=writeFloat32LE;function writeFloat64BE(J,E,ee){E===void 0&&(E=new Uint8Array(8)),ee===void 0&&(ee=0);var te=new DataView(E.buffer,E.byteOffset,E.byteLength);return te.setFloat64(ee,J),E}binary.writeFloat64BE=writeFloat64BE;function writeFloat64LE(J,E,ee){E===void 0&&(E=new Uint8Array(8)),ee===void 0&&(ee=0);var te=new DataView(E.buffer,E.byteOffset,E.byteLength);return te.setFloat64(ee,J,!0),E}binary.writeFloat64LE=writeFloat64LE;(function(J){Object.defineProperty(J,"__esModule",{value:!0}),J.randomStringForEntropy=J.randomString=J.randomUint32=J.randomBytes=J.defaultRandomSource=void 0;const E=system,ee=binary,te=wipe$1;J.defaultRandomSource=new E.SystemRandomSource;function re(ae,ce=J.defaultRandomSource){return ce.randomBytes(ae)}J.randomBytes=re;function ne(ae=J.defaultRandomSource){const ce=re(4,ae),le=(0,ee.readUint32LE)(ce);return(0,te.wipe)(ce),le}J.randomUint32=ne;const ie="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";function se(ae,ce=ie,le=J.defaultRandomSource){if(ce.length<2)throw new Error("randomString charset is too short");if(ce.length>256)throw new Error("randomString charset is too long");let he="";const de=ce.length,ue=256-256%de;for(;ae>0;){const pe=re(Math.ceil(ae*256/ue),le);for(let ye=0;ye<pe.length&&ae>0;ye++){const me=pe[ye];me<ue&&(he+=ce.charAt(me%de),ae--)}(0,te.wipe)(pe)}return he}J.randomString=se;function oe(ae,ce=ie,le=J.defaultRandomSource){const he=Math.ceil(ae/(Math.log(ce.length)/Math.LN2));return se(he,ce,le)}J.randomStringForEntropy=oe})(random);var sha512$1={};(function(J){Object.defineProperty(J,"__esModule",{value:!0});var E=binary,ee=wipe$1;J.DIGEST_LENGTH=64,J.BLOCK_SIZE=128;var te=function(){function se(){this.digestLength=J.DIGEST_LENGTH,this.blockSize=J.BLOCK_SIZE,this._stateHi=new Int32Array(8),this._stateLo=new Int32Array(8),this._tempHi=new Int32Array(16),this._tempLo=new Int32Array(16),this._buffer=new Uint8Array(256),this._bufferLength=0,this._bytesHashed=0,this._finished=!1,this.reset()}return se.prototype._initState=function(){this._stateHi[0]=1779033703,this._stateHi[1]=3144134277,this._stateHi[2]=1013904242,this._stateHi[3]=2773480762,this._stateHi[4]=1359893119,this._stateHi[5]=2600822924,this._stateHi[6]=528734635,this._stateHi[7]=1541459225,this._stateLo[0]=4089235720,this._stateLo[1]=2227873595,this._stateLo[2]=4271175723,this._stateLo[3]=1595750129,this._stateLo[4]=2917565137,this._stateLo[5]=725511199,this._stateLo[6]=4215389547,this._stateLo[7]=327033209},se.prototype.reset=function(){return this._initState(),this._bufferLength=0,this._bytesHashed=0,this._finished=!1,this},se.prototype.clean=function(){ee.wipe(this._buffer),ee.wipe(this._tempHi),ee.wipe(this._tempLo),this.reset()},se.prototype.update=function(oe,ae){if(ae===void 0&&(ae=oe.length),this._finished)throw new Error("SHA512: can't update because hash was finished.");var ce=0;if(this._bytesHashed+=ae,this._bufferLength>0){for(;this._bufferLength<J.BLOCK_SIZE&&ae>0;)this._buffer[this._bufferLength++]=oe[ce++],ae--;this._bufferLength===this.blockSize&&(ne(this._tempHi,this._tempLo,this._stateHi,this._stateLo,this._buffer,0,this.blockSize),this._bufferLength=0)}for(ae>=this.blockSize&&(ce=ne(this._tempHi,this._tempLo,this._stateHi,this._stateLo,oe,ce,ae),ae%=this.blockSize);ae>0;)this._buffer[this._bufferLength++]=oe[ce++],ae--;return this},se.prototype.finish=function(oe){if(!this._finished){var ae=this._bytesHashed,ce=this._bufferLength,le=ae/536870912|0,he=ae<<3,de=ae%128<112?128:256;this._buffer[ce]=128;for(var ue=ce+1;ue<de-8;ue++)this._buffer[ue]=0;E.writeUint32BE(le,this._buffer,de-8),E.writeUint32BE(he,this._buffer,de-4),ne(this._tempHi,this._tempLo,this._stateHi,this._stateLo,this._buffer,0,de),this._finished=!0}for(var ue=0;ue<this.digestLength/8;ue++)E.writeUint32BE(this._stateHi[ue],oe,ue*8),E.writeUint32BE(this._stateLo[ue],oe,ue*8+4);return this},se.prototype.digest=function(){var oe=new Uint8Array(this.digestLength);return this.finish(oe),oe},se.prototype.saveState=function(){if(this._finished)throw new Error("SHA256: cannot save finished state");return{stateHi:new Int32Array(this._stateHi),stateLo:new Int32Array(this._stateLo),buffer:this._bufferLength>0?new Uint8Array(this._buffer):void 0,bufferLength:this._bufferLength,bytesHashed:this._bytesHashed}},se.prototype.restoreState=function(oe){return this._stateHi.set(oe.stateHi),this._stateLo.set(oe.stateLo),this._bufferLength=oe.bufferLength,oe.buffer&&this._buffer.set(oe.buffer),this._bytesHashed=oe.bytesHashed,this._finished=!1,this},se.prototype.cleanSavedState=function(oe){ee.wipe(oe.stateHi),ee.wipe(oe.stateLo),oe.buffer&&ee.wipe(oe.buffer),oe.bufferLength=0,oe.bytesHashed=0},se}();J.SHA512=te;var re=new Int32Array([1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591]);function ne(se,oe,ae,ce,le,he,de){for(var ue=ae[0],pe=ae[1],ye=ae[2],me=ae[3],be=ae[4],_e=ae[5],we=ae[6],$e=ae[7],ve=ce[0],fe=ce[1],Ee=ce[2],ke=ce[3],Ne=ce[4],xe=ce[5],Ue=ce[6],Ke=ce[7],Te,Ce,Ve,Re,Le,De,Be,Oe;de>=128;){for(var Ge=0;Ge<16;Ge++){var Me=8*Ge+he;se[Ge]=E.readUint32BE(le,Me),oe[Ge]=E.readUint32BE(le,Me+4)}for(var Ge=0;Ge<80;Ge++){var je=ue,We=pe,ze=ye,Ae=me,Pe=be,Ie=_e,ge=we,Se=$e,Fe=ve,He=fe,qe=Ee,Ye=ke,rt=Ne,ot=xe,pt=Ue,gt=Ke;if(Te=$e,Ce=Ke,Le=Ce&65535,De=Ce>>>16,Be=Te&65535,Oe=Te>>>16,Te=(be>>>14|Ne<<32-14)^(be>>>18|Ne<<32-18)^(Ne>>>41-32|be<<32-(41-32)),Ce=(Ne>>>14|be<<32-14)^(Ne>>>18|be<<32-18)^(be>>>41-32|Ne<<32-(41-32)),Le+=Ce&65535,De+=Ce>>>16,Be+=Te&65535,Oe+=Te>>>16,Te=be&_e^~be&we,Ce=Ne&xe^~Ne&Ue,Le+=Ce&65535,De+=Ce>>>16,Be+=Te&65535,Oe+=Te>>>16,Te=re[Ge*2],Ce=re[Ge*2+1],Le+=Ce&65535,De+=Ce>>>16,Be+=Te&65535,Oe+=Te>>>16,Te=se[Ge%16],Ce=oe[Ge%16],Le+=Ce&65535,De+=Ce>>>16,Be+=Te&65535,Oe+=Te>>>16,De+=Le>>>16,Be+=De>>>16,Oe+=Be>>>16,Ve=Be&65535|Oe<<16,Re=Le&65535|De<<16,Te=Ve,Ce=Re,Le=Ce&65535,De=Ce>>>16,Be=Te&65535,Oe=Te>>>16,Te=(ue>>>28|ve<<32-28)^(ve>>>34-32|ue<<32-(34-32))^(ve>>>39-32|ue<<32-(39-32)),Ce=(ve>>>28|ue<<32-28)^(ue>>>34-32|ve<<32-(34-32))^(ue>>>39-32|ve<<32-(39-32)),Le+=Ce&65535,De+=Ce>>>16,Be+=Te&65535,Oe+=Te>>>16,Te=ue&pe^ue&ye^pe&ye,Ce=ve&fe^ve&Ee^fe&Ee,Le+=Ce&65535,De+=Ce>>>16,Be+=Te&65535,Oe+=Te>>>16,De+=Le>>>16,Be+=De>>>16,Oe+=Be>>>16,Se=Be&65535|Oe<<16,gt=Le&65535|De<<16,Te=Ae,Ce=Ye,Le=Ce&65535,De=Ce>>>16,Be=Te&65535,Oe=Te>>>16,Te=Ve,Ce=Re,Le+=Ce&65535,De+=Ce>>>16,Be+=Te&65535,Oe+=Te>>>16,De+=Le>>>16,Be+=De>>>16,Oe+=Be>>>16,Ae=Be&65535|Oe<<16,Ye=Le&65535|De<<16,pe=je,ye=We,me=ze,be=Ae,_e=Pe,we=Ie,$e=ge,ue=Se,fe=Fe,Ee=He,ke=qe,Ne=Ye,xe=rt,Ue=ot,Ke=pt,ve=gt,Ge%16===15)for(var Me=0;Me<16;Me++)Te=se[Me],Ce=oe[Me],Le=Ce&65535,De=Ce>>>16,Be=Te&65535,Oe=Te>>>16,Te=se[(Me+9)%16],Ce=oe[(Me+9)%16],Le+=Ce&65535,De+=Ce>>>16,Be+=Te&65535,Oe+=Te>>>16,Ve=se[(Me+1)%16],Re=oe[(Me+1)%16],Te=(Ve>>>1|Re<<32-1)^(Ve>>>8|Re<<32-8)^Ve>>>7,Ce=(Re>>>1|Ve<<32-1)^(Re>>>8|Ve<<32-8)^(Re>>>7|Ve<<32-7),Le+=Ce&65535,De+=Ce>>>16,Be+=Te&65535,Oe+=Te>>>16,Ve=se[(Me+14)%16],Re=oe[(Me+14)%16],Te=(Ve>>>19|Re<<32-19)^(Re>>>61-32|Ve<<32-(61-32))^Ve>>>6,Ce=(Re>>>19|Ve<<32-19)^(Ve>>>61-32|Re<<32-(61-32))^(Re>>>6|Ve<<32-6),Le+=Ce&65535,De+=Ce>>>16,Be+=Te&65535,Oe+=Te>>>16,De+=Le>>>16,Be+=De>>>16,Oe+=Be>>>16,se[Me]=Be&65535|Oe<<16,oe[Me]=Le&65535|De<<16}Te=ue,Ce=ve,Le=Ce&65535,De=Ce>>>16,Be=Te&65535,Oe=Te>>>16,Te=ae[0],Ce=ce[0],Le+=Ce&65535,De+=Ce>>>16,Be+=Te&65535,Oe+=Te>>>16,De+=Le>>>16,Be+=De>>>16,Oe+=Be>>>16,ae[0]=ue=Be&65535|Oe<<16,ce[0]=ve=Le&65535|De<<16,Te=pe,Ce=fe,Le=Ce&65535,De=Ce>>>16,Be=Te&65535,Oe=Te>>>16,Te=ae[1],Ce=ce[1],Le+=Ce&65535,De+=Ce>>>16,Be+=Te&65535,Oe+=Te>>>16,De+=Le>>>16,Be+=De>>>16,Oe+=Be>>>16,ae[1]=pe=Be&65535|Oe<<16,ce[1]=fe=Le&65535|De<<16,Te=ye,Ce=Ee,Le=Ce&65535,De=Ce>>>16,Be=Te&65535,Oe=Te>>>16,Te=ae[2],Ce=ce[2],Le+=Ce&65535,De+=Ce>>>16,Be+=Te&65535,Oe+=Te>>>16,De+=Le>>>16,Be+=De>>>16,Oe+=Be>>>16,ae[2]=ye=Be&65535|Oe<<16,ce[2]=Ee=Le&65535|De<<16,Te=me,Ce=ke,Le=Ce&65535,De=Ce>>>16,Be=Te&65535,Oe=Te>>>16,Te=ae[3],Ce=ce[3],Le+=Ce&65535,De+=Ce>>>16,Be+=Te&65535,Oe+=Te>>>16,De+=Le>>>16,Be+=De>>>16,Oe+=Be>>>16,ae[3]=me=Be&65535|Oe<<16,ce[3]=ke=Le&65535|De<<16,Te=be,Ce=Ne,Le=Ce&65535,De=Ce>>>16,Be=Te&65535,Oe=Te>>>16,Te=ae[4],Ce=ce[4],Le+=Ce&65535,De+=Ce>>>16,Be+=Te&65535,Oe+=Te>>>16,De+=Le>>>16,Be+=De>>>16,Oe+=Be>>>16,ae[4]=be=Be&65535|Oe<<16,ce[4]=Ne=Le&65535|De<<16,Te=_e,Ce=xe,Le=Ce&65535,De=Ce>>>16,Be=Te&65535,Oe=Te>>>16,Te=ae[5],Ce=ce[5],Le+=Ce&65535,De+=Ce>>>16,Be+=Te&65535,Oe+=Te>>>16,De+=Le>>>16,Be+=De>>>16,Oe+=Be>>>16,ae[5]=_e=Be&65535|Oe<<16,ce[5]=xe=Le&65535|De<<16,Te=we,Ce=Ue,Le=Ce&65535,De=Ce>>>16,Be=Te&65535,Oe=Te>>>16,Te=ae[6],Ce=ce[6],Le+=Ce&65535,De+=Ce>>>16,Be+=Te&65535,Oe+=Te>>>16,De+=Le>>>16,Be+=De>>>16,Oe+=Be>>>16,ae[6]=we=Be&65535|Oe<<16,ce[6]=Ue=Le&65535|De<<16,Te=$e,Ce=Ke,Le=Ce&65535,De=Ce>>>16,Be=Te&65535,Oe=Te>>>16,Te=ae[7],Ce=ce[7],Le+=Ce&65535,De+=Ce>>>16,Be+=Te&65535,Oe+=Te>>>16,De+=Le>>>16,Be+=De>>>16,Oe+=Be>>>16,ae[7]=$e=Be&65535|Oe<<16,ce[7]=Ke=Le&65535|De<<16,he+=128,de-=128}return he}function ie(se){var oe=new te;oe.update(se);var ae=oe.digest();return oe.clean(),ae}J.hash=ie})(sha512$1);(function(J){Object.defineProperty(J,"__esModule",{value:!0}),J.convertSecretKeyToX25519=J.convertPublicKeyToX25519=J.verify=J.sign=J.extractPublicKeyFromSecretKey=J.generateKeyPair=J.generateKeyPairFromSeed=J.SEED_LENGTH=J.SECRET_KEY_LENGTH=J.PUBLIC_KEY_LENGTH=J.SIGNATURE_LENGTH=void 0;const E=random,ee=sha512$1,te=wipe$1;J.SIGNATURE_LENGTH=64,J.PUBLIC_KEY_LENGTH=32,J.SECRET_KEY_LENGTH=64,J.SEED_LENGTH=32;function re(Ae){const Pe=new Float64Array(16);if(Ae)for(let Ie=0;Ie<Ae.length;Ie++)Pe[Ie]=Ae[Ie];return Pe}const ne=new Uint8Array(32);ne[0]=9;const ie=re(),se=re([1]),oe=re([30883,4953,19914,30187,55467,16705,2637,112,59544,30585,16505,36039,65139,11119,27886,20995]),ae=re([61785,9906,39828,60374,45398,33411,5274,224,53552,61171,33010,6542,64743,22239,55772,9222]),ce=re([54554,36645,11616,51542,42930,38181,51040,26924,56412,64982,57905,49316,21502,52590,14035,8553]),le=re([26200,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214]),he=re([41136,18958,6951,50414,58488,44335,6150,12099,55207,15867,153,11085,57099,20417,9344,11139]);function de(Ae,Pe){for(let Ie=0;Ie<16;Ie++)Ae[Ie]=Pe[Ie]|0}function ue(Ae){let Pe=1;for(let Ie=0;Ie<16;Ie++){let ge=Ae[Ie]+Pe+65535;Pe=Math.floor(ge/65536),Ae[Ie]=ge-Pe*65536}Ae[0]+=Pe-1+37*(Pe-1)}function pe(Ae,Pe,Ie){const ge=~(Ie-1);for(let Se=0;Se<16;Se++){const Fe=ge&(Ae[Se]^Pe[Se]);Ae[Se]^=Fe,Pe[Se]^=Fe}}function ye(Ae,Pe){const Ie=re(),ge=re();for(let Se=0;Se<16;Se++)ge[Se]=Pe[Se];ue(ge),ue(ge),ue(ge);for(let Se=0;Se<2;Se++){Ie[0]=ge[0]-65517;for(let He=1;He<15;He++)Ie[He]=ge[He]-65535-(Ie[He-1]>>16&1),Ie[He-1]&=65535;Ie[15]=ge[15]-32767-(Ie[14]>>16&1);const Fe=Ie[15]>>16&1;Ie[14]&=65535,pe(ge,Ie,1-Fe)}for(let Se=0;Se<16;Se++)Ae[2*Se]=ge[Se]&255,Ae[2*Se+1]=ge[Se]>>8}function me(Ae,Pe){let Ie=0;for(let ge=0;ge<32;ge++)Ie|=Ae[ge]^Pe[ge];return(1&Ie-1>>>8)-1}function be(Ae,Pe){const Ie=new Uint8Array(32),ge=new Uint8Array(32);return ye(Ie,Ae),ye(ge,Pe),me(Ie,ge)}function _e(Ae){const Pe=new Uint8Array(32);return ye(Pe,Ae),Pe[0]&1}function we(Ae,Pe){for(let Ie=0;Ie<16;Ie++)Ae[Ie]=Pe[2*Ie]+(Pe[2*Ie+1]<<8);Ae[15]&=32767}function $e(Ae,Pe,Ie){for(let ge=0;ge<16;ge++)Ae[ge]=Pe[ge]+Ie[ge]}function ve(Ae,Pe,Ie){for(let ge=0;ge<16;ge++)Ae[ge]=Pe[ge]-Ie[ge]}function fe(Ae,Pe,Ie){let ge,Se,Fe=0,He=0,qe=0,Ye=0,rt=0,ot=0,pt=0,gt=0,it=0,nt=0,et=0,tt=0,Qe=0,Xe=0,Je=0,Ze=0,st=0,at=0,ct=0,lt=0,ut=0,ht=0,dt=0,ft=0,kt=0,Nt=0,Bt=0,Dt=0,xt=0,Ot=0,Kt=0,yt=Ie[0],mt=Ie[1],bt=Ie[2],_t=Ie[3],Et=Ie[4],wt=Ie[5],vt=Ie[6],$t=Ie[7],St=Ie[8],It=Ie[9],At=Ie[10],Rt=Ie[11],Tt=Ie[12],Ct=Ie[13],Pt=Ie[14],Lt=Ie[15];ge=Pe[0],Fe+=ge*yt,He+=ge*mt,qe+=ge*bt,Ye+=ge*_t,rt+=ge*Et,ot+=ge*wt,pt+=ge*vt,gt+=ge*$t,it+=ge*St,nt+=ge*It,et+=ge*At,tt+=ge*Rt,Qe+=ge*Tt,Xe+=ge*Ct,Je+=ge*Pt,Ze+=ge*Lt,ge=Pe[1],He+=ge*yt,qe+=ge*mt,Ye+=ge*bt,rt+=ge*_t,ot+=ge*Et,pt+=ge*wt,gt+=ge*vt,it+=ge*$t,nt+=ge*St,et+=ge*It,tt+=ge*At,Qe+=ge*Rt,Xe+=ge*Tt,Je+=ge*Ct,Ze+=ge*Pt,st+=ge*Lt,ge=Pe[2],qe+=ge*yt,Ye+=ge*mt,rt+=ge*bt,ot+=ge*_t,pt+=ge*Et,gt+=ge*wt,it+=ge*vt,nt+=ge*$t,et+=ge*St,tt+=ge*It,Qe+=ge*At,Xe+=ge*Rt,Je+=ge*Tt,Ze+=ge*Ct,st+=ge*Pt,at+=ge*Lt,ge=Pe[3],Ye+=ge*yt,rt+=ge*mt,ot+=ge*bt,pt+=ge*_t,gt+=ge*Et,it+=ge*wt,nt+=ge*vt,et+=ge*$t,tt+=ge*St,Qe+=ge*It,Xe+=ge*At,Je+=ge*Rt,Ze+=ge*Tt,st+=ge*Ct,at+=ge*Pt,ct+=ge*Lt,ge=Pe[4],rt+=ge*yt,ot+=ge*mt,pt+=ge*bt,gt+=ge*_t,it+=ge*Et,nt+=ge*wt,et+=ge*vt,tt+=ge*$t,Qe+=ge*St,Xe+=ge*It,Je+=ge*At,Ze+=ge*Rt,st+=ge*Tt,at+=ge*Ct,ct+=ge*Pt,lt+=ge*Lt,ge=Pe[5],ot+=ge*yt,pt+=ge*mt,gt+=ge*bt,it+=ge*_t,nt+=ge*Et,et+=ge*wt,tt+=ge*vt,Qe+=ge*$t,Xe+=ge*St,Je+=ge*It,Ze+=ge*At,st+=ge*Rt,at+=ge*Tt,ct+=ge*Ct,lt+=ge*Pt,ut+=ge*Lt,ge=Pe[6],pt+=ge*yt,gt+=ge*mt,it+=ge*bt,nt+=ge*_t,et+=ge*Et,tt+=ge*wt,Qe+=ge*vt,Xe+=ge*$t,Je+=ge*St,Ze+=ge*It,st+=ge*At,at+=ge*Rt,ct+=ge*Tt,lt+=ge*Ct,ut+=ge*Pt,ht+=ge*Lt,ge=Pe[7],gt+=ge*yt,it+=ge*mt,nt+=ge*bt,et+=ge*_t,tt+=ge*Et,Qe+=ge*wt,Xe+=ge*vt,Je+=ge*$t,Ze+=ge*St,st+=ge*It,at+=ge*At,ct+=ge*Rt,lt+=ge*Tt,ut+=ge*Ct,ht+=ge*Pt,dt+=ge*Lt,ge=Pe[8],it+=ge*yt,nt+=ge*mt,et+=ge*bt,tt+=ge*_t,Qe+=ge*Et,Xe+=ge*wt,Je+=ge*vt,Ze+=ge*$t,st+=ge*St,at+=ge*It,ct+=ge*At,lt+=ge*Rt,ut+=ge*Tt,ht+=ge*Ct,dt+=ge*Pt,ft+=ge*Lt,ge=Pe[9],nt+=ge*yt,et+=ge*mt,tt+=ge*bt,Qe+=ge*_t,Xe+=ge*Et,Je+=ge*wt,Ze+=ge*vt,st+=ge*$t,at+=ge*St,ct+=ge*It,lt+=ge*At,ut+=ge*Rt,ht+=ge*Tt,dt+=ge*Ct,ft+=ge*Pt,kt+=ge*Lt,ge=Pe[10],et+=ge*yt,tt+=ge*mt,Qe+=ge*bt,Xe+=ge*_t,Je+=ge*Et,Ze+=ge*wt,st+=ge*vt,at+=ge*$t,ct+=ge*St,lt+=ge*It,ut+=ge*At,ht+=ge*Rt,dt+=ge*Tt,ft+=ge*Ct,kt+=ge*Pt,Nt+=ge*Lt,ge=Pe[11],tt+=ge*yt,Qe+=ge*mt,Xe+=ge*bt,Je+=ge*_t,Ze+=ge*Et,st+=ge*wt,at+=ge*vt,ct+=ge*$t,lt+=ge*St,ut+=ge*It,ht+=ge*At,dt+=ge*Rt,ft+=ge*Tt,kt+=ge*Ct,Nt+=ge*Pt,Bt+=ge*Lt,ge=Pe[12],Qe+=ge*yt,Xe+=ge*mt,Je+=ge*bt,Ze+=ge*_t,st+=ge*Et,at+=ge*wt,ct+=ge*vt,lt+=ge*$t,ut+=ge*St,ht+=ge*It,dt+=ge*At,ft+=ge*Rt,kt+=ge*Tt,Nt+=ge*Ct,Bt+=ge*Pt,Dt+=ge*Lt,ge=Pe[13],Xe+=ge*yt,Je+=ge*mt,Ze+=ge*bt,st+=ge*_t,at+=ge*Et,ct+=ge*wt,lt+=ge*vt,ut+=ge*$t,ht+=ge*St,dt+=ge*It,ft+=ge*At,kt+=ge*Rt,Nt+=ge*Tt,Bt+=ge*Ct,Dt+=ge*Pt,xt+=ge*Lt,ge=Pe[14],Je+=ge*yt,Ze+=ge*mt,st+=ge*bt,at+=ge*_t,ct+=ge*Et,lt+=ge*wt,ut+=ge*vt,ht+=ge*$t,dt+=ge*St,ft+=ge*It,kt+=ge*At,Nt+=ge*Rt,Bt+=ge*Tt,Dt+=ge*Ct,xt+=ge*Pt,Ot+=ge*Lt,ge=Pe[15],Ze+=ge*yt,st+=ge*mt,at+=ge*bt,ct+=ge*_t,lt+=ge*Et,ut+=ge*wt,ht+=ge*vt,dt+=ge*$t,ft+=ge*St,kt+=ge*It,Nt+=ge*At,Bt+=ge*Rt,Dt+=ge*Tt,xt+=ge*Ct,Ot+=ge*Pt,Kt+=ge*Lt,Fe+=38*st,He+=38*at,qe+=38*ct,Ye+=38*lt,rt+=38*ut,ot+=38*ht,pt+=38*dt,gt+=38*ft,it+=38*kt,nt+=38*Nt,et+=38*Bt,tt+=38*Dt,Qe+=38*xt,Xe+=38*Ot,Je+=38*Kt,Se=1,ge=Fe+Se+65535,Se=Math.floor(ge/65536),Fe=ge-Se*65536,ge=He+Se+65535,Se=Math.floor(ge/65536),He=ge-Se*65536,ge=qe+Se+65535,Se=Math.floor(ge/65536),qe=ge-Se*65536,ge=Ye+Se+65535,Se=Math.floor(ge/65536),Ye=ge-Se*65536,ge=rt+Se+65535,Se=Math.floor(ge/65536),rt=ge-Se*65536,ge=ot+Se+65535,Se=Math.floor(ge/65536),ot=ge-Se*65536,ge=pt+Se+65535,Se=Math.floor(ge/65536),pt=ge-Se*65536,ge=gt+Se+65535,Se=Math.floor(ge/65536),gt=ge-Se*65536,ge=it+Se+65535,Se=Math.floor(ge/65536),it=ge-Se*65536,ge=nt+Se+65535,Se=Math.floor(ge/65536),nt=ge-Se*65536,ge=et+Se+65535,Se=Math.floor(ge/65536),et=ge-Se*65536,ge=tt+Se+65535,Se=Math.floor(ge/65536),tt=ge-Se*65536,ge=Qe+Se+65535,Se=Math.floor(ge/65536),Qe=ge-Se*65536,ge=Xe+Se+65535,Se=Math.floor(ge/65536),Xe=ge-Se*65536,ge=Je+Se+65535,Se=Math.floor(ge/65536),Je=ge-Se*65536,ge=Ze+Se+65535,Se=Math.floor(ge/65536),Ze=ge-Se*65536,Fe+=Se-1+37*(Se-1),Se=1,ge=Fe+Se+65535,Se=Math.floor(ge/65536),Fe=ge-Se*65536,ge=He+Se+65535,Se=Math.floor(ge/65536),He=ge-Se*65536,ge=qe+Se+65535,Se=Math.floor(ge/65536),qe=ge-Se*65536,ge=Ye+Se+65535,Se=Math.floor(ge/65536),Ye=ge-Se*65536,ge=rt+Se+65535,Se=Math.floor(ge/65536),rt=ge-Se*65536,ge=ot+Se+65535,Se=Math.floor(ge/65536),ot=ge-Se*65536,ge=pt+Se+65535,Se=Math.floor(ge/65536),pt=ge-Se*65536,ge=gt+Se+65535,Se=Math.floor(ge/65536),gt=ge-Se*65536,ge=it+Se+65535,Se=Math.floor(ge/65536),it=ge-Se*65536,ge=nt+Se+65535,Se=Math.floor(ge/65536),nt=ge-Se*65536,ge=et+Se+65535,Se=Math.floor(ge/65536),et=ge-Se*65536,ge=tt+Se+65535,Se=Math.floor(ge/65536),tt=ge-Se*65536,ge=Qe+Se+65535,Se=Math.floor(ge/65536),Qe=ge-Se*65536,ge=Xe+Se+65535,Se=Math.floor(ge/65536),Xe=ge-Se*65536,ge=Je+Se+65535,Se=Math.floor(ge/65536),Je=ge-Se*65536,ge=Ze+Se+65535,Se=Math.floor(ge/65536),Ze=ge-Se*65536,Fe+=Se-1+37*(Se-1),Ae[0]=Fe,Ae[1]=He,Ae[2]=qe,Ae[3]=Ye,Ae[4]=rt,Ae[5]=ot,Ae[6]=pt,Ae[7]=gt,Ae[8]=it,Ae[9]=nt,Ae[10]=et,Ae[11]=tt,Ae[12]=Qe,Ae[13]=Xe,Ae[14]=Je,Ae[15]=Ze}function Ee(Ae,Pe){fe(Ae,Pe,Pe)}function ke(Ae,Pe){const Ie=re();let ge;for(ge=0;ge<16;ge++)Ie[ge]=Pe[ge];for(ge=253;ge>=0;ge--)Ee(Ie,Ie),ge!==2&&ge!==4&&fe(Ie,Ie,Pe);for(ge=0;ge<16;ge++)Ae[ge]=Ie[ge]}function Ne(Ae,Pe){const Ie=re();let ge;for(ge=0;ge<16;ge++)Ie[ge]=Pe[ge];for(ge=250;ge>=0;ge--)Ee(Ie,Ie),ge!==1&&fe(Ie,Ie,Pe);for(ge=0;ge<16;ge++)Ae[ge]=Ie[ge]}function xe(Ae,Pe){const Ie=re(),ge=re(),Se=re(),Fe=re(),He=re(),qe=re(),Ye=re(),rt=re(),ot=re();ve(Ie,Ae[1],Ae[0]),ve(ot,Pe[1],Pe[0]),fe(Ie,Ie,ot),$e(ge,Ae[0],Ae[1]),$e(ot,Pe[0],Pe[1]),fe(ge,ge,ot),fe(Se,Ae[3],Pe[3]),fe(Se,Se,ae),fe(Fe,Ae[2],Pe[2]),$e(Fe,Fe,Fe),ve(He,ge,Ie),ve(qe,Fe,Se),$e(Ye,Fe,Se),$e(rt,ge,Ie),fe(Ae[0],He,qe),fe(Ae[1],rt,Ye),fe(Ae[2],Ye,qe),fe(Ae[3],He,rt)}function Ue(Ae,Pe,Ie){for(let ge=0;ge<4;ge++)pe(Ae[ge],Pe[ge],Ie)}function Ke(Ae,Pe){const Ie=re(),ge=re(),Se=re();ke(Se,Pe[2]),fe(Ie,Pe[0],Se),fe(ge,Pe[1],Se),ye(Ae,ge),Ae[31]^=_e(Ie)<<7}function Te(Ae,Pe,Ie){de(Ae[0],ie),de(Ae[1],se),de(Ae[2],se),de(Ae[3],ie);for(let ge=255;ge>=0;--ge){const Se=Ie[ge/8|0]>>(ge&7)&1;Ue(Ae,Pe,Se),xe(Pe,Ae),xe(Ae,Ae),Ue(Ae,Pe,Se)}}function Ce(Ae,Pe){const Ie=[re(),re(),re(),re()];de(Ie[0],ce),de(Ie[1],le),de(Ie[2],se),fe(Ie[3],ce,le),Te(Ae,Ie,Pe)}function Ve(Ae){if(Ae.length!==J.SEED_LENGTH)throw new Error(`ed25519: seed must be ${J.SEED_LENGTH} bytes`);const Pe=(0,ee.hash)(Ae);Pe[0]&=248,Pe[31]&=127,Pe[31]|=64;const Ie=new Uint8Array(32),ge=[re(),re(),re(),re()];Ce(ge,Pe),Ke(Ie,ge);const Se=new Uint8Array(64);return Se.set(Ae),Se.set(Ie,32),{publicKey:Ie,secretKey:Se}}J.generateKeyPairFromSeed=Ve;function Re(Ae){const Pe=(0,E.randomBytes)(32,Ae),Ie=Ve(Pe);return(0,te.wipe)(Pe),Ie}J.generateKeyPair=Re;function Le(Ae){if(Ae.length!==J.SECRET_KEY_LENGTH)throw new Error(`ed25519: secret key must be ${J.SECRET_KEY_LENGTH} bytes`);return new Uint8Array(Ae.subarray(32))}J.extractPublicKeyFromSecretKey=Le;const De=new Float64Array([237,211,245,92,26,99,18,88,214,156,247,162,222,249,222,20,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16]);function Be(Ae,Pe){let Ie,ge,Se,Fe;for(ge=63;ge>=32;--ge){for(Ie=0,Se=ge-32,Fe=ge-12;Se<Fe;++Se)Pe[Se]+=Ie-16*Pe[ge]*De[Se-(ge-32)],Ie=Math.floor((Pe[Se]+128)/256),Pe[Se]-=Ie*256;Pe[Se]+=Ie,Pe[ge]=0}for(Ie=0,Se=0;Se<32;Se++)Pe[Se]+=Ie-(Pe[31]>>4)*De[Se],Ie=Pe[Se]>>8,Pe[Se]&=255;for(Se=0;Se<32;Se++)Pe[Se]-=Ie*De[Se];for(ge=0;ge<32;ge++)Pe[ge+1]+=Pe[ge]>>8,Ae[ge]=Pe[ge]&255}function Oe(Ae){const Pe=new Float64Array(64);for(let Ie=0;Ie<64;Ie++)Pe[Ie]=Ae[Ie];for(let Ie=0;Ie<64;Ie++)Ae[Ie]=0;Be(Ae,Pe)}function Ge(Ae,Pe){const Ie=new Float64Array(64),ge=[re(),re(),re(),re()],Se=(0,ee.hash)(Ae.subarray(0,32));Se[0]&=248,Se[31]&=127,Se[31]|=64;const Fe=new Uint8Array(64);Fe.set(Se.subarray(32),32);const He=new ee.SHA512;He.update(Fe.subarray(32)),He.update(Pe);const qe=He.digest();He.clean(),Oe(qe),Ce(ge,qe),Ke(Fe,ge),He.reset(),He.update(Fe.subarray(0,32)),He.update(Ae.subarray(32)),He.update(Pe);const Ye=He.digest();Oe(Ye);for(let rt=0;rt<32;rt++)Ie[rt]=qe[rt];for(let rt=0;rt<32;rt++)for(let ot=0;ot<32;ot++)Ie[rt+ot]+=Ye[rt]*Se[ot];return Be(Fe.subarray(32),Ie),Fe}J.sign=Ge;function Me(Ae,Pe){const Ie=re(),ge=re(),Se=re(),Fe=re(),He=re(),qe=re(),Ye=re();return de(Ae[2],se),we(Ae[1],Pe),Ee(Se,Ae[1]),fe(Fe,Se,oe),ve(Se,Se,Ae[2]),$e(Fe,Ae[2],Fe),Ee(He,Fe),Ee(qe,He),fe(Ye,qe,He),fe(Ie,Ye,Se),fe(Ie,Ie,Fe),Ne(Ie,Ie),fe(Ie,Ie,Se),fe(Ie,Ie,Fe),fe(Ie,Ie,Fe),fe(Ae[0],Ie,Fe),Ee(ge,Ae[0]),fe(ge,ge,Fe),be(ge,Se)&&fe(Ae[0],Ae[0],he),Ee(ge,Ae[0]),fe(ge,ge,Fe),be(ge,Se)?-1:(_e(Ae[0])===Pe[31]>>7&&ve(Ae[0],ie,Ae[0]),fe(Ae[3],Ae[0],Ae[1]),0)}function je(Ae,Pe,Ie){const ge=new Uint8Array(32),Se=[re(),re(),re(),re()],Fe=[re(),re(),re(),re()];if(Ie.length!==J.SIGNATURE_LENGTH)throw new Error(`ed25519: signature must be ${J.SIGNATURE_LENGTH} bytes`);if(Me(Fe,Ae))return!1;const He=new ee.SHA512;He.update(Ie.subarray(0,32)),He.update(Ae),He.update(Pe);const qe=He.digest();return Oe(qe),Te(Se,Fe,qe),Ce(Fe,Ie.subarray(32)),xe(Se,Fe),Ke(ge,Se),!me(Ie,ge)}J.verify=je;function We(Ae){let Pe=[re(),re(),re(),re()];if(Me(Pe,Ae))throw new Error("Ed25519: invalid public key");let Ie=re(),ge=re(),Se=Pe[1];$e(Ie,se,Se),ve(ge,se,Se),ke(ge,ge),fe(Ie,Ie,ge);let Fe=new Uint8Array(32);return ye(Fe,Ie),Fe}J.convertPublicKeyToX25519=We;function ze(Ae){const Pe=(0,ee.hash)(Ae.subarray(0,32));Pe[0]&=248,Pe[31]&=127,Pe[31]|=64;const Ie=new Uint8Array(Pe.subarray(0,32));return(0,te.wipe)(Pe),Ie}J.convertSecretKeyToX25519=ze})(ed25519$1);const ed25519=getDefaultExportFromCjs(ed25519$1);function asUint8Array$2(J){return globalThis.Buffer!=null?new Uint8Array(J.buffer,J.byteOffset,J.byteLength):J}function allocUnsafe$4(J=0){return globalThis.Buffer?.allocUnsafe!=null?asUint8Array$2(globalThis.Buffer.allocUnsafe(J)):new Uint8Array(J)}function concat$4(J,E){E==null&&(E=J.reduce((re,ne)=>re+ne.length,0));const ee=allocUnsafe$4(E);let te=0;for(const re of J)ee.set(re,te),te+=re.length;return asUint8Array$2(ee)}function equals$3(J,E){if(J===E)return!0;if(J.byteLength!==E.byteLength)return!1;for(let ee=0;ee<J.byteLength;ee++)if(J[ee]!==E[ee])return!1;return!0}function base$5(J,E){if(J.length>=255)throw new TypeError("Alphabet too long");for(var ee=new Uint8Array(256),te=0;te<ee.length;te++)ee[te]=255;for(var re=0;re<J.length;re++){var ne=J.charAt(re),ie=ne.charCodeAt(0);if(ee[ie]!==255)throw new TypeError(ne+" is ambiguous");ee[ie]=re}var se=J.length,oe=J.charAt(0),ae=Math.log(se)/Math.log(256),ce=Math.log(256)/Math.log(se);function le(ue){if(ue instanceof Uint8Array||(ArrayBuffer.isView(ue)?ue=new Uint8Array(ue.buffer,ue.byteOffset,ue.byteLength):Array.isArray(ue)&&(ue=Uint8Array.from(ue))),!(ue instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(ue.length===0)return"";for(var pe=0,ye=0,me=0,be=ue.length;me!==be&&ue[me]===0;)me++,pe++;for(var _e=(be-me)*ce+1>>>0,we=new Uint8Array(_e);me!==be;){for(var $e=ue[me],ve=0,fe=_e-1;($e!==0||ve<ye)&&fe!==-1;fe--,ve++)$e+=256*we[fe]>>>0,we[fe]=$e%se>>>0,$e=$e/se>>>0;if($e!==0)throw new Error("Non-zero carry");ye=ve,me++}for(var Ee=_e-ye;Ee!==_e&&we[Ee]===0;)Ee++;for(var ke=oe.repeat(pe);Ee<_e;++Ee)ke+=J.charAt(we[Ee]);return ke}function he(ue){if(typeof ue!="string")throw new TypeError("Expected String");if(ue.length===0)return new Uint8Array;var pe=0;if(ue[pe]!==" "){for(var ye=0,me=0;ue[pe]===oe;)ye++,pe++;for(var be=(ue.length-pe)*ae+1>>>0,_e=new Uint8Array(be);ue[pe];){var we=ee[ue.charCodeAt(pe)];if(we===255)return;for(var $e=0,ve=be-1;(we!==0||$e<me)&&ve!==-1;ve--,$e++)we+=se*_e[ve]>>>0,_e[ve]=we%256>>>0,we=we/256>>>0;if(we!==0)throw new Error("Non-zero carry");me=$e,pe++}if(ue[pe]!==" "){for(var fe=be-me;fe!==be&&_e[fe]===0;)fe++;for(var Ee=new Uint8Array(ye+(be-fe)),ke=ye;fe!==be;)Ee[ke++]=_e[fe++];return Ee}}}function de(ue){var pe=he(ue);if(pe)return pe;throw new Error(`Non-${E} character`)}return{encode:le,decodeUnsafe:he,decode:de}}var src$5=base$5,_brrp__multiformats_scope_baseX$2=src$5;const coerce$2=J=>{if(J instanceof Uint8Array&&J.constructor.name==="Uint8Array")return J;if(J instanceof ArrayBuffer)return new Uint8Array(J);if(ArrayBuffer.isView(J))return new Uint8Array(J.buffer,J.byteOffset,J.byteLength);throw new Error("Unknown type, must be binary type")},fromString$7=J=>new TextEncoder().encode(J),toString$7=J=>new TextDecoder().decode(J);let Encoder$3=class{constructor(J,E,ee){this.name=J,this.prefix=E,this.baseEncode=ee}encode(J){if(J instanceof Uint8Array)return`${this.prefix}${this.baseEncode(J)}`;throw Error("Unknown type, must be binary type")}},Decoder$4=class{constructor(J,E,ee){if(this.name=J,this.prefix=E,E.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=E.codePointAt(0),this.baseDecode=ee}decode(J){if(typeof J=="string"){if(J.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(J)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(J.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(J){return or$3(this,J)}},ComposedDecoder$2=class{constructor(J){this.decoders=J}or(J){return or$3(this,J)}decode(J){const E=J[0],ee=this.decoders[E];if(ee)return ee.decode(J);throw RangeError(`Unable to decode multibase string ${JSON.stringify(J)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};const or$3=(J,E)=>new ComposedDecoder$2({...J.decoders||{[J.prefix]:J},...E.decoders||{[E.prefix]:E}});let Codec$2=class{constructor(J,E,ee,te){this.name=J,this.prefix=E,this.baseEncode=ee,this.baseDecode=te,this.encoder=new Encoder$3(J,E,ee),this.decoder=new Decoder$4(J,E,te)}encode(J){return this.encoder.encode(J)}decode(J){return this.decoder.decode(J)}};const from$3=({name:J,prefix:E,encode:ee,decode:te})=>new Codec$2(J,E,ee,te),baseX$3=({prefix:J,name:E,alphabet:ee})=>{const{encode:te,decode:re}=_brrp__multiformats_scope_baseX$2(ee,E);return from$3({prefix:J,name:E,encode:te,decode:ne=>coerce$2(re(ne))})},decode$e=(J,E,ee,te)=>{const re={};for(let ce=0;ce<E.length;++ce)re[E[ce]]=ce;let ne=J.length;for(;J[ne-1]==="=";)--ne;const ie=new Uint8Array(ne*ee/8|0);let se=0,oe=0,ae=0;for(let ce=0;ce<ne;++ce){const le=re[J[ce]];if(le===void 0)throw new SyntaxError(`Non-${te} character`);oe=oe<<ee|le,se+=ee,se>=8&&(se-=8,ie[ae++]=255&oe>>se)}if(se>=ee||255&oe<<8-se)throw new SyntaxError("Unexpected end of data");return ie},encode$f=(J,E,ee)=>{const te=E[E.length-1]==="=",re=(1<<ee)-1;let ne="",ie=0,se=0;for(let oe=0;oe<J.length;++oe)for(se=se<<8|J[oe],ie+=8;ie>ee;)ie-=ee,ne+=E[re&se>>ie];if(ie&&(ne+=E[re&se<<ee-ie]),te)for(;ne.length*ee&7;)ne+="=";return ne},rfc4648$4=({name:J,prefix:E,bitsPerChar:ee,alphabet:te})=>from$3({prefix:E,name:J,encode(re){return encode$f(re,te,ee)},decode(re){return decode$e(re,te,ee,J)}}),identity$4=from$3({prefix:"\0",name:"identity",encode:J=>toString$7(J),decode:J=>fromString$7(J)}),identityBase$2=Object.freeze(Object.defineProperty({__proto__:null,identity:identity$4},Symbol.toStringTag,{value:"Module"})),base2$4=rfc4648$4({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),base2$5=Object.freeze(Object.defineProperty({__proto__:null,base2:base2$4},Symbol.toStringTag,{value:"Module"})),base8$4=rfc4648$4({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),base8$5=Object.freeze(Object.defineProperty({__proto__:null,base8:base8$4},Symbol.toStringTag,{value:"Module"})),base10$4=baseX$3({prefix:"9",name:"base10",alphabet:"0123456789"}),base10$5=Object.freeze(Object.defineProperty({__proto__:null,base10:base10$4},Symbol.toStringTag,{value:"Module"})),base16$4=rfc4648$4({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),base16upper$2=rfc4648$4({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),base16$5=Object.freeze(Object.defineProperty({__proto__:null,base16:base16$4,base16upper:base16upper$2},Symbol.toStringTag,{value:"Module"})),base32$4=rfc4648$4({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),base32upper$2=rfc4648$4({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),base32pad$2=rfc4648$4({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),base32padupper$2=rfc4648$4({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),base32hex$2=rfc4648$4({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),base32hexupper$2=rfc4648$4({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),base32hexpad$2=rfc4648$4({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),base32hexpadupper$2=rfc4648$4({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),base32z$2=rfc4648$4({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),base32$5=Object.freeze(Object.defineProperty({__proto__:null,base32:base32$4,base32hex:base32hex$2,base32hexpad:base32hexpad$2,base32hexpadupper:base32hexpadupper$2,base32hexupper:base32hexupper$2,base32pad:base32pad$2,base32padupper:base32padupper$2,base32upper:base32upper$2,base32z:base32z$2},Symbol.toStringTag,{value:"Module"})),base36$4=baseX$3({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),base36upper$2=baseX$3({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),base36$5=Object.freeze(Object.defineProperty({__proto__:null,base36:base36$4,base36upper:base36upper$2},Symbol.toStringTag,{value:"Module"})),base58btc$2=baseX$3({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),base58flickr$2=baseX$3({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),base58$2=Object.freeze(Object.defineProperty({__proto__:null,base58btc:base58btc$2,base58flickr:base58flickr$2},Symbol.toStringTag,{value:"Module"})),base64$6=rfc4648$4({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),base64pad$2=rfc4648$4({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),base64url$2=rfc4648$4({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),base64urlpad$2=rfc4648$4({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),base64$7=Object.freeze(Object.defineProperty({__proto__:null,base64:base64$6,base64pad:base64pad$2,base64url:base64url$2,base64urlpad:base64urlpad$2},Symbol.toStringTag,{value:"Module"})),alphabet$2=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),alphabetBytesToChars$2=alphabet$2.reduce((J,E,ee)=>(J[ee]=E,J),[]),alphabetCharsToBytes$2=alphabet$2.reduce((J,E,ee)=>(J[E.codePointAt(0)]=ee,J),[]);function encode$e(J){return J.reduce((E,ee)=>(E+=alphabetBytesToChars$2[ee],E),"")}function decode$d(J){const E=[];for(const ee of J){const te=alphabetCharsToBytes$2[ee.codePointAt(0)];if(te===void 0)throw new Error(`Non-base256emoji character: ${ee}`);E.push(te)}return new Uint8Array(E)}const base256emoji$4=from$3({prefix:"🚀",name:"base256emoji",encode:encode$e,decode:decode$d}),base256emoji$5=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:base256emoji$4},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const bases$2={...identityBase$2,...base2$5,...base8$5,...base10$5,...base16$5,...base32$5,...base36$5,...base58$2,...base64$7,...base256emoji$5};function createCodec$3(J,E,ee,te){return{name:J,prefix:E,encoder:{name:J,prefix:E,encode:ee},decoder:{decode:te}}}const string$2=createCodec$3("utf8","u",J=>"u"+new TextDecoder("utf8").decode(J),J=>new TextEncoder().encode(J.substring(1))),ascii$2=createCodec$3("ascii","a",J=>{let E="a";for(let ee=0;ee<J.length;ee++)E+=String.fromCharCode(J[ee]);return E},J=>{J=J.substring(1);const E=allocUnsafe$4(J.length);for(let ee=0;ee<J.length;ee++)E[ee]=J.charCodeAt(ee);return E}),BASES$2={utf8:string$2,"utf-8":string$2,hex:bases$2.base16,latin1:ascii$2,ascii:ascii$2,binary:ascii$2,...bases$2};function fromString$6(J,E="utf8"){const ee=BASES$2[E];if(ee==null)throw new Error(`Unsupported encoding "${E}"`);return(E==="utf8"||E==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?asUint8Array$2(globalThis.Buffer.from(J,"utf-8")):ee.decoder.decode(`${ee.prefix}${J}`)}function toString$6(J,E="utf8"){const ee=BASES$2[E];if(ee==null)throw new Error(`Unsupported encoding "${E}"`);return(E==="utf8"||E==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(J.buffer,J.byteOffset,J.byteLength).toString("utf8"):ee.encoder.encode(J).substring(1)}const{Kem,Kdf,Aead,CipherSuite}=hpke,EMPTY_SALT=new Uint8Array(0),LABEL_CHANNEL_ID=new TextEncoder().encode("channel_id"),EXPORT_LABEL_NONCE=new TextEncoder().encode("5edm nonce"),EXPORT_LABEL_KEY=new TextEncoder().encode("5edm key"),EXPORT_LABEL_SESSIONID_RECIPIENT=new TextEncoder().encode("5edm recipient session id"),EXPORT_LABEL_SESSIONID_SENDER=new TextEncoder().encode("5edm sender session id"),concatBuffers=function(J,E){return concat$4([new Uint8Array(J),new Uint8Array(E)])};class Encrypter{constructor(E=new CipherSuite({kem:Kem.DhkemX25519HkdfSha256,kdf:Kdf.HkdfSha256,aead:Aead.Aes256Gcm})){this.suite=E}sessionId;toSessionId;context;async seal(E,ee){if(!this.context||!this.toSessionId)throw new Error("CryptoContext not initialized");const te=ee?concatBuffers(this.toSessionId,ee):this.toSessionId;return{header:te,payload:await this.context.seal(E,te)}}async open(E,ee,te){if(!this.context)throw new Error("CryptoContext not initialized");const re=te?concatBuffers(ee,te):ee;try{return await this.context.open(E,re)}catch(ne){throw console.log("failed to decrypt.",ne),ne}}async deriveChannelId(E){const ee=await(await this.suite.kdfContext()).labeledExtract(EMPTY_SALT,LABEL_CHANNEL_ID,new Uint8Array(E)),te=new Uint8Array(16);return te.set(new Uint8Array(ee,0,16)),te.buffer}}class InitiatorCryptoContext extends Encrypter{#e;handshakeChannelId;async init(){const E=ed25519.generateKeyPair(),ee=ed25519.convertSecretKeyToX25519(E.secretKey);this.#e=await this.suite.importKey("raw",ee,!1);const te=E.publicKey,re=await this.deriveChannelId(te);return this.handshakeChannelId=re,{serializedPublicKey:te,handshakeChannelId:re}}async handleJoin(E){if(!this.#e)throw new Error("CryptoContext not initialized");const[ee,te]=E.header,[re,ne]=E.payload;let ie;try{ie=await this.suite.open({recipientKey:this.#e,enc:ee},te,ne)}catch(ue){throw console.log("failed to decrypt sender public key.",ue),ue}if(!ie)throw new Error("Could not decrypt handshake payload");const se=await this.suite.importKey("raw",ed25519.convertPublicKeyToX25519(new Uint8Array(ie))),oe=await this.suite.createRecipientContext({recipientKey:this.#e,enc:re,senderPublicKey:se}),ae=await oe.export(EXPORT_LABEL_KEY,32),ce=await oe.export(EXPORT_LABEL_NONCE,32),le=await oe.export(EXPORT_LABEL_SESSIONID_RECIPIENT,16),he=await oe.export(EXPORT_LABEL_SESSIONID_SENDER,16);await oe.setupBidirectional(ae,ce),this.context=oe,this.sessionId=le,this.toSessionId=he;let de=new ArrayBuffer(0);try{de=await this.context.open(ne,this.handshakeChannelId)}catch(ue){throw console.log("failed to decrypt.",ue),ue}return{plaintext:de,sessionId:le,toSessionId:he}}}class JoinerCryptoContext extends Encrypter{toChannelId;async initSender(E,ee){const te=ed25519.generateKeyPair(),re=ed25519.convertSecretKeyToX25519(te.secretKey),ne=await this.suite.importKey("raw",re,!1),ie=await this.suite.importKey("raw",ed25519.convertPublicKeyToX25519(new Uint8Array(E))),se=await this.suite.createSenderContext({recipientPublicKey:ie,senderKey:ne}),oe=await se.export(EXPORT_LABEL_KEY,32),ae=await se.export(EXPORT_LABEL_NONCE,32),ce=await se.export(EXPORT_LABEL_SESSIONID_RECIPIENT,16),le=await se.export(EXPORT_LABEL_SESSIONID_SENDER,16);await se.setupBidirectional(oe,ae);const he=await this.deriveChannelId(E);this.toChannelId=he,this.sessionId=le,this.toSessionId=ce,this.context=se;const de=await this.context.seal(ee,he),ue=te.publicKey,{ct:pe,enc:ye}=await this.suite.seal({recipientPublicKey:ie},ue,de);return{toChannelId:he,sessionId:le,toSessionId:ce,envelope:{payload:[se.enc,de],header:[ye,pe]}}}}function encodeUrlParam(J){return base64$8.encodeURLSafe(new Uint8Array(J))}class EventStreamSource{constructor(E,ee,te){this.eventTarget=E,this.eventNames=ee,this.options=te}#e;#t={};start(E){for(const ee of this.eventNames)this.#t[ee]=te=>{E.enqueue(te)},this.eventTarget.addEventListener(ee,this.#t[ee]);this.#e=ee=>{this.options?.onError?this.options.onError(E,ee):E.enqueue(ee)},this.eventTarget.addEventListener("error",this.#e)}pull(){}cancel(){for(const E of Object.keys(this.#t))this.eventTarget.removeEventListener(E,this.#t[E]);this.#e&&this.eventTarget.removeEventListener("error",this.#e),this.options?.onCancel&&this.options?.onCancel(this.eventTarget)}}function streamAsyncIterator(J){return async function*(){const E=J.getReader();try{for(;;){const{done:ee,value:te}=await E.read();if(ee)return;yield te}}finally{E.releaseLock()}}()}let EventIterator$2=class{constructor(J,E,ee){this.eventTarget=J,this.#e=new EventStreamSource(this.eventTarget,E,ee),this.#t=new ReadableStream(this.#e)}#e;#t;#r;cancelSource(){this.#e.cancel()}[Symbol.asyncIterator](){return this.#r||(this.#r=streamAsyncIterator(this.#t)),this.#r}};class SseTransport{constructor(E="/api/sse?channelId=",ee=EventSource){this.baseUrl=E,this.EventSourceClass=ee}#e=[];listen(E){const ee=new this.EventSourceClass(`${this.baseUrl}${E}`),te=new EventIterator$2(ee,["open","message"],{onCancel:()=>ee.close()});return this.#e.push(te),te[Symbol.asyncIterator]()}close(){for(const E of this.#e)E.cancelSource();return this.#e=[],Promise.resolve()}}class FetchSenderTransport{constructor(E="/api/send?channelId="){this.baseUrl=E}send(E,ee){return this.#e(E,ee)}async#e(E,ee){let te=0;do{let re;try{return re=await fetch(`${this.baseUrl}${ee}`,{method:"POST",body:E}),{ok:re.ok,status:re.status,statusText:re.statusText}}catch(ne){console.warn(te,ne)}re?.ok||await new Promise(ne=>setTimeout(ne,1e3*te++))}while(te<5);throw new Error("could not send")}close(){return Promise.resolve()}}class HttpTransportCreator{constructor(E={baseSendApiUrl:"/api/send?channelId=",baseRecieveApiUrl:"/api/sse?channelId="},ee=FetchSenderTransport,te=SseTransport){this.options=E,this.SenderClass=ee,this.ReceiverClass=te}async createSenderTransport(E){return new this.SenderClass(E?.connectingAddress??this.options.baseSendApiUrl)}async createReceiverTransport(E){return new this.ReceiverClass(E?.connectingAddress??this.options.baseRecieveApiUrl)}}var browser$3={exports:{}},ms$1,hasRequiredMs;function requireMs(){if(hasRequiredMs)return ms$1;hasRequiredMs=1;var J=1e3,E=J*60,ee=E*60,te=ee*24,re=te*7,ne=te*365.25;ms$1=function(ce,le){le=le||{};var he=typeof ce;if(he==="string"&&ce.length>0)return ie(ce);if(he==="number"&&isFinite(ce))return le.long?oe(ce):se(ce);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(ce))};function ie(ce){if(ce=String(ce),!(ce.length>100)){var le=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(ce);if(le){var he=parseFloat(le[1]),de=(le[2]||"ms").toLowerCase();switch(de){case"years":case"year":case"yrs":case"yr":case"y":return he*ne;case"weeks":case"week":case"w":return he*re;case"days":case"day":case"d":return he*te;case"hours":case"hour":case"hrs":case"hr":case"h":return he*ee;case"minutes":case"minute":case"mins":case"min":case"m":return he*E;case"seconds":case"second":case"secs":case"sec":case"s":return he*J;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return he;default:return}}}}function se(ce){var le=Math.abs(ce);return le>=te?Math.round(ce/te)+"d":le>=ee?Math.round(ce/ee)+"h":le>=E?Math.round(ce/E)+"m":le>=J?Math.round(ce/J)+"s":ce+"ms"}function oe(ce){var le=Math.abs(ce);return le>=te?ae(ce,le,te,"day"):le>=ee?ae(ce,le,ee,"hour"):le>=E?ae(ce,le,E,"minute"):le>=J?ae(ce,le,J,"second"):ce+" ms"}function ae(ce,le,he,de){var ue=le>=he*1.5;return Math.round(ce/he)+" "+de+(ue?"s":"")}return ms$1}function setup(J){ee.debug=ee,ee.default=ee,ee.coerce=oe,ee.disable=ne,ee.enable=re,ee.enabled=ie,ee.humanize=requireMs(),ee.destroy=ae,Object.keys(J).forEach(ce=>{ee[ce]=J[ce]}),ee.names=[],ee.skips=[],ee.formatters={};function E(ce){let le=0;for(let he=0;he<ce.length;he++)le=(le<<5)-le+ce.charCodeAt(he),le|=0;return ee.colors[Math.abs(le)%ee.colors.length]}ee.selectColor=E;function ee(ce){let le,he=null,de,ue;function pe(...ye){if(!pe.enabled)return;const me=pe,be=Number(new Date),_e=be-(le||be);me.diff=_e,me.prev=le,me.curr=be,le=be,ye[0]=ee.coerce(ye[0]),typeof ye[0]!="string"&&ye.unshift("%O");let we=0;ye[0]=ye[0].replace(/%([a-zA-Z%])/g,($e,ve)=>{if($e==="%%")return"%";we++;const fe=ee.formatters[ve];if(typeof fe=="function"){const Ee=ye[we];$e=fe.call(me,Ee),ye.splice(we,1),we--}return $e}),ee.formatArgs.call(me,ye),(me.log||ee.log).apply(me,ye)}return pe.namespace=ce,pe.useColors=ee.useColors(),pe.color=ee.selectColor(ce),pe.extend=te,pe.destroy=ee.destroy,Object.defineProperty(pe,"enabled",{enumerable:!0,configurable:!1,get:()=>he!==null?he:(de!==ee.namespaces&&(de=ee.namespaces,ue=ee.enabled(ce)),ue),set:ye=>{he=ye}}),typeof ee.init=="function"&&ee.init(pe),pe}function te(ce,le){const he=ee(this.namespace+(typeof le>"u"?":":le)+ce);return he.log=this.log,he}function re(ce){ee.save(ce),ee.namespaces=ce,ee.names=[],ee.skips=[];let le;const he=(typeof ce=="string"?ce:"").split(/[\s,]+/),de=he.length;for(le=0;le<de;le++)he[le]&&(ce=he[le].replace(/\*/g,".*?"),ce[0]==="-"?ee.skips.push(new RegExp("^"+ce.slice(1)+"$")):ee.names.push(new RegExp("^"+ce+"$")))}function ne(){const ce=[...ee.names.map(se),...ee.skips.map(se).map(le=>"-"+le)].join(",");return ee.enable(""),ce}function ie(ce){if(ce[ce.length-1]==="*")return!0;let le,he;for(le=0,he=ee.skips.length;le<he;le++)if(ee.skips[le].test(ce))return!1;for(le=0,he=ee.names.length;le<he;le++)if(ee.names[le].test(ce))return!0;return!1}function se(ce){return ce.toString().substring(2,ce.toString().length-2).replace(/\.\*\?$/,"*")}function oe(ce){return ce instanceof Error?ce.stack||ce.message:ce}function ae(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return ee.enable(ee.load()),ee}var common=setup;(function(J,E){E.formatArgs=te,E.save=re,E.load=ne,E.useColors=ee,E.storage=ie(),E.destroy=(()=>{let oe=!1;return()=>{oe||(oe=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),E.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function ee(){return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}function te(oe){if(oe[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+oe[0]+(this.useColors?"%c ":" ")+"+"+J.exports.humanize(this.diff),!this.useColors)return;const ae="color: "+this.color;oe.splice(1,0,ae,"color: inherit");let ce=0,le=0;oe[0].replace(/%[a-zA-Z%]/g,he=>{he!=="%%"&&(ce++,he==="%c"&&(le=ce))}),oe.splice(le,0,ae)}E.log=console.debug||console.log||(()=>{});function re(oe){try{oe?E.storage.setItem("debug",oe):E.storage.removeItem("debug")}catch{}}function ne(){let oe;try{oe=E.storage.getItem("debug")}catch{}return!oe&&typeof process<"u"&&"env"in process&&(oe={}.DEBUG),oe}function ie(){try{return localStorage}catch{}}J.exports=common(E);const{formatters:se}=J.exports;se.j=function(oe){try{return JSON.stringify(oe)}catch(ae){return"[UnexpectedJSONParseError]: "+ae.message}}})(browser$3,browser$3.exports);var browserExports=browser$3.exports;const debug=getDefaultExportFromCjs(browserExports);function base$4(J,E){if(J.length>=255)throw new TypeError("Alphabet too long");for(var ee=new Uint8Array(256),te=0;te<ee.length;te++)ee[te]=255;for(var re=0;re<J.length;re++){var ne=J.charAt(re),ie=ne.charCodeAt(0);if(ee[ie]!==255)throw new TypeError(ne+" is ambiguous");ee[ie]=re}var se=J.length,oe=J.charAt(0),ae=Math.log(se)/Math.log(256),ce=Math.log(256)/Math.log(se);function le(ue){if(ue instanceof Uint8Array||(ArrayBuffer.isView(ue)?ue=new Uint8Array(ue.buffer,ue.byteOffset,ue.byteLength):Array.isArray(ue)&&(ue=Uint8Array.from(ue))),!(ue instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(ue.length===0)return"";for(var pe=0,ye=0,me=0,be=ue.length;me!==be&&ue[me]===0;)me++,pe++;for(var _e=(be-me)*ce+1>>>0,we=new Uint8Array(_e);me!==be;){for(var $e=ue[me],ve=0,fe=_e-1;($e!==0||ve<ye)&&fe!==-1;fe--,ve++)$e+=256*we[fe]>>>0,we[fe]=$e%se>>>0,$e=$e/se>>>0;if($e!==0)throw new Error("Non-zero carry");ye=ve,me++}for(var Ee=_e-ye;Ee!==_e&&we[Ee]===0;)Ee++;for(var ke=oe.repeat(pe);Ee<_e;++Ee)ke+=J.charAt(we[Ee]);return ke}function he(ue){if(typeof ue!="string")throw new TypeError("Expected String");if(ue.length===0)return new Uint8Array;var pe=0;if(ue[pe]!==" "){for(var ye=0,me=0;ue[pe]===oe;)ye++,pe++;for(var be=(ue.length-pe)*ae+1>>>0,_e=new Uint8Array(be);ue[pe];){var we=ee[ue.charCodeAt(pe)];if(we===255)return;for(var $e=0,ve=be-1;(we!==0||$e<me)&&ve!==-1;ve--,$e++)we+=se*_e[ve]>>>0,_e[ve]=we%256>>>0,we=we/256>>>0;if(we!==0)throw new Error("Non-zero carry");me=$e,pe++}if(ue[pe]!==" "){for(var fe=be-me;fe!==be&&_e[fe]===0;)fe++;for(var Ee=new Uint8Array(ye+(be-fe)),ke=ye;fe!==be;)Ee[ke++]=_e[fe++];return Ee}}}function de(ue){var pe=he(ue);if(pe)return pe;throw new Error(`Non-${E} character`)}return{encode:le,decodeUnsafe:he,decode:de}}var src$4=base$4,_brrp__multiformats_scope_baseX$1=src$4;const equals$2=(J,E)=>{if(J===E)return!0;if(J.byteLength!==E.byteLength)return!1;for(let ee=0;ee<J.byteLength;ee++)if(J[ee]!==E[ee])return!1;return!0},coerce$1=J=>{if(J instanceof Uint8Array&&J.constructor.name==="Uint8Array")return J;if(J instanceof ArrayBuffer)return new Uint8Array(J);if(ArrayBuffer.isView(J))return new Uint8Array(J.buffer,J.byteOffset,J.byteLength);throw new Error("Unknown type, must be binary type")},fromString$5=J=>new TextEncoder().encode(J),toString$5=J=>new TextDecoder().decode(J);let Encoder$2=class{constructor(J,E,ee){this.name=J,this.prefix=E,this.baseEncode=ee}encode(J){if(J instanceof Uint8Array)return`${this.prefix}${this.baseEncode(J)}`;throw Error("Unknown type, must be binary type")}},Decoder$3=class{constructor(J,E,ee){if(this.name=J,this.prefix=E,E.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=E.codePointAt(0),this.baseDecode=ee}decode(J){if(typeof J=="string"){if(J.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(J)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(J.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(J){return or$2(this,J)}},ComposedDecoder$1=class{constructor(J){this.decoders=J}or(J){return or$2(this,J)}decode(J){const E=J[0],ee=this.decoders[E];if(ee)return ee.decode(J);throw RangeError(`Unable to decode multibase string ${JSON.stringify(J)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};const or$2=(J,E)=>new ComposedDecoder$1({...J.decoders||{[J.prefix]:J},...E.decoders||{[E.prefix]:E}});let Codec$1=class{constructor(J,E,ee,te){this.name=J,this.prefix=E,this.baseEncode=ee,this.baseDecode=te,this.encoder=new Encoder$2(J,E,ee),this.decoder=new Decoder$3(J,E,te)}encode(J){return this.encoder.encode(J)}decode(J){return this.decoder.decode(J)}};const from$2=({name:J,prefix:E,encode:ee,decode:te})=>new Codec$1(J,E,ee,te),baseX$2=({prefix:J,name:E,alphabet:ee})=>{const{encode:te,decode:re}=_brrp__multiformats_scope_baseX$1(ee,E);return from$2({prefix:J,name:E,encode:te,decode:ne=>coerce$1(re(ne))})},decode$c=(J,E,ee,te)=>{const re={};for(let ce=0;ce<E.length;++ce)re[E[ce]]=ce;let ne=J.length;for(;J[ne-1]==="=";)--ne;const ie=new Uint8Array(ne*ee/8|0);let se=0,oe=0,ae=0;for(let ce=0;ce<ne;++ce){const le=re[J[ce]];if(le===void 0)throw new SyntaxError(`Non-${te} character`);oe=oe<<ee|le,se+=ee,se>=8&&(se-=8,ie[ae++]=255&oe>>se)}if(se>=ee||255&oe<<8-se)throw new SyntaxError("Unexpected end of data");return ie},encode$d=(J,E,ee)=>{const te=E[E.length-1]==="=",re=(1<<ee)-1;let ne="",ie=0,se=0;for(let oe=0;oe<J.length;++oe)for(se=se<<8|J[oe],ie+=8;ie>ee;)ie-=ee,ne+=E[re&se>>ie];if(ie&&(ne+=E[re&se<<ee-ie]),te)for(;ne.length*ee&7;)ne+="=";return ne},rfc4648$3=({name:J,prefix:E,bitsPerChar:ee,alphabet:te})=>from$2({prefix:E,name:J,encode(re){return encode$d(re,te,ee)},decode(re){return decode$c(re,te,ee,J)}}),base58btc$1=baseX$2({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),base58flickr$1=baseX$2({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),base58$1=Object.freeze(Object.defineProperty({__proto__:null,base58btc:base58btc$1,base58flickr:base58flickr$1},Symbol.toStringTag,{value:"Module"})),base32$2=rfc4648$3({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),base32upper$1=rfc4648$3({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),base32pad$1=rfc4648$3({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),base32padupper$1=rfc4648$3({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),base32hex$1=rfc4648$3({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),base32hexupper$1=rfc4648$3({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),base32hexpad$1=rfc4648$3({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),base32hexpadupper$1=rfc4648$3({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),base32z$1=rfc4648$3({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),base32$3=Object.freeze(Object.defineProperty({__proto__:null,base32:base32$2,base32hex:base32hex$1,base32hexpad:base32hexpad$1,base32hexpadupper:base32hexpadupper$1,base32hexupper:base32hexupper$1,base32pad:base32pad$1,base32padupper:base32padupper$1,base32upper:base32upper$1,base32z:base32z$1},Symbol.toStringTag,{value:"Module"})),base64$4=rfc4648$3({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),base64pad$1=rfc4648$3({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),base64url$1=rfc4648$3({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),base64urlpad$1=rfc4648$3({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),base64$5=Object.freeze(Object.defineProperty({__proto__:null,base64:base64$4,base64pad:base64pad$1,base64url:base64url$1,base64urlpad:base64urlpad$1},Symbol.toStringTag,{value:"Module"}));debug.formatters.b=J=>J==null?"undefined":base58btc$1.baseEncode(J);debug.formatters.t=J=>J==null?"undefined":base32$2.baseEncode(J);debug.formatters.m=J=>J==null?"undefined":base64$4.baseEncode(J);debug.formatters.p=J=>J==null?"undefined":J.toString();debug.formatters.c=J=>J==null?"undefined":J.toString();debug.formatters.k=J=>J==null?"undefined":J.toString();function createDisabledLogger(J){const E=()=>{};return E.enabled=!1,E.color="",E.diff=0,E.log=()=>{},E.namespace=J,E.destroy=()=>!0,E.extend=()=>E,E}function logger(J){let E=createDisabledLogger(`${J}:trace`);return debug.enabled(`${J}:trace`)&&debug.names.map(ee=>ee.toString()).find(ee=>ee.includes(":trace"))!=null&&(E=debug(`${J}:trace`)),Object.assign(debug(J),{error:debug(`${J}:error`),trace:E})}let EventEmitter$3=class extends EventTarget{#e=new Map;listenerCount(J){const E=this.#e.get(J);return E==null?0:E.length}addEventListener(J,E,ee){super.addEventListener(J,E,ee);let te=this.#e.get(J);te==null&&(te=[],this.#e.set(J,te)),te.push({callback:E,once:(ee!==!0&&ee!==!1&&ee?.once)??!1})}removeEventListener(J,E,ee){super.removeEventListener(J.toString(),E??null,ee);let te=this.#e.get(J);te!=null&&(te=te.filter(({callback:re})=>re!==E),this.#e.set(J,te))}dispatchEvent(J){const E=super.dispatchEvent(J);let ee=this.#e.get(J.type);return ee==null||(ee=ee.filter(({once:te})=>!te),this.#e.set(J.type,ee)),E}safeDispatchEvent(J,E){return this.dispatchEvent(new CustomEvent$1(J,E))}};class CustomEventPolyfill extends Event{detail;constructor(E,ee){super(E,ee),this.detail=ee?.detail}}const CustomEvent$1=globalThis.CustomEvent??CustomEventPolyfill;let AbortError$5=class Mt extends Error{code;type;constructor(E="The operation was aborted"){super(E),this.code=Mt.code,this.type=Mt.type}static code="ABORT_ERR";static type="aborted"};class CodeError extends Error{code;props;constructor(E,ee,te){super(E),this.code=ee,this.name=te?.name??"CodeError",this.props=te??{}}}var encode_1$2=encode$c,MSB$5=128,REST$5=127,MSBALL$2=~REST$5,INT$2=Math.pow(2,31);function encode$c(J,E,ee){E=E||[],ee=ee||0;for(var te=ee;J>=INT$2;)E[ee++]=J&255|MSB$5,J/=128;for(;J&MSBALL$2;)E[ee++]=J&255|MSB$5,J>>>=7;return E[ee]=J|0,encode$c.bytes=ee-te+1,E}var decode$b=read$3,MSB$1$1=128,REST$1$1=127;function read$3(J,te){var ee=0,te=te||0,re=0,ne=te,ie,se=J.length;do{if(ne>=se)throw read$3.bytes=0,new RangeError("Could not decode varint");ie=J[ne++],ee+=re<28?(ie&REST$1$1)<<re:(ie&REST$1$1)*Math.pow(2,re),re+=7}while(ie>=MSB$1$1);return read$3.bytes=ne-te,ee}var N1$3=Math.pow(2,7),N2$3=Math.pow(2,14),N3$3=Math.pow(2,21),N4$3=Math.pow(2,28),N5$3=Math.pow(2,35),N6$3=Math.pow(2,42),N7$3=Math.pow(2,49),N8$3=Math.pow(2,56),N9$3=Math.pow(2,63),length$2=function(J){return J<N1$3?1:J<N2$3?2:J<N3$3?3:J<N4$3?4:J<N5$3?5:J<N6$3?6:J<N7$3?7:J<N8$3?8:J<N9$3?9:10},varint$4={encode:encode_1$2,decode:decode$b,encodingLength:length$2},_brrp_varint=varint$4;const decode$a=(J,E=0)=>[_brrp_varint.decode(J,E),_brrp_varint.decode.bytes],encodeTo=(J,E,ee=0)=>(_brrp_varint.encode(J,E,ee),E),encodingLength=J=>_brrp_varint.encodingLength(J),create$3=(J,E)=>{const ee=E.byteLength,te=encodingLength(J),re=te+encodingLength(ee),ne=new Uint8Array(re+ee);return encodeTo(J,ne,0),encodeTo(ee,ne,te),ne.set(E,re),new Digest(J,ee,E,ne)},decode$9=J=>{const E=coerce$1(J),[ee,te]=decode$a(E),[re,ne]=decode$a(E.subarray(te)),ie=E.subarray(te+ne);if(ie.byteLength!==re)throw new Error("Incorrect length");return new Digest(ee,re,ie,E)},equals$1=(J,E)=>{if(J===E)return!0;{const ee=E;return J.code===ee.code&&J.size===ee.size&&ee.bytes instanceof Uint8Array&&equals$2(J.bytes,ee.bytes)}};class Digest{constructor(E,ee,te,re){this.code=E,this.size=ee,this.digest=te,this.bytes=re}}const format$3=(J,E)=>{const{bytes:ee,version:te}=J;switch(te){case 0:return toStringV0(ee,baseCache(J),E||base58btc$1.encoder);default:return toStringV1(ee,baseCache(J),E||base32$2.encoder)}},cache$1=new WeakMap,baseCache=J=>{const E=cache$1.get(J);if(E==null){const ee=new Map;return cache$1.set(J,ee),ee}return E};class CID{constructor(E,ee,te,re){this.code=ee,this.version=E,this.multihash=te,this.bytes=re,this["/"]=re}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:E,multihash:ee}=this;if(E!==DAG_PB_CODE)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(ee.code!==SHA_256_CODE)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return CID.createV0(ee)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:E,digest:ee}=this.multihash,te=create$3(E,ee);return CID.createV1(this.code,te)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(E){return CID.equals(this,E)}static equals(E,ee){const te=ee;return te&&E.code===te.code&&E.version===te.version&&equals$1(E.multihash,te.multihash)}toString(E){return format$3(this,E)}toJSON(){return{"/":format$3(this)}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(E){if(E==null)return null;const ee=E;if(ee instanceof CID)return ee;if(ee["/"]!=null&&ee["/"]===ee.bytes||ee.asCID===ee){const{version:te,code:re,multihash:ne,bytes:ie}=ee;return new CID(te,re,ne,ie||encodeCID(te,re,ne.bytes))}else if(ee[cidSymbol]===!0){const{version:te,multihash:re,code:ne}=ee,ie=decode$9(re);return CID.create(te,ne,ie)}else return null}static create(E,ee,te){if(typeof ee!="number")throw new Error("String codecs are no longer supported");if(!(te.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(E){case 0:{if(ee!==DAG_PB_CODE)throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);return new CID(E,ee,te,te.bytes)}case 1:{const re=encodeCID(E,ee,te.bytes);return new CID(E,ee,te,re)}default:throw new Error("Invalid version")}}static createV0(E){return CID.create(0,DAG_PB_CODE,E)}static createV1(E,ee){return CID.create(1,E,ee)}static decode(E){const[ee,te]=CID.decodeFirst(E);if(te.length)throw new Error("Incorrect length");return ee}static decodeFirst(E){const ee=CID.inspectBytes(E),te=ee.size-ee.multihashSize,re=coerce$1(E.subarray(te,te+ee.multihashSize));if(re.byteLength!==ee.multihashSize)throw new Error("Incorrect length");const ne=re.subarray(ee.multihashSize-ee.digestSize),ie=new Digest(ee.multihashCode,ee.digestSize,ne,re);return[ee.version===0?CID.createV0(ie):CID.createV1(ee.codec,ie),E.subarray(ee.size)]}static inspectBytes(E){let ee=0;const te=()=>{const[le,he]=decode$a(E.subarray(ee));return ee+=he,le};let re=te(),ne=DAG_PB_CODE;if(re===18?(re=0,ee=0):ne=te(),re!==0&&re!==1)throw new RangeError(`Invalid CID version ${re}`);const ie=ee,se=te(),oe=te(),ae=ee+oe,ce=ae-ie;return{version:re,codec:ne,multihashCode:se,digestSize:oe,multihashSize:ce,size:ae}}static parse(E,ee){const[te,re]=parseCIDtoBytes(E,ee),ne=CID.decode(re);if(ne.version===0&&E[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return baseCache(ne).set(te,E),ne}}const parseCIDtoBytes=(J,E)=>{switch(J[0]){case"Q":{const ee=E||base58btc$1;return[base58btc$1.prefix,ee.decode(`${base58btc$1.prefix}${J}`)]}case base58btc$1.prefix:{const ee=E||base58btc$1;return[base58btc$1.prefix,ee.decode(J)]}case base32$2.prefix:{const ee=E||base32$2;return[base32$2.prefix,ee.decode(J)]}default:{if(E==null)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[J[0],E.decode(J)]}}},toStringV0=(J,E,ee)=>{const{prefix:te}=ee;if(te!==base58btc$1.prefix)throw Error(`Cannot string encode V0 in ${ee.name} encoding`);const re=E.get(te);if(re==null){const ne=ee.encode(J).slice(1);return E.set(te,ne),ne}else return re},toStringV1=(J,E,ee)=>{const{prefix:te}=ee,re=E.get(te);if(re==null){const ne=ee.encode(J);return E.set(te,ne),ne}else return re},DAG_PB_CODE=112,SHA_256_CODE=18,encodeCID=(J,E,ee)=>{const te=encodingLength(J),re=te+encodingLength(E),ne=new Uint8Array(re+ee.byteLength);return encodeTo(J,ne,0),encodeTo(E,ne,te),ne.set(ee,re),ne},cidSymbol=Symbol.for("@ipld/js-cid/CID");function equals(J,E){if(J===E)return!0;if(J.byteLength!==E.byteLength)return!1;for(let ee=0;ee<J.byteLength;ee++)if(J[ee]!==E[ee])return!1;return!0}const identity$3=from$2({prefix:"\0",name:"identity",encode:J=>toString$5(J),decode:J=>fromString$5(J)}),identityBase$1=Object.freeze(Object.defineProperty({__proto__:null,identity:identity$3},Symbol.toStringTag,{value:"Module"})),base2$2=rfc4648$3({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),base2$3=Object.freeze(Object.defineProperty({__proto__:null,base2:base2$2},Symbol.toStringTag,{value:"Module"})),base8$2=rfc4648$3({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),base8$3=Object.freeze(Object.defineProperty({__proto__:null,base8:base8$2},Symbol.toStringTag,{value:"Module"})),base10$2=baseX$2({prefix:"9",name:"base10",alphabet:"0123456789"}),base10$3=Object.freeze(Object.defineProperty({__proto__:null,base10:base10$2},Symbol.toStringTag,{value:"Module"})),base16$2=rfc4648$3({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),base16upper$1=rfc4648$3({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),base16$3=Object.freeze(Object.defineProperty({__proto__:null,base16:base16$2,base16upper:base16upper$1},Symbol.toStringTag,{value:"Module"})),base36$2=baseX$2({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),base36upper$1=baseX$2({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),base36$3=Object.freeze(Object.defineProperty({__proto__:null,base36:base36$2,base36upper:base36upper$1},Symbol.toStringTag,{value:"Module"})),alphabet$1=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),alphabetBytesToChars$1=alphabet$1.reduce((J,E,ee)=>(J[ee]=E,J),[]),alphabetCharsToBytes$1=alphabet$1.reduce((J,E,ee)=>(J[E.codePointAt(0)]=ee,J),[]);function encode$b(J){return J.reduce((E,ee)=>(E+=alphabetBytesToChars$1[ee],E),"")}function decode$8(J){const E=[];for(const ee of J){const te=alphabetCharsToBytes$1[ee.codePointAt(0)];if(te===void 0)throw new Error(`Non-base256emoji character: ${ee}`);E.push(te)}return new Uint8Array(E)}const base256emoji$2=from$2({prefix:"🚀",name:"base256emoji",encode:encode$b,decode:decode$8}),base256emoji$3=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:base256emoji$2},Symbol.toStringTag,{value:"Module"})),from$1=({name:J,code:E,encode:ee})=>new Hasher(J,E,ee);class Hasher{constructor(E,ee,te){this.name=E,this.code=ee,this.encode=te}digest(E){if(E instanceof Uint8Array){const ee=this.encode(E);return ee instanceof Uint8Array?create$3(this.code,ee):ee.then(te=>create$3(this.code,te))}else throw Error("Unknown type, must be binary type")}}const sha=J=>async E=>new Uint8Array(await crypto.subtle.digest(J,E)),sha256$2=from$1({name:"sha2-256",code:18,encode:sha("SHA-256")}),code=0,name="identity",encode$a=coerce$1,digest=J=>create$3(code,encode$a(J)),identity$2={code,name,encode:encode$a,digest};new TextEncoder;new TextDecoder;const bases$1={...identityBase$1,...base2$3,...base8$3,...base10$3,...base16$3,...base32$3,...base36$3,...base58$1,...base64$5,...base256emoji$3};function asUint8Array$1(J){return globalThis.Buffer!=null?new Uint8Array(J.buffer,J.byteOffset,J.byteLength):J}function alloc(J=0){return globalThis.Buffer?.alloc!=null?asUint8Array$1(globalThis.Buffer.alloc(J)):new Uint8Array(J)}function allocUnsafe$3(J=0){return globalThis.Buffer?.allocUnsafe!=null?asUint8Array$1(globalThis.Buffer.allocUnsafe(J)):new Uint8Array(J)}function createCodec$2(J,E,ee,te){return{name:J,prefix:E,encoder:{name:J,prefix:E,encode:ee},decoder:{decode:te}}}const string$1=createCodec$2("utf8","u",J=>"u"+new TextDecoder("utf8").decode(J),J=>new TextEncoder().encode(J.substring(1))),ascii$1=createCodec$2("ascii","a",J=>{let E="a";for(let ee=0;ee<J.length;ee++)E+=String.fromCharCode(J[ee]);return E},J=>{J=J.substring(1);const E=allocUnsafe$3(J.length);for(let ee=0;ee<J.length;ee++)E[ee]=J.charCodeAt(ee);return E}),BASES$1={utf8:string$1,"utf-8":string$1,hex:bases$1.base16,latin1:ascii$1,ascii:ascii$1,binary:ascii$1,...bases$1};function toString$4(J,E="utf8"){const ee=BASES$1[E];if(ee==null)throw new Error(`Unsupported encoding "${E}"`);return(E==="utf8"||E==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(J.buffer,J.byteOffset,J.byteLength).toString("utf8"):ee.encoder.encode(J).substring(1)}var encode_1$1=encode$9,MSB$4=128,REST$4=127,MSBALL$1=~REST$4,INT$1=Math.pow(2,31);function encode$9(J,E,ee){if(Number.MAX_SAFE_INTEGER&&J>Number.MAX_SAFE_INTEGER)throw encode$9.bytes=0,new RangeError("Could not encode varint");E=E||[],ee=ee||0;for(var te=ee;J>=INT$1;)E[ee++]=J&255|MSB$4,J/=128;for(;J&MSBALL$1;)E[ee++]=J&255|MSB$4,J>>>=7;return E[ee]=J|0,encode$9.bytes=ee-te+1,E}var decode$7=read$2,MSB$3=128,REST$3=127;function read$2(J,te){var ee=0,te=te||0,re=0,ne=te,ie,se=J.length;do{if(ne>=se||re>49)throw read$2.bytes=0,new RangeError("Could not decode varint");ie=J[ne++],ee+=re<28?(ie&REST$3)<<re:(ie&REST$3)*Math.pow(2,re),re+=7}while(ie>=MSB$3);return read$2.bytes=ne-te,ee}var N1$2=Math.pow(2,7),N2$2=Math.pow(2,14),N3$2=Math.pow(2,21),N4$2=Math.pow(2,28),N5$2=Math.pow(2,35),N6$2=Math.pow(2,42),N7$2=Math.pow(2,49),N8$2=Math.pow(2,56),N9$2=Math.pow(2,63),length$1=function(J){return J<N1$2?1:J<N2$2?2:J<N3$2?3:J<N4$2?4:J<N5$2?5:J<N6$2?6:J<N7$2?7:J<N8$2?8:J<N9$2?9:10},varint$2={encode:encode_1$1,decode:decode$7,encodingLength:length$1};const varint$3=getDefaultExportFromCjs(varint$2);function concat$3(J,E){E==null&&(E=J.reduce((re,ne)=>re+ne.length,0));const ee=allocUnsafe$3(E);let te=0;for(const re of J)ee.set(re,te),te+=re.length;return asUint8Array$1(ee)}class Parser{index=0;input="";new(E){return this.index=0,this.input=E,this}readAtomically(E){const ee=this.index,te=E();return te===void 0&&(this.index=ee),te}parseWith(E){const ee=E();if(this.index===this.input.length)return ee}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(E){return this.readAtomically(()=>{const ee=this.readChar();if(ee===E)return ee})}readSeparator(E,ee,te){return this.readAtomically(()=>{if(!(ee>0&&this.readGivenChar(E)===void 0))return te()})}readNumber(E,ee,te,re){return this.readAtomically(()=>{let ne=0,ie=0;const se=this.peekChar();if(se===void 0)return;const oe=se==="0",ae=2**(8*re)-1;for(;;){const ce=this.readAtomically(()=>{const le=this.readChar();if(le===void 0)return;const he=Number.parseInt(le,E);if(!Number.isNaN(he))return he});if(ce===void 0)break;if(ne*=E,ne+=ce,ne>ae||(ie+=1,ee!==void 0&&ie>ee))return}if(ie!==0)return!te&&oe&&ie>1?void 0:ne})}readIPv4Addr(){return this.readAtomically(()=>{const E=new Uint8Array(4);for(let ee=0;ee<E.length;ee++){const te=this.readSeparator(".",ee,()=>this.readNumber(10,3,!1,1));if(te===void 0)return;E[ee]=te}return E})}readIPv6Addr(){const E=ee=>{for(let te=0;te<ee.length/2;te++){const re=te*2;if(te<ee.length-3){const ie=this.readSeparator(":",te,()=>this.readIPv4Addr());if(ie!==void 0)return ee[re]=ie[0],ee[re+1]=ie[1],ee[re+2]=ie[2],ee[re+3]=ie[3],[re+4,!0]}const ne=this.readSeparator(":",te,()=>this.readNumber(16,4,!0,2));if(ne===void 0)return[re,!1];ee[re]=ne>>8,ee[re+1]=ne&255}return[ee.length,!1]};return this.readAtomically(()=>{const ee=new Uint8Array(16),[te,re]=E(ee);if(te===16)return ee;if(re||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;const ne=new Uint8Array(14),ie=16-(te+2),[se]=E(ne.subarray(0,ie));return ee.set(ne.subarray(0,se),16-se),ee})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}}const MAX_IPV6_LENGTH=45,MAX_IPV4_LENGTH=15,parser=new Parser;function parseIPv4(J){if(!(J.length>MAX_IPV4_LENGTH))return parser.new(J).parseWith(()=>parser.readIPv4Addr())}function parseIPv6(J){if(!(J.length>MAX_IPV6_LENGTH))return parser.new(J).parseWith(()=>parser.readIPv6Addr())}function parseIP(J){if(!(J.length>MAX_IPV6_LENGTH))return parser.new(J).parseWith(()=>parser.readIPAddr())}function fromString$4(J,E="utf8"){const ee=BASES$1[E];if(ee==null)throw new Error(`Unsupported encoding "${E}"`);return(E==="utf8"||E==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?asUint8Array$1(globalThis.Buffer.from(J,"utf-8")):ee.decoder.decode(`${ee.prefix}${J}`)}function isIPv4(J){return!!parseIPv4(J)}function isIPv6(J){return!!parseIPv6(J)}function isIP(J){return!!parseIP(J)}const isV4=isIPv4,isV6=isIPv6,toBytes$1=function(J){let E=0;if(J=J.toString().trim(),isV4(J)){const ee=new Uint8Array(E+4);return J.split(/\./g).forEach(te=>{ee[E++]=parseInt(te,10)&255}),ee}if(isV6(J)){const ee=J.split(":",8);let te;for(te=0;te<ee.length;te++){const ne=isV4(ee[te]);let ie;ne&&(ie=toBytes$1(ee[te]),ee[te]=toString$4(ie.slice(0,2),"base16")),ie!=null&&++te<8&&ee.splice(te,0,toString$4(ie.slice(2,4),"base16"))}if(ee[0]==="")for(;ee.length<8;)ee.unshift("0");else if(ee[ee.length-1]==="")for(;ee.length<8;)ee.push("0");else if(ee.length<8){for(te=0;te<ee.length&&ee[te]!=="";te++);const ne=[te,1];for(te=9-ee.length;te>0;te--)ne.push("0");ee.splice.apply(ee,ne)}const re=new Uint8Array(E+16);for(te=0;te<ee.length;te++){const ne=parseInt(ee[te],16);re[E++]=ne>>8&255,re[E++]=ne&255}return re}throw new Error("invalid ip address")},toString$3=function(J,E=0,ee){E=~~E,ee=ee??J.length-E;const te=new DataView(J.buffer);if(ee===4){const re=[];for(let ne=0;ne<ee;ne++)re.push(J[E+ne]);return re.join(".")}if(ee===16){const re=[];for(let ne=0;ne<ee;ne+=2)re.push(te.getUint16(E+ne).toString(16));return re.join(":").replace(/(^|:)0(:0)*:0(:|$)/,"$1::$3").replace(/:{3,4}/,"::")}return""},V=-1,names$3={},codes$7={},table=[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,V,"ip6zone"],[43,8,"ipcidr"],[53,V,"dns",!0],[54,V,"dns4",!0],[55,V,"dns6",!0],[56,V,"dnsaddr",!0],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[280,0,"webrtc-direct"],[281,0,"webrtc"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,V,"unix",!1,!0],[421,V,"ipfs"],[421,V,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,V,"garlic64"],[448,0,"tls"],[449,V,"sni"],[460,0,"quic"],[461,0,"quic-v1"],[465,0,"webtransport"],[466,V,"certhash"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[777,V,"memory"]];table.forEach(J=>{const E=createProtocol(...J);codes$7[E.code]=E,names$3[E.name]=E});function createProtocol(J,E,ee,te,re){return{code:J,size:E,name:ee,resolvable:!!te,path:!!re}}function getProtocol(J){if(typeof J=="number"){if(codes$7[J]!=null)return codes$7[J];throw new Error(`no protocol with code: ${J}`)}else if(typeof J=="string"){if(names$3[J]!=null)return names$3[J];throw new Error(`no protocol with name: ${J}`)}throw new Error(`invalid protocol id type: ${typeof J}`)}getProtocol("ip4");getProtocol("ip6");getProtocol("ipcidr");function convertToString(J,E){switch(getProtocol(J).code){case 4:case 41:return bytes2ip(E);case 42:return bytes2str(E);case 6:case 273:case 33:case 132:return bytes2port(E).toString();case 53:case 54:case 55:case 56:case 400:case 449:case 777:return bytes2str(E);case 421:return bytes2mh(E);case 444:return bytes2onion(E);case 445:return bytes2onion(E);case 466:return bytes2mb(E);default:return toString$4(E,"base16")}}function convertToBytes(J,E){switch(getProtocol(J).code){case 4:return ip2bytes(E);case 41:return ip2bytes(E);case 42:return str2bytes(E);case 6:case 273:case 33:case 132:return port2bytes(parseInt(E,10));case 53:case 54:case 55:case 56:case 400:case 449:case 777:return str2bytes(E);case 421:return mh2bytes(E);case 444:return onion2bytes(E);case 445:return onion32bytes(E);case 466:return mb2bytes(E);default:return fromString$4(E,"base16")}}const decoders=Object.values(bases$1).map(J=>J.decoder),anybaseDecoder=function(){let J=decoders[0].or(decoders[1]);return decoders.slice(2).forEach(E=>J=J.or(E)),J}();function ip2bytes(J){if(!isIP(J))throw new Error("invalid ip address");return toBytes$1(J)}function bytes2ip(J){const E=toString$3(J,0,J.length);if(E==null)throw new Error("ipBuff is required");if(!isIP(E))throw new Error("invalid ip address");return E}function port2bytes(J){const E=new ArrayBuffer(2);return new DataView(E).setUint16(0,J),new Uint8Array(E)}function bytes2port(J){return new DataView(J.buffer).getUint16(J.byteOffset)}function str2bytes(J){const E=fromString$4(J),ee=Uint8Array.from(varint$3.encode(E.length));return concat$3([ee,E],ee.length+E.length)}function bytes2str(J){const E=varint$3.decode(J);if(J=J.slice(varint$3.decode.bytes),J.length!==E)throw new Error("inconsistent lengths");return toString$4(J)}function mh2bytes(J){let E;J[0]==="Q"||J[0]==="1"?E=decode$9(base58btc$1.decode(`z${J}`)).bytes:E=CID.parse(J).multihash.bytes;const ee=Uint8Array.from(varint$3.encode(E.length));return concat$3([ee,E],ee.length+E.length)}function mb2bytes(J){const E=anybaseDecoder.decode(J),ee=Uint8Array.from(varint$3.encode(E.length));return concat$3([ee,E],ee.length+E.length)}function bytes2mb(J){const E=varint$3.decode(J),ee=J.slice(varint$3.decode.bytes);if(ee.length!==E)throw new Error("inconsistent lengths");return"u"+toString$4(ee,"base64url")}function bytes2mh(J){const E=varint$3.decode(J),ee=J.slice(varint$3.decode.bytes);if(ee.length!==E)throw new Error("inconsistent lengths");return toString$4(ee,"base58btc")}function onion2bytes(J){const E=J.split(":");if(E.length!==2)throw new Error(`failed to parse onion addr: ["'${E.join('", "')}'"]' does not contain a port number`);if(E[0].length!==16)throw new Error(`failed to parse onion addr: ${E[0]} not a Tor onion address.`);const ee=base32$2.decode("b"+E[0]),te=parseInt(E[1],10);if(te<1||te>65536)throw new Error("Port number is not in range(1, 65536)");const re=port2bytes(te);return concat$3([ee,re],ee.length+re.length)}function onion32bytes(J){const E=J.split(":");if(E.length!==2)throw new Error(`failed to parse onion addr: ["'${E.join('", "')}'"]' does not contain a port number`);if(E[0].length!==56)throw new Error(`failed to parse onion addr: ${E[0]} not a Tor onion3 address.`);const ee=base32$2.decode(`b${E[0]}`),te=parseInt(E[1],10);if(te<1||te>65536)throw new Error("Port number is not in range(1, 65536)");const re=port2bytes(te);return concat$3([ee,re],ee.length+re.length)}function bytes2onion(J){const E=J.slice(0,J.length-2),ee=J.slice(J.length-2),te=toString$4(E,"base32"),re=bytes2port(ee);return`${te}:${re}`}function stringToStringTuples(J){const E=[],ee=J.split("/").slice(1);if(ee.length===1&&ee[0]==="")return[];for(let te=0;te<ee.length;te++){const re=ee[te],ne=getProtocol(re);if(ne.size===0){E.push([re]);continue}if(te++,te>=ee.length)throw ParseError("invalid address: "+J);if(ne.path===!0){E.push([re,cleanPath(ee.slice(te).join("/"))]);break}E.push([re,ee[te]])}return E}function stringTuplesToString(J){const E=[];return J.map(ee=>{const te=protoFromTuple(ee);return E.push(te.name),ee.length>1&&ee[1]!=null&&E.push(ee[1]),null}),cleanPath(E.join("/"))}function stringTuplesToTuples(J){return J.map(E=>{Array.isArray(E)||(E=[E]);const ee=protoFromTuple(E);return E.length>1?[ee.code,convertToBytes(ee.code,E[1])]:[ee.code]})}function tuplesToStringTuples(J){return J.map(E=>{const ee=protoFromTuple(E);return E[1]!=null?[ee.code,convertToString(ee.code,E[1])]:[ee.code]})}function tuplesToBytes(J){return fromBytes(concat$3(J.map(E=>{const ee=protoFromTuple(E);let te=Uint8Array.from(varint$3.encode(ee.code));return E.length>1&&E[1]!=null&&(te=concat$3([te,E[1]])),te})))}function sizeForAddr(J,E){return J.size>0?J.size/8:J.size===0?0:varint$3.decode(E)+(varint$3.decode.bytes??0)}function bytesToTuples(J){const E=[];let ee=0;for(;ee<J.length;){const te=varint$3.decode(J,ee),re=varint$3.decode.bytes??0,ne=getProtocol(te),ie=sizeForAddr(ne,J.slice(ee+re));if(ie===0){E.push([te]),ee+=re;continue}const se=J.slice(ee+re,ee+re+ie);if(ee+=ie+re,ee>J.length)throw ParseError("Invalid address Uint8Array: "+toString$4(J,"base16"));E.push([te,se])}return E}function bytesToString(J){const E=bytesToTuples(J),ee=tuplesToStringTuples(E);return stringTuplesToString(ee)}function stringToBytes(J){J=cleanPath(J);const E=stringToStringTuples(J),ee=stringTuplesToTuples(E);return tuplesToBytes(ee)}function fromString$3(J){return stringToBytes(J)}function fromBytes(J){const E=validateBytes(J);if(E!=null)throw E;return Uint8Array.from(J)}function validateBytes(J){try{bytesToTuples(J)}catch(E){return E}}function cleanPath(J){return"/"+J.trim().split("/").filter(E=>E).join("/")}function ParseError(J){return new Error("Error parsing address: "+J)}function protoFromTuple(J){return getProtocol(J[0])}const inspect$1=Symbol.for("nodejs.util.inspect.custom"),DNS_CODES=[getProtocol("dns").code,getProtocol("dns4").code,getProtocol("dns6").code,getProtocol("dnsaddr").code],resolvers=new Map,symbol$4=Symbol.for("@multiformats/js-multiaddr/multiaddr");function isMultiaddr(J){return!!J?.[symbol$4]}class DefaultMultiaddr{bytes;#e;#t;#r;#n;[symbol$4]=!0;constructor(E){if(E==null&&(E=""),E instanceof Uint8Array)this.bytes=fromBytes(E);else if(typeof E=="string"){if(E.length>0&&E.charAt(0)!=="/")throw new Error(`multiaddr "${E}" must start with a "/"`);this.bytes=fromString$3(E)}else if(isMultiaddr(E))this.bytes=fromBytes(E.bytes);else throw new Error("addr must be a string, Buffer, or another Multiaddr")}toString(){return this.#e==null&&(this.#e=bytesToString(this.bytes)),this.#e}toJSON(){return this.toString()}toOptions(){let E,ee,te,re,ne="";const ie=getProtocol("tcp"),se=getProtocol("udp"),oe=getProtocol("ip4"),ae=getProtocol("ip6"),ce=getProtocol("dns6"),le=getProtocol("ip6zone");for(const[he,de]of this.stringTuples())he===le.code&&(ne=`%${de??""}`),DNS_CODES.includes(he)&&(ee=ie.name,re=443,te=`${de??""}${ne}`,E=he===ce.code?6:4),(he===ie.code||he===se.code)&&(ee=getProtocol(he).name,re=parseInt(de??"")),(he===oe.code||he===ae.code)&&(ee=getProtocol(he).name,te=`${de??""}${ne}`,E=he===ae.code?6:4);if(E==null||ee==null||te==null||re==null)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:E,host:te,transport:ee,port:re}}protos(){return this.protoCodes().map(E=>Object.assign({},getProtocol(E)))}protoCodes(){const E=[],ee=this.bytes;let te=0;for(;te<ee.length;){const re=varint$3.decode(ee,te),ne=varint$3.decode.bytes??0,ie=getProtocol(re),se=sizeForAddr(ie,ee.slice(te+ne));te+=se+ne,E.push(re)}return E}protoNames(){return this.protos().map(E=>E.name)}tuples(){return this.#t==null&&(this.#t=bytesToTuples(this.bytes)),this.#t}stringTuples(){return this.#r==null&&(this.#r=tuplesToStringTuples(this.tuples())),this.#r}encapsulate(E){return E=new DefaultMultiaddr(E),new DefaultMultiaddr(this.toString()+E.toString())}decapsulate(E){const ee=E.toString(),te=this.toString(),re=te.lastIndexOf(ee);if(re<0)throw new Error(`Address ${this.toString()} does not contain subaddress: ${E.toString()}`);return new DefaultMultiaddr(te.slice(0,re))}decapsulateCode(E){const ee=this.tuples();for(let te=ee.length-1;te>=0;te--)if(ee[te][0]===E)return new DefaultMultiaddr(tuplesToBytes(ee.slice(0,te)));return this}getPeerId(){try{const E=this.stringTuples().filter(ee=>ee[0]===names$3.ipfs.code).pop();if(E?.[1]!=null){const ee=E[1];return ee[0]==="Q"||ee[0]==="1"?toString$4(base58btc$1.decode(`z${ee}`),"base58btc"):toString$4(CID.parse(ee).multihash.bytes,"base58btc")}return null}catch{return null}}getPath(){if(this.#n===void 0)try{this.#n=this.stringTuples().filter(E=>getProtocol(E[0]).path===!0)[0][1],this.#n==null&&(this.#n=null)}catch{this.#n=null}return this.#n}equals(E){return equals(this.bytes,E.bytes)}async resolve(E){const ee=this.protos().find(re=>re.resolvable);if(ee==null)return[this];const te=resolvers.get(ee.name);if(te==null)throw new CodeError(`no available resolver for ${ee.name}`,"ERR_NO_AVAILABLE_RESOLVER");return(await te(this,E)).map(re=>new DefaultMultiaddr(re))}nodeAddress(){const E=this.toOptions();if(E.transport!=="tcp"&&E.transport!=="udp")throw new Error(`multiaddr must have a valid format - no protocol with name: "${E.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:E.family,address:E.host,port:E.port}}isThinWaistAddress(E){const ee=(E??this).protos();return!(ee.length!==2||ee[0].code!==4&&ee[0].code!==41||ee[1].code!==6&&ee[1].code!==273)}[inspect$1](){return`Multiaddr(${bytesToString(this.bytes)})`}}function multiaddr(J){return new DefaultMultiaddr(J)}function isAsyncIterable$a(J){return J[Symbol.asyncIterator]!=null}function all$1(J){if(isAsyncIterable$a(J))return(async()=>{const ee=[];for await(const te of J)ee.push(te);return ee})();const E=[];for(const ee of J)E.push(ee);return E}function isAsyncIterable$9(J){return J[Symbol.asyncIterator]!=null}function sort(J,E){return isAsyncIterable$9(J)?async function*(){yield*(await all$1(J)).sort(E)}():function*(){yield*all$1(J).sort(E)}()}function isAsyncIterable$8(J){return J[Symbol.asyncIterator]!=null}function drain(J){if(isAsyncIterable$8(J))return(async()=>{for await(const E of J);})();for(const E of J);}function peekable(J){const[E,ee]=J[Symbol.asyncIterator]!=null?[J[Symbol.asyncIterator](),Symbol.asyncIterator]:[J[Symbol.iterator](),Symbol.iterator],te=[];return{peek:()=>E.next(),push:re=>{te.push(re)},next:()=>te.length>0?{done:!1,value:te.shift()}:E.next(),[ee](){return this}}}function isAsyncIterable$7(J){return J[Symbol.asyncIterator]!=null}function filter(J,E){if(isAsyncIterable$7(J))return async function*(){for await(const se of J)await E(se)&&(yield se)}();const ee=peekable(J),{value:te,done:re}=ee.next();if(re===!0)return function*(){}();const ne=E(te);if(typeof ne.then=="function")return async function*(){await ne&&(yield te);for await(const se of ee)await E(se)&&(yield se)}();const ie=E;return function*(){ne===!0&&(yield te);for(const se of ee)ie(se)&&(yield se)}()}function isAsyncIterable$6(J){return J[Symbol.asyncIterator]!=null}function take(J,E){return isAsyncIterable$6(J)?async function*(){let ee=0;if(!(E<1)){for await(const te of J)if(yield te,ee++,ee===E)return}}():function*(){let ee=0;if(!(E<1)){for(const te of J)if(yield te,ee++,ee===E)return}}()}class BaseDatastore{put(E,ee,te){return Promise.reject(new Error(".put is not implemented"))}get(E,ee){return Promise.reject(new Error(".get is not implemented"))}has(E,ee){return Promise.reject(new Error(".has is not implemented"))}delete(E,ee){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(E,ee={}){for await(const{key:te,value:re}of E)await this.put(te,re,ee),yield te}async*getMany(E,ee={}){for await(const te of E)yield{key:te,value:await this.get(te,ee)}}async*deleteMany(E,ee={}){for await(const te of E)await this.delete(te,ee),yield te}batch(){let E=[],ee=[];return{put(te,re){E.push({key:te,value:re})},delete(te){ee.push(te)},commit:async te=>{await drain(this.putMany(E,te)),E=[],await drain(this.deleteMany(ee,te)),ee=[]}}}async*_all(E,ee){throw new Error("._all is not implemented")}async*_allKeys(E,ee){throw new Error("._allKeys is not implemented")}query(E,ee){let te=this._all(E,ee);if(E.prefix!=null){const re=E.prefix;te=filter(te,ne=>ne.key.toString().startsWith(re))}if(Array.isArray(E.filters)&&(te=E.filters.reduce((re,ne)=>filter(re,ne),te)),Array.isArray(E.orders)&&(te=E.orders.reduce((re,ne)=>sort(re,ne),te)),E.offset!=null){let re=0;const ne=E.offset;te=filter(te,()=>re++>=ne)}return E.limit!=null&&(te=take(te,E.limit)),te}queryKeys(E,ee){let te=this._allKeys(E,ee);if(E.prefix!=null){const re=E.prefix;te=filter(te,ne=>ne.toString().startsWith(re))}if(Array.isArray(E.filters)&&(te=E.filters.reduce((re,ne)=>filter(re,ne),te)),Array.isArray(E.orders)&&(te=E.orders.reduce((re,ne)=>sort(re,ne),te)),E.offset!=null){const re=E.offset;let ne=0;te=filter(te,()=>ne++>=re)}return E.limit!=null&&(te=take(te,E.limit)),te}}let nanoid=(J=21)=>crypto.getRandomValues(new Uint8Array(J)).reduce((E,ee)=>(ee&=63,ee<36?E+=ee.toString(36):ee<62?E+=(ee-26).toString(36).toUpperCase():ee>62?E+="-":E+="_",E),"");const pathSepS="/",pathSepB=new TextEncoder().encode(pathSepS),pathSep=pathSepB[0];class Key{constructor(E,ee){if(typeof E=="string")this._buf=fromString$4(E);else if(E instanceof Uint8Array)this._buf=E;else throw new Error("Invalid key, should be String of Uint8Array");if(ee==null&&(ee=!0),ee&&this.clean(),this._buf.byteLength===0||this._buf[0]!==pathSep)throw new Error("Invalid key")}toString(E="utf8"){return toString$4(this._buf,E)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(E){return new Key(E.join(pathSepS))}static random(){return new Key(nanoid().replace(/-/g,""))}static asKey(E){return E instanceof Uint8Array||typeof E=="string"?new Key(E):typeof E.uint8Array=="function"?new Key(E.uint8Array()):null}clean(){if((this._buf==null||this._buf.byteLength===0)&&(this._buf=pathSepB),this._buf[0]!==pathSep){const E=new Uint8Array(this._buf.byteLength+1);E.fill(pathSep,0,1),E.set(this._buf,1),this._buf=E}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===pathSep;)this._buf=this._buf.subarray(0,-1)}less(E){const ee=this.list(),te=E.list();for(let re=0;re<ee.length;re++){if(te.length<re+1)return!1;const ne=ee[re],ie=te[re];if(ne<ie)return!0;if(ne>ie)return!1}return ee.length<te.length}reverse(){return Key.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const E=this.namespaces();return E[E.length-1]}list(){return this.toString().split(pathSepS).slice(1)}type(){return namespaceType(this.baseNamespace())}name(){return namespaceValue(this.baseNamespace())}instance(E){return new Key(this.toString()+":"+E)}path(){let E=this.parent().toString();return E.endsWith(pathSepS)||(E+=pathSepS),E+=this.type(),new Key(E)}parent(){const E=this.list();return E.length===1?new Key(pathSepS):new Key(E.slice(0,-1).join(pathSepS))}child(E){return this.toString()===pathSepS?E:E.toString()===pathSepS?this:new Key(this.toString()+E.toString(),!1)}isAncestorOf(E){return E.toString()===this.toString()?!1:E.toString().startsWith(this.toString())}isDecendantOf(E){return E.toString()===this.toString()?!1:this.toString().startsWith(E.toString())}isTopLevel(){return this.list().length===1}concat(...E){return Key.withNamespaces([...this.namespaces(),...flatten(E.map(ee=>ee.namespaces()))])}}function namespaceType(J){const E=J.split(":");return E.length<2?"":E.slice(0,-1).join(":")}function namespaceValue(J){const E=J.split(":");return E[E.length-1]}function flatten(J){return[].concat(...J)}function assign(J,E){for(const ee in E)Object.defineProperty(J,ee,{value:E[ee],enumerable:!0,configurable:!0});return J}function createError(J,E,ee){if(!J||typeof J=="string")throw new TypeError("Please pass an Error to err-code");ee||(ee={}),typeof E=="object"&&(ee=E,E=""),E&&(ee.code=E);try{return assign(J,ee)}catch{ee.message=J.message,ee.stack=J.stack;const te=function(){};return te.prototype=Object.create(Object.getPrototypeOf(J)),assign(new te,ee)}}var errCode=createError;const errCode$1=getDefaultExportFromCjs(errCode);function notFoundError(J){return J=J??new Error("Not Found"),errCode$1(J,"ERR_NOT_FOUND")}class MemoryDatastore extends BaseDatastore{constructor(){super(),this.data=new Map}put(E,ee){return this.data.set(E.toString(),ee),E}get(E){const ee=this.data.get(E.toString());if(ee==null)throw notFoundError();return ee}has(E){return this.data.has(E.toString())}delete(E){this.data.delete(E.toString())}*_all(){for(const[E,ee]of this.data.entries())yield{key:new Key(E),value:ee}}*_allKeys(){for(const E of this.data.keys())yield new Key(E)}}var messages;(function(J){J.NOT_STARTED_YET="The libp2p node is not started yet",J.DHT_DISABLED="DHT is not available",J.PUBSUB_DISABLED="PubSub is not available",J.CONN_ENCRYPTION_REQUIRED="At least one connection encryption module is required",J.ERR_TRANSPORTS_REQUIRED="At least one transport module is required",J.ERR_PROTECTOR_REQUIRED="Private network is enforced, but no protector was provided",J.NOT_FOUND="Not found"})(messages||(messages={}));var codes$6;(function(J){J.DHT_DISABLED="ERR_DHT_DISABLED",J.ERR_PUBSUB_DISABLED="ERR_PUBSUB_DISABLED",J.PUBSUB_NOT_STARTED="ERR_PUBSUB_NOT_STARTED",J.DHT_NOT_STARTED="ERR_DHT_NOT_STARTED",J.CONN_ENCRYPTION_REQUIRED="ERR_CONN_ENCRYPTION_REQUIRED",J.ERR_TRANSPORTS_REQUIRED="ERR_TRANSPORTS_REQUIRED",J.ERR_PROTECTOR_REQUIRED="ERR_PROTECTOR_REQUIRED",J.ERR_PEER_DIAL_INTERCEPTED="ERR_PEER_DIAL_INTERCEPTED",J.ERR_CONNECTION_INTERCEPTED="ERR_CONNECTION_INTERCEPTED",J.ERR_INVALID_PROTOCOLS_FOR_STREAM="ERR_INVALID_PROTOCOLS_FOR_STREAM",J.ERR_CONNECTION_ENDED="ERR_CONNECTION_ENDED",J.ERR_CONNECTION_FAILED="ERR_CONNECTION_FAILED",J.ERR_NODE_NOT_STARTED="ERR_NODE_NOT_STARTED",J.ERR_ALREADY_ABORTED="ERR_ALREADY_ABORTED",J.ERR_TOO_MANY_ADDRESSES="ERR_TOO_MANY_ADDRESSES",J.ERR_NO_VALID_ADDRESSES="ERR_NO_VALID_ADDRESSES",J.ERR_RELAYED_DIAL="ERR_RELAYED_DIAL",J.ERR_DIALED_SELF="ERR_DIALED_SELF",J.ERR_DISCOVERED_SELF="ERR_DISCOVERED_SELF",J.ERR_DUPLICATE_TRANSPORT="ERR_DUPLICATE_TRANSPORT",J.ERR_ENCRYPTION_FAILED="ERR_ENCRYPTION_FAILED",J.ERR_HOP_REQUEST_FAILED="ERR_HOP_REQUEST_FAILED",J.ERR_INVALID_KEY="ERR_INVALID_KEY",J.ERR_INVALID_MESSAGE="ERR_INVALID_MESSAGE",J.ERR_INVALID_PARAMETERS="ERR_INVALID_PARAMETERS",J.ERR_INVALID_PEER="ERR_INVALID_PEER",J.ERR_MUXER_UNAVAILABLE="ERR_MUXER_UNAVAILABLE",J.ERR_NOT_FOUND="ERR_NOT_FOUND",J.ERR_TIMEOUT="ERR_TIMEOUT",J.ERR_TRANSPORT_UNAVAILABLE="ERR_TRANSPORT_UNAVAILABLE",J.ERR_TRANSPORT_DIAL_FAILED="ERR_TRANSPORT_DIAL_FAILED",J.ERR_UNSUPPORTED_PROTOCOL="ERR_UNSUPPORTED_PROTOCOL",J.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED="ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED",J.ERR_INVALID_MULTIADDR="ERR_INVALID_MULTIADDR",J.ERR_SIGNATURE_NOT_VALID="ERR_SIGNATURE_NOT_VALID",J.ERR_FIND_SELF="ERR_FIND_SELF",J.ERR_NO_ROUTERS_AVAILABLE="ERR_NO_ROUTERS_AVAILABLE",J.ERR_CONNECTION_NOT_MULTIPLEXED="ERR_CONNECTION_NOT_MULTIPLEXED",J.ERR_NO_DIAL_TOKENS="ERR_NO_DIAL_TOKENS",J.ERR_KEYCHAIN_REQUIRED="ERR_KEYCHAIN_REQUIRED",J.ERR_INVALID_CMS="ERR_INVALID_CMS",J.ERR_MISSING_KEYS="ERR_MISSING_KEYS",J.ERR_NO_KEY="ERR_NO_KEY",J.ERR_INVALID_KEY_NAME="ERR_INVALID_KEY_NAME",J.ERR_INVALID_KEY_TYPE="ERR_INVALID_KEY_TYPE",J.ERR_KEY_ALREADY_EXISTS="ERR_KEY_ALREADY_EXISTS",J.ERR_INVALID_KEY_SIZE="ERR_INVALID_KEY_SIZE",J.ERR_KEY_NOT_FOUND="ERR_KEY_NOT_FOUND",J.ERR_OLD_KEY_NAME_INVALID="ERR_OLD_KEY_NAME_INVALID",J.ERR_NEW_KEY_NAME_INVALID="ERR_NEW_KEY_NAME_INVALID",J.ERR_PASSWORD_REQUIRED="ERR_PASSWORD_REQUIRED",J.ERR_PEM_REQUIRED="ERR_PEM_REQUIRED",J.ERR_CANNOT_READ_KEY="ERR_CANNOT_READ_KEY",J.ERR_MISSING_PRIVATE_KEY="ERR_MISSING_PRIVATE_KEY",J.ERR_MISSING_PUBLIC_KEY="ERR_MISSING_PUBLIC_KEY",J.ERR_INVALID_OLD_PASS_TYPE="ERR_INVALID_OLD_PASS_TYPE",J.ERR_INVALID_NEW_PASS_TYPE="ERR_INVALID_NEW_PASS_TYPE",J.ERR_INVALID_PASS_LENGTH="ERR_INVALID_PASS_LENGTH",J.ERR_NOT_IMPLEMENTED="ERR_NOT_IMPLEMENTED",J.ERR_WRONG_PING_ACK="ERR_WRONG_PING_ACK",J.ERR_INVALID_RECORD="ERR_INVALID_RECORD",J.ERR_ALREADY_SUCCEEDED="ERR_ALREADY_SUCCEEDED",J.ERR_NO_HANDLER_FOR_PROTOCOL="ERR_NO_HANDLER_FOR_PROTOCOL",J.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS="ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS",J.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS="ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS",J.ERR_CONNECTION_DENIED="ERR_CONNECTION_DENIED",J.ERR_TRANSFER_LIMIT_EXCEEDED="ERR_TRANSFER_LIMIT_EXCEEDED"})(codes$6||(codes$6={}));function isAsyncIterable$5(J){return J[Symbol.asyncIterator]!=null}function map$1(J,E){if(isAsyncIterable$5(J))return async function*(){for await(const se of J)yield E(se)}();const ee=peekable(J),{value:te,done:re}=ee.next();if(re===!0)return function*(){}();const ne=E(te);if(typeof ne.then=="function")return async function*(){yield await ne;for await(const se of ee)yield E(se)}();const ie=E;return function*(){yield ne;for(const se of ee)yield ie(se)}()}async function*storeAddresses(J,E){yield*map$1(J,async ee=>(await E.merge(ee.id,{multiaddrs:ee.multiaddrs}),ee))}function uniquePeers(J){const E=new Set;return filter(J,ee=>E.has(ee.id.toString())?!1:(E.add(ee.id.toString()),!0))}async function*requirePeers(J,E=1){let ee=0;for await(const te of J)ee++,yield te;if(ee<E)throw new CodeError(`more peers required, seen: ${ee}  min: ${E}`,"NOT_FOUND")}class FixedFIFO{constructor(E){if(!(E>0)||E-1&E)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(E),this.mask=E-1,this.top=0,this.btm=0,this.next=null}push(E){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=E,this.top=this.top+1&this.mask,!0)}shift(){const E=this.buffer[this.btm];if(E!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,E}isEmpty(){return this.buffer[this.btm]===void 0}}class FIFO{constructor(E={}){this.hwm=E.splitLimit??16,this.head=new FixedFIFO(this.hwm),this.tail=this.head,this.size=0}calculateSize(E){return E?.byteLength!=null?E.byteLength:1}push(E){if(E?.value!=null&&(this.size+=this.calculateSize(E.value)),!this.head.push(E)){const ee=this.head;this.head=ee.next=new FixedFIFO(2*this.head.buffer.length),this.head.push(E)}}shift(){let E=this.tail.shift();if(E===void 0&&this.tail.next!=null){const ee=this.tail.next;this.tail.next=null,this.tail=ee,E=this.tail.shift()}return E?.value!=null&&(this.size-=this.calculateSize(E.value)),E}isEmpty(){return this.head.isEmpty()}}function pushable(J={}){return _pushable(E=>{const ee=E.shift();if(ee==null)return{done:!0};if(ee.error!=null)throw ee.error;return{done:ee.done===!0,value:ee.value}},J)}function pushableV(J={}){return _pushable(E=>{let ee;const te=[];for(;!E.isEmpty()&&(ee=E.shift(),ee!=null);){if(ee.error!=null)throw ee.error;ee.done===!1&&te.push(ee.value)}return ee==null?{done:!0}:{done:ee.done===!0,value:te}},J)}function _pushable(J,E){E=E??{};let ee=E.onEnd,te=new FIFO,re,ne,ie;const se=async()=>te.isEmpty()?ie?{done:!0}:await new Promise((pe,ye)=>{ne=me=>{ne=null,te.push(me);try{pe(J(te))}catch(be){ye(be)}return re}}):J(te),oe=pe=>ne!=null?ne(pe):(te.push(pe),re),ae=pe=>(te=new FIFO,ne!=null?ne({error:pe}):(te.push({error:pe}),re)),ce=pe=>{if(ie)return re;if(E?.objectMode!==!0&&pe?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return oe({done:!1,value:pe})},le=pe=>ie?re:(ie=!0,pe!=null?ae(pe):oe({done:!0})),he=()=>(te=new FIFO,le(),{done:!0}),de=pe=>(le(pe),{done:!0});if(re={[Symbol.asyncIterator](){return this},next:se,return:he,throw:de,push:ce,end:le,get readableLength(){return te.size}},ee==null)return re;const ue=re;return re={[Symbol.asyncIterator](){return this},next(){return ue.next()},throw(pe){return ue.throw(pe),ee!=null&&(ee(pe),ee=void 0),{done:!0}},return(){return ue.return(),ee!=null&&(ee(),ee=void 0),{done:!0}},push:ce,end(pe){return ue.end(pe),ee!=null&&(ee(pe),ee=void 0),re},get readableLength(){return ue.readableLength}},re}function isAsyncIterable$4(J){return J[Symbol.asyncIterator]!=null}function merge$1(...J){const E=[];for(const ee of J)isAsyncIterable$4(ee)||E.push(ee);return E.length===J.length?function*(){for(const ee of E)yield*ee}():async function*(){const ee=pushable({objectMode:!0});Promise.resolve().then(async()=>{try{await Promise.all(J.map(async te=>{for await(const re of te)ee.push(re)})),ee.end()}catch(te){ee.end(te)}}),yield*ee}()}function pipe(J,...E){if(J==null)throw new Error("Empty pipeline");if(isDuplex(J)){const te=J;J=()=>te.source}else if(isIterable(J)||isAsyncIterable$3(J)){const te=J;J=()=>te}const ee=[J,...E];if(ee.length>1&&isDuplex(ee[ee.length-1])&&(ee[ee.length-1]=ee[ee.length-1].sink),ee.length>2)for(let te=1;te<ee.length-1;te++)isDuplex(ee[te])&&(ee[te]=duplexPipelineFn(ee[te]));return rawPipe(...ee)}const rawPipe=(...J)=>{let E;for(;J.length>0;)E=J.shift()(E);return E},isAsyncIterable$3=J=>J?.[Symbol.asyncIterator]!=null,isIterable=J=>J?.[Symbol.iterator]!=null,isDuplex=J=>J==null?!1:J.sink!=null&&J.source!=null,duplexPipelineFn=J=>E=>{const ee=J.sink(E);if(ee?.then!=null){const te=pushable({objectMode:!0});ee.then(()=>{te.end()},ie=>{te.end(ie)});let re;const ne=J.source;if(isAsyncIterable$3(ne))re=async function*(){yield*ne,te.end()};else if(isIterable(ne))re=function*(){yield*ne,te.end()};else throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");return merge$1(te,re())}return J.source};function isAsyncIterable$2(J){return J[Symbol.asyncIterator]!=null}function first(J){if(isAsyncIterable$2(J))return(async()=>{for await(const E of J)return E})();for(const E of J)return E}const log$B=logger("libp2p:peer-routing");class DefaultPeerRouting{constructor(E,ee){this.components=E,this.routers=ee.routers??[]}async findPeer(E,ee){if(this.routers.length===0)throw new CodeError("No peer routers available",codes$6.ERR_NO_ROUTERS_AVAILABLE);if(E.toString()===this.components.peerId.toString())throw new CodeError("Should not try to find self",codes$6.ERR_FIND_SELF);const te=await pipe(merge$1(...this.routers.map(re=>async function*(){try{yield await re.findPeer(E,ee)}catch(ne){log$B.error(ne)}}())),re=>filter(re,Boolean),re=>storeAddresses(re,this.components.peerStore),async re=>await first(re));if(te!=null)return te;throw new CodeError(messages.NOT_FOUND,codes$6.ERR_NOT_FOUND)}async*getClosestPeers(E,ee){if(this.routers.length===0)throw new CodeError("No peer routers available",codes$6.ERR_NO_ROUTERS_AVAILABLE);yield*pipe(merge$1(...this.routers.map(te=>te.getClosestPeers(E,ee))),te=>storeAddresses(te,this.components.peerStore),te=>uniquePeers(te),te=>requirePeers(te))}}class CompoundContentRouting{constructor(E,ee){this.routers=ee.routers??[],this.started=!1,this.components=E}isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(E,ee={}){if(this.routers.length===0)throw new CodeError("No content routers available",codes$6.ERR_NO_ROUTERS_AVAILABLE);yield*pipe(merge$1(...this.routers.map(te=>te.findProviders(E,ee))),te=>storeAddresses(te,this.components.peerStore),te=>uniquePeers(te),te=>requirePeers(te))}async provide(E,ee={}){if(this.routers.length===0)throw new CodeError("No content routers available",codes$6.ERR_NO_ROUTERS_AVAILABLE);await Promise.all(this.routers.map(async te=>{await te.provide(E,ee)}))}async put(E,ee,te){if(!this.isStarted())throw new CodeError(messages.NOT_STARTED_YET,codes$6.DHT_NOT_STARTED);await Promise.all(this.routers.map(async re=>{await re.put(E,ee,te)}))}async get(E,ee){if(!this.isStarted())throw new CodeError(messages.NOT_STARTED_YET,codes$6.DHT_NOT_STARTED);return await Promise.any(this.routers.map(async te=>await te.get(E,ee)))}}const symbol$3=Symbol.for("@libp2p/peer-id");function isPeerId(J){return J!=null&&!!J[symbol$3]}const inspect=Symbol.for("nodejs.util.inspect.custom"),baseDecoder=Object.values(bases$1).map(J=>J.decoder).reduce((J,E)=>J.or(E),bases$1.identity.decoder),LIBP2P_KEY_CODE=114,MARSHALLED_ED225519_PUBLIC_KEY_LENGTH=36,MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH=37;class PeerIdImpl{constructor(E){this.type=E.type,this.multihash=E.multihash,this.privateKey=E.privateKey,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}get[symbol$3](){return!0}toString(){return this.string==null&&(this.string=base58btc$1.encode(this.multihash.bytes).slice(1)),this.string}toCID(){return CID.createV1(LIBP2P_KEY_CODE,this.multihash)}toBytes(){return this.multihash.bytes}toJSON(){return this.toString()}equals(E){if(E instanceof Uint8Array)return equals(this.multihash.bytes,E);if(typeof E=="string")return peerIdFromString(E).equals(this);if(E?.multihash?.bytes!=null)return equals(this.multihash.bytes,E.multihash.bytes);throw new Error("not valid Id")}[inspect](){return`PeerId(${this.toString()})`}}class RSAPeerIdImpl extends PeerIdImpl{constructor(E){super({...E,type:"RSA"}),this.type="RSA",this.publicKey=E.publicKey}}class Ed25519PeerIdImpl extends PeerIdImpl{constructor(E){super({...E,type:"Ed25519"}),this.type="Ed25519",this.publicKey=E.multihash.digest}}class Secp256k1PeerIdImpl extends PeerIdImpl{constructor(E){super({...E,type:"secp256k1"}),this.type="secp256k1",this.publicKey=E.multihash.digest}}function peerIdFromString(J,E){if(J.charAt(0)==="1"||J.charAt(0)==="Q"){const ee=decode$9(base58btc$1.decode(`z${J}`));return J.startsWith("12D")?new Ed25519PeerIdImpl({multihash:ee}):J.startsWith("16U")?new Secp256k1PeerIdImpl({multihash:ee}):new RSAPeerIdImpl({multihash:ee})}return peerIdFromBytes(baseDecoder.decode(J))}function peerIdFromBytes(J){try{const E=decode$9(J);if(E.code===identity$2.code){if(E.digest.length===MARSHALLED_ED225519_PUBLIC_KEY_LENGTH)return new Ed25519PeerIdImpl({multihash:E});if(E.digest.length===MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH)return new Secp256k1PeerIdImpl({multihash:E})}if(E.code===sha256$2.code)return new RSAPeerIdImpl({multihash:E})}catch{return peerIdFromCID(CID.decode(J))}throw new Error("Supplied PeerID CID is invalid")}function peerIdFromCID(J){if(J==null||J.multihash==null||J.version==null||J.version===1&&J.code!==LIBP2P_KEY_CODE)throw new Error("Supplied PeerID CID is invalid");const E=J.multihash;if(E.code===sha256$2.code)return new RSAPeerIdImpl({multihash:J.multihash});if(E.code===identity$2.code){if(E.digest.length===MARSHALLED_ED225519_PUBLIC_KEY_LENGTH)return new Ed25519PeerIdImpl({multihash:J.multihash});if(E.digest.length===MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH)return new Secp256k1PeerIdImpl({multihash:J.multihash})}throw new Error("Supplied PeerID CID is invalid")}async function peerIdFromKeys(J,E){return J.length===MARSHALLED_ED225519_PUBLIC_KEY_LENGTH?new Ed25519PeerIdImpl({multihash:create$3(identity$2.code,J),privateKey:E}):J.length===MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH?new Secp256k1PeerIdImpl({multihash:create$3(identity$2.code,J),privateKey:E}):new RSAPeerIdImpl({multihash:await sha256$2.digest(J),publicKey:J,privateKey:E})}function debounce(J,E){let ee;return function(){const te=function(){ee=void 0,J()};clearTimeout(ee),ee=setTimeout(te,E)}}const log$A=logger("libp2p:address-manager"),defaultAddressFilter=J=>J;function stripPeerId(J,E){const ee=J.getPeerId();return ee!=null&&peerIdFromString(ee).equals(E)&&(J=J.decapsulate(multiaddr(`/p2p/${E.toString()}`))),J}class DefaultAddressManager{constructor(E,ee={}){const{listen:te=[],announce:re=[]}=ee;this.components=E,this.listen=te.map(ne=>ne.toString()),this.announce=new Set(re.map(ne=>ne.toString())),this.observed=new Map,this.announceFilter=ee.announceFilter??defaultAddressFilter,this._updatePeerStoreAddresses=debounce(this._updatePeerStoreAddresses.bind(this),1e3),E.events.addEventListener("transport:listening",()=>{this._updatePeerStoreAddresses()}),E.events.addEventListener("transport:close",()=>{this._updatePeerStoreAddresses()})}_updatePeerStoreAddresses(){const E=this.getAnnounceAddrs().concat(this.components.transportManager.getAddrs()).concat([...this.observed.entries()].filter(([ee,te])=>te.confident).map(([ee])=>multiaddr(ee))).map(ee=>ee.getPeerId()===this.components.peerId.toString()?ee.decapsulate(`/p2p/${this.components.peerId.toString()}`):ee);this.components.peerStore.patch(this.components.peerId,{multiaddrs:E}).catch(ee=>{log$A.error("error updating addresses",ee)})}getListenAddrs(){return Array.from(this.listen).map(E=>multiaddr(E))}getAnnounceAddrs(){return Array.from(this.announce).map(E=>multiaddr(E))}getObservedAddrs(){return Array.from(this.observed).map(([E])=>multiaddr(E))}addObservedAddr(E){E=stripPeerId(E,this.components.peerId);const ee=E.toString();this.observed.has(ee)||this.observed.set(ee,{confident:!1})}confirmObservedAddr(E){E=stripPeerId(E,this.components.peerId);const ee=E.toString(),te=(this.observed.get(ee)??{confident:!1}).confident;this.observed.set(ee,{confident:!0}),te||this._updatePeerStoreAddresses()}removeObservedAddr(E){E=stripPeerId(E,this.components.peerId);const ee=E.toString();this.observed.delete(ee)}getAddresses(){let E=this.getAnnounceAddrs().map(te=>te.toString());E.length===0&&(E=this.components.transportManager.getAddrs().map(te=>te.toString())),E=E.concat(Array.from(this.observed).filter(([te,re])=>re.confident).map(([te])=>te));const ee=new Set(E);return this.announceFilter(Array.from(ee).map(te=>multiaddr(te))).map(te=>te.protos().pop()?.path===!0||te.getPeerId()===this.components.peerId.toString()?te:te.encapsulate(`/p2p/${this.components.peerId.toString()}`))}}const KEEP_ALIVE="keep-alive";var RateLimiterAbstract_1=class{constructor(J={}){this.points=J.points,this.duration=J.duration,this.blockDuration=J.blockDuration,this.execEvenly=J.execEvenly,this.execEvenlyMinDelayMs=J.execEvenlyMinDelayMs,this.keyPrefix=J.keyPrefix}get points(){return this._points}set points(J){this._points=J>=0?J:4}get duration(){return this._duration}set duration(J){this._duration=typeof J>"u"?1:J}get msDuration(){return this.duration*1e3}get blockDuration(){return this._blockDuration}set blockDuration(J){this._blockDuration=typeof J>"u"?0:J}get msBlockDuration(){return this.blockDuration*1e3}get execEvenly(){return this._execEvenly}set execEvenly(J){this._execEvenly=typeof J>"u"?!1:!!J}get execEvenlyMinDelayMs(){return this._execEvenlyMinDelayMs}set execEvenlyMinDelayMs(J){this._execEvenlyMinDelayMs=typeof J>"u"?Math.ceil(this.msDuration/this.points):J}get keyPrefix(){return this._keyPrefix}set keyPrefix(J){if(typeof J>"u"&&(J="rlflx"),typeof J!="string")throw new Error("keyPrefix must be string");this._keyPrefix=J}_getKeySecDuration(J={}){return J&&J.customDuration>=0?J.customDuration:this.duration}getKey(J){return this.keyPrefix.length>0?`${this.keyPrefix}:${J}`:J}parseKey(J){return J.substring(this.keyPrefix.length)}consume(){throw new Error("You have to implement the method 'consume'!")}penalty(){throw new Error("You have to implement the method 'penalty'!")}reward(){throw new Error("You have to implement the method 'reward'!")}get(){throw new Error("You have to implement the method 'get'!")}set(){throw new Error("You have to implement the method 'set'!")}block(){throw new Error("You have to implement the method 'block'!")}delete(){throw new Error("You have to implement the method 'delete'!")}},BlockedKeys_1$1=class{constructor(){this._keys={},this._addedKeysAmount=0}collectExpired(){const J=Date.now();Object.keys(this._keys).forEach(E=>{this._keys[E]<=J&&delete this._keys[E]}),this._addedKeysAmount=Object.keys(this._keys).length}add(J,E){this.addMs(J,E*1e3)}addMs(J,E){this._keys[J]=Date.now()+E,this._addedKeysAmount++,this._addedKeysAmount>999&&this.collectExpired()}msBeforeExpire(J){const E=this._keys[J];if(E&&E>=Date.now()){this.collectExpired();const ee=Date.now();return E>=ee?E-ee:0}return 0}delete(J){J?delete this._keys[J]:Object.keys(this._keys).forEach(E=>{delete this._keys[E]})}};const BlockedKeys$1=BlockedKeys_1$1;var BlockedKeys_1=BlockedKeys$1,RateLimiterRes_1=class{constructor(J,E,ee,te){this.remainingPoints=typeof J>"u"?0:J,this.msBeforeNext=typeof E>"u"?0:E,this.consumedPoints=typeof ee>"u"?0:ee,this.isFirstInDuration=typeof te>"u"?!1:te}get msBeforeNext(){return this._msBeforeNext}set msBeforeNext(J){return this._msBeforeNext=J,this}get remainingPoints(){return this._remainingPoints}set remainingPoints(J){return this._remainingPoints=J,this}get consumedPoints(){return this._consumedPoints}set consumedPoints(J){return this._consumedPoints=J,this}get isFirstInDuration(){return this._isFirstInDuration}set isFirstInDuration(J){this._isFirstInDuration=!!J}_getDecoratedProperties(){return{remainingPoints:this.remainingPoints,msBeforeNext:this.msBeforeNext,consumedPoints:this.consumedPoints,isFirstInDuration:this.isFirstInDuration}}[Symbol.for("nodejs.util.inspect.custom")](){return this._getDecoratedProperties()}toString(){return JSON.stringify(this._getDecoratedProperties())}toJSON(){return this._getDecoratedProperties()}};const RateLimiterAbstract$3=RateLimiterAbstract_1,BlockedKeys=BlockedKeys_1,RateLimiterRes$b=RateLimiterRes_1;var RateLimiterStoreAbstract_1=class extends RateLimiterAbstract$3{constructor(J={}){super(J),this.inMemoryBlockOnConsumed=J.inMemoryBlockOnConsumed||J.inmemoryBlockOnConsumed,this.inMemoryBlockDuration=J.inMemoryBlockDuration||J.inmemoryBlockDuration,this.insuranceLimiter=J.insuranceLimiter,this._inMemoryBlockedKeys=new BlockedKeys}get client(){return this._client}set client(J){if(typeof J>"u")throw new Error("storeClient is not set");this._client=J}_afterConsume(J,E,ee,te,re,ne={}){const ie=this._getRateLimiterRes(ee,te,re);if(this.inMemoryBlockOnConsumed>0&&!(this.inMemoryBlockDuration>0)&&ie.consumedPoints>=this.inMemoryBlockOnConsumed)return this._inMemoryBlockedKeys.addMs(ee,ie.msBeforeNext),ie.consumedPoints>this.points?E(ie):J(ie);if(ie.consumedPoints>this.points){let se=Promise.resolve();this.blockDuration>0&&ie.consumedPoints<=this.points+te&&(ie.msBeforeNext=this.msBlockDuration,se=this._block(ee,ie.consumedPoints,this.msBlockDuration,ne)),this.inMemoryBlockOnConsumed>0&&ie.consumedPoints>=this.inMemoryBlockOnConsumed&&(this._inMemoryBlockedKeys.add(ee,this.inMemoryBlockDuration),ie.msBeforeNext=this.msInMemoryBlockDuration),se.then(()=>{E(ie)}).catch(oe=>{E(oe)})}else if(this.execEvenly&&ie.msBeforeNext>0&&!ie.isFirstInDuration){let se=Math.ceil(ie.msBeforeNext/(ie.remainingPoints+2));se<this.execEvenlyMinDelayMs&&(se=ie.consumedPoints*this.execEvenlyMinDelayMs),setTimeout(J,se,ie)}else J(ie)}_handleError(J,E,ee,te,re,ne=!1,ie={}){this.insuranceLimiter instanceof RateLimiterAbstract$3?this.insuranceLimiter[E](re,ne,ie).then(se=>{ee(se)}).catch(se=>{te(se)}):te(J)}get _inmemoryBlockedKeys(){return this._inMemoryBlockedKeys}getInmemoryBlockMsBeforeExpire(J){return this.getInMemoryBlockMsBeforeExpire(J)}get inmemoryBlockOnConsumed(){return this.inMemoryBlockOnConsumed}set inmemoryBlockOnConsumed(J){this.inMemoryBlockOnConsumed=J}get inmemoryBlockDuration(){return this.inMemoryBlockDuration}set inmemoryBlockDuration(J){this.inMemoryBlockDuration=J}get msInmemoryBlockDuration(){return this.inMemoryBlockDuration*1e3}getInMemoryBlockMsBeforeExpire(J){return this.inMemoryBlockOnConsumed>0?this._inMemoryBlockedKeys.msBeforeExpire(J):0}get inMemoryBlockOnConsumed(){return this._inMemoryBlockOnConsumed}set inMemoryBlockOnConsumed(J){if(this._inMemoryBlockOnConsumed=J?parseInt(J):0,this.inMemoryBlockOnConsumed>0&&this.points>this.inMemoryBlockOnConsumed)throw new Error('inMemoryBlockOnConsumed option must be greater or equal "points" option')}get inMemoryBlockDuration(){return this._inMemoryBlockDuration}set inMemoryBlockDuration(J){if(this._inMemoryBlockDuration=J?parseInt(J):0,this.inMemoryBlockDuration>0&&this.inMemoryBlockOnConsumed===0)throw new Error("inMemoryBlockOnConsumed option must be set up")}get msInMemoryBlockDuration(){return this._inMemoryBlockDuration*1e3}get insuranceLimiter(){return this._insuranceLimiter}set insuranceLimiter(J){if(typeof J<"u"&&!(J instanceof RateLimiterAbstract$3))throw new Error("insuranceLimiter must be instance of RateLimiterAbstract");this._insuranceLimiter=J,this._insuranceLimiter&&(this._insuranceLimiter.blockDuration=this.blockDuration,this._insuranceLimiter.execEvenly=this.execEvenly)}block(J,E,ee={}){const te=E*1e3;return this._block(this.getKey(J),this.points+1,te,ee)}set(J,E,ee,te={}){const re=(ee>=0?ee:this.duration)*1e3;return this._block(this.getKey(J),E,re,te)}consume(J,E=1,ee={}){return new Promise((te,re)=>{const ne=this.getKey(J),ie=this.getInMemoryBlockMsBeforeExpire(ne);if(ie>0)return re(new RateLimiterRes$b(0,ie));this._upsert(ne,E,this._getKeySecDuration(ee)*1e3,!1,ee).then(se=>{this._afterConsume(te,re,ne,E,se)}).catch(se=>{this._handleError(se,"consume",te,re,J,E,ee)})})}penalty(J,E=1,ee={}){const te=this.getKey(J);return new Promise((re,ne)=>{this._upsert(te,E,this._getKeySecDuration(ee)*1e3,!1,ee).then(ie=>{re(this._getRateLimiterRes(te,E,ie))}).catch(ie=>{this._handleError(ie,"penalty",re,ne,J,E,ee)})})}reward(J,E=1,ee={}){const te=this.getKey(J);return new Promise((re,ne)=>{this._upsert(te,-E,this._getKeySecDuration(ee)*1e3,!1,ee).then(ie=>{re(this._getRateLimiterRes(te,-E,ie))}).catch(ie=>{this._handleError(ie,"reward",re,ne,J,E,ee)})})}get(J,E={}){const ee=this.getKey(J);return new Promise((te,re)=>{this._get(ee,E).then(ne=>{te(ne===null||typeof ne>"u"?null:this._getRateLimiterRes(ee,0,ne))}).catch(ne=>{this._handleError(ne,"get",te,re,J,E)})})}delete(J,E={}){const ee=this.getKey(J);return new Promise((te,re)=>{this._delete(ee,E).then(ne=>{this._inMemoryBlockedKeys.delete(ee),te(ne)}).catch(ne=>{this._handleError(ne,"delete",te,re,J,E)})})}deleteInMemoryBlockedAll(){this._inMemoryBlockedKeys.delete()}_getRateLimiterRes(J,E,ee){throw new Error("You have to implement the method '_getRateLimiterRes'!")}_block(J,E,ee,te={}){return new Promise((re,ne)=>{this._upsert(J,E,ee,!0,te).then(()=>{re(new RateLimiterRes$b(0,ee>0?ee:-1,E))}).catch(ie=>{this._handleError(ie,"block",re,ne,this.parseKey(J),ee/1e3,te)})})}_get(J,E={}){throw new Error("You have to implement the method '_get'!")}_delete(J,E={}){throw new Error("You have to implement the method '_delete'!")}_upsert(J,E,ee,te=!1,re={}){throw new Error("You have to implement the method '_upsert'!")}};const RateLimiterStoreAbstract$4=RateLimiterStoreAbstract_1,RateLimiterRes$a=RateLimiterRes_1,incrTtlLuaScript="redis.call('set', KEYS[1], 0, 'EX', ARGV[2], 'NX') local consumed = redis.call('incrby', KEYS[1], ARGV[1]) local ttl = redis.call('pttl', KEYS[1]) if ttl == -1 then   redis.call('expire', KEYS[1], ARGV[2])   ttl = 1000 * ARGV[2] end return {consumed, ttl} ";let RateLimiterRedis$1=class extends RateLimiterStoreAbstract$4{constructor(J){super(J),J.redis?this.client=J.redis:this.client=J.storeClient,this._rejectIfRedisNotReady=!!J.rejectIfRedisNotReady,typeof this.client.defineCommand=="function"&&this.client.defineCommand("rlflxIncr",{numberOfKeys:1,lua:incrTtlLuaScript})}_isRedisReady(){return this._rejectIfRedisNotReady?!(this.client.status&&this.client.status!=="ready"||typeof this.client.isReady=="function"&&!this.client.isReady()):!0}_getRateLimiterRes(J,E,ee){let[te,re]=ee;Array.isArray(te)&&([,te]=te,[,re]=re);const ne=new RateLimiterRes$a;return ne.consumedPoints=parseInt(te),ne.isFirstInDuration=ne.consumedPoints===E,ne.remainingPoints=Math.max(this.points-ne.consumedPoints,0),ne.msBeforeNext=re,ne}_upsert(J,E,ee,te=!1){return new Promise((re,ne)=>{if(!this._isRedisReady())return ne(new Error("Redis connection is not ready"));const ie=Math.floor(ee/1e3),se=this.client.multi();if(te)ie>0?se.set(J,E,"EX",ie):se.set(J,E),se.pttl(J).exec((oe,ae)=>oe?ne(oe):re(ae));else if(ie>0){const oe=function(ae,ce){return ae?ne(ae):re(ce)};typeof this.client.rlflxIncr=="function"?this.client.rlflxIncr(J,E,ie,oe):this.client.eval(incrTtlLuaScript,1,J,E,ie,oe)}else se.incrby(J,E).pttl(J).exec((oe,ae)=>oe?ne(oe):re(ae))})}_get(J){return new Promise((E,ee)=>{if(!this._isRedisReady())return ee(new Error("Redis connection is not ready"));this.client.multi().get(J).pttl(J).exec((te,re)=>{if(te)ee(te);else{const[ne]=re;if(ne===null)return E(null);E(re)}})})}_delete(J){return new Promise((E,ee)=>{this.client.del(J,(te,re)=>{te?ee(te):E(re>0)})})}};var RateLimiterRedis_1=RateLimiterRedis$1;const RateLimiterStoreAbstract$3=RateLimiterStoreAbstract_1,RateLimiterRes$9=RateLimiterRes_1;function getDriverVersion(J){try{const E=J.client?J.client:J,{version:ee}=E.topology.s.options.metadata.driver,te=ee.split(".").map(re=>parseInt(re));return{major:te[0],feature:te[1],patch:te[2]}}catch{return{major:0,feature:0,patch:0}}}let RateLimiterMongo$1=class Ft extends RateLimiterStoreAbstract$3{constructor(E){super(E),this.dbName=E.dbName,this.tableName=E.tableName,this.indexKeyPrefix=E.indexKeyPrefix,E.mongo?this.client=E.mongo:this.client=E.storeClient,typeof this.client.then=="function"?this.client.then(ee=>{this.client=ee,this._initCollection(),this._driverVersion=getDriverVersion(this.client)}):(this._initCollection(),this._driverVersion=getDriverVersion(this.client))}get dbName(){return this._dbName}set dbName(E){this._dbName=typeof E>"u"?Ft.getDbName():E}static getDbName(){return"node-rate-limiter-flexible"}get tableName(){return this._tableName}set tableName(E){this._tableName=typeof E>"u"?this.keyPrefix:E}get client(){return this._client}set client(E){if(typeof E>"u")throw new Error("mongo is not set");this._client=E}get indexKeyPrefix(){return this._indexKeyPrefix}set indexKeyPrefix(E){this._indexKeyPrefix=E||{}}_initCollection(){const E=(typeof this.client.db=="function"?this.client.db(this.dbName):this.client).collection(this.tableName);E.createIndex({expire:-1},{expireAfterSeconds:0}),E.createIndex(Object.assign({},this.indexKeyPrefix,{key:1}),{unique:!0}),this._collection=E}_getRateLimiterRes(E,ee,te){const re=new RateLimiterRes$9;let ne;return typeof te.value>"u"?ne=te:ne=te.value,re.isFirstInDuration=ne.points===ee,re.consumedPoints=ne.points,re.remainingPoints=Math.max(this.points-re.consumedPoints,0),re.msBeforeNext=ne.expire!==null?Math.max(new Date(ne.expire).getTime()-Date.now(),0):-1,re}_upsert(E,ee,te,re=!1,ne={}){if(!this._collection)return Promise.reject(Error("Mongo connection is not established"));const ie=ne.attrs||{};let se,oe;re?(se={key:E},se=Object.assign(se,ie),oe={$set:{key:E,points:ee,expire:te>0?new Date(Date.now()+te):null}},oe.$set=Object.assign(oe.$set,ie)):(se={$or:[{expire:{$gt:new Date}},{expire:{$eq:null}}],key:E},se=Object.assign(se,ie),oe={$setOnInsert:{key:E,expire:te>0?new Date(Date.now()+te):null},$inc:{points:ee}},oe.$setOnInsert=Object.assign(oe.$setOnInsert,ie));const ae={upsert:!0};return this._driverVersion.major>=4||this._driverVersion.major===3&&this._driverVersion.feature>=7||this._driverVersion.feature>=6&&this._driverVersion.patch>=7?ae.returnDocument="after":ae.returnOriginal=!1,new Promise((ce,le)=>{this._collection.findOneAndUpdate(se,oe,ae).then(he=>{ce(he)}).catch(he=>{if(he&&he.code===11e3){const de=Object.assign({$or:[{expire:{$lte:new Date}},{expire:{$eq:null}}],key:E},ie),ue={$set:Object.assign({key:E,points:ee,expire:te>0?new Date(Date.now()+te):null},ie)};this._collection.findOneAndUpdate(de,ue,ae).then(pe=>{ce(pe)}).catch(pe=>{pe&&pe.code===11e3?this._upsert(E,ee,te,re).then(ye=>ce(ye)).catch(ye=>le(ye)):le(pe)})}else le(he)})})}_get(E,ee={}){if(!this._collection)return Promise.reject(Error("Mongo connection is not established"));const te=ee.attrs||{},re=Object.assign({key:E,$or:[{expire:{$gt:new Date}},{expire:{$eq:null}}]},te);return this._collection.findOne(re)}_delete(E,ee={}){if(!this._collection)return Promise.reject(Error("Mongo connection is not established"));const te=ee.attrs||{},re=Object.assign({key:E},te);return this._collection.deleteOne(re).then(ne=>ne.deletedCount>0)}};var RateLimiterMongo_1=RateLimiterMongo$1;const RateLimiterStoreAbstract$2=RateLimiterStoreAbstract_1,RateLimiterRes$8=RateLimiterRes_1;let RateLimiterMySQL$1=class extends RateLimiterStoreAbstract$2{constructor(J,E=null){super(J),this.client=J.storeClient,this.clientType=J.storeType,this.dbName=J.dbName,this.tableName=J.tableName,this.clearExpiredByTimeout=J.clearExpiredByTimeout,this.tableCreated=J.tableCreated,this.tableCreated?(this.clearExpiredByTimeout&&this._clearExpiredHourAgo(),typeof E=="function"&&E()):this._createDbAndTable().then(()=>{this.tableCreated=!0,this.clearExpiredByTimeout&&this._clearExpiredHourAgo(),typeof E=="function"&&E()}).catch(ee=>{if(typeof E=="function")E(ee);else throw ee})}clearExpired(J){return new Promise(E=>{this._getConnection().then(ee=>{ee.query("DELETE FROM ??.?? WHERE expire < ?",[this.dbName,this.tableName,J],()=>{this._releaseConnection(ee),E()})}).catch(()=>{E()})})}_clearExpiredHourAgo(){this._clearExpiredTimeoutId&&clearTimeout(this._clearExpiredTimeoutId),this._clearExpiredTimeoutId=setTimeout(()=>{this.clearExpired(Date.now()-36e5).then(()=>{this._clearExpiredHourAgo()})},3e5),this._clearExpiredTimeoutId.unref()}_getConnection(){switch(this.clientType){case"pool":return new Promise((J,E)=>{this.client.getConnection((ee,te)=>{if(ee)return E(ee);J(te)})});case"sequelize":return this.client.connectionManager.getConnection();case"knex":return this.client.client.acquireConnection();default:return Promise.resolve(this.client)}}_releaseConnection(J){switch(this.clientType){case"pool":return J.release();case"sequelize":return this.client.connectionManager.releaseConnection(J);case"knex":return this.client.client.releaseConnection(J);default:return!0}}_createDbAndTable(){return new Promise((J,E)=>{this._getConnection().then(ee=>{ee.query(`CREATE DATABASE IF NOT EXISTS \`${this.dbName}\`;`,te=>{if(te)return this._releaseConnection(ee),E(te);ee.query(this._getCreateTableStmt(),re=>{if(re)return this._releaseConnection(ee),E(re);this._releaseConnection(ee),J()})})}).catch(ee=>{E(ee)})})}_getCreateTableStmt(){return`CREATE TABLE IF NOT EXISTS \`${this.dbName}\`.\`${this.tableName}\` (\`key\` VARCHAR(255) CHARACTER SET utf8 NOT NULL,\`points\` INT(9) NOT NULL default 0,\`expire\` BIGINT UNSIGNED,PRIMARY KEY (\`key\`)) ENGINE = INNODB;`}get clientType(){return this._clientType}set clientType(J){if(typeof J>"u")if(this.client.constructor.name==="Connection")J="connection";else if(this.client.constructor.name==="Pool")J="pool";else if(this.client.constructor.name==="Sequelize")J="sequelize";else throw new Error("storeType is not defined");this._clientType=J.toLowerCase()}get dbName(){return this._dbName}set dbName(J){this._dbName=typeof J>"u"?"rtlmtrflx":J}get tableName(){return this._tableName}set tableName(J){this._tableName=typeof J>"u"?this.keyPrefix:J}get tableCreated(){return this._tableCreated}set tableCreated(J){this._tableCreated=typeof J>"u"?!1:!!J}get clearExpiredByTimeout(){return this._clearExpiredByTimeout}set clearExpiredByTimeout(J){this._clearExpiredByTimeout=typeof J>"u"?!0:!!J}_getRateLimiterRes(J,E,ee){const te=new RateLimiterRes$8,[re]=ee;return te.isFirstInDuration=E===re.points,te.consumedPoints=te.isFirstInDuration?E:re.points,te.remainingPoints=Math.max(this.points-te.consumedPoints,0),te.msBeforeNext=re.expire?Math.max(re.expire-Date.now(),0):-1,te}_upsertTransaction(J,E,ee,te,re){return new Promise((ne,ie)=>{J.query("BEGIN",se=>{if(se)return J.rollback(),ie(se);const oe=Date.now(),ae=te>0?oe+te:null;let ce,le;re?(ce=`INSERT INTO ??.?? VALUES (?, ?, ?)
          ON DUPLICATE KEY UPDATE 
            points = ?, 
            expire = ?;`,le=[this.dbName,this.tableName,E,ee,ae,ee,ae]):(ce=`INSERT INTO ??.?? VALUES (?, ?, ?)
          ON DUPLICATE KEY UPDATE 
            points = IF(expire <= ?, ?, points + (?)), 
            expire = IF(expire <= ?, ?, expire);`,le=[this.dbName,this.tableName,E,ee,ae,oe,ee,ee,oe,ae]),J.query(ce,le,he=>{if(he)return J.rollback(),ie(he);J.query("SELECT points, expire FROM ??.?? WHERE `key` = ?;",[this.dbName,this.tableName,E],(de,ue)=>{if(de)return J.rollback(),ie(de);J.query("COMMIT",pe=>{if(pe)return J.rollback(),ie(pe);ne(ue)})})})})})}_upsert(J,E,ee,te=!1){return this.tableCreated?new Promise((re,ne)=>{this._getConnection().then(ie=>{this._upsertTransaction(ie,J,E,ee,te).then(se=>{re(se),this._releaseConnection(ie)}).catch(se=>{ne(se),this._releaseConnection(ie)})}).catch(ie=>{ne(ie)})}):Promise.reject(Error("Table is not created yet"))}_get(J){return this.tableCreated?new Promise((E,ee)=>{this._getConnection().then(te=>{te.query("SELECT points, expire FROM ??.?? WHERE `key` = ? AND (`expire` > ? OR `expire` IS NULL)",[this.dbName,this.tableName,J,Date.now()],(re,ne)=>{re?ee(re):ne.length===0?E(null):E(ne),this._releaseConnection(te)})}).catch(te=>{ee(te)})}):Promise.reject(Error("Table is not created yet"))}_delete(J){return this.tableCreated?new Promise((E,ee)=>{this._getConnection().then(te=>{te.query("DELETE FROM ??.?? WHERE `key` = ?",[this.dbName,this.tableName,J],(re,ne)=>{re?ee(re):E(ne.affectedRows>0),this._releaseConnection(te)})}).catch(te=>{ee(te)})}):Promise.reject(Error("Table is not created yet"))}};var RateLimiterMySQL_1=RateLimiterMySQL$1;const RateLimiterStoreAbstract$1=RateLimiterStoreAbstract_1,RateLimiterRes$7=RateLimiterRes_1;let RateLimiterPostgres$1=class extends RateLimiterStoreAbstract$1{constructor(J,E=null){super(J),this.client=J.storeClient,this.clientType=J.storeType,this.tableName=J.tableName,this.clearExpiredByTimeout=J.clearExpiredByTimeout,this.tableCreated=J.tableCreated,this.tableCreated?typeof E=="function"&&E():this._createTable().then(()=>{this.tableCreated=!0,this.clearExpiredByTimeout&&this._clearExpiredHourAgo(),typeof E=="function"&&E()}).catch(ee=>{if(typeof E=="function")E(ee);else throw ee})}clearExpired(J){return new Promise(E=>{const ee={name:"rlflx-clear-expired",text:`DELETE FROM ${this.tableName} WHERE expire < $1`,values:[J]};this._query(ee).then(()=>{E()}).catch(()=>{E()})})}_clearExpiredHourAgo(){this._clearExpiredTimeoutId&&clearTimeout(this._clearExpiredTimeoutId),this._clearExpiredTimeoutId=setTimeout(()=>{this.clearExpired(Date.now()-36e5).then(()=>{this._clearExpiredHourAgo()})},3e5),this._clearExpiredTimeoutId.unref()}_getConnection(){switch(this.clientType){case"pool":return Promise.resolve(this.client);case"sequelize":return this.client.connectionManager.getConnection();case"knex":return this.client.client.acquireConnection();case"typeorm":return Promise.resolve(this.client.driver.master);default:return Promise.resolve(this.client)}}_releaseConnection(J){switch(this.clientType){case"pool":return!0;case"sequelize":return this.client.connectionManager.releaseConnection(J);case"knex":return this.client.client.releaseConnection(J);case"typeorm":return!0;default:return!0}}_createTable(){return new Promise((J,E)=>{this._query({text:this._getCreateTableStmt()}).then(()=>{J()}).catch(ee=>{ee.code==="23505"?J():E(ee)})})}_getCreateTableStmt(){return`CREATE TABLE IF NOT EXISTS ${this.tableName} ( 
      key varchar(255) PRIMARY KEY,
      points integer NOT NULL DEFAULT 0,
      expire bigint
    );`}get clientType(){return this._clientType}set clientType(J){const E=this.client.constructor.name;if(typeof J>"u")if(E==="Client")J="client";else if(E==="Pool"||E==="BoundPool")J="pool";else if(E==="Sequelize")J="sequelize";else throw new Error("storeType is not defined");this._clientType=J.toLowerCase()}get tableName(){return this._tableName}set tableName(J){this._tableName=typeof J>"u"?this.keyPrefix:J}get tableCreated(){return this._tableCreated}set tableCreated(J){this._tableCreated=typeof J>"u"?!1:!!J}get clearExpiredByTimeout(){return this._clearExpiredByTimeout}set clearExpiredByTimeout(J){this._clearExpiredByTimeout=typeof J>"u"?!0:!!J}_getRateLimiterRes(J,E,ee){const te=new RateLimiterRes$7,re=ee.rows[0];return te.isFirstInDuration=E===re.points,te.consumedPoints=te.isFirstInDuration?E:re.points,te.remainingPoints=Math.max(this.points-te.consumedPoints,0),te.msBeforeNext=re.expire?Math.max(re.expire-Date.now(),0):-1,te}_query(J){const E={name:`${this.tableName.toLowerCase()}:${J.name}`,text:J.text,values:J.values};return new Promise((ee,te)=>{this._getConnection().then(re=>{re.query(E).then(ne=>{ee(ne),this._releaseConnection(re)}).catch(ne=>{te(ne),this._releaseConnection(re)})}).catch(re=>{te(re)})})}_upsert(J,E,ee,te=!1){if(!this.tableCreated)return Promise.reject(Error("Table is not created yet"));const re=ee>0?Date.now()+ee:null,ne=te?" $3 ":` CASE
             WHEN ${this.tableName}.expire <= $4 THEN $3
             ELSE ${this.tableName}.expire
            END `;return this._query({name:te?"rlflx-upsert-force":"rlflx-upsert",text:`
            INSERT INTO ${this.tableName} VALUES ($1, $2, $3)
              ON CONFLICT(key) DO UPDATE SET
                points = CASE
                          WHEN (${this.tableName}.expire <= $4 OR 1=${te?1:0}) THEN $2
                          ELSE ${this.tableName}.points + ($2)
                         END,
                expire = ${ne}
            RETURNING points, expire;`,values:[J,E,re,Date.now()]})}_get(J){return this.tableCreated?new Promise((E,ee)=>{this._query({name:"rlflx-get",text:`
            SELECT points, expire FROM ${this.tableName} WHERE key = $1 AND (expire > $2 OR expire IS NULL);`,values:[J,Date.now()]}).then(te=>{te.rowCount===0&&(te=null),E(te)}).catch(te=>{ee(te)})}):Promise.reject(Error("Table is not created yet"))}_delete(J){return this.tableCreated?this._query({name:"rlflx-delete",text:`DELETE FROM ${this.tableName} WHERE key = $1`,values:[J]}).then(E=>E.rowCount>0):Promise.reject(Error("Table is not created yet"))}};var RateLimiterPostgres_1=RateLimiterPostgres$1,Record_1=class{constructor(J,E,ee=null){this.value=J,this.expiresAt=E,this.timeoutId=ee}get value(){return this._value}set value(J){this._value=parseInt(J)}get expiresAt(){return this._expiresAt}set expiresAt(J){!(J instanceof Date)&&Number.isInteger(J)&&(J=new Date(J)),this._expiresAt=J}get timeoutId(){return this._timeoutId}set timeoutId(J){this._timeoutId=J}};const Record=Record_1,RateLimiterRes$6=RateLimiterRes_1;var MemoryStorage_1=class{constructor(){this._storage={}}incrby(J,E,ee){if(this._storage[J]){const te=this._storage[J].expiresAt?this._storage[J].expiresAt.getTime()-new Date().getTime():-1;return te!==0?(this._storage[J].value=this._storage[J].value+E,new RateLimiterRes$6(0,te,this._storage[J].value,!1)):this.set(J,E,ee)}return this.set(J,E,ee)}set(J,E,ee){const te=ee*1e3;return this._storage[J]&&this._storage[J].timeoutId&&clearTimeout(this._storage[J].timeoutId),this._storage[J]=new Record(E,te>0?new Date(Date.now()+te):null),te>0&&(this._storage[J].timeoutId=setTimeout(()=>{delete this._storage[J]},te),this._storage[J].timeoutId.unref&&this._storage[J].timeoutId.unref()),new RateLimiterRes$6(0,te===0?-1:te,this._storage[J].value,!0)}get(J){if(this._storage[J]){const E=this._storage[J].expiresAt?this._storage[J].expiresAt.getTime()-new Date().getTime():-1;return new RateLimiterRes$6(0,E,this._storage[J].value,!1)}return null}delete(J){return this._storage[J]?(this._storage[J].timeoutId&&clearTimeout(this._storage[J].timeoutId),delete this._storage[J],!0):!1}};const RateLimiterAbstract$2=RateLimiterAbstract_1,MemoryStorage=MemoryStorage_1,RateLimiterRes$5=RateLimiterRes_1;let RateLimiterMemory$2=class extends RateLimiterAbstract$2{constructor(J={}){super(J),this._memoryStorage=new MemoryStorage}consume(J,E=1,ee={}){return new Promise((te,re)=>{const ne=this.getKey(J),ie=this._getKeySecDuration(ee);let se=this._memoryStorage.incrby(ne,E,ie);if(se.remainingPoints=Math.max(this.points-se.consumedPoints,0),se.consumedPoints>this.points)this.blockDuration>0&&se.consumedPoints<=this.points+E&&(se=this._memoryStorage.set(ne,se.consumedPoints,this.blockDuration)),re(se);else if(this.execEvenly&&se.msBeforeNext>0&&!se.isFirstInDuration){let oe=Math.ceil(se.msBeforeNext/(se.remainingPoints+2));oe<this.execEvenlyMinDelayMs&&(oe=se.consumedPoints*this.execEvenlyMinDelayMs),setTimeout(te,oe,se)}else te(se)})}penalty(J,E=1,ee={}){const te=this.getKey(J);return new Promise(re=>{const ne=this._getKeySecDuration(ee),ie=this._memoryStorage.incrby(te,E,ne);ie.remainingPoints=Math.max(this.points-ie.consumedPoints,0),re(ie)})}reward(J,E=1,ee={}){const te=this.getKey(J);return new Promise(re=>{const ne=this._getKeySecDuration(ee),ie=this._memoryStorage.incrby(te,-E,ne);ie.remainingPoints=Math.max(this.points-ie.consumedPoints,0),re(ie)})}block(J,E){const ee=E*1e3,te=this.points+1;return this._memoryStorage.set(this.getKey(J),te,E),Promise.resolve(new RateLimiterRes$5(0,ee===0?-1:ee,te))}set(J,E,ee){const te=(ee>=0?ee:this.duration)*1e3;return this._memoryStorage.set(this.getKey(J),E,ee),Promise.resolve(new RateLimiterRes$5(0,te===0?-1:te,E))}get(J){const E=this._memoryStorage.get(this.getKey(J));return E!==null&&(E.remainingPoints=Math.max(this.points-E.consumedPoints,0)),Promise.resolve(E)}delete(J){return Promise.resolve(this._memoryStorage.delete(this.getKey(J)))}};var RateLimiterMemory_1=RateLimiterMemory$2;const cluster=require$$8,crypto$4=require$$8,RateLimiterAbstract$1=RateLimiterAbstract_1,RateLimiterMemory$1=RateLimiterMemory_1,RateLimiterRes$4=RateLimiterRes_1,channel="rate_limiter_flexible";let masterInstance=null;const masterSendToWorker=function(J,E,ee,te){let re;te===null||te===!0||te===!1?re=te:re={remainingPoints:te.remainingPoints,msBeforeNext:te.msBeforeNext,consumedPoints:te.consumedPoints,isFirstInDuration:te.isFirstInDuration},J.send({channel,keyPrefix:E.keyPrefix,promiseId:E.promiseId,type:ee,data:re})},workerWaitInit=function(J){setTimeout(()=>{this._initiated?process.send(J):typeof this._promises[J.promiseId]<"u"&&workerWaitInit.call(this,J)},30)},workerSendToMaster=function(J,E,ee,te,re){const ne={channel,keyPrefix:this.keyPrefix,func:J,promiseId:E,data:{key:ee,arg:te,opts:re}};this._initiated?process.send(ne):workerWaitInit.call(this,ne)},masterProcessMsg=function(J,E){if(!E||E.channel!==channel||typeof this._rateLimiters[E.keyPrefix]>"u")return!1;let ee;switch(E.func){case"consume":ee=this._rateLimiters[E.keyPrefix].consume(E.data.key,E.data.arg,E.data.opts);break;case"penalty":ee=this._rateLimiters[E.keyPrefix].penalty(E.data.key,E.data.arg,E.data.opts);break;case"reward":ee=this._rateLimiters[E.keyPrefix].reward(E.data.key,E.data.arg,E.data.opts);break;case"block":ee=this._rateLimiters[E.keyPrefix].block(E.data.key,E.data.arg,E.data.opts);break;case"get":ee=this._rateLimiters[E.keyPrefix].get(E.data.key,E.data.opts);break;case"delete":ee=this._rateLimiters[E.keyPrefix].delete(E.data.key,E.data.opts);break;default:return!1}ee&&ee.then(te=>{masterSendToWorker(J,E,"resolve",te)}).catch(te=>{masterSendToWorker(J,E,"reject",te)})},workerProcessMsg=function(J){if(!J||J.channel!==channel||J.keyPrefix!==this.keyPrefix)return!1;if(this._promises[J.promiseId]){clearTimeout(this._promises[J.promiseId].timeoutId);let E;switch(J.data===null||J.data===!0||J.data===!1?E=J.data:E=new RateLimiterRes$4(J.data.remainingPoints,J.data.msBeforeNext,J.data.consumedPoints,J.data.isFirstInDuration),J.type){case"resolve":this._promises[J.promiseId].resolve(E);break;case"reject":this._promises[J.promiseId].reject(E);break;default:throw new Error(`RateLimiterCluster: no such message type '${J.type}'`)}delete this._promises[J.promiseId]}},getOpts=function(){return{points:this.points,duration:this.duration,blockDuration:this.blockDuration,execEvenly:this.execEvenly,execEvenlyMinDelayMs:this.execEvenlyMinDelayMs,keyPrefix:this.keyPrefix}},savePromise=function(J,E){const ee=process.hrtime();let te=ee[0].toString()+ee[1].toString();return typeof this._promises[te]<"u"&&(te+=crypto$4.randomBytes(12).toString("base64")),this._promises[te]={resolve:J,reject:E,timeoutId:setTimeout(()=>{delete this._promises[te],E(new Error("RateLimiterCluster timeout: no answer from master in time"))},this.timeoutMs)},te};let RateLimiterClusterMaster$1=class{constructor(){if(masterInstance)return masterInstance;this._rateLimiters={},cluster.setMaxListeners(0),cluster.on("message",(J,E)=>{E&&E.channel===channel&&E.type==="init"?(typeof this._rateLimiters[E.opts.keyPrefix]>"u"&&(this._rateLimiters[E.opts.keyPrefix]=new RateLimiterMemory$1(E.opts)),J.send({channel,type:"init",keyPrefix:E.opts.keyPrefix})):masterProcessMsg.call(this,J,E)}),masterInstance=this}},RateLimiterClusterMasterPM2$1=class{constructor(J){if(masterInstance)return masterInstance;this._rateLimiters={},J.launchBus((E,ee)=>{ee.on("process:msg",te=>{const re=te.raw;if(re&&re.channel===channel&&re.type==="init")typeof this._rateLimiters[re.opts.keyPrefix]>"u"&&(this._rateLimiters[re.opts.keyPrefix]=new RateLimiterMemory$1(re.opts)),J.sendDataToProcessId(te.process.pm_id,{data:{},topic:channel,channel,type:"init",keyPrefix:re.opts.keyPrefix},(ne,ie)=>{ne&&console.log(ne,ie)});else{const ne={send:ie=>{const se=ie;se.topic=channel,typeof se.data>"u"&&(se.data={}),J.sendDataToProcessId(te.process.pm_id,se,(oe,ae)=>{oe&&console.log(oe,ae)})}};masterProcessMsg.call(this,ne,re)}})}),masterInstance=this}};class RateLimiterClusterWorker extends RateLimiterAbstract$1{get timeoutMs(){return this._timeoutMs}set timeoutMs(E){this._timeoutMs=typeof E>"u"?5e3:Math.abs(parseInt(E))}constructor(E={}){super(E),process.setMaxListeners(0),this.timeoutMs=E.timeoutMs,this._initiated=!1,process.on("message",ee=>{ee&&ee.channel===channel&&ee.type==="init"&&ee.keyPrefix===this.keyPrefix?this._initiated=!0:workerProcessMsg.call(this,ee)}),process.send({channel,type:"init",opts:getOpts.call(this)}),this._promises={}}consume(E,ee=1,te={}){return new Promise((re,ne)=>{const ie=savePromise.call(this,re,ne);workerSendToMaster.call(this,"consume",ie,E,ee,te)})}penalty(E,ee=1,te={}){return new Promise((re,ne)=>{const ie=savePromise.call(this,re,ne);workerSendToMaster.call(this,"penalty",ie,E,ee,te)})}reward(E,ee=1,te={}){return new Promise((re,ne)=>{const ie=savePromise.call(this,re,ne);workerSendToMaster.call(this,"reward",ie,E,ee,te)})}block(E,ee,te={}){return new Promise((re,ne)=>{const ie=savePromise.call(this,re,ne);workerSendToMaster.call(this,"block",ie,E,ee,te)})}get(E,ee={}){return new Promise((te,re)=>{const ne=savePromise.call(this,te,re);workerSendToMaster.call(this,"get",ne,E,ee)})}delete(E,ee={}){return new Promise((te,re)=>{const ne=savePromise.call(this,te,re);workerSendToMaster.call(this,"delete",ne,E,ee)})}}var RateLimiterCluster$1={RateLimiterClusterMaster:RateLimiterClusterMaster$1,RateLimiterClusterMasterPM2:RateLimiterClusterMasterPM2$1,RateLimiterCluster:RateLimiterClusterWorker};const RateLimiterStoreAbstract=RateLimiterStoreAbstract_1,RateLimiterRes$3=RateLimiterRes_1;let RateLimiterMemcache$1=class extends RateLimiterStoreAbstract{constructor(J){super(J),this.client=J.storeClient}_getRateLimiterRes(J,E,ee){const te=new RateLimiterRes$3;return te.consumedPoints=parseInt(ee.consumedPoints),te.isFirstInDuration=ee.consumedPoints===E,te.remainingPoints=Math.max(this.points-te.consumedPoints,0),te.msBeforeNext=ee.msBeforeNext,te}_upsert(J,E,ee,te=!1,re={}){return new Promise((ne,ie)=>{const se=Date.now(),oe=Math.floor(ee/1e3);te?this.client.set(J,E,oe,ae=>{ae?ie(ae):this.client.set(`${J}_expire`,oe>0?se+oe*1e3:-1,oe,()=>{const ce={consumedPoints:E,msBeforeNext:oe>0?oe*1e3:-1};ne(ce)})}):this.client.incr(J,E,(ae,ce)=>{ae||ce===!1?this.client.add(J,E,oe,(le,he)=>{if(le||!he)if(typeof re.attemptNumber>"u"||re.attemptNumber<3){const de=Object.assign({},re);de.attemptNumber=de.attemptNumber?de.attemptNumber+1:1,this._upsert(J,E,ee,te,de).then(ue=>ne(ue)).catch(ue=>ie(ue))}else ie(new Error("Can not add key"));else this.client.add(`${J}_expire`,oe>0?se+oe*1e3:-1,oe,()=>{const de={consumedPoints:E,msBeforeNext:oe>0?oe*1e3:-1};ne(de)})}):this.client.get(`${J}_expire`,(le,he)=>{if(le)ie(le);else{const de=he===!1?0:he,ue={consumedPoints:ce,msBeforeNext:de>=0?Math.max(de-se,0):-1};ne(ue)}})})})}_get(J){return new Promise((E,ee)=>{const te=Date.now();this.client.get(J,(re,ne)=>{ne?this.client.get(`${J}_expire`,(ie,se)=>{if(ie)ee(ie);else{const oe=se===!1?0:se,ae={consumedPoints:ne,msBeforeNext:oe>=0?Math.max(oe-te,0):-1};E(ae)}}):E(null)})})}_delete(J){return new Promise((E,ee)=>{this.client.del(J,(te,re)=>{te?ee(te):re===!1?E(re):this.client.del(`${J}_expire`,ne=>{ne?ee(ne):E(re)})})})}};var RateLimiterMemcache_1=RateLimiterMemcache$1;const RateLimiterRes$2=RateLimiterRes_1;var RLWrapperBlackAndWhite_1=class{constructor(J={}){this.limiter=J.limiter,this.blackList=J.blackList,this.whiteList=J.whiteList,this.isBlackListed=J.isBlackListed,this.isWhiteListed=J.isWhiteListed,this.runActionAnyway=J.runActionAnyway}get limiter(){return this._limiter}set limiter(J){if(typeof J>"u")throw new Error("limiter is not set");this._limiter=J}get runActionAnyway(){return this._runActionAnyway}set runActionAnyway(J){this._runActionAnyway=typeof J>"u"?!1:J}get blackList(){return this._blackList}set blackList(J){this._blackList=Array.isArray(J)?J:[]}get isBlackListed(){return this._isBlackListed}set isBlackListed(J){if(typeof J>"u"&&(J=()=>!1),typeof J!="function")throw new Error("isBlackListed must be function");this._isBlackListed=J}get whiteList(){return this._whiteList}set whiteList(J){this._whiteList=Array.isArray(J)?J:[]}get isWhiteListed(){return this._isWhiteListed}set isWhiteListed(J){if(typeof J>"u"&&(J=()=>!1),typeof J!="function")throw new Error("isWhiteListed must be function");this._isWhiteListed=J}isBlackListedSomewhere(J){return this.blackList.indexOf(J)>=0||this.isBlackListed(J)}isWhiteListedSomewhere(J){return this.whiteList.indexOf(J)>=0||this.isWhiteListed(J)}getBlackRes(){return new RateLimiterRes$2(0,Number.MAX_SAFE_INTEGER,0,!1)}getWhiteRes(){return new RateLimiterRes$2(Number.MAX_SAFE_INTEGER,0,0,!1)}rejectBlack(){return Promise.reject(this.getBlackRes())}resolveBlack(){return Promise.resolve(this.getBlackRes())}resolveWhite(){return Promise.resolve(this.getWhiteRes())}consume(J,E=1){let ee;return this.isWhiteListedSomewhere(J)?ee=this.resolveWhite():this.isBlackListedSomewhere(J)&&(ee=this.rejectBlack()),typeof ee>"u"?this.limiter.consume(J,E):(this.runActionAnyway&&this.limiter.consume(J,E).catch(()=>{}),ee)}block(J,E){let ee;return this.isWhiteListedSomewhere(J)?ee=this.resolveWhite():this.isBlackListedSomewhere(J)&&(ee=this.resolveBlack()),typeof ee>"u"?this.limiter.block(J,E):(this.runActionAnyway&&this.limiter.block(J,E).catch(()=>{}),ee)}penalty(J,E){let ee;return this.isWhiteListedSomewhere(J)?ee=this.resolveWhite():this.isBlackListedSomewhere(J)&&(ee=this.resolveBlack()),typeof ee>"u"?this.limiter.penalty(J,E):(this.runActionAnyway&&this.limiter.penalty(J,E).catch(()=>{}),ee)}reward(J,E){let ee;return this.isWhiteListedSomewhere(J)?ee=this.resolveWhite():this.isBlackListedSomewhere(J)&&(ee=this.resolveBlack()),typeof ee>"u"?this.limiter.reward(J,E):(this.runActionAnyway&&this.limiter.reward(J,E).catch(()=>{}),ee)}get(J){let E;return this.isWhiteListedSomewhere(J)?E=this.resolveWhite():this.isBlackListedSomewhere(J)&&(E=this.resolveBlack()),typeof E>"u"||this.runActionAnyway?this.limiter.get(J):E}delete(J){return this.limiter.delete(J)}};const RateLimiterAbstract=RateLimiterAbstract_1;var RateLimiterUnion_1=class{constructor(...J){if(J.length<1)throw new Error("RateLimiterUnion: at least one limiter have to be passed");J.forEach(E=>{if(!(E instanceof RateLimiterAbstract))throw new Error("RateLimiterUnion: all limiters have to be instance of RateLimiterAbstract")}),this._limiters=J}consume(J,E=1){return new Promise((ee,te)=>{const re=[];this._limiters.forEach(ne=>{re.push(ne.consume(J,E).catch(ie=>({rejected:!0,rej:ie})))}),Promise.all(re).then(ne=>{const ie={};let se=!1;ne.forEach(oe=>{oe.rejected===!0&&(se=!0)});for(let oe=0;oe<ne.length;oe++)se&&ne[oe].rejected===!0?ie[this._limiters[oe].keyPrefix]=ne[oe].rej:se||(ie[this._limiters[oe].keyPrefix]=ne[oe]);se?te(ie):ee(ie)})})}},RateLimiterQueueError_1=class extends Error{constructor(J,E){super(),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor),this.name="CustomError",this.message=J,E&&(this.extra=E)}};const RateLimiterQueueError=RateLimiterQueueError_1,MAX_QUEUE_SIZE=4294967295,KEY_DEFAULT="limiter";var RateLimiterQueue_1=class{constructor(J,E={maxQueueSize:MAX_QUEUE_SIZE}){this._queueLimiters={KEY_DEFAULT:new RateLimiterQueueInternal(J,E)},this._limiterFlexible=J,this._maxQueueSize=E.maxQueueSize}getTokensRemaining(J=KEY_DEFAULT){return this._queueLimiters[J]?this._queueLimiters[J].getTokensRemaining():Promise.resolve(this._limiterFlexible.points)}removeTokens(J,E=KEY_DEFAULT){return this._queueLimiters[E]||(this._queueLimiters[E]=new RateLimiterQueueInternal(this._limiterFlexible,{key:E,maxQueueSize:this._maxQueueSize})),this._queueLimiters[E].removeTokens(J)}};class RateLimiterQueueInternal{constructor(E,ee={maxQueueSize:MAX_QUEUE_SIZE,key:KEY_DEFAULT}){this._key=ee.key,this._waitTimeout=null,this._queue=[],this._limiterFlexible=E,this._maxQueueSize=ee.maxQueueSize}getTokensRemaining(){return this._limiterFlexible.get(this._key).then(E=>E!==null?E.remainingPoints:this._limiterFlexible.points)}removeTokens(E){const ee=this;return new Promise((te,re)=>{if(E>ee._limiterFlexible.points){re(new RateLimiterQueueError(`Requested tokens ${E} exceeds maximum ${ee._limiterFlexible.points} tokens per interval`));return}ee._queue.length>0?ee._queueRequest.call(ee,te,re,E):ee._limiterFlexible.consume(ee._key,E).then(ne=>{te(ne.remainingPoints)}).catch(ne=>{ne instanceof Error?re(ne):(ee._queueRequest.call(ee,te,re,E),ee._waitTimeout===null&&(ee._waitTimeout=setTimeout(ee._processFIFO.bind(ee),ne.msBeforeNext)))})})}_queueRequest(E,ee,te){const re=this;re._queue.length<re._maxQueueSize?re._queue.push({resolve:E,reject:ee,tokens:te}):ee(new RateLimiterQueueError(`Number of requests reached it's maximum ${re._maxQueueSize}`))}_processFIFO(){const E=this;if(E._waitTimeout!==null&&(clearTimeout(E._waitTimeout),E._waitTimeout=null),E._queue.length===0)return;const ee=E._queue.shift();E._limiterFlexible.consume(E._key,ee.tokens).then(te=>{ee.resolve(te.remainingPoints),E._processFIFO.call(E)}).catch(te=>{te instanceof Error?(ee.reject(te),E._processFIFO.call(E)):(E._queue.unshift(ee),E._waitTimeout===null&&(E._waitTimeout=setTimeout(E._processFIFO.bind(E),te.msBeforeNext)))})}}const RateLimiterRes$1=RateLimiterRes_1;var BurstyRateLimiter_1=class{constructor(J,E){this._rateLimiter=J,this._burstLimiter=E}_combineRes(J,E){return new RateLimiterRes$1(J.remainingPoints,Math.min(J.msBeforeNext,E.msBeforeNext),J.consumedPoints,J.isFirstInDuration)}consume(J,E=1,ee={}){return this._rateLimiter.consume(J,E,ee).catch(te=>te instanceof RateLimiterRes$1?this._burstLimiter.consume(J,E,ee).then(re=>Promise.resolve(this._combineRes(te,re))).catch(re=>re instanceof RateLimiterRes$1?Promise.reject(this._combineRes(te,re)):Promise.reject(re)):Promise.reject(te))}get(J){return Promise.all([this._rateLimiter.get(J),this._burstLimiter.get(J)]).then(([E,ee])=>this._combineRes(E,ee))}get points(){return this._rateLimiter.points}};const RateLimiterRedis=RateLimiterRedis_1,RateLimiterMongo=RateLimiterMongo_1,RateLimiterMySQL=RateLimiterMySQL_1,RateLimiterPostgres=RateLimiterPostgres_1,{RateLimiterClusterMaster,RateLimiterClusterMasterPM2,RateLimiterCluster}=RateLimiterCluster$1,RateLimiterMemory=RateLimiterMemory_1,RateLimiterMemcache=RateLimiterMemcache_1,RLWrapperBlackAndWhite=RLWrapperBlackAndWhite_1,RateLimiterUnion=RateLimiterUnion_1,RateLimiterQueue=RateLimiterQueue_1,BurstyRateLimiter=BurstyRateLimiter_1,RateLimiterRes=RateLimiterRes_1;var rateLimiterFlexible={RateLimiterRedis,RateLimiterMongo,RateLimiterMySQL,RateLimiterPostgres,RateLimiterMemory,RateLimiterMemcache,RateLimiterClusterMaster,RateLimiterClusterMasterPM2,RateLimiterCluster,RLWrapperBlackAndWhite,RateLimiterUnion,RateLimiterQueue,BurstyRateLimiter,RateLimiterRes};const log$z=logger("libp2p:get-peer");function getPeerAddress(J){if(isPeerId(J))return{peerId:J,multiaddrs:[]};Array.isArray(J)||(J=[J]);let E;if(J.length>0){const ee=J[0].getPeerId();E=ee==null?void 0:peerIdFromString(ee),J.forEach(te=>{if(!isMultiaddr(te))throw log$z.error("multiaddr %s was invalid",te),new CodeError("Invalid Multiaddr",codes$6.ERR_INVALID_MULTIADDR);const re=te.getPeerId();if(re==null){if(E!=null)throw new CodeError("Multiaddrs must all have the same peer id or have no peer id",codes$6.ERR_INVALID_PARAMETERS)}else{const ne=peerIdFromString(re);if(E==null||!E.equals(ne))throw new CodeError("Multiaddrs must all have the same peer id or have no peer id",codes$6.ERR_INVALID_PARAMETERS)}})}return{peerId:E,multiaddrs:J}}function mapIterable(J,E){const ee={[Symbol.iterator]:()=>ee,next:()=>{const te=J.next(),re=te.value;return te.done===!0||re==null?{done:!0,value:void 0}:{done:!1,value:E(re)}}};return ee}class PeerMap{constructor(E){if(this.map=new Map,E!=null)for(const[ee,te]of E.entries())this.map.set(ee.toString(),te)}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(E){this.map.delete(E.toString())}entries(){return mapIterable(this.map.entries(),E=>[peerIdFromString(E[0]),E[1]])}forEach(E){this.map.forEach((ee,te)=>{E(ee,peerIdFromString(te),this)})}get(E){return this.map.get(E.toString())}has(E){return this.map.has(E.toString())}set(E,ee){this.map.set(E.toString(),ee)}keys(){return mapIterable(this.map.keys(),E=>peerIdFromString(E))}values(){return this.map.values()}get size(){return this.map.size}}class PeerSet{constructor(E){if(this.set=new Set,E!=null)for(const ee of E)this.set.add(ee.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(E){this.set.add(E.toString())}clear(){this.set.clear()}delete(E){this.set.delete(E.toString())}entries(){return mapIterable(this.set.entries(),E=>{const ee=peerIdFromString(E[0]);return[ee,ee]})}forEach(E){this.set.forEach(ee=>{const te=peerIdFromString(ee);E(te,te,this)})}has(E){return this.set.has(E.toString())}values(){return mapIterable(this.set.values(),E=>peerIdFromString(E))}intersection(E){const ee=new PeerSet;for(const te of E)this.has(te)&&ee.add(te);return ee}difference(E){const ee=new PeerSet;for(const te of this)E.has(te)||ee.add(te);return ee}union(E){const ee=new PeerSet;for(const te of E)ee.add(te);for(const te of this)ee.add(te);return ee}}var eventemitter3={exports:{}};(function(J){var E=Object.prototype.hasOwnProperty,ee="~";function te(){}Object.create&&(te.prototype=Object.create(null),new te().__proto__||(ee=!1));function re(oe,ae,ce){this.fn=oe,this.context=ae,this.once=ce||!1}function ne(oe,ae,ce,le,he){if(typeof ce!="function")throw new TypeError("The listener must be a function");var de=new re(ce,le||oe,he),ue=ee?ee+ae:ae;return oe._events[ue]?oe._events[ue].fn?oe._events[ue]=[oe._events[ue],de]:oe._events[ue].push(de):(oe._events[ue]=de,oe._eventsCount++),oe}function ie(oe,ae){--oe._eventsCount===0?oe._events=new te:delete oe._events[ae]}function se(){this._events=new te,this._eventsCount=0}se.prototype.eventNames=function(){var oe=[],ae,ce;if(this._eventsCount===0)return oe;for(ce in ae=this._events)E.call(ae,ce)&&oe.push(ee?ce.slice(1):ce);return Object.getOwnPropertySymbols?oe.concat(Object.getOwnPropertySymbols(ae)):oe},se.prototype.listeners=function(oe){var ae=ee?ee+oe:oe,ce=this._events[ae];if(!ce)return[];if(ce.fn)return[ce.fn];for(var le=0,he=ce.length,de=new Array(he);le<he;le++)de[le]=ce[le].fn;return de},se.prototype.listenerCount=function(oe){var ae=ee?ee+oe:oe,ce=this._events[ae];return ce?ce.fn?1:ce.length:0},se.prototype.emit=function(oe,ae,ce,le,he,de){var ue=ee?ee+oe:oe;if(!this._events[ue])return!1;var pe=this._events[ue],ye=arguments.length,me,be;if(pe.fn){switch(pe.once&&this.removeListener(oe,pe.fn,void 0,!0),ye){case 1:return pe.fn.call(pe.context),!0;case 2:return pe.fn.call(pe.context,ae),!0;case 3:return pe.fn.call(pe.context,ae,ce),!0;case 4:return pe.fn.call(pe.context,ae,ce,le),!0;case 5:return pe.fn.call(pe.context,ae,ce,le,he),!0;case 6:return pe.fn.call(pe.context,ae,ce,le,he,de),!0}for(be=1,me=new Array(ye-1);be<ye;be++)me[be-1]=arguments[be];pe.fn.apply(pe.context,me)}else{var _e=pe.length,we;for(be=0;be<_e;be++)switch(pe[be].once&&this.removeListener(oe,pe[be].fn,void 0,!0),ye){case 1:pe[be].fn.call(pe[be].context);break;case 2:pe[be].fn.call(pe[be].context,ae);break;case 3:pe[be].fn.call(pe[be].context,ae,ce);break;case 4:pe[be].fn.call(pe[be].context,ae,ce,le);break;default:if(!me)for(we=1,me=new Array(ye-1);we<ye;we++)me[we-1]=arguments[we];pe[be].fn.apply(pe[be].context,me)}}return!0},se.prototype.on=function(oe,ae,ce){return ne(this,oe,ae,ce,!1)},se.prototype.once=function(oe,ae,ce){return ne(this,oe,ae,ce,!0)},se.prototype.removeListener=function(oe,ae,ce,le){var he=ee?ee+oe:oe;if(!this._events[he])return this;if(!ae)return ie(this,he),this;var de=this._events[he];if(de.fn)de.fn===ae&&(!le||de.once)&&(!ce||de.context===ce)&&ie(this,he);else{for(var ue=0,pe=[],ye=de.length;ue<ye;ue++)(de[ue].fn!==ae||le&&!de[ue].once||ce&&de[ue].context!==ce)&&pe.push(de[ue]);pe.length?this._events[he]=pe.length===1?pe[0]:pe:ie(this,he)}return this},se.prototype.removeAllListeners=function(oe){var ae;return oe?(ae=ee?ee+oe:oe,this._events[ae]&&ie(this,ae)):(this._events=new te,this._eventsCount=0),this},se.prototype.off=se.prototype.removeListener,se.prototype.addListener=se.prototype.on,se.prefixed=ee,se.EventEmitter=se,J.exports=se})(eventemitter3);var eventemitter3Exports=eventemitter3.exports;const EventEmitter$2=getDefaultExportFromCjs(eventemitter3Exports);let TimeoutError$1=class extends Error{constructor(J){super(J),this.name="TimeoutError"}},AbortError$4=class extends Error{constructor(J){super(),this.name="AbortError",this.message=J}};const getDOMException$1=J=>globalThis.DOMException===void 0?new AbortError$4(J):new DOMException(J),getAbortedReason$1=J=>{const E=J.reason===void 0?getDOMException$1("This operation was aborted."):J.reason;return E instanceof Error?E:getDOMException$1(E)};function pTimeout$1(J,E,ee,te){let re;const ne=new Promise((ie,se)=>{if(typeof E!="number"||Math.sign(E)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${E}\``);if(E===Number.POSITIVE_INFINITY){ie(J);return}if(te={customTimers:{setTimeout,clearTimeout},...te},te.signal){const{signal:oe}=te;oe.aborted&&se(getAbortedReason$1(oe)),oe.addEventListener("abort",()=>{se(getAbortedReason$1(oe))})}re=te.customTimers.setTimeout.call(void 0,()=>{if(typeof ee=="function"){try{ie(ee())}catch(ce){se(ce)}return}const oe=typeof ee=="string"?ee:`Promise timed out after ${E} milliseconds`,ae=ee instanceof Error?ee:new TimeoutError$1(oe);typeof J.cancel=="function"&&J.cancel(),se(ae)},E),(async()=>{try{ie(await J)}catch(oe){se(oe)}finally{te.customTimers.clearTimeout.call(void 0,re)}})()});return ne.clear=()=>{clearTimeout(re),re=void 0},ne}function lowerBound(J,E,ee){let te=0,re=J.length;for(;re>0;){const ne=Math.trunc(re/2);let ie=te+ne;ee(J[ie],E)<=0?(te=++ie,re-=ne+1):re=ne}return te}var __classPrivateFieldGet$5=globalThis&&globalThis.__classPrivateFieldGet||function(J,E,ee,te){if(ee==="a"&&!te)throw new TypeError("Private accessor was defined without a getter");if(typeof E=="function"?J!==E||!te:!E.has(J))throw new TypeError("Cannot read private member from an object whose class did not declare it");return ee==="m"?te:ee==="a"?te.call(J):te?te.value:E.get(J)},_PriorityQueue_queue;class PriorityQueue{constructor(){_PriorityQueue_queue.set(this,[])}enqueue(E,ee){ee={priority:0,...ee};const te={priority:ee.priority,run:E};if(this.size&&__classPrivateFieldGet$5(this,_PriorityQueue_queue,"f")[this.size-1].priority>=ee.priority){__classPrivateFieldGet$5(this,_PriorityQueue_queue,"f").push(te);return}const re=lowerBound(__classPrivateFieldGet$5(this,_PriorityQueue_queue,"f"),te,(ne,ie)=>ie.priority-ne.priority);__classPrivateFieldGet$5(this,_PriorityQueue_queue,"f").splice(re,0,te)}dequeue(){return __classPrivateFieldGet$5(this,_PriorityQueue_queue,"f").shift()?.run}filter(E){return __classPrivateFieldGet$5(this,_PriorityQueue_queue,"f").filter(ee=>ee.priority===E.priority).map(ee=>ee.run)}get size(){return __classPrivateFieldGet$5(this,_PriorityQueue_queue,"f").length}}_PriorityQueue_queue=new WeakMap;var __classPrivateFieldSet$1=globalThis&&globalThis.__classPrivateFieldSet||function(J,E,ee,te,re){if(te==="m")throw new TypeError("Private method is not writable");if(te==="a"&&!re)throw new TypeError("Private accessor was defined without a setter");if(typeof E=="function"?J!==E||!re:!E.has(J))throw new TypeError("Cannot write private member to an object whose class did not declare it");return te==="a"?re.call(J,ee):re?re.value=ee:E.set(J,ee),ee},__classPrivateFieldGet$4=globalThis&&globalThis.__classPrivateFieldGet||function(J,E,ee,te){if(ee==="a"&&!te)throw new TypeError("Private accessor was defined without a getter");if(typeof E=="function"?J!==E||!te:!E.has(J))throw new TypeError("Cannot read private member from an object whose class did not declare it");return ee==="m"?te:ee==="a"?te.call(J):te?te.value:E.get(J)},_PQueue_instances,_PQueue_carryoverConcurrencyCount,_PQueue_isIntervalIgnored,_PQueue_intervalCount,_PQueue_intervalCap,_PQueue_interval,_PQueue_intervalEnd,_PQueue_intervalId,_PQueue_timeoutId,_PQueue_queue,_PQueue_queueClass,_PQueue_pending,_PQueue_concurrency,_PQueue_isPaused,_PQueue_throwOnTimeout,_PQueue_doesIntervalAllowAnother_get,_PQueue_doesConcurrentAllowAnother_get,_PQueue_next,_PQueue_onResumeInterval,_PQueue_isIntervalPaused_get,_PQueue_tryToStartAnother,_PQueue_initializeIntervalIfNeeded,_PQueue_onInterval,_PQueue_processQueue,_PQueue_throwOnAbort,_PQueue_onEvent;let AbortError$3=class extends Error{};class PQueue extends EventEmitter$2{constructor(E){var ee,te,re,ne;if(super(),_PQueue_instances.add(this),_PQueue_carryoverConcurrencyCount.set(this,void 0),_PQueue_isIntervalIgnored.set(this,void 0),_PQueue_intervalCount.set(this,0),_PQueue_intervalCap.set(this,void 0),_PQueue_interval.set(this,void 0),_PQueue_intervalEnd.set(this,0),_PQueue_intervalId.set(this,void 0),_PQueue_timeoutId.set(this,void 0),_PQueue_queue.set(this,void 0),_PQueue_queueClass.set(this,void 0),_PQueue_pending.set(this,0),_PQueue_concurrency.set(this,void 0),_PQueue_isPaused.set(this,void 0),_PQueue_throwOnTimeout.set(this,void 0),Object.defineProperty(this,"timeout",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),E={carryoverConcurrencyCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:PriorityQueue,...E},!(typeof E.intervalCap=="number"&&E.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(te=(ee=E.intervalCap)===null||ee===void 0?void 0:ee.toString())!==null&&te!==void 0?te:""}\` (${typeof E.intervalCap})`);if(E.interval===void 0||!(Number.isFinite(E.interval)&&E.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(ne=(re=E.interval)===null||re===void 0?void 0:re.toString())!==null&&ne!==void 0?ne:""}\` (${typeof E.interval})`);__classPrivateFieldSet$1(this,_PQueue_carryoverConcurrencyCount,E.carryoverConcurrencyCount,"f"),__classPrivateFieldSet$1(this,_PQueue_isIntervalIgnored,E.intervalCap===Number.POSITIVE_INFINITY||E.interval===0,"f"),__classPrivateFieldSet$1(this,_PQueue_intervalCap,E.intervalCap,"f"),__classPrivateFieldSet$1(this,_PQueue_interval,E.interval,"f"),__classPrivateFieldSet$1(this,_PQueue_queue,new E.queueClass,"f"),__classPrivateFieldSet$1(this,_PQueue_queueClass,E.queueClass,"f"),this.concurrency=E.concurrency,this.timeout=E.timeout,__classPrivateFieldSet$1(this,_PQueue_throwOnTimeout,E.throwOnTimeout===!0,"f"),__classPrivateFieldSet$1(this,_PQueue_isPaused,E.autoStart===!1,"f")}get concurrency(){return __classPrivateFieldGet$4(this,_PQueue_concurrency,"f")}set concurrency(E){if(!(typeof E=="number"&&E>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${E}\` (${typeof E})`);__classPrivateFieldSet$1(this,_PQueue_concurrency,E,"f"),__classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_processQueue).call(this)}async add(E,ee={}){return ee={timeout:this.timeout,throwOnTimeout:__classPrivateFieldGet$4(this,_PQueue_throwOnTimeout,"f"),...ee},new Promise((te,re)=>{__classPrivateFieldGet$4(this,_PQueue_queue,"f").enqueue(async()=>{var ne,ie,se;__classPrivateFieldSet$1(this,_PQueue_pending,(ie=__classPrivateFieldGet$4(this,_PQueue_pending,"f"),ie++,ie),"f"),__classPrivateFieldSet$1(this,_PQueue_intervalCount,(se=__classPrivateFieldGet$4(this,_PQueue_intervalCount,"f"),se++,se),"f");try{if(!((ne=ee.signal)===null||ne===void 0)&&ne.aborted)throw new AbortError$3("The task was aborted.");let oe=E({signal:ee.signal});ee.timeout&&(oe=pTimeout$1(Promise.resolve(oe),ee.timeout)),ee.signal&&(oe=Promise.race([oe,__classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_throwOnAbort).call(this,ee.signal)]));const ae=await oe;te(ae),this.emit("completed",ae)}catch(oe){if(oe instanceof TimeoutError$1&&!ee.throwOnTimeout){te();return}re(oe),this.emit("error",oe)}finally{__classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_next).call(this)}},ee),this.emit("add"),__classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_tryToStartAnother).call(this)})}async addAll(E,ee){return Promise.all(E.map(async te=>this.add(te,ee)))}start(){return __classPrivateFieldGet$4(this,_PQueue_isPaused,"f")?(__classPrivateFieldSet$1(this,_PQueue_isPaused,!1,"f"),__classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_processQueue).call(this),this):this}pause(){__classPrivateFieldSet$1(this,_PQueue_isPaused,!0,"f")}clear(){__classPrivateFieldSet$1(this,_PQueue_queue,new(__classPrivateFieldGet$4(this,_PQueue_queueClass,"f")),"f")}async onEmpty(){__classPrivateFieldGet$4(this,_PQueue_queue,"f").size!==0&&await __classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_onEvent).call(this,"empty")}async onSizeLessThan(E){__classPrivateFieldGet$4(this,_PQueue_queue,"f").size<E||await __classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_onEvent).call(this,"next",()=>__classPrivateFieldGet$4(this,_PQueue_queue,"f").size<E)}async onIdle(){__classPrivateFieldGet$4(this,_PQueue_pending,"f")===0&&__classPrivateFieldGet$4(this,_PQueue_queue,"f").size===0||await __classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_onEvent).call(this,"idle")}get size(){return __classPrivateFieldGet$4(this,_PQueue_queue,"f").size}sizeBy(E){return __classPrivateFieldGet$4(this,_PQueue_queue,"f").filter(E).length}get pending(){return __classPrivateFieldGet$4(this,_PQueue_pending,"f")}get isPaused(){return __classPrivateFieldGet$4(this,_PQueue_isPaused,"f")}}_PQueue_carryoverConcurrencyCount=new WeakMap,_PQueue_isIntervalIgnored=new WeakMap,_PQueue_intervalCount=new WeakMap,_PQueue_intervalCap=new WeakMap,_PQueue_interval=new WeakMap,_PQueue_intervalEnd=new WeakMap,_PQueue_intervalId=new WeakMap,_PQueue_timeoutId=new WeakMap,_PQueue_queue=new WeakMap,_PQueue_queueClass=new WeakMap,_PQueue_pending=new WeakMap,_PQueue_concurrency=new WeakMap,_PQueue_isPaused=new WeakMap,_PQueue_throwOnTimeout=new WeakMap,_PQueue_instances=new WeakSet,_PQueue_doesIntervalAllowAnother_get=function(){return __classPrivateFieldGet$4(this,_PQueue_isIntervalIgnored,"f")||__classPrivateFieldGet$4(this,_PQueue_intervalCount,"f")<__classPrivateFieldGet$4(this,_PQueue_intervalCap,"f")},_PQueue_doesConcurrentAllowAnother_get=function(){return __classPrivateFieldGet$4(this,_PQueue_pending,"f")<__classPrivateFieldGet$4(this,_PQueue_concurrency,"f")},_PQueue_next=function(){var J;__classPrivateFieldSet$1(this,_PQueue_pending,(J=__classPrivateFieldGet$4(this,_PQueue_pending,"f"),J--,J),"f"),__classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_tryToStartAnother).call(this),this.emit("next")},_PQueue_onResumeInterval=function(){__classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_onInterval).call(this),__classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_initializeIntervalIfNeeded).call(this),__classPrivateFieldSet$1(this,_PQueue_timeoutId,void 0,"f")},_PQueue_isIntervalPaused_get=function(){const J=Date.now();if(__classPrivateFieldGet$4(this,_PQueue_intervalId,"f")===void 0){const E=__classPrivateFieldGet$4(this,_PQueue_intervalEnd,"f")-J;if(E<0)__classPrivateFieldSet$1(this,_PQueue_intervalCount,__classPrivateFieldGet$4(this,_PQueue_carryoverConcurrencyCount,"f")?__classPrivateFieldGet$4(this,_PQueue_pending,"f"):0,"f");else return __classPrivateFieldGet$4(this,_PQueue_timeoutId,"f")===void 0&&__classPrivateFieldSet$1(this,_PQueue_timeoutId,setTimeout(()=>{__classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_onResumeInterval).call(this)},E),"f"),!0}return!1},_PQueue_tryToStartAnother=function(){if(__classPrivateFieldGet$4(this,_PQueue_queue,"f").size===0)return __classPrivateFieldGet$4(this,_PQueue_intervalId,"f")&&clearInterval(__classPrivateFieldGet$4(this,_PQueue_intervalId,"f")),__classPrivateFieldSet$1(this,_PQueue_intervalId,void 0,"f"),this.emit("empty"),__classPrivateFieldGet$4(this,_PQueue_pending,"f")===0&&this.emit("idle"),!1;if(!__classPrivateFieldGet$4(this,_PQueue_isPaused,"f")){const J=!__classPrivateFieldGet$4(this,_PQueue_instances,"a",_PQueue_isIntervalPaused_get);if(__classPrivateFieldGet$4(this,_PQueue_instances,"a",_PQueue_doesIntervalAllowAnother_get)&&__classPrivateFieldGet$4(this,_PQueue_instances,"a",_PQueue_doesConcurrentAllowAnother_get)){const E=__classPrivateFieldGet$4(this,_PQueue_queue,"f").dequeue();return E?(this.emit("active"),E(),J&&__classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_initializeIntervalIfNeeded).call(this),!0):!1}}return!1},_PQueue_initializeIntervalIfNeeded=function(){__classPrivateFieldGet$4(this,_PQueue_isIntervalIgnored,"f")||__classPrivateFieldGet$4(this,_PQueue_intervalId,"f")!==void 0||(__classPrivateFieldSet$1(this,_PQueue_intervalId,setInterval(()=>{__classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_onInterval).call(this)},__classPrivateFieldGet$4(this,_PQueue_interval,"f")),"f"),__classPrivateFieldSet$1(this,_PQueue_intervalEnd,Date.now()+__classPrivateFieldGet$4(this,_PQueue_interval,"f"),"f"))},_PQueue_onInterval=function(){__classPrivateFieldGet$4(this,_PQueue_intervalCount,"f")===0&&__classPrivateFieldGet$4(this,_PQueue_pending,"f")===0&&__classPrivateFieldGet$4(this,_PQueue_intervalId,"f")&&(clearInterval(__classPrivateFieldGet$4(this,_PQueue_intervalId,"f")),__classPrivateFieldSet$1(this,_PQueue_intervalId,void 0,"f")),__classPrivateFieldSet$1(this,_PQueue_intervalCount,__classPrivateFieldGet$4(this,_PQueue_carryoverConcurrencyCount,"f")?__classPrivateFieldGet$4(this,_PQueue_pending,"f"):0,"f"),__classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_processQueue).call(this)},_PQueue_processQueue=function(){for(;__classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_tryToStartAnother).call(this););},_PQueue_throwOnAbort=async function(J){return new Promise((E,ee)=>{J.addEventListener("abort",()=>{ee(new AbortError$3("The task was aborted."))},{once:!0})})},_PQueue_onEvent=async function(J,E){return new Promise(ee=>{const te=()=>{E&&!E()||(this.off(J,te),ee())};this.on(J,te)})};const DIAL_TIMEOUT=3e4,INBOUND_UPGRADE_TIMEOUT=3e4,MAX_PARALLEL_DIALS=100,MAX_PEER_ADDRS_TO_DIAL=25,MAX_PARALLEL_DIALS_PER_PEER=10,MIN_CONNECTIONS=50,MAX_CONNECTIONS=300,AUTO_DIAL_INTERVAL=5e3,AUTO_DIAL_CONCURRENCY=25,AUTO_DIAL_PRIORITY=0,INBOUND_CONNECTION_THRESHOLD=5,MAX_INCOMING_PENDING_CONNECTIONS=10,log$y=logger("libp2p:connection-manager:auto-dial"),defaultOptions$6={minConnections:MIN_CONNECTIONS,autoDialConcurrency:AUTO_DIAL_CONCURRENCY,autoDialPriority:AUTO_DIAL_PRIORITY,autoDialInterval:AUTO_DIAL_INTERVAL};class AutoDial{constructor(E,ee){this.connectionManager=E.connectionManager,this.peerStore=E.peerStore,this.minConnections=ee.minConnections??defaultOptions$6.minConnections,this.autoDialPriority=ee.autoDialPriority??defaultOptions$6.autoDialPriority,this.autoDialIntervalMs=ee.autoDialInterval??defaultOptions$6.autoDialInterval,this.started=!1,this.queue=new PQueue({concurrency:ee.autoDialConcurrency??defaultOptions$6.autoDialConcurrency}),this.queue.addListener("error",te=>{log$y.error("error during auto-dial",te)}),E.events.addEventListener("connection:close",()=>{this.autoDial().catch(te=>{log$y.error(te)})})}isStarted(){return this.started}start(){this.autoDialInterval=setInterval(()=>{this.autoDial().catch(E=>{log$y.error("error while autodialing",E)})},this.autoDialIntervalMs),this.started=!0}afterStart(){this.autoDial().catch(E=>{log$y.error("error while autodialing",E)})}stop(){this.queue.clear(),clearInterval(this.autoDialInterval),this.started=!1}async autoDial(){if(!this.started)return;const E=this.connectionManager.getConnectionsMap(),ee=E.size,te=new PeerSet(this.connectionManager.getDialQueue().map(oe=>oe.peerId).filter(Boolean));if(ee>=this.minConnections){log$y("have enough connections %d/%d",ee,this.minConnections);return}log$y("not enough connections %d/%d - will dial peers to increase the number of connections",ee,this.minConnections);const re=await this.peerStore.all(),ne=re.filter(oe=>!(oe.addresses.length===0||E.has(oe.id)||te.has(oe.id))).sort(()=>Math.random()>.5?1:-1),ie=new PeerMap;for(const oe of ne)ie.has(oe.id)||ie.set(oe.id,[...oe.tags.values()].reduce((ae,ce)=>ae+ce.value,0));const se=ne.sort((oe,ae)=>{const ce=ie.get(oe.id)??0,le=ie.get(ae.id)??0;return ce>le?-1:ce<le?1:0});log$y("selected %d/%d peers to dial",se.length,re.length);for(const oe of se)this.queue.add(async()=>{const ae=this.connectionManager.getConnectionsMap().size;if(ae>=this.minConnections){log$y("got enough connections now %d/%d",ae,this.minConnections),this.queue.clear();return}log$y("connecting to a peerStore stored peer %p",oe.id),await this.connectionManager.openConnection(oe.id,{priority:this.autoDialPriority})}).catch(ae=>{log$y.error("could not connect to peerStore stored peer",ae)})}}var Netmask_1;(function(){var J,E,ee,te,re,ne,ie,se;se=function(oe){var ae,ce,le,he;return ae=(oe&255<<24)>>>24,ce=(oe&255<<16)>>>16,le=(oe&65280)>>>8,he=oe&255,[ae,ce,le,he].join(".")},ie=function(oe){var ae,ce,le,he,de,ue;for(ae=[],le=he=0;he<=3&&oe.length!==0;le=++he){if(le>0){if(oe[0]!==".")throw new Error("Invalid IP");oe=oe.substring(1)}ue=E(oe),de=ue[0],ce=ue[1],oe=oe.substring(ce),ae.push(de)}if(oe.length!==0)throw new Error("Invalid IP");switch(ae.length){case 1:if(ae[0]>4294967295)throw new Error("Invalid IP");return ae[0]>>>0;case 2:if(ae[0]>255||ae[1]>16777215)throw new Error("Invalid IP");return(ae[0]<<24|ae[1])>>>0;case 3:if(ae[0]>255||ae[1]>255||ae[2]>65535)throw new Error("Invalid IP");return(ae[0]<<24|ae[1]<<16|ae[2])>>>0;case 4:if(ae[0]>255||ae[1]>255||ae[2]>255||ae[3]>255)throw new Error("Invalid IP");return(ae[0]<<24|ae[1]<<16|ae[2]<<8|ae[3])>>>0;default:throw new Error("Invalid IP")}},ee=function(oe){return oe.charCodeAt(0)},te=ee("0"),ne=ee("a"),re=ee("A"),E=function(oe){var ae,ce,le,he,de;for(he=0,ae=10,ce="9",le=0,oe.length>1&&oe[le]==="0"&&(oe[le+1]==="x"||oe[le+1]==="X"?(le+=2,ae=16):"0"<=oe[le+1]&&oe[le+1]<="9"&&(le++,ae=8,ce="7")),de=le;le<oe.length;){if("0"<=oe[le]&&oe[le]<=ce)he=he*ae+(ee(oe[le])-te)>>>0;else if(ae===16)if("a"<=oe[le]&&oe[le]<="f")he=he*ae+(10+ee(oe[le])-ne)>>>0;else if("A"<=oe[le]&&oe[le]<="F")he=he*ae+(10+ee(oe[le])-re)>>>0;else break;else break;if(he>4294967295)throw new Error("too large");le++}if(le===de)throw new Error("empty octet");return[he,le]},J=function(){function oe(ae,ce){var le,he,de;if(typeof ae!="string")throw new Error("Missing `net' parameter");if(ce||(de=ae.split("/",2),ae=de[0],ce=de[1]),ce||(ce=32),typeof ce=="string"&&ce.indexOf(".")>-1){try{this.maskLong=ie(ce)}catch{throw new Error("Invalid mask: "+ce)}for(le=he=32;he>=0;le=--he)if(this.maskLong===4294967295<<32-le>>>0){this.bitmask=le;break}}else if(ce||ce===0)this.bitmask=parseInt(ce,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0);else throw new Error("Invalid mask: empty");try{this.netLong=(ie(ae)&this.maskLong)>>>0}catch{throw new Error("Invalid net address: "+ae)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+ce);this.size=Math.pow(2,32-this.bitmask),this.base=se(this.netLong),this.mask=se(this.maskLong),this.hostmask=se(~this.maskLong),this.first=this.bitmask<=30?se(this.netLong+1):this.base,this.last=this.bitmask<=30?se(this.netLong+this.size-2):se(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?se(this.netLong+this.size-1):void 0}return oe.prototype.contains=function(ae){return typeof ae=="string"&&(ae.indexOf("/")>0||ae.split(".").length!==4)&&(ae=new oe(ae)),ae instanceof oe?this.contains(ae.base)&&this.contains(ae.broadcast||ae.last):(ie(ae)&this.maskLong)>>>0===(this.netLong&this.maskLong)>>>0},oe.prototype.next=function(ae){return ae==null&&(ae=1),new oe(se(this.netLong+this.size*ae),this.mask)},oe.prototype.forEach=function(ae){var ce,le,he;for(he=ie(this.first),le=ie(this.last),ce=0;he<=le;)ae(se(he),he,ce),ce++,he++},oe.prototype.toString=function(){return this.base+"/"+this.bitmask},oe}(),Netmask_1=J}).call(commonjsGlobal);const word="[a-fA-F\\d:]",boundry=J=>J&&J.includeBoundaries?`(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))`:"",v4="(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}",v6segment="[a-fA-F\\d]{1,4}",v6=`
(?:
(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment}:){6}(?:${v4}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment}:){5}(?::${v4}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment}){0,5}:${v4}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm,"").replace(/\n/g,"").trim(),v46Exact=new RegExp(`(?:^${v4}$)|(?:^${v6}$)`),v4exact=new RegExp(`^${v4}$`),v6exact=new RegExp(`^${v6}$`),ipRegex=J=>J&&J.exact?v46Exact:new RegExp(`(?:${boundry(J)}${v4}${boundry(J)})|(?:${boundry(J)}${v6}${boundry(J)})`,"g");ipRegex.v4=J=>J&&J.exact?v4exact:new RegExp(`${boundry(J)}${v4}${boundry(J)}`,"g");ipRegex.v6=J=>J&&J.exact?v6exact:new RegExp(`${boundry(J)}${v6}${boundry(J)}`,"g");var ipaddr$1={exports:{}};(function(J){(function(E){const ee="(0?\\d+|0x[a-f0-9]+)",te={fourOctet:new RegExp(`^${ee}\\.${ee}\\.${ee}\\.${ee}$`,"i"),threeOctet:new RegExp(`^${ee}\\.${ee}\\.${ee}$`,"i"),twoOctet:new RegExp(`^${ee}\\.${ee}$`,"i"),longValue:new RegExp(`^${ee}$`,"i")},re=new RegExp("^0[0-7]+$","i"),ne=new RegExp("^0x[a-f0-9]+$","i"),ie="%[0-9a-z]{1,}",se="(?:[0-9a-f]+::?)+",oe={zoneIndex:new RegExp(ie,"i"),native:new RegExp(`^(::)?(${se})?([0-9a-f]+)?(::)?(${ie})?$`,"i"),deprecatedTransitional:new RegExp(`^(?:::)(${ee}\\.${ee}\\.${ee}\\.${ee}(${ie})?)$`,"i"),transitional:new RegExp(`^((?:${se})|(?:::)(?:${se})?)${ee}\\.${ee}\\.${ee}\\.${ee}(${ie})?$`,"i")};function ae(ue,pe){if(ue.indexOf("::")!==ue.lastIndexOf("::"))return null;let ye=0,me=-1,be=(ue.match(oe.zoneIndex)||[])[0],_e,we;for(be&&(be=be.substring(1),ue=ue.replace(/%.+$/,""));(me=ue.indexOf(":",me+1))>=0;)ye++;if(ue.substr(0,2)==="::"&&ye--,ue.substr(-2,2)==="::"&&ye--,ye>pe)return null;for(we=pe-ye,_e=":";we--;)_e+="0:";return ue=ue.replace("::",_e),ue[0]===":"&&(ue=ue.slice(1)),ue[ue.length-1]===":"&&(ue=ue.slice(0,-1)),pe=function(){const $e=ue.split(":"),ve=[];for(let fe=0;fe<$e.length;fe++)ve.push(parseInt($e[fe],16));return ve}(),{parts:pe,zoneId:be}}function ce(ue,pe,ye,me){if(ue.length!==pe.length)throw new Error("ipaddr: cannot match CIDR for objects with different lengths");let be=0,_e;for(;me>0;){if(_e=ye-me,_e<0&&(_e=0),ue[be]>>_e!==pe[be]>>_e)return!1;me-=ye,be+=1}return!0}function le(ue){if(ne.test(ue))return parseInt(ue,16);if(ue[0]==="0"&&!isNaN(parseInt(ue[1],10))){if(re.test(ue))return parseInt(ue,8);throw new Error(`ipaddr: cannot parse ${ue} as octal`)}return parseInt(ue,10)}function he(ue,pe){for(;ue.length<pe;)ue=`0${ue}`;return ue}const de={};de.IPv4=function(){function ue(pe){if(pe.length!==4)throw new Error("ipaddr: ipv4 octet count should be 4");let ye,me;for(ye=0;ye<pe.length;ye++)if(me=pe[ye],!(0<=me&&me<=255))throw new Error("ipaddr: ipv4 octet should fit in 8 bits");this.octets=pe}return ue.prototype.SpecialRanges={unspecified:[[new ue([0,0,0,0]),8]],broadcast:[[new ue([255,255,255,255]),32]],multicast:[[new ue([224,0,0,0]),4]],linkLocal:[[new ue([169,254,0,0]),16]],loopback:[[new ue([127,0,0,0]),8]],carrierGradeNat:[[new ue([100,64,0,0]),10]],private:[[new ue([10,0,0,0]),8],[new ue([172,16,0,0]),12],[new ue([192,168,0,0]),16]],reserved:[[new ue([192,0,0,0]),24],[new ue([192,0,2,0]),24],[new ue([192,88,99,0]),24],[new ue([198,51,100,0]),24],[new ue([203,0,113,0]),24],[new ue([240,0,0,0]),4]]},ue.prototype.kind=function(){return"ipv4"},ue.prototype.match=function(pe,ye){let me;if(ye===void 0&&(me=pe,pe=me[0],ye=me[1]),pe.kind()!=="ipv4")throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");return ce(this.octets,pe.octets,8,ye)},ue.prototype.prefixLengthFromSubnetMask=function(){let pe=0,ye=!1;const me={0:8,128:7,192:6,224:5,240:4,248:3,252:2,254:1,255:0};let be,_e,we;for(be=3;be>=0;be-=1)if(_e=this.octets[be],_e in me){if(we=me[_e],ye&&we!==0)return null;we!==8&&(ye=!0),pe+=we}else return null;return 32-pe},ue.prototype.range=function(){return de.subnetMatch(this,this.SpecialRanges)},ue.prototype.toByteArray=function(){return this.octets.slice(0)},ue.prototype.toIPv4MappedAddress=function(){return de.IPv6.parse(`::ffff:${this.toString()}`)},ue.prototype.toNormalizedString=function(){return this.toString()},ue.prototype.toString=function(){return this.octets.join(".")},ue}(),de.IPv4.broadcastAddressFromCIDR=function(ue){try{const pe=this.parseCIDR(ue),ye=pe[0].toByteArray(),me=this.subnetMaskFromPrefixLength(pe[1]).toByteArray(),be=[];let _e=0;for(;_e<4;)be.push(parseInt(ye[_e],10)|parseInt(me[_e],10)^255),_e++;return new this(be)}catch{throw new Error("ipaddr: the address does not have IPv4 CIDR format")}},de.IPv4.isIPv4=function(ue){return this.parser(ue)!==null},de.IPv4.isValid=function(ue){try{return new this(this.parser(ue)),!0}catch{return!1}},de.IPv4.isValidFourPartDecimal=function(ue){return!!(de.IPv4.isValid(ue)&&ue.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/))},de.IPv4.networkAddressFromCIDR=function(ue){let pe,ye,me,be,_e;try{for(pe=this.parseCIDR(ue),me=pe[0].toByteArray(),_e=this.subnetMaskFromPrefixLength(pe[1]).toByteArray(),be=[],ye=0;ye<4;)be.push(parseInt(me[ye],10)&parseInt(_e[ye],10)),ye++;return new this(be)}catch{throw new Error("ipaddr: the address does not have IPv4 CIDR format")}},de.IPv4.parse=function(ue){const pe=this.parser(ue);if(pe===null)throw new Error("ipaddr: string is not formatted like an IPv4 Address");return new this(pe)},de.IPv4.parseCIDR=function(ue){let pe;if(pe=ue.match(/^(.+)\/(\d+)$/)){const ye=parseInt(pe[2]);if(ye>=0&&ye<=32){const me=[this.parse(pe[1]),ye];return Object.defineProperty(me,"toString",{value:function(){return this.join("/")}}),me}}throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range")},de.IPv4.parser=function(ue){let pe,ye,me;if(pe=ue.match(te.fourOctet))return function(){const be=pe.slice(1,6),_e=[];for(let we=0;we<be.length;we++)ye=be[we],_e.push(le(ye));return _e}();if(pe=ue.match(te.longValue)){if(me=le(pe[1]),me>4294967295||me<0)throw new Error("ipaddr: address outside defined range");return function(){const be=[];let _e;for(_e=0;_e<=24;_e+=8)be.push(me>>_e&255);return be}().reverse()}else return(pe=ue.match(te.twoOctet))?function(){const be=pe.slice(1,4),_e=[];if(me=le(be[1]),me>16777215||me<0)throw new Error("ipaddr: address outside defined range");return _e.push(le(be[0])),_e.push(me>>16&255),_e.push(me>>8&255),_e.push(me&255),_e}():(pe=ue.match(te.threeOctet))?function(){const be=pe.slice(1,5),_e=[];if(me=le(be[2]),me>65535||me<0)throw new Error("ipaddr: address outside defined range");return _e.push(le(be[0])),_e.push(le(be[1])),_e.push(me>>8&255),_e.push(me&255),_e}():null},de.IPv4.subnetMaskFromPrefixLength=function(ue){if(ue=parseInt(ue),ue<0||ue>32)throw new Error("ipaddr: invalid IPv4 prefix length");const pe=[0,0,0,0];let ye=0;const me=Math.floor(ue/8);for(;ye<me;)pe[ye]=255,ye++;return me<4&&(pe[me]=Math.pow(2,ue%8)-1<<8-ue%8),new this(pe)},de.IPv6=function(){function ue(pe,ye){let me,be;if(pe.length===16)for(this.parts=[],me=0;me<=14;me+=2)this.parts.push(pe[me]<<8|pe[me+1]);else if(pe.length===8)this.parts=pe;else throw new Error("ipaddr: ipv6 part count should be 8 or 16");for(me=0;me<this.parts.length;me++)if(be=this.parts[me],!(0<=be&&be<=65535))throw new Error("ipaddr: ipv6 part should fit in 16 bits");ye&&(this.zoneId=ye)}return ue.prototype.SpecialRanges={unspecified:[new ue([0,0,0,0,0,0,0,0]),128],linkLocal:[new ue([65152,0,0,0,0,0,0,0]),10],multicast:[new ue([65280,0,0,0,0,0,0,0]),8],loopback:[new ue([0,0,0,0,0,0,0,1]),128],uniqueLocal:[new ue([64512,0,0,0,0,0,0,0]),7],ipv4Mapped:[new ue([0,0,0,0,0,65535,0,0]),96],rfc6145:[new ue([0,0,0,0,65535,0,0,0]),96],rfc6052:[new ue([100,65435,0,0,0,0,0,0]),96],"6to4":[new ue([8194,0,0,0,0,0,0,0]),16],teredo:[new ue([8193,0,0,0,0,0,0,0]),32],reserved:[[new ue([8193,3512,0,0,0,0,0,0]),32]]},ue.prototype.isIPv4MappedAddress=function(){return this.range()==="ipv4Mapped"},ue.prototype.kind=function(){return"ipv6"},ue.prototype.match=function(pe,ye){let me;if(ye===void 0&&(me=pe,pe=me[0],ye=me[1]),pe.kind()!=="ipv6")throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");return ce(this.parts,pe.parts,16,ye)},ue.prototype.prefixLengthFromSubnetMask=function(){let pe=0,ye=!1;const me={0:16,32768:15,49152:14,57344:13,61440:12,63488:11,64512:10,65024:9,65280:8,65408:7,65472:6,65504:5,65520:4,65528:3,65532:2,65534:1,65535:0};let be,_e;for(let we=7;we>=0;we-=1)if(be=this.parts[we],be in me){if(_e=me[be],ye&&_e!==0)return null;_e!==16&&(ye=!0),pe+=_e}else return null;return 128-pe},ue.prototype.range=function(){return de.subnetMatch(this,this.SpecialRanges)},ue.prototype.toByteArray=function(){let pe;const ye=[],me=this.parts;for(let be=0;be<me.length;be++)pe=me[be],ye.push(pe>>8),ye.push(pe&255);return ye},ue.prototype.toFixedLengthString=function(){const pe=function(){const me=[];for(let be=0;be<this.parts.length;be++)me.push(he(this.parts[be].toString(16),4));return me}.call(this).join(":");let ye="";return this.zoneId&&(ye=`%${this.zoneId}`),pe+ye},ue.prototype.toIPv4Address=function(){if(!this.isIPv4MappedAddress())throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");const pe=this.parts.slice(-2),ye=pe[0],me=pe[1];return new de.IPv4([ye>>8,ye&255,me>>8,me&255])},ue.prototype.toNormalizedString=function(){const pe=function(){const me=[];for(let be=0;be<this.parts.length;be++)me.push(this.parts[be].toString(16));return me}.call(this).join(":");let ye="";return this.zoneId&&(ye=`%${this.zoneId}`),pe+ye},ue.prototype.toRFC5952String=function(){const pe=/((^|:)(0(:|$)){2,})/g,ye=this.toNormalizedString();let me=0,be=-1,_e;for(;_e=pe.exec(ye);)_e[0].length>be&&(me=_e.index,be=_e[0].length);return be<0?ye:`${ye.substring(0,me)}::${ye.substring(me+be)}`},ue.prototype.toString=function(){return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/,"::")},ue}(),de.IPv6.broadcastAddressFromCIDR=function(ue){try{const pe=this.parseCIDR(ue),ye=pe[0].toByteArray(),me=this.subnetMaskFromPrefixLength(pe[1]).toByteArray(),be=[];let _e=0;for(;_e<16;)be.push(parseInt(ye[_e],10)|parseInt(me[_e],10)^255),_e++;return new this(be)}catch(pe){throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${pe})`)}},de.IPv6.isIPv6=function(ue){return this.parser(ue)!==null},de.IPv6.isValid=function(ue){if(typeof ue=="string"&&ue.indexOf(":")===-1)return!1;try{const pe=this.parser(ue);return new this(pe.parts,pe.zoneId),!0}catch{return!1}},de.IPv6.networkAddressFromCIDR=function(ue){let pe,ye,me,be,_e;try{for(pe=this.parseCIDR(ue),me=pe[0].toByteArray(),_e=this.subnetMaskFromPrefixLength(pe[1]).toByteArray(),be=[],ye=0;ye<16;)be.push(parseInt(me[ye],10)&parseInt(_e[ye],10)),ye++;return new this(be)}catch(we){throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${we})`)}},de.IPv6.parse=function(ue){const pe=this.parser(ue);if(pe.parts===null)throw new Error("ipaddr: string is not formatted like an IPv6 Address");return new this(pe.parts,pe.zoneId)},de.IPv6.parseCIDR=function(ue){let pe,ye,me;if((ye=ue.match(/^(.+)\/(\d+)$/))&&(pe=parseInt(ye[2]),pe>=0&&pe<=128))return me=[this.parse(ye[1]),pe],Object.defineProperty(me,"toString",{value:function(){return this.join("/")}}),me;throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range")},de.IPv6.parser=function(ue){let pe,ye,me,be,_e,we;if(me=ue.match(oe.deprecatedTransitional))return this.parser(`::ffff:${me[1]}`);if(oe.native.test(ue))return ae(ue,8);if((me=ue.match(oe.transitional))&&(we=me[6]||"",pe=ae(me[1].slice(0,-1)+we,6),pe.parts)){for(_e=[parseInt(me[2]),parseInt(me[3]),parseInt(me[4]),parseInt(me[5])],ye=0;ye<_e.length;ye++)if(be=_e[ye],!(0<=be&&be<=255))return null;return pe.parts.push(_e[0]<<8|_e[1]),pe.parts.push(_e[2]<<8|_e[3]),{parts:pe.parts,zoneId:pe.zoneId}}return null},de.IPv6.subnetMaskFromPrefixLength=function(ue){if(ue=parseInt(ue),ue<0||ue>128)throw new Error("ipaddr: invalid IPv6 prefix length");const pe=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];let ye=0;const me=Math.floor(ue/8);for(;ye<me;)pe[ye]=255,ye++;return me<16&&(pe[me]=Math.pow(2,ue%8)-1<<8-ue%8),new this(pe)},de.fromByteArray=function(ue){const pe=ue.length;if(pe===4)return new de.IPv4(ue);if(pe===16)return new de.IPv6(ue);throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address")},de.isValid=function(ue){return de.IPv6.isValid(ue)||de.IPv4.isValid(ue)},de.parse=function(ue){if(de.IPv6.isValid(ue))return de.IPv6.parse(ue);if(de.IPv4.isValid(ue))return de.IPv4.parse(ue);throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format")},de.parseCIDR=function(ue){try{return de.IPv6.parseCIDR(ue)}catch{try{return de.IPv4.parseCIDR(ue)}catch{throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format")}}},de.process=function(ue){const pe=this.parse(ue);return pe.kind()==="ipv6"&&pe.isIPv4MappedAddress()?pe.toIPv4Address():pe},de.subnetMatch=function(ue,pe,ye){let me,be,_e,we;ye==null&&(ye="unicast");for(be in pe)if(Object.prototype.hasOwnProperty.call(pe,be)){for(_e=pe[be],_e[0]&&!(_e[0]instanceof Array)&&(_e=[_e]),me=0;me<_e.length;me++)if(we=_e[me],ue.kind()===we[0].kind()&&ue.match.apply(ue,we))return be}return ye},J.exports?J.exports=de:E.ipaddr=de})(commonjsGlobal)})(ipaddr$1);var ipaddrExports=ipaddr$1.exports;const ipaddr=getDefaultExportFromCjs(ipaddrExports),{isValid:is_valid,parse:parse$1}=ipaddr,PRIVATE_IP_RANGES=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"],NETMASK_RANGES=PRIVATE_IP_RANGES.map(J=>new Netmask_1(J));function ipv4_check(J){for(let E of NETMASK_RANGES)if(E.contains(J))return!0;return!1}function ipv6_check(J){return/^::$/.test(J)||/^::1$/.test(J)||/^::f{4}:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(J)||/^::f{4}:0.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(J)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(J)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(J)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(J)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(J)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(J)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(J)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(J)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(J)||/^ff([0-9a-fA-F]{2,2}):/i.test(J)}const is_ip_private=J=>{if(is_valid(J)){const E=parse$1(J);if(E.kind()==="ipv4")return ipv4_check(E.toNormalizedString());if(E.kind()==="ipv6")return ipv6_check(J)}else if(isIP(J)&&ipRegex.v6().test(J))return ipv6_check(J)};function isPrivate(J){try{const{address:E}=J.nodeAddress();return!!is_ip_private(E)}catch{return!0}}function publicAddressesFirst(J,E){const ee=isPrivate(J.multiaddr),te=isPrivate(E.multiaddr);return ee&&!te?1:!ee&&te||J.isCertified&&!E.isCertified?-1:!J.isCertified&&E.isCertified?1:0}var s$1=1e3,m=s$1*60,h=m*60,d=h*24,w=d*7,y=d*365.25,ms=function(J,E){E=E||{};var ee=typeof J;if(ee==="string"&&J.length>0)return parse(J);if(ee==="number"&&isFinite(J))return E.long?fmtLong(J):fmtShort(J);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(J))};function parse(J){if(J=String(J),!(J.length>100)){var E=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(J);if(E){var ee=parseFloat(E[1]),te=(E[2]||"ms").toLowerCase();switch(te){case"years":case"year":case"yrs":case"yr":case"y":return ee*y;case"weeks":case"week":case"w":return ee*w;case"days":case"day":case"d":return ee*d;case"hours":case"hour":case"hrs":case"hr":case"h":return ee*h;case"minutes":case"minute":case"mins":case"min":case"m":return ee*m;case"seconds":case"second":case"secs":case"sec":case"s":return ee*s$1;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return ee;default:return}}}}function fmtShort(J){var E=Math.abs(J);return E>=d?Math.round(J/d)+"d":E>=h?Math.round(J/h)+"h":E>=m?Math.round(J/m)+"m":E>=s$1?Math.round(J/s$1)+"s":J+"ms"}function fmtLong(J){var E=Math.abs(J);return E>=d?plural(J,E,d,"day"):E>=h?plural(J,E,h,"hour"):E>=m?plural(J,E,m,"minute"):E>=s$1?plural(J,E,s$1,"second"):J+" ms"}function plural(J,E,ee,te){var re=E>=ee*1.5;return Math.round(J/ee)+" "+te+(re?"s":"")}var receptacle=Receptacle,toMS=ms,cache=Receptacle.prototype,counter=new Date%1e9;function getUID(){return(Math.random()*1e9>>>0)+counter++}function Receptacle(J){J=J||{},this.id=J.id||getUID(),this.max=J.max||1/0,this.items=J.items||[],this._lookup={},this.size=this.items.length,this.lastModified=new Date(J.lastModified||new Date);for(var E,ee,te=this.items.length;te--;)E=this.items[te],ee=new Date(E.expires)-new Date,this._lookup[E.key]=E,ee>0?this.expire(E.key,ee):ee<=0&&this.delete(E.key)}cache.has=function(J){return J in this._lookup};cache.get=function(J){if(!this.has(J))return null;var E=this._lookup[J];return E.refresh&&this.expire(J,E.refresh),this.items.splice(this.items.indexOf(E),1),this.items.push(E),E.value};cache.meta=function(J){if(!this.has(J))return null;var E=this._lookup[J];return"meta"in E?E.meta:null};cache.set=function(J,E,ee){var te=this._lookup[J],re=this._lookup[J]={key:J,value:E};return this.lastModified=new Date,te?(clearTimeout(te.timeout),this.items.splice(this.items.indexOf(te),1,re)):(this.size>=this.max&&this.delete(this.items[0].key),this.items.push(re),this.size++),ee&&("ttl"in ee&&this.expire(J,ee.ttl),"meta"in ee&&(re.meta=ee.meta),ee.refresh&&(re.refresh=ee.ttl)),this};cache.delete=function(J){var E=this._lookup[J];return E?(this.lastModified=new Date,this.items.splice(this.items.indexOf(E),1),clearTimeout(E.timeout),delete this._lookup[J],this.size--,this):!1};cache.expire=function(J,E){var ee=E||0,te=this._lookup[J];if(!te)return this;if(typeof ee=="string"&&(ee=toMS(E)),typeof ee!="number")throw new TypeError("Expiration time must be a string or number.");return clearTimeout(te.timeout),te.timeout=setTimeout(this.delete.bind(this,te.key),ee),te.expires=Number(new Date)+ee,this};cache.clear=function(){for(var J=this.items.length;J--;)this.delete(this.items[J].key);return this};cache.toJSON=function(){for(var J=new Array(this.items.length),E,ee=J.length;ee--;)E=this.items[ee],J[ee]={key:E.key,meta:E.meta,value:E.value,expires:E.expires,refresh:E.refresh};return{id:this.id,max:isFinite(this.max)?this.max:void 0,lastModified:this.lastModified,items:J}};const Receptacle$1=getDefaultExportFromCjs(receptacle),globalFetch=globalThis.fetch,globalHeaders=globalThis.Headers;function buildResource(J,E,ee){return`${J}?name=${E}&type=${ee}`}async function request(J,E){return await(await globalFetch(J,{headers:new globalHeaders({accept:"application/dns-json"}),signal:E})).json()}function getCacheKey(J,E){return`${E}_${J}`}const log$x=Object.assign(debug("dns-over-http-resolver"),{error:debug("dns-over-http-resolver:error")});class Resolver{constructor(E={}){this._cache=new Receptacle$1({max:E?.maxCache??100}),this._TXTcache=new Receptacle$1({max:E?.maxCache??100}),this._servers=["https://cloudflare-dns.com/dns-query","https://dns.google/resolve"],this._request=E.request??request,this._abortControllers=[]}cancel(){this._abortControllers.forEach(E=>E.abort())}getServers(){return this._servers}_getShuffledServers(){const E=[...this._servers];for(let ee=E.length-1;ee>0;ee--){const te=Math.floor(Math.random()*ee),re=E[ee];E[ee]=E[te],E[te]=re}return E}setServers(E){this._servers=E}async resolve(E,ee="A"){switch(ee){case"A":return await this.resolve4(E);case"AAAA":return await this.resolve6(E);case"TXT":return await this.resolveTxt(E);default:throw new Error(`${ee} is not supported`)}}async resolve4(E){const ee="A",te=this._cache.get(getCacheKey(E,ee));if(te!=null)return te;let re=!1;for(const ne of this._getShuffledServers()){const ie=new AbortController;this._abortControllers.push(ie);try{const se=await this._request(buildResource(ne,E,ee),ie.signal),oe=se.Answer.map(ce=>ce.data),ae=Math.min(...se.Answer.map(ce=>ce.TTL));return this._cache.set(getCacheKey(E,ee),oe,{ttl:ae}),oe}catch{ie.signal.aborted&&(re=!0),log$x.error(`${ne} could not resolve ${E} record ${ee}`)}finally{this._abortControllers=this._abortControllers.filter(se=>se!==ie)}}throw re?Object.assign(new Error("queryA ECANCELLED"),{code:"ECANCELLED"}):new Error(`Could not resolve ${E} record ${ee}`)}async resolve6(E){const ee="AAAA",te=this._cache.get(getCacheKey(E,ee));if(te!=null)return te;let re=!1;for(const ne of this._getShuffledServers()){const ie=new AbortController;this._abortControllers.push(ie);try{const se=await this._request(buildResource(ne,E,ee),ie.signal),oe=se.Answer.map(ce=>ce.data),ae=Math.min(...se.Answer.map(ce=>ce.TTL));return this._cache.set(getCacheKey(E,ee),oe,{ttl:ae}),oe}catch{ie.signal.aborted&&(re=!0),log$x.error(`${ne} could not resolve ${E} record ${ee}`)}finally{this._abortControllers=this._abortControllers.filter(se=>se!==ie)}}throw re?Object.assign(new Error("queryAaaa ECANCELLED"),{code:"ECANCELLED"}):new Error(`Could not resolve ${E} record ${ee}`)}async resolveTxt(E){const ee="TXT",te=this._TXTcache.get(getCacheKey(E,ee));if(te!=null)return te;let re=!1;for(const ne of this._getShuffledServers()){const ie=new AbortController;this._abortControllers.push(ie);try{const se=await this._request(buildResource(ne,E,ee),ie.signal),oe=se.Answer.map(ce=>[ce.data.replace(/['"]+/g,"")]),ae=Math.min(...se.Answer.map(ce=>ce.TTL));return this._TXTcache.set(getCacheKey(E,ee),oe,{ttl:ae}),oe}catch{ie.signal.aborted&&(re=!0),log$x.error(`${ne} could not resolve ${E} record ${ee}`)}finally{this._abortControllers=this._abortControllers.filter(se=>se!==ie)}}throw re?Object.assign(new Error("queryTxt ECANCELLED"),{code:"ECANCELLED"}):new Error(`Could not resolve ${E} record ${ee}`)}clearCache(){this._cache.clear(),this._TXTcache.clear()}}const{code:dnsaddrCode}=getProtocol("dnsaddr");async function dnsaddrResolver(J,E={}){const ee=new Resolver;E.signal!=null&&E.signal.addEventListener("abort",()=>{ee.cancel()});const te=J.getPeerId(),[,re]=J.stringTuples().find(([ie])=>ie===dnsaddrCode)??[];if(re==null)throw new Error("No hostname found in multiaddr");let ne=(await ee.resolveTxt(`_dnsaddr.${re}`)).flat().map(ie=>ie.split("=")[1]).filter(Boolean);return te!=null&&(ne=ne.filter(ie=>ie.includes(te))),ne}function anySignal(J){const E=new globalThis.AbortController;function ee(){E.abort();for(const ne of J)ne?.removeEventListener!=null&&ne.removeEventListener("abort",ee)}for(const ne of J){if(ne?.aborted===!0){ee();break}ne?.addEventListener!=null&&ne.addEventListener("abort",ee)}function te(){for(const ne of J)ne?.removeEventListener!=null&&ne.removeEventListener("abort",ee)}const re=E.signal;return re.clear=te,re}var domain;function EventHandlers(){}EventHandlers.prototype=Object.create(null);function EventEmitter$1(){EventEmitter$1.init.call(this)}function setMaxListeners(J,...E){if(typeof J!="number"||J<0||isNaN(J))throw new TypeError('"n" argument must be a positive number');if(E.length===0)EventEmitter$1.defaultMaxListeners=J;else for(let ee=0;ee<E.length;ee++){const te=E[ee];if(typeof te.setMaxListeners=="function")te.setMaxListeners(J);else throw new TypeError('"eventTargets" must be instances of "EventEmitter"')}}EventEmitter$1.setMaxListeners=setMaxListeners;EventEmitter$1.EventEmitter=EventEmitter$1;EventEmitter$1.usingDomains=!1;EventEmitter$1.prototype.domain=void 0;EventEmitter$1.prototype._events=void 0;EventEmitter$1.prototype._maxListeners=void 0;EventEmitter$1.defaultMaxListeners=10;EventEmitter$1.init=function(){this.domain=null,EventEmitter$1.usingDomains&&domain.active,(!this._events||this._events===Object.getPrototypeOf(this)._events)&&(this._events=new EventHandlers,this._eventsCount=0),this._maxListeners=this._maxListeners||void 0};EventEmitter$1.prototype.setMaxListeners=function(J){if(typeof J!="number"||J<0||isNaN(J))throw new TypeError('"n" argument must be a positive number');return this._maxListeners=J,this};function $getMaxListeners(J){return J._maxListeners===void 0?EventEmitter$1.defaultMaxListeners:J._maxListeners}EventEmitter$1.prototype.getMaxListeners=function(){return $getMaxListeners(this)};function emitNone(J,E,ee){if(E)J.call(ee);else for(var te=J.length,re=arrayClone(J,te),ne=0;ne<te;++ne)re[ne].call(ee)}function emitOne(J,E,ee,te){if(E)J.call(ee,te);else for(var re=J.length,ne=arrayClone(J,re),ie=0;ie<re;++ie)ne[ie].call(ee,te)}function emitTwo(J,E,ee,te,re){if(E)J.call(ee,te,re);else for(var ne=J.length,ie=arrayClone(J,ne),se=0;se<ne;++se)ie[se].call(ee,te,re)}function emitThree(J,E,ee,te,re,ne){if(E)J.call(ee,te,re,ne);else for(var ie=J.length,se=arrayClone(J,ie),oe=0;oe<ie;++oe)se[oe].call(ee,te,re,ne)}function emitMany(J,E,ee,te){if(E)J.apply(ee,te);else for(var re=J.length,ne=arrayClone(J,re),ie=0;ie<re;++ie)ne[ie].apply(ee,te)}EventEmitter$1.prototype.emit=function(J){var E,ee,te,re,ne,ie,se,oe=J==="error";if(ie=this._events,ie)oe=oe&&ie.error==null;else if(!oe)return!1;if(se=this.domain,oe){if(E=arguments[1],se)E||(E=new Error('Uncaught, unspecified "error" event')),E.domainEmitter=this,E.domain=se,E.domainThrown=!1,se.emit("error",E);else{if(E instanceof Error)throw E;var ae=new Error('Uncaught, unspecified "error" event. ('+E+")");throw ae.context=E,ae}return!1}if(ee=ie[J],!ee)return!1;var ce=typeof ee=="function";switch(te=arguments.length,te){case 1:emitNone(ee,ce,this);break;case 2:emitOne(ee,ce,this,arguments[1]);break;case 3:emitTwo(ee,ce,this,arguments[1],arguments[2]);break;case 4:emitThree(ee,ce,this,arguments[1],arguments[2],arguments[3]);break;default:for(re=new Array(te-1),ne=1;ne<te;ne++)re[ne-1]=arguments[ne];emitMany(ee,ce,this,re)}return!0};function _addListener(J,E,ee,te){var re,ne,ie;if(typeof ee!="function")throw new TypeError('"listener" argument must be a function');if(ne=J._events,ne?(ne.newListener&&(J.emit("newListener",E,ee.listener?ee.listener:ee),ne=J._events),ie=ne[E]):(ne=J._events=new EventHandlers,J._eventsCount=0),!ie)ie=ne[E]=ee,++J._eventsCount;else if(typeof ie=="function"?ie=ne[E]=te?[ee,ie]:[ie,ee]:te?ie.unshift(ee):ie.push(ee),!ie.warned&&(re=$getMaxListeners(J),re&&re>0&&ie.length>re)){ie.warned=!0;var se=new Error("Possible EventEmitter memory leak detected. "+ie.length+" "+E+" listeners added. Use emitter.setMaxListeners() to increase limit");se.name="MaxListenersExceededWarning",se.emitter=J,se.type=E,se.count=ie.length,emitWarning(se)}return J}function emitWarning(J){typeof console.warn=="function"?console.warn(J):console.log(J)}EventEmitter$1.prototype.addListener=function(J,E){return _addListener(this,J,E,!1)};EventEmitter$1.prototype.on=EventEmitter$1.prototype.addListener;EventEmitter$1.prototype.prependListener=function(J,E){return _addListener(this,J,E,!0)};function _onceWrap(J,E,ee){var te=!1;function re(){J.removeListener(E,re),te||(te=!0,ee.apply(J,arguments))}return re.listener=ee,re}EventEmitter$1.prototype.once=function(J,E){if(typeof E!="function")throw new TypeError('"listener" argument must be a function');return this.on(J,_onceWrap(this,J,E)),this};EventEmitter$1.prototype.prependOnceListener=function(J,E){if(typeof E!="function")throw new TypeError('"listener" argument must be a function');return this.prependListener(J,_onceWrap(this,J,E)),this};EventEmitter$1.prototype.removeListener=function(J,E){var ee,te,re,ne,ie;if(typeof E!="function")throw new TypeError('"listener" argument must be a function');if(te=this._events,!te)return this;if(ee=te[J],!ee)return this;if(ee===E||ee.listener&&ee.listener===E)--this._eventsCount===0?this._events=new EventHandlers:(delete te[J],te.removeListener&&this.emit("removeListener",J,ee.listener||E));else if(typeof ee!="function"){for(re=-1,ne=ee.length;ne-- >0;)if(ee[ne]===E||ee[ne].listener&&ee[ne].listener===E){ie=ee[ne].listener,re=ne;break}if(re<0)return this;if(ee.length===1){if(ee[0]=void 0,--this._eventsCount===0)return this._events=new EventHandlers,this;delete te[J]}else spliceOne(ee,re);te.removeListener&&this.emit("removeListener",J,ie||E)}return this};EventEmitter$1.prototype.removeAllListeners=function(J){var E,ee;if(ee=this._events,!ee)return this;if(!ee.removeListener)return arguments.length===0?(this._events=new EventHandlers,this._eventsCount=0):ee[J]&&(--this._eventsCount===0?this._events=new EventHandlers:delete ee[J]),this;if(arguments.length===0){for(var te=Object.keys(ee),re=0,ne;re<te.length;++re)ne=te[re],ne!=="removeListener"&&this.removeAllListeners(ne);return this.removeAllListeners("removeListener"),this._events=new EventHandlers,this._eventsCount=0,this}if(E=ee[J],typeof E=="function")this.removeListener(J,E);else if(E)do this.removeListener(J,E[E.length-1]);while(E[0]);return this};EventEmitter$1.prototype.listeners=function(J){var E,ee,te=this._events;return te?(E=te[J],E?typeof E=="function"?ee=[E.listener||E]:ee=unwrapListeners(E):ee=[]):ee=[],ee};EventEmitter$1.listenerCount=function(J,E){return typeof J.listenerCount=="function"?J.listenerCount(E):listenerCount.call(J,E)};EventEmitter$1.prototype.listenerCount=listenerCount;function listenerCount(J){var E=this._events;if(E){var ee=E[J];if(typeof ee=="function")return 1;if(ee)return ee.length}return 0}EventEmitter$1.prototype.eventNames=function(){return this._eventsCount>0?Reflect.ownKeys(this._events):[]};function spliceOne(J,E){for(var ee=E,te=ee+1,re=J.length;te<re;ee+=1,te+=1)J[ee]=J[te];J.pop()}function arrayClone(J,E){for(var ee=new Array(E);E--;)ee[E]=J[E];return ee}function unwrapListeners(J){for(var E=new Array(J.length),ee=0;ee<E.length;++ee)E[ee]=J[ee].listener||J[ee];return E}const log$w=logger("libp2p:connection-manager:utils");async function resolveMultiaddrs(J,E){if(!J.protoNames().includes("dnsaddr"))return[J];const ee=await resolveRecord(J,E),te=(await Promise.all(ee.map(async re=>await resolveMultiaddrs(re,E)))).flat().reduce((re,ne)=>(re.find(ie=>ie.equals(ne))==null&&re.push(ne),re),[]);return log$w("resolved %s to",J,te.map(re=>re.toString())),te}async function resolveRecord(J,E){try{return J=multiaddr(J.toString()),await J.resolve(E)}catch(ee){return log$w.error(`multiaddr ${J.toString()} could not be resolved`,ee),[]}}function combineSignals(...J){const E=[];for(const te of J)if(te!=null){try{setMaxListeners?.(1/0,te)}catch{}E.push(te)}const ee=anySignal(E);try{setMaxListeners?.(1/0,ee)}catch{}return ee}function pDefer(){const J={};return J.promise=new Promise((E,ee)=>{J.resolve=E,J.reject=ee}),J}const log$v=logger("libp2p:connection-manager:dial-queue"),defaultOptions$5={addressSorter:publicAddressesFirst,maxParallelDials:MAX_PARALLEL_DIALS,maxPeerAddrsToDial:MAX_PEER_ADDRS_TO_DIAL,maxParallelDialsPerPeer:MAX_PARALLEL_DIALS_PER_PEER,dialTimeout:DIAL_TIMEOUT,resolvers:{dnsaddr:dnsaddrResolver}};class DialQueue{constructor(E,ee={}){this.addressSorter=ee.addressSorter??defaultOptions$5.addressSorter,this.maxPeerAddrsToDial=ee.maxPeerAddrsToDial??defaultOptions$5.maxPeerAddrsToDial,this.maxParallelDialsPerPeer=ee.maxParallelDialsPerPeer??defaultOptions$5.maxParallelDialsPerPeer,this.dialTimeout=ee.dialTimeout??defaultOptions$5.dialTimeout,this.peerId=E.peerId,this.peerStore=E.peerStore,this.connectionGater=E.connectionGater,this.transportManager=E.transportManager,this.shutDownController=new AbortController;try{setMaxListeners?.(1/0,this.shutDownController.signal)}catch{}this.pendingDialCount=E.metrics?.registerMetric("libp2p_dialler_pending_dials"),this.inProgressDialCount=E.metrics?.registerMetric("libp2p_dialler_in_progress_dials"),this.pendingDials=[];for(const[te,re]of Object.entries(ee.resolvers??{}))resolvers.set(te,re);this.queue=new PQueue({concurrency:ee.maxParallelDials??defaultOptions$5.maxParallelDials}),this.queue.on("add",()=>{this.pendingDialCount?.update(this.queue.size),this.inProgressDialCount?.update(this.queue.pending)}),this.queue.on("active",()=>{this.pendingDialCount?.update(this.queue.size),this.inProgressDialCount?.update(this.queue.pending)}),this.queue.on("completed",()=>{this.pendingDialCount?.update(this.queue.size),this.inProgressDialCount?.update(this.queue.pending)}),this.queue.on("error",te=>{log$v.error("error in dial queue",te),this.pendingDialCount?.update(this.queue.size),this.inProgressDialCount?.update(this.queue.pending)}),this.queue.on("empty",()=>{this.pendingDialCount?.update(this.queue.size),this.inProgressDialCount?.update(this.queue.pending)}),this.queue.on("idle",()=>{this.pendingDialCount?.update(this.queue.size),this.inProgressDialCount?.update(this.queue.pending)})}stop(){this.shutDownController.abort()}async dial(E,ee={}){const{peerId:te,multiaddrs:re}=getPeerAddress(E),ne=re.map(ce=>({multiaddr:ce,isCertified:!1})),ie=this.createDialAbortControllers(ee.signal);let se;try{se=await this.calculateMultiaddrs(te,ne,{...ee,signal:ie})}catch(ce){throw ie.clear(),ce}const oe=this.pendingDials.find(ce=>!!(ce.peerId!=null&&te!=null&&ce.peerId.equals(te)||se.map(({multiaddr:le})=>le.toString()).join()===ce.multiaddrs.map(le=>le.toString()).join()));if(oe!=null)return log$v("joining existing dial target for %p",te),ie.clear(),await oe.promise;log$v("creating dial target for",se.map(({multiaddr:ce})=>ce.toString()));const ae={id:randomId(),status:"queued",peerId:te,multiaddrs:se.map(({multiaddr:ce})=>ce)};return ae.promise=this.performDial(ae,{...ee,signal:ie}).finally(()=>{this.pendingDials=this.pendingDials.filter(ce=>ce.id!==ae.id),ie.clear()}).catch(ce=>{throw log$v.error("dial failed to %s",ae.multiaddrs.map(le=>le.toString()).join(", "),ce),ie.aborted?new CodeError(ce.message,codes$6.ERR_TIMEOUT):ce}),this.pendingDials.push(ae),await ae.promise}createDialAbortControllers(E){const ee=anySignal([AbortSignal.timeout(this.dialTimeout),this.shutDownController.signal,E]);try{setMaxListeners?.(1/0,ee)}catch{}return ee}async calculateMultiaddrs(E,ee=[],te={}){if(E!=null){if(this.peerId.equals(E))throw new CodeError("Tried to dial self",codes$6.ERR_DIALED_SELF);if(await this.connectionGater.denyDialPeer?.(E)===!0)throw new CodeError("The dial request is blocked by gater.allowDialPeer",codes$6.ERR_PEER_DIAL_INTERCEPTED);if(ee.length===0){log$v("loading multiaddrs for %p",E);try{const ce=await this.peerStore.get(E);ee.push(...ce.addresses),log$v("loaded multiaddrs for %p",E,ee.map(({multiaddr:le})=>le.toString()))}catch(ce){if(ce.code!==codes$6.ERR_NOT_FOUND)throw ce}}}const re=(await Promise.all(ee.map(async ce=>{const le=await resolveMultiaddrs(ce.multiaddr,te);return le.length===1&&le[0].equals(ce.multiaddr)?ce:le.map(he=>({multiaddr:he,isCertified:!1}))}))).flat(),ne=re.filter(ce=>!!this.transportManager.transportForMultiaddr(ce.multiaddr)),ie=new Map;for(const ce of ne){const le=ce.multiaddr.toString(),he=ie.get(le);if(he!=null){he.isCertified=he.isCertified||ce.isCertified||!1;continue}ie.set(le,ce)}let se=[...ie.values()];if((se.length===0||se.length>this.maxPeerAddrsToDial)&&(log$v("addresses for %p before filtering",E??"unknown peer",re.map(({multiaddr:ce})=>ce.toString())),log$v("addresses for %p after filtering",E??"unknown peer",se.map(({multiaddr:ce})=>ce.toString()))),se.length===0)throw new CodeError("The dial request has no valid addresses",codes$6.ERR_NO_VALID_ADDRESSES);if(se.length>this.maxPeerAddrsToDial)throw new CodeError("dial with more addresses than allowed",codes$6.ERR_TOO_MANY_ADDRESSES);if(E!=null){const ce=`/p2p/${E.toString()}`;se=se.map(le=>{const he=le.multiaddr.getPeerId();return le.multiaddr.protos().pop()?.path===!0?le:he!==E.toString()?{multiaddr:le.multiaddr.encapsulate(ce),isCertified:le.isCertified}:le})}const oe=[];for(const ce of se)this.connectionGater.denyDialMultiaddr!=null&&await this.connectionGater.denyDialMultiaddr(ce.multiaddr)||oe.push(ce);const ae=oe.sort(this.addressSorter);if(ae.length===0)throw new CodeError("The connection gater denied all addresses in the dial request",codes$6.ERR_NO_VALID_ADDRESSES);return ae}async performDial(E,ee={}){const te=E.multiaddrs.map(()=>new AbortController);try{const re=new PQueue({concurrency:this.maxParallelDialsPerPeer});re.on("error",ie=>{log$v.error("error dialling",ie)});const ne=await Promise.any(E.multiaddrs.map(async(ie,se)=>{const oe=te[se];if(oe==null)throw new CodeError("dialAction did not come with an AbortController",codes$6.ERR_INVALID_PARAMETERS);const ae=combineSignals(oe.signal,ee.signal);ae.addEventListener("abort",()=>{log$v("dial to %s aborted",ie)});const ce=pDefer();return await re.add(async()=>{if(ae.aborted){log$v("dial to %s was aborted before reaching the head of the peer dial queue",ie),ce.reject(new AbortError$5);return}await this.queue.add(async()=>{try{if(ae.aborted){log$v("dial to %s was aborted before reaching the head of the dial queue",ie),ce.reject(new AbortError$5);return}E.status="active";const le=await this.transportManager.dial(ie,{...ee,signal:ae});if(oe.signal.aborted){log$v("multiple dials succeeded, closing superfluous connection"),le.close().catch(he=>{log$v.error("error closing superfluous connection",he)}),ce.reject(new AbortError$5);return}te[se]=void 0,te.forEach(he=>{he!==void 0&&he.abort()}),log$v("dial to %s succeeded",ie),ce.resolve(le)}catch(le){log$v.error("error during dial of %s",ie,le),ce.reject(le)}},{...ee,signal:ae}).catch(le=>{ce.reject(le)})},{signal:ae}).catch(le=>{ce.reject(le)}).finally(()=>{ae.clear()}),await ce.promise}));if(ne==null)throw new CodeError("successful dial led to empty object returned from peer dial queue",codes$6.ERR_TRANSPORT_DIAL_FAILED);return E.status="success",ne}catch(re){throw E.status="error",E.multiaddrs.length===1&&re.name==="AggregateError"?re.errors[0]:re}}}function randomId(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}const log$u=logger("libp2p:connection-manager:connection-pruner"),defaultOptions$4={maxConnections:MAX_CONNECTIONS,allow:[]};class ConnectionPruner{constructor(E,ee={}){this.maxConnections=ee.maxConnections??defaultOptions$4.maxConnections,this.allow=ee.allow??defaultOptions$4.allow,this.connectionManager=E.connectionManager,this.peerStore=E.peerStore,this.events=E.events,E.events.addEventListener("connection:open",()=>{this.maybePruneConnections().catch(te=>{log$u.error(te)})})}async maybePruneConnections(){const E=this.connectionManager.getConnections(),ee=E.length,te=Math.max(ee-this.maxConnections,0);if(log$u("checking max connections limit %d/%d",ee,this.maxConnections),ee<=this.maxConnections)return;log$u("max connections limit exceeded %d/%d, pruning %d connection(s)",ee,this.maxConnections,te);const re=new PeerMap;for(const se of E){const oe=se.remotePeer;if(!re.has(oe)){re.set(oe,0);try{const ae=await this.peerStore.get(oe);re.set(oe,[...ae.tags.values()].reduce((ce,le)=>ce+le.value,0))}catch(ae){ae.code!=="ERR_NOT_FOUND"&&log$u.error("error loading peer tags",ae)}}}const ne=E.sort((se,oe)=>{const ae=re.get(se.remotePeer)??0,ce=re.get(oe.remotePeer)??0;if(ae>ce)return 1;if(ae<ce)return-1;const le=se.stat.timeline.open,he=oe.stat.timeline.open;return le<he?1:le>he?-1:0}),ie=[];for(const se of ne)if(log$u("too many connections open - closing a connection to %p",se.remotePeer),this.allow.some(oe=>se.remoteAddr.toString().startsWith(oe.toString()))||ie.push(se),ie.length===te)break;await Promise.all(ie.map(async se=>{try{await se.close()}catch(oe){log$u.error(oe)}})),this.events.safeDispatchEvent("connection:prune",{detail:ie})}}const log$t=logger("libp2p:connection-manager"),DEFAULT_DIAL_PRIORITY=50,defaultOptions$3={minConnections:MIN_CONNECTIONS,maxConnections:MAX_CONNECTIONS,inboundConnectionThreshold:INBOUND_CONNECTION_THRESHOLD,maxIncomingPendingConnections:MAX_INCOMING_PENDING_CONNECTIONS,autoDialConcurrency:AUTO_DIAL_CONCURRENCY,autoDialPriority:AUTO_DIAL_PRIORITY};class DefaultConnectionManager{constructor(E,ee={}){this.maxConnections=ee.maxConnections??defaultOptions$3.maxConnections;const te=ee.minConnections??defaultOptions$3.minConnections;if(this.maxConnections<te)throw new CodeError("Connection Manager maxConnections must be greater than minConnections",codes$6.ERR_INVALID_PARAMETERS);this.connections=new PeerMap,this.started=!1,this.peerStore=E.peerStore,this.metrics=E.metrics,this.events=E.events,this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),this.allow=(ee.allow??[]).map(re=>multiaddr(re)),this.deny=(ee.deny??[]).map(re=>multiaddr(re)),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=ee.maxIncomingPendingConnections??defaultOptions$3.maxIncomingPendingConnections,this.inboundConnectionRateLimiter=new rateLimiterFlexible.RateLimiterMemory({points:ee.inboundConnectionThreshold??defaultOptions$3.inboundConnectionThreshold,duration:1}),this.autoDial=new AutoDial({connectionManager:this,peerStore:E.peerStore,events:E.events},{minConnections:te,autoDialConcurrency:ee.autoDialConcurrency??defaultOptions$3.autoDialConcurrency,autoDialPriority:ee.autoDialPriority??defaultOptions$3.autoDialPriority}),this.connectionPruner=new ConnectionPruner({connectionManager:this,peerStore:E.peerStore,events:E.events},{maxConnections:this.maxConnections,allow:this.allow}),this.dialQueue=new DialQueue({peerId:E.peerId,metrics:E.metrics,peerStore:E.peerStore,transportManager:E.transportManager,connectionGater:E.connectionGater},{addressSorter:ee.addressSorter??publicAddressesFirst,maxParallelDials:ee.maxParallelDials??MAX_PARALLEL_DIALS,maxPeerAddrsToDial:ee.maxPeerAddrsToDial??MAX_PEER_ADDRS_TO_DIAL,dialTimeout:ee.dialTimeout??DIAL_TIMEOUT,resolvers:ee.resolvers??{dnsaddr:dnsaddrResolver}})}isStarted(){return this.started}async start(){this.metrics?.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const E={inbound:0,outbound:0};for(const ee of this.connections.values())for(const te of ee)te.stat.direction==="inbound"?E.inbound++:E.outbound++;return E}}),this.metrics?.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const E={};for(const ee of this.connections.values())for(const te of ee)for(const re of te.streams){const ne=`${re.stat.direction} ${re.stat.protocol??"unnegotiated"}`;E[ne]=(E[ne]??0)+1}return E}}),this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const E={};for(const te of this.connections.values())for(const re of te){const ne={};for(const ie of re.streams){const se=`${ie.stat.direction} ${ie.stat.protocol??"unnegotiated"}`;ne[se]=(ne[se]??0)+1}for(const[ie,se]of Object.entries(ne))E[ie]=E[ie]??[],E[ie].push(se)}const ee={};for(let[te,re]of Object.entries(E)){re=re.sort((ie,se)=>ie-se);const ne=Math.floor(re.length*.9);ee[te]=re[ne]}return ee}}),this.autoDial.start(),this.started=!0,log$t("started")}async afterStart(){Promise.resolve().then(async()=>{const E=[];for(const ee of await this.peerStore.all())ee.tags.has(KEEP_ALIVE)&&E.push(ee.id);await Promise.all(E.map(async ee=>{await this.openConnection(ee).catch(te=>{log$t.error(te)})}))}).catch(E=>{log$t.error(E)}),this.autoDial.afterStart()}async stop(){this.dialQueue.stop(),this.autoDial.stop();const E=[];for(const ee of this.connections.values())for(const te of ee)E.push((async()=>{try{await te.close()}catch(re){log$t.error(re)}})());log$t("closing %d connections",E.length),await Promise.all(E),this.connections.clear(),log$t("stopped")}onConnect(E){this._onConnect(E).catch(ee=>{log$t.error(ee)})}async _onConnect(E){const{detail:ee}=E;if(!this.started){await ee.close();return}const te=ee.remotePeer,re=this.connections.get(te);let ne=!1;re!=null?re.push(ee):(ne=!0,this.connections.set(te,[ee])),te.publicKey!=null&&te.type==="RSA"&&await this.peerStore.patch(te,{publicKey:te.publicKey}),ne&&this.events.safeDispatchEvent("peer:connect",{detail:ee.remotePeer})}onDisconnect(E){const{detail:ee}=E;if(!this.started)return;const te=ee.remotePeer;let re=this.connections.get(te);re!=null&&re.length>1?(re=re.filter(ne=>ne.id!==ee.id),this.connections.set(te,re)):re!=null&&(this.connections.delete(te),this.events.safeDispatchEvent("peer:disconnect",{detail:ee.remotePeer}))}getConnections(E){if(E!=null)return this.connections.get(E)??[];let ee=[];for(const te of this.connections.values())ee=ee.concat(te);return ee}getConnectionsMap(){return this.connections}async openConnection(E,ee={}){if(!this.isStarted())throw new CodeError("Not started",codes$6.ERR_NODE_NOT_STARTED);const{peerId:te}=getPeerAddress(E);if(te!=null){log$t("dial %p",te);const se=this.getConnections(te);if(se.length>0)return log$t("had an existing connection to %p",te),se[0]}const re=await this.dialQueue.dial(E,{...ee,priority:ee.priority??DEFAULT_DIAL_PRIORITY});let ne=this.connections.get(re.remotePeer);ne==null&&(ne=[],this.connections.set(re.remotePeer,ne));let ie=!1;for(const se of ne)se.id===re.id&&(ie=!0);return ie||ne.push(re),re}async closeConnections(E){const ee=this.connections.get(E)??[];await Promise.all(ee.map(async te=>{await te.close()}))}async acceptIncomingConnection(E){if(this.deny.some(ee=>E.remoteAddr.toString().startsWith(ee.toString())))return log$t("connection from %s refused - connection remote address was in deny list",E.remoteAddr),!1;if(this.allow.some(ee=>E.remoteAddr.toString().startsWith(ee.toString())))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return log$t("connection from %s refused - incomingPendingConnections exceeded by peer %s",E.remoteAddr),!1;if(E.remoteAddr.isThinWaistAddress()){const ee=E.remoteAddr.nodeAddress().address;try{await this.inboundConnectionRateLimiter.consume(ee,1)}catch{return log$t("connection from %s refused - inboundConnectionThreshold exceeded by host %s",ee,E.remoteAddr),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(log$t("connection from %s refused - maxConnections exceeded",E.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){return this.dialQueue.pendingDials}}function isHighSurrogate$1(J){return J>=55296&&J<=56319}function isLowSurrogate$1(J){return J>=56320&&J<=57343}var truncate$2=function(J,E,ee){if(typeof E!="string")throw new Error("Input must be string");for(var te=E.length,re=0,ne,ie,se=0;se<te;se+=1){if(ne=E.charCodeAt(se),ie=E[se],isHighSurrogate$1(ne)&&isLowSurrogate$1(E.charCodeAt(se+1))&&(se+=1,ie+=E[se]),re+=J(ie),re===ee)return E.slice(0,se+1);if(re>ee)return E.slice(0,se-ie.length+1)}return E};function isHighSurrogate(J){return J>=55296&&J<=56319}function isLowSurrogate(J){return J>=56320&&J<=57343}var browser$2=function(J){if(typeof J!="string")throw new Error("Input must be string");for(var E=J.length,ee=0,te=null,re=null,ne=0;ne<E;ne++)te=J.charCodeAt(ne),isLowSurrogate(te)?re!=null&&isHighSurrogate(re)?ee+=1:ee+=3:te<=127?ee+=1:te>=128&&te<=2047?ee+=2:te>=2048&&te<=65535&&(ee+=3),re=te;return ee},truncate$1=truncate$2,getLength=browser$2,browser$1=truncate$1.bind(null,getLength),truncate=browser$1,illegalRe=/[\/\?<>\\:\*\|"]/g,controlRe=/[\x00-\x1f\x80-\x9f]/g,reservedRe=/^\.+$/,windowsReservedRe=/^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i,windowsTrailingRe=/[\. ]+$/;function sanitize(J,E){if(typeof J!="string")throw new Error("Input must be string");var ee=J.replace(illegalRe,E).replace(controlRe,E).replace(reservedRe,E).replace(windowsReservedRe,E).replace(windowsTrailingRe,E);return truncate(ee,255)}var sanitizeFilename=function(J,E){var ee=E&&E.replacement||"",te=sanitize(J,ee);return ee===""?te:sanitize(te,"")};const sanitize$1=getDefaultExportFromCjs(sanitizeFilename);var isPlainObj=J=>{if(Object.prototype.toString.call(J)!=="[object Object]")return!1;const E=Object.getPrototypeOf(J);return E===null||E===Object.prototype};const isOptionObject=isPlainObj,{hasOwnProperty}=Object.prototype,{propertyIsEnumerable}=Object,defineProperty=(J,E,ee)=>Object.defineProperty(J,E,{value:ee,writable:!0,enumerable:!0,configurable:!0}),globalThis$1=commonjsGlobal,defaultMergeOptions={concatArrays:!1,ignoreUndefined:!1},getEnumerableOwnPropertyKeys=J=>{const E=[];for(const ee in J)hasOwnProperty.call(J,ee)&&E.push(ee);if(Object.getOwnPropertySymbols){const ee=Object.getOwnPropertySymbols(J);for(const te of ee)propertyIsEnumerable.call(J,te)&&E.push(te)}return E};function clone(J){return Array.isArray(J)?cloneArray(J):isOptionObject(J)?cloneOptionObject(J):J}function cloneArray(J){const E=J.slice(0,0);return getEnumerableOwnPropertyKeys(J).forEach(ee=>{defineProperty(E,ee,clone(J[ee]))}),E}function cloneOptionObject(J){const E=Object.getPrototypeOf(J)===null?Object.create(null):{};return getEnumerableOwnPropertyKeys(J).forEach(ee=>{defineProperty(E,ee,clone(J[ee]))}),E}const mergeKeys=(J,E,ee,te)=>(ee.forEach(re=>{typeof E[re]>"u"&&te.ignoreUndefined||(re in J&&J[re]!==Object.getPrototypeOf(J)?defineProperty(J,re,merge(J[re],E[re],te)):defineProperty(J,re,clone(E[re])))}),J),concatArrays=(J,E,ee)=>{let te=J.slice(0,0),re=0;return[J,E].forEach(ne=>{const ie=[];for(let se=0;se<ne.length;se++)hasOwnProperty.call(ne,se)&&(ie.push(String(se)),ne===J?defineProperty(te,re++,ne[se]):defineProperty(te,re++,clone(ne[se])));te=mergeKeys(te,ne,getEnumerableOwnPropertyKeys(ne).filter(se=>!ie.includes(se)),ee)}),te};function merge(J,E,ee){return ee.concatArrays&&Array.isArray(J)&&Array.isArray(E)?concatArrays(J,E,ee):!isOptionObject(E)||!isOptionObject(J)?clone(E):mergeKeys(J,E,getEnumerableOwnPropertyKeys(E),ee)}var mergeOptions=function(...J){const E=merge(clone(defaultMergeOptions),this!==globalThis$1&&this||{},defaultMergeOptions);let ee={_:{}};for(const te of J)if(te!==void 0){if(!isOptionObject(te))throw new TypeError("`"+te+"` is not an Option Object");ee=merge(ee,{_:te},E)}return ee._};const mergeOptions$1=getDefaultExportFromCjs(mergeOptions);var codes$5;(function(J){J.ERR_INVALID_PARAMETERS="ERR_INVALID_PARAMETERS",J.ERR_INVALID_KEY_NAME="ERR_INVALID_KEY_NAME",J.ERR_INVALID_KEY_TYPE="ERR_INVALID_KEY_TYPE",J.ERR_KEY_ALREADY_EXISTS="ERR_KEY_ALREADY_EXISTS",J.ERR_INVALID_KEY_SIZE="ERR_INVALID_KEY_SIZE",J.ERR_KEY_NOT_FOUND="ERR_KEY_NOT_FOUND",J.ERR_OLD_KEY_NAME_INVALID="ERR_OLD_KEY_NAME_INVALID",J.ERR_NEW_KEY_NAME_INVALID="ERR_NEW_KEY_NAME_INVALID",J.ERR_PASSWORD_REQUIRED="ERR_PASSWORD_REQUIRED",J.ERR_PEM_REQUIRED="ERR_PEM_REQUIRED",J.ERR_CANNOT_READ_KEY="ERR_CANNOT_READ_KEY",J.ERR_MISSING_PRIVATE_KEY="ERR_MISSING_PRIVATE_KEY",J.ERR_INVALID_OLD_PASS_TYPE="ERR_INVALID_OLD_PASS_TYPE",J.ERR_INVALID_NEW_PASS_TYPE="ERR_INVALID_NEW_PASS_TYPE",J.ERR_INVALID_PASS_LENGTH="ERR_INVALID_PASS_LENGTH"})(codes$5||(codes$5={}));var forge$m={options:{usePureJavaScript:!1}};const forge$n=getDefaultExportFromCjs(forge$m);var util$8={exports:{}},api={},baseN$1=api,_reverseAlphabets={};api.encode=function(J,E,ee){if(typeof E!="string")throw new TypeError('"alphabet" must be a string.');if(ee!==void 0&&typeof ee!="number")throw new TypeError('"maxline" must be a number.');var te="";if(!(J instanceof Uint8Array))te=_encodeWithByteBuffer(J,E);else{var re=0,ne=E.length,ie=E.charAt(0),se=[0];for(re=0;re<J.length;++re){for(var oe=0,ae=J[re];oe<se.length;++oe)ae+=se[oe]<<8,se[oe]=ae%ne,ae=ae/ne|0;for(;ae>0;)se.push(ae%ne),ae=ae/ne|0}for(re=0;J[re]===0&&re<J.length-1;++re)te+=ie;for(re=se.length-1;re>=0;--re)te+=E[se[re]]}if(ee){var ce=new RegExp(".{1,"+ee+"}","g");te=te.match(ce).join(`\r
`)}return te};api.decode=function(J,E){if(typeof J!="string")throw new TypeError('"input" must be a string.');if(typeof E!="string")throw new TypeError('"alphabet" must be a string.');var ee=_reverseAlphabets[E];if(!ee){ee=_reverseAlphabets[E]=[];for(var te=0;te<E.length;++te)ee[E.charCodeAt(te)]=te}J=J.replace(/\s/g,"");for(var re=E.length,ne=E.charAt(0),ie=[0],te=0;te<J.length;te++){var se=ee[J.charCodeAt(te)];if(se===void 0)return;for(var oe=0,ae=se;oe<ie.length;++oe)ae+=ie[oe]*re,ie[oe]=ae&255,ae>>=8;for(;ae>0;)ie.push(ae&255),ae>>=8}for(var ce=0;J[ce]===ne&&ce<J.length-1;++ce)ie.push(0);return typeof Buffer<"u"?Buffer.from(ie.reverse()):new Uint8Array(ie.reverse())};function _encodeWithByteBuffer(J,E){var ee=0,te=E.length,re=E.charAt(0),ne=[0];for(ee=0;ee<J.length();++ee){for(var ie=0,se=J.at(ee);ie<ne.length;++ie)se+=ne[ie]<<8,ne[ie]=se%te,se=se/te|0;for(;se>0;)ne.push(se%te),se=se/te|0}var oe="";for(ee=0;J.at(ee)===0&&ee<J.length()-1;++ee)oe+=re;for(ee=ne.length-1;ee>=0;--ee)oe+=E[ne[ee]];return oe}var forge$l=forge$m,baseN=baseN$1,util$7=util$8.exports=forge$l.util=forge$l.util||{};(function(){if(typeof process<"u"&&process.nextTick&&!process.browser){util$7.nextTick=process.nextTick,typeof setImmediate=="function"?util$7.setImmediate=setImmediate:util$7.setImmediate=util$7.nextTick;return}if(typeof setImmediate=="function"){util$7.setImmediate=function(){return setImmediate.apply(void 0,arguments)},util$7.nextTick=function(ie){return setImmediate(ie)};return}if(util$7.setImmediate=function(ie){setTimeout(ie,0)},typeof window<"u"&&typeof window.postMessage=="function"){let ie=function(se){if(se.source===window&&se.data===J){se.stopPropagation();var oe=E.slice();E.length=0,oe.forEach(function(ae){ae()})}};var J="forge.setImmediate",E=[];util$7.setImmediate=function(se){E.push(se),E.length===1&&window.postMessage(J,"*")},window.addEventListener("message",ie,!0)}if(typeof MutationObserver<"u"){var ee=Date.now(),te=!0,re=document.createElement("div"),E=[];new MutationObserver(function(){var se=E.slice();E.length=0,se.forEach(function(oe){oe()})}).observe(re,{attributes:!0});var ne=util$7.setImmediate;util$7.setImmediate=function(se){Date.now()-ee>15?(ee=Date.now(),ne(se)):(E.push(se),E.length===1&&re.setAttribute("a",te=!te))}}util$7.nextTick=util$7.setImmediate})();util$7.isNodejs=typeof process<"u"&&process.versions&&process.versions.node;util$7.globalScope=function(){return util$7.isNodejs?commonjsGlobal:typeof self>"u"?window:self}();util$7.isArray=Array.isArray||function(J){return Object.prototype.toString.call(J)==="[object Array]"};util$7.isArrayBuffer=function(J){return typeof ArrayBuffer<"u"&&J instanceof ArrayBuffer};util$7.isArrayBufferView=function(J){return J&&util$7.isArrayBuffer(J.buffer)&&J.byteLength!==void 0};function _checkBitsParam(J){if(!(J===8||J===16||J===24||J===32))throw new Error("Only 8, 16, 24, or 32 bits supported: "+J)}util$7.ByteBuffer=ByteStringBuffer;function ByteStringBuffer(J){if(this.data="",this.read=0,typeof J=="string")this.data=J;else if(util$7.isArrayBuffer(J)||util$7.isArrayBufferView(J))if(typeof Buffer<"u"&&J instanceof Buffer)this.data=J.toString("binary");else{var E=new Uint8Array(J);try{this.data=String.fromCharCode.apply(null,E)}catch{for(var ee=0;ee<E.length;++ee)this.putByte(E[ee])}}else(J instanceof ByteStringBuffer||typeof J=="object"&&typeof J.data=="string"&&typeof J.read=="number")&&(this.data=J.data,this.read=J.read);this._constructedStringLength=0}util$7.ByteStringBuffer=ByteStringBuffer;var _MAX_CONSTRUCTED_STRING_LENGTH=4096;util$7.ByteStringBuffer.prototype._optimizeConstructedString=function(J){this._constructedStringLength+=J,this._constructedStringLength>_MAX_CONSTRUCTED_STRING_LENGTH&&(this.data.substr(0,1),this._constructedStringLength=0)};util$7.ByteStringBuffer.prototype.length=function(){return this.data.length-this.read};util$7.ByteStringBuffer.prototype.isEmpty=function(){return this.length()<=0};util$7.ByteStringBuffer.prototype.putByte=function(J){return this.putBytes(String.fromCharCode(J))};util$7.ByteStringBuffer.prototype.fillWithByte=function(J,E){J=String.fromCharCode(J);for(var ee=this.data;E>0;)E&1&&(ee+=J),E>>>=1,E>0&&(J+=J);return this.data=ee,this._optimizeConstructedString(E),this};util$7.ByteStringBuffer.prototype.putBytes=function(J){return this.data+=J,this._optimizeConstructedString(J.length),this};util$7.ByteStringBuffer.prototype.putString=function(J){return this.putBytes(util$7.encodeUtf8(J))};util$7.ByteStringBuffer.prototype.putInt16=function(J){return this.putBytes(String.fromCharCode(J>>8&255)+String.fromCharCode(J&255))};util$7.ByteStringBuffer.prototype.putInt24=function(J){return this.putBytes(String.fromCharCode(J>>16&255)+String.fromCharCode(J>>8&255)+String.fromCharCode(J&255))};util$7.ByteStringBuffer.prototype.putInt32=function(J){return this.putBytes(String.fromCharCode(J>>24&255)+String.fromCharCode(J>>16&255)+String.fromCharCode(J>>8&255)+String.fromCharCode(J&255))};util$7.ByteStringBuffer.prototype.putInt16Le=function(J){return this.putBytes(String.fromCharCode(J&255)+String.fromCharCode(J>>8&255))};util$7.ByteStringBuffer.prototype.putInt24Le=function(J){return this.putBytes(String.fromCharCode(J&255)+String.fromCharCode(J>>8&255)+String.fromCharCode(J>>16&255))};util$7.ByteStringBuffer.prototype.putInt32Le=function(J){return this.putBytes(String.fromCharCode(J&255)+String.fromCharCode(J>>8&255)+String.fromCharCode(J>>16&255)+String.fromCharCode(J>>24&255))};util$7.ByteStringBuffer.prototype.putInt=function(J,E){_checkBitsParam(E);var ee="";do E-=8,ee+=String.fromCharCode(J>>E&255);while(E>0);return this.putBytes(ee)};util$7.ByteStringBuffer.prototype.putSignedInt=function(J,E){return J<0&&(J+=2<<E-1),this.putInt(J,E)};util$7.ByteStringBuffer.prototype.putBuffer=function(J){return this.putBytes(J.getBytes())};util$7.ByteStringBuffer.prototype.getByte=function(){return this.data.charCodeAt(this.read++)};util$7.ByteStringBuffer.prototype.getInt16=function(){var J=this.data.charCodeAt(this.read)<<8^this.data.charCodeAt(this.read+1);return this.read+=2,J};util$7.ByteStringBuffer.prototype.getInt24=function(){var J=this.data.charCodeAt(this.read)<<16^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2);return this.read+=3,J};util$7.ByteStringBuffer.prototype.getInt32=function(){var J=this.data.charCodeAt(this.read)<<24^this.data.charCodeAt(this.read+1)<<16^this.data.charCodeAt(this.read+2)<<8^this.data.charCodeAt(this.read+3);return this.read+=4,J};util$7.ByteStringBuffer.prototype.getInt16Le=function(){var J=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8;return this.read+=2,J};util$7.ByteStringBuffer.prototype.getInt24Le=function(){var J=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2)<<16;return this.read+=3,J};util$7.ByteStringBuffer.prototype.getInt32Le=function(){var J=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2)<<16^this.data.charCodeAt(this.read+3)<<24;return this.read+=4,J};util$7.ByteStringBuffer.prototype.getInt=function(J){_checkBitsParam(J);var E=0;do E=(E<<8)+this.data.charCodeAt(this.read++),J-=8;while(J>0);return E};util$7.ByteStringBuffer.prototype.getSignedInt=function(J){var E=this.getInt(J),ee=2<<J-2;return E>=ee&&(E-=ee<<1),E};util$7.ByteStringBuffer.prototype.getBytes=function(J){var E;return J?(J=Math.min(this.length(),J),E=this.data.slice(this.read,this.read+J),this.read+=J):J===0?E="":(E=this.read===0?this.data:this.data.slice(this.read),this.clear()),E};util$7.ByteStringBuffer.prototype.bytes=function(J){return typeof J>"u"?this.data.slice(this.read):this.data.slice(this.read,this.read+J)};util$7.ByteStringBuffer.prototype.at=function(J){return this.data.charCodeAt(this.read+J)};util$7.ByteStringBuffer.prototype.setAt=function(J,E){return this.data=this.data.substr(0,this.read+J)+String.fromCharCode(E)+this.data.substr(this.read+J+1),this};util$7.ByteStringBuffer.prototype.last=function(){return this.data.charCodeAt(this.data.length-1)};util$7.ByteStringBuffer.prototype.copy=function(){var J=util$7.createBuffer(this.data);return J.read=this.read,J};util$7.ByteStringBuffer.prototype.compact=function(){return this.read>0&&(this.data=this.data.slice(this.read),this.read=0),this};util$7.ByteStringBuffer.prototype.clear=function(){return this.data="",this.read=0,this};util$7.ByteStringBuffer.prototype.truncate=function(J){var E=Math.max(0,this.length()-J);return this.data=this.data.substr(this.read,E),this.read=0,this};util$7.ByteStringBuffer.prototype.toHex=function(){for(var J="",E=this.read;E<this.data.length;++E){var ee=this.data.charCodeAt(E);ee<16&&(J+="0"),J+=ee.toString(16)}return J};util$7.ByteStringBuffer.prototype.toString=function(){return util$7.decodeUtf8(this.bytes())};function DataBuffer(J,E){E=E||{},this.read=E.readOffset||0,this.growSize=E.growSize||1024;var ee=util$7.isArrayBuffer(J),te=util$7.isArrayBufferView(J);if(ee||te){ee?this.data=new DataView(J):this.data=new DataView(J.buffer,J.byteOffset,J.byteLength),this.write="writeOffset"in E?E.writeOffset:this.data.byteLength;return}this.data=new DataView(new ArrayBuffer(0)),this.write=0,J!=null&&this.putBytes(J),"writeOffset"in E&&(this.write=E.writeOffset)}util$7.DataBuffer=DataBuffer;util$7.DataBuffer.prototype.length=function(){return this.write-this.read};util$7.DataBuffer.prototype.isEmpty=function(){return this.length()<=0};util$7.DataBuffer.prototype.accommodate=function(J,E){if(this.length()>=J)return this;E=Math.max(E||this.growSize,J);var ee=new Uint8Array(this.data.buffer,this.data.byteOffset,this.data.byteLength),te=new Uint8Array(this.length()+E);return te.set(ee),this.data=new DataView(te.buffer),this};util$7.DataBuffer.prototype.putByte=function(J){return this.accommodate(1),this.data.setUint8(this.write++,J),this};util$7.DataBuffer.prototype.fillWithByte=function(J,E){this.accommodate(E);for(var ee=0;ee<E;++ee)this.data.setUint8(J);return this};util$7.DataBuffer.prototype.putBytes=function(J,E){if(util$7.isArrayBufferView(J)){var ee=new Uint8Array(J.buffer,J.byteOffset,J.byteLength),te=ee.byteLength-ee.byteOffset;this.accommodate(te);var re=new Uint8Array(this.data.buffer,this.write);return re.set(ee),this.write+=te,this}if(util$7.isArrayBuffer(J)){var ee=new Uint8Array(J);this.accommodate(ee.byteLength);var re=new Uint8Array(this.data.buffer);return re.set(ee,this.write),this.write+=ee.byteLength,this}if(J instanceof util$7.DataBuffer||typeof J=="object"&&typeof J.read=="number"&&typeof J.write=="number"&&util$7.isArrayBufferView(J.data)){var ee=new Uint8Array(J.data.byteLength,J.read,J.length());this.accommodate(ee.byteLength);var re=new Uint8Array(J.data.byteLength,this.write);return re.set(ee),this.write+=ee.byteLength,this}if(J instanceof util$7.ByteStringBuffer&&(J=J.data,E="binary"),E=E||"binary",typeof J=="string"){var ne;if(E==="hex")return this.accommodate(Math.ceil(J.length/2)),ne=new Uint8Array(this.data.buffer,this.write),this.write+=util$7.binary.hex.decode(J,ne,this.write),this;if(E==="base64")return this.accommodate(Math.ceil(J.length/4)*3),ne=new Uint8Array(this.data.buffer,this.write),this.write+=util$7.binary.base64.decode(J,ne,this.write),this;if(E==="utf8"&&(J=util$7.encodeUtf8(J),E="binary"),E==="binary"||E==="raw")return this.accommodate(J.length),ne=new Uint8Array(this.data.buffer,this.write),this.write+=util$7.binary.raw.decode(ne),this;if(E==="utf16")return this.accommodate(J.length*2),ne=new Uint16Array(this.data.buffer,this.write),this.write+=util$7.text.utf16.encode(ne),this;throw new Error("Invalid encoding: "+E)}throw Error("Invalid parameter: "+J)};util$7.DataBuffer.prototype.putBuffer=function(J){return this.putBytes(J),J.clear(),this};util$7.DataBuffer.prototype.putString=function(J){return this.putBytes(J,"utf16")};util$7.DataBuffer.prototype.putInt16=function(J){return this.accommodate(2),this.data.setInt16(this.write,J),this.write+=2,this};util$7.DataBuffer.prototype.putInt24=function(J){return this.accommodate(3),this.data.setInt16(this.write,J>>8&65535),this.data.setInt8(this.write,J>>16&255),this.write+=3,this};util$7.DataBuffer.prototype.putInt32=function(J){return this.accommodate(4),this.data.setInt32(this.write,J),this.write+=4,this};util$7.DataBuffer.prototype.putInt16Le=function(J){return this.accommodate(2),this.data.setInt16(this.write,J,!0),this.write+=2,this};util$7.DataBuffer.prototype.putInt24Le=function(J){return this.accommodate(3),this.data.setInt8(this.write,J>>16&255),this.data.setInt16(this.write,J>>8&65535,!0),this.write+=3,this};util$7.DataBuffer.prototype.putInt32Le=function(J){return this.accommodate(4),this.data.setInt32(this.write,J,!0),this.write+=4,this};util$7.DataBuffer.prototype.putInt=function(J,E){_checkBitsParam(E),this.accommodate(E/8);do E-=8,this.data.setInt8(this.write++,J>>E&255);while(E>0);return this};util$7.DataBuffer.prototype.putSignedInt=function(J,E){return _checkBitsParam(E),this.accommodate(E/8),J<0&&(J+=2<<E-1),this.putInt(J,E)};util$7.DataBuffer.prototype.getByte=function(){return this.data.getInt8(this.read++)};util$7.DataBuffer.prototype.getInt16=function(){var J=this.data.getInt16(this.read);return this.read+=2,J};util$7.DataBuffer.prototype.getInt24=function(){var J=this.data.getInt16(this.read)<<8^this.data.getInt8(this.read+2);return this.read+=3,J};util$7.DataBuffer.prototype.getInt32=function(){var J=this.data.getInt32(this.read);return this.read+=4,J};util$7.DataBuffer.prototype.getInt16Le=function(){var J=this.data.getInt16(this.read,!0);return this.read+=2,J};util$7.DataBuffer.prototype.getInt24Le=function(){var J=this.data.getInt8(this.read)^this.data.getInt16(this.read+1,!0)<<8;return this.read+=3,J};util$7.DataBuffer.prototype.getInt32Le=function(){var J=this.data.getInt32(this.read,!0);return this.read+=4,J};util$7.DataBuffer.prototype.getInt=function(J){_checkBitsParam(J);var E=0;do E=(E<<8)+this.data.getInt8(this.read++),J-=8;while(J>0);return E};util$7.DataBuffer.prototype.getSignedInt=function(J){var E=this.getInt(J),ee=2<<J-2;return E>=ee&&(E-=ee<<1),E};util$7.DataBuffer.prototype.getBytes=function(J){var E;return J?(J=Math.min(this.length(),J),E=this.data.slice(this.read,this.read+J),this.read+=J):J===0?E="":(E=this.read===0?this.data:this.data.slice(this.read),this.clear()),E};util$7.DataBuffer.prototype.bytes=function(J){return typeof J>"u"?this.data.slice(this.read):this.data.slice(this.read,this.read+J)};util$7.DataBuffer.prototype.at=function(J){return this.data.getUint8(this.read+J)};util$7.DataBuffer.prototype.setAt=function(J,E){return this.data.setUint8(J,E),this};util$7.DataBuffer.prototype.last=function(){return this.data.getUint8(this.write-1)};util$7.DataBuffer.prototype.copy=function(){return new util$7.DataBuffer(this)};util$7.DataBuffer.prototype.compact=function(){if(this.read>0){var J=new Uint8Array(this.data.buffer,this.read),E=new Uint8Array(J.byteLength);E.set(J),this.data=new DataView(E),this.write-=this.read,this.read=0}return this};util$7.DataBuffer.prototype.clear=function(){return this.data=new DataView(new ArrayBuffer(0)),this.read=this.write=0,this};util$7.DataBuffer.prototype.truncate=function(J){return this.write=Math.max(0,this.length()-J),this.read=Math.min(this.read,this.write),this};util$7.DataBuffer.prototype.toHex=function(){for(var J="",E=this.read;E<this.data.byteLength;++E){var ee=this.data.getUint8(E);ee<16&&(J+="0"),J+=ee.toString(16)}return J};util$7.DataBuffer.prototype.toString=function(J){var E=new Uint8Array(this.data,this.read,this.length());if(J=J||"utf8",J==="binary"||J==="raw")return util$7.binary.raw.encode(E);if(J==="hex")return util$7.binary.hex.encode(E);if(J==="base64")return util$7.binary.base64.encode(E);if(J==="utf8")return util$7.text.utf8.decode(E);if(J==="utf16")return util$7.text.utf16.decode(E);throw new Error("Invalid encoding: "+J)};util$7.createBuffer=function(J,E){return E=E||"raw",J!==void 0&&E==="utf8"&&(J=util$7.encodeUtf8(J)),new util$7.ByteBuffer(J)};util$7.fillString=function(J,E){for(var ee="";E>0;)E&1&&(ee+=J),E>>>=1,E>0&&(J+=J);return ee};util$7.xorBytes=function(J,E,ee){for(var te="",re="",ne="",ie=0,se=0;ee>0;--ee,++ie)re=J.charCodeAt(ie)^E.charCodeAt(ie),se>=10&&(te+=ne,ne="",se=0),ne+=String.fromCharCode(re),++se;return te+=ne,te};util$7.hexToBytes=function(J){var E="",ee=0;for(J.length&!0&&(ee=1,E+=String.fromCharCode(parseInt(J[0],16)));ee<J.length;ee+=2)E+=String.fromCharCode(parseInt(J.substr(ee,2),16));return E};util$7.bytesToHex=function(J){return util$7.createBuffer(J).toHex()};util$7.int32ToBytes=function(J){return String.fromCharCode(J>>24&255)+String.fromCharCode(J>>16&255)+String.fromCharCode(J>>8&255)+String.fromCharCode(J&255)};var _base64="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",_base64Idx=[62,-1,-1,-1,63,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,64,-1,-1,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,-1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51],_base58="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";util$7.encode64=function(J,E){for(var ee="",te="",re,ne,ie,se=0;se<J.length;)re=J.charCodeAt(se++),ne=J.charCodeAt(se++),ie=J.charCodeAt(se++),ee+=_base64.charAt(re>>2),ee+=_base64.charAt((re&3)<<4|ne>>4),isNaN(ne)?ee+="==":(ee+=_base64.charAt((ne&15)<<2|ie>>6),ee+=isNaN(ie)?"=":_base64.charAt(ie&63)),E&&ee.length>E&&(te+=ee.substr(0,E)+`\r
`,ee=ee.substr(E));return te+=ee,te};util$7.decode64=function(J){J=J.replace(/[^A-Za-z0-9\+\/\=]/g,"");for(var E="",ee,te,re,ne,ie=0;ie<J.length;)ee=_base64Idx[J.charCodeAt(ie++)-43],te=_base64Idx[J.charCodeAt(ie++)-43],re=_base64Idx[J.charCodeAt(ie++)-43],ne=_base64Idx[J.charCodeAt(ie++)-43],E+=String.fromCharCode(ee<<2|te>>4),re!==64&&(E+=String.fromCharCode((te&15)<<4|re>>2),ne!==64&&(E+=String.fromCharCode((re&3)<<6|ne)));return E};util$7.encodeUtf8=function(J){return unescape(encodeURIComponent(J))};util$7.decodeUtf8=function(J){return decodeURIComponent(escape(J))};util$7.binary={raw:{},hex:{},base64:{},base58:{},baseN:{encode:baseN.encode,decode:baseN.decode}};util$7.binary.raw.encode=function(J){return String.fromCharCode.apply(null,J)};util$7.binary.raw.decode=function(J,E,ee){var te=E;te||(te=new Uint8Array(J.length)),ee=ee||0;for(var re=ee,ne=0;ne<J.length;++ne)te[re++]=J.charCodeAt(ne);return E?re-ee:te};util$7.binary.hex.encode=util$7.bytesToHex;util$7.binary.hex.decode=function(J,E,ee){var te=E;te||(te=new Uint8Array(Math.ceil(J.length/2))),ee=ee||0;var re=0,ne=ee;for(J.length&1&&(re=1,te[ne++]=parseInt(J[0],16));re<J.length;re+=2)te[ne++]=parseInt(J.substr(re,2),16);return E?ne-ee:te};util$7.binary.base64.encode=function(J,E){for(var ee="",te="",re,ne,ie,se=0;se<J.byteLength;)re=J[se++],ne=J[se++],ie=J[se++],ee+=_base64.charAt(re>>2),ee+=_base64.charAt((re&3)<<4|ne>>4),isNaN(ne)?ee+="==":(ee+=_base64.charAt((ne&15)<<2|ie>>6),ee+=isNaN(ie)?"=":_base64.charAt(ie&63)),E&&ee.length>E&&(te+=ee.substr(0,E)+`\r
`,ee=ee.substr(E));return te+=ee,te};util$7.binary.base64.decode=function(J,E,ee){var te=E;te||(te=new Uint8Array(Math.ceil(J.length/4)*3)),J=J.replace(/[^A-Za-z0-9\+\/\=]/g,""),ee=ee||0;for(var re,ne,ie,se,oe=0,ae=ee;oe<J.length;)re=_base64Idx[J.charCodeAt(oe++)-43],ne=_base64Idx[J.charCodeAt(oe++)-43],ie=_base64Idx[J.charCodeAt(oe++)-43],se=_base64Idx[J.charCodeAt(oe++)-43],te[ae++]=re<<2|ne>>4,ie!==64&&(te[ae++]=(ne&15)<<4|ie>>2,se!==64&&(te[ae++]=(ie&3)<<6|se));return E?ae-ee:te.subarray(0,ae)};util$7.binary.base58.encode=function(J,E){return util$7.binary.baseN.encode(J,_base58,E)};util$7.binary.base58.decode=function(J,E){return util$7.binary.baseN.decode(J,_base58,E)};util$7.text={utf8:{},utf16:{}};util$7.text.utf8.encode=function(J,E,ee){J=util$7.encodeUtf8(J);var te=E;te||(te=new Uint8Array(J.length)),ee=ee||0;for(var re=ee,ne=0;ne<J.length;++ne)te[re++]=J.charCodeAt(ne);return E?re-ee:te};util$7.text.utf8.decode=function(J){return util$7.decodeUtf8(String.fromCharCode.apply(null,J))};util$7.text.utf16.encode=function(J,E,ee){var te=E;te||(te=new Uint8Array(J.length*2));var re=new Uint16Array(te.buffer);ee=ee||0;for(var ne=ee,ie=ee,se=0;se<J.length;++se)re[ie++]=J.charCodeAt(se),ne+=2;return E?ne-ee:te};util$7.text.utf16.decode=function(J){return String.fromCharCode.apply(null,new Uint16Array(J.buffer))};util$7.deflate=function(J,E,ee){if(E=util$7.decode64(J.deflate(util$7.encode64(E)).rval),ee){var te=2,re=E.charCodeAt(1);re&32&&(te=6),E=E.substring(te,E.length-4)}return E};util$7.inflate=function(J,E,ee){var te=J.inflate(util$7.encode64(E)).rval;return te===null?null:util$7.decode64(te)};var _setStorageObject=function(J,E,ee){if(!J)throw new Error("WebStorage not available.");var te;if(ee===null?te=J.removeItem(E):(ee=util$7.encode64(JSON.stringify(ee)),te=J.setItem(E,ee)),typeof te<"u"&&te.rval!==!0){var re=new Error(te.error.message);throw re.id=te.error.id,re.name=te.error.name,re}},_getStorageObject=function(J,E){if(!J)throw new Error("WebStorage not available.");var ee=J.getItem(E);if(J.init)if(ee.rval===null){if(ee.error){var te=new Error(ee.error.message);throw te.id=ee.error.id,te.name=ee.error.name,te}ee=null}else ee=ee.rval;return ee!==null&&(ee=JSON.parse(util$7.decode64(ee))),ee},_setItem=function(J,E,ee,te){var re=_getStorageObject(J,E);re===null&&(re={}),re[ee]=te,_setStorageObject(J,E,re)},_getItem=function(J,E,ee){var te=_getStorageObject(J,E);return te!==null&&(te=ee in te?te[ee]:null),te},_removeItem=function(J,E,ee){var te=_getStorageObject(J,E);if(te!==null&&ee in te){delete te[ee];var re=!0;for(var ne in te){re=!1;break}re&&(te=null),_setStorageObject(J,E,te)}},_clearItems=function(J,E){_setStorageObject(J,E,null)},_callStorageFunction=function(J,E,ee){var te=null;typeof ee>"u"&&(ee=["web","flash"]);var re,ne=!1,ie=null;for(var se in ee){re=ee[se];try{if(re==="flash"||re==="both"){if(E[0]===null)throw new Error("Flash local storage not available.");te=J.apply(this,E),ne=re==="flash"}(re==="web"||re==="both")&&(E[0]=localStorage,te=J.apply(this,E),ne=!0)}catch(oe){ie=oe}if(ne)break}if(!ne)throw ie;return te};util$7.setItem=function(J,E,ee,te,re){_callStorageFunction(_setItem,arguments,re)};util$7.getItem=function(J,E,ee,te){return _callStorageFunction(_getItem,arguments,te)};util$7.removeItem=function(J,E,ee,te){_callStorageFunction(_removeItem,arguments,te)};util$7.clearItems=function(J,E,ee){_callStorageFunction(_clearItems,arguments,ee)};util$7.isEmpty=function(J){for(var E in J)if(J.hasOwnProperty(E))return!1;return!0};util$7.format=function(J){for(var E=/%./g,ee,te,re=0,ne=[],ie=0;ee=E.exec(J);){te=J.substring(ie,E.lastIndex-2),te.length>0&&ne.push(te),ie=E.lastIndex;var se=ee[0][1];switch(se){case"s":case"o":re<arguments.length?ne.push(arguments[re+++1]):ne.push("<?>");break;case"%":ne.push("%");break;default:ne.push("<%"+se+"?>")}}return ne.push(J.substring(ie)),ne.join("")};util$7.formatNumber=function(J,E,ee,te){var re=J,ne=isNaN(E=Math.abs(E))?2:E,ie=ee===void 0?",":ee,se=te===void 0?".":te,oe=re<0?"-":"",ae=parseInt(re=Math.abs(+re||0).toFixed(ne),10)+"",ce=ae.length>3?ae.length%3:0;return oe+(ce?ae.substr(0,ce)+se:"")+ae.substr(ce).replace(/(\d{3})(?=\d)/g,"$1"+se)+(ne?ie+Math.abs(re-ae).toFixed(ne).slice(2):"")};util$7.formatSize=function(J){return J>=1073741824?J=util$7.formatNumber(J/1073741824,2,".","")+" GiB":J>=1048576?J=util$7.formatNumber(J/1048576,2,".","")+" MiB":J>=1024?J=util$7.formatNumber(J/1024,0)+" KiB":J=util$7.formatNumber(J,0)+" bytes",J};util$7.bytesFromIP=function(J){return J.indexOf(".")!==-1?util$7.bytesFromIPv4(J):J.indexOf(":")!==-1?util$7.bytesFromIPv6(J):null};util$7.bytesFromIPv4=function(J){if(J=J.split("."),J.length!==4)return null;for(var E=util$7.createBuffer(),ee=0;ee<J.length;++ee){var te=parseInt(J[ee],10);if(isNaN(te))return null;E.putByte(te)}return E.getBytes()};util$7.bytesFromIPv6=function(J){var E=0;J=J.split(":").filter(function(ie){return ie.length===0&&++E,!0});for(var ee=(8-J.length+E)*2,te=util$7.createBuffer(),re=0;re<8;++re){if(!J[re]||J[re].length===0){te.fillWithByte(0,ee),ee=0;continue}var ne=util$7.hexToBytes(J[re]);ne.length<2&&te.putByte(0),te.putBytes(ne)}return te.getBytes()};util$7.bytesToIP=function(J){return J.length===4?util$7.bytesToIPv4(J):J.length===16?util$7.bytesToIPv6(J):null};util$7.bytesToIPv4=function(J){if(J.length!==4)return null;for(var E=[],ee=0;ee<J.length;++ee)E.push(J.charCodeAt(ee));return E.join(".")};util$7.bytesToIPv6=function(J){if(J.length!==16)return null;for(var E=[],ee=[],te=0,re=0;re<J.length;re+=2){for(var ne=util$7.bytesToHex(J[re]+J[re+1]);ne[0]==="0"&&ne!=="0";)ne=ne.substr(1);if(ne==="0"){var ie=ee[ee.length-1],se=E.length;!ie||se!==ie.end+1?ee.push({start:se,end:se}):(ie.end=se,ie.end-ie.start>ee[te].end-ee[te].start&&(te=ee.length-1))}E.push(ne)}if(ee.length>0){var oe=ee[te];oe.end-oe.start>0&&(E.splice(oe.start,oe.end-oe.start+1,""),oe.start===0&&E.unshift(""),oe.end===7&&E.push(""))}return E.join(":")};util$7.estimateCores=function(J,E){if(typeof J=="function"&&(E=J,J={}),J=J||{},"cores"in util$7&&!J.update)return E(null,util$7.cores);if(typeof navigator<"u"&&"hardwareConcurrency"in navigator&&navigator.hardwareConcurrency>0)return util$7.cores=navigator.hardwareConcurrency,E(null,util$7.cores);if(typeof Worker>"u")return util$7.cores=1,E(null,util$7.cores);if(typeof Blob>"u")return util$7.cores=2,E(null,util$7.cores);var ee=URL.createObjectURL(new Blob(["(",function(){self.addEventListener("message",function(ie){var se=Date.now(),oe=se+4;self.postMessage({st:se,et:oe})})}.toString(),")()"],{type:"application/javascript"}));te([],5,16);function te(ie,se,oe){if(se===0){var ae=Math.floor(ie.reduce(function(ce,le){return ce+le},0)/ie.length);return util$7.cores=Math.max(1,ae),URL.revokeObjectURL(ee),E(null,util$7.cores)}re(oe,function(ce,le){ie.push(ne(oe,le)),te(ie,se-1,oe)})}function re(ie,se){for(var oe=[],ae=[],ce=0;ce<ie;++ce){var le=new Worker(ee);le.addEventListener("message",function(he){if(ae.push(he.data),ae.length===ie){for(var de=0;de<ie;++de)oe[de].terminate();se(null,ae)}}),oe.push(le)}for(var ce=0;ce<ie;++ce)oe[ce].postMessage(ce)}function ne(ie,se){for(var oe=[],ae=0;ae<ie;++ae)for(var ce=se[ae],le=oe[ae]=[],he=0;he<ie;++he)if(ae!==he){var de=se[he];(ce.st>de.st&&ce.st<de.et||de.st>ce.st&&de.st<ce.et)&&le.push(he)}return oe.reduce(function(ue,pe){return Math.max(ue,pe.length)},0)}};var utilExports=util$8.exports;const forgeUtil=getDefaultExportFromCjs(utilExports);var forge$k=forge$m;forge$k.pki=forge$k.pki||{};var oids$1=forge$k.pki.oids=forge$k.oids=forge$k.oids||{};function _IN(J,E){oids$1[J]=E,oids$1[E]=J}function _I_(J,E){oids$1[J]=E}_IN("1.2.840.113549.1.1.1","rsaEncryption");_IN("1.2.840.113549.1.1.4","md5WithRSAEncryption");_IN("1.2.840.113549.1.1.5","sha1WithRSAEncryption");_IN("1.2.840.113549.1.1.7","RSAES-OAEP");_IN("1.2.840.113549.1.1.8","mgf1");_IN("1.2.840.113549.1.1.9","pSpecified");_IN("1.2.840.113549.1.1.10","RSASSA-PSS");_IN("1.2.840.113549.1.1.11","sha256WithRSAEncryption");_IN("1.2.840.113549.1.1.12","sha384WithRSAEncryption");_IN("1.2.840.113549.1.1.13","sha512WithRSAEncryption");_IN("1.3.101.112","EdDSA25519");_IN("1.2.840.10040.4.3","dsa-with-sha1");_IN("1.3.14.3.2.7","desCBC");_IN("1.3.14.3.2.26","sha1");_IN("1.3.14.3.2.29","sha1WithRSASignature");_IN("2.16.840.1.101.3.4.2.1","sha256");_IN("2.16.840.1.101.3.4.2.2","sha384");_IN("2.16.840.1.101.3.4.2.3","sha512");_IN("2.16.840.1.101.3.4.2.4","sha224");_IN("2.16.840.1.101.3.4.2.5","sha512-224");_IN("2.16.840.1.101.3.4.2.6","sha512-256");_IN("1.2.840.113549.2.2","md2");_IN("1.2.840.113549.2.5","md5");_IN("1.2.840.113549.1.7.1","data");_IN("1.2.840.113549.1.7.2","signedData");_IN("1.2.840.113549.1.7.3","envelopedData");_IN("1.2.840.113549.1.7.4","signedAndEnvelopedData");_IN("1.2.840.113549.1.7.5","digestedData");_IN("1.2.840.113549.1.7.6","encryptedData");_IN("1.2.840.113549.1.9.1","emailAddress");_IN("1.2.840.113549.1.9.2","unstructuredName");_IN("1.2.840.113549.1.9.3","contentType");_IN("1.2.840.113549.1.9.4","messageDigest");_IN("1.2.840.113549.1.9.5","signingTime");_IN("1.2.840.113549.1.9.6","counterSignature");_IN("1.2.840.113549.1.9.7","challengePassword");_IN("1.2.840.113549.1.9.8","unstructuredAddress");_IN("1.2.840.113549.1.9.14","extensionRequest");_IN("1.2.840.113549.1.9.20","friendlyName");_IN("1.2.840.113549.1.9.21","localKeyId");_IN("1.2.840.113549.1.9.22.1","x509Certificate");_IN("1.2.840.113549.1.12.10.1.1","keyBag");_IN("1.2.840.113549.1.12.10.1.2","pkcs8ShroudedKeyBag");_IN("1.2.840.113549.1.12.10.1.3","certBag");_IN("1.2.840.113549.1.12.10.1.4","crlBag");_IN("1.2.840.113549.1.12.10.1.5","secretBag");_IN("1.2.840.113549.1.12.10.1.6","safeContentsBag");_IN("1.2.840.113549.1.5.13","pkcs5PBES2");_IN("1.2.840.113549.1.5.12","pkcs5PBKDF2");_IN("1.2.840.113549.1.12.1.1","pbeWithSHAAnd128BitRC4");_IN("1.2.840.113549.1.12.1.2","pbeWithSHAAnd40BitRC4");_IN("1.2.840.113549.1.12.1.3","pbeWithSHAAnd3-KeyTripleDES-CBC");_IN("1.2.840.113549.1.12.1.4","pbeWithSHAAnd2-KeyTripleDES-CBC");_IN("1.2.840.113549.1.12.1.5","pbeWithSHAAnd128BitRC2-CBC");_IN("1.2.840.113549.1.12.1.6","pbewithSHAAnd40BitRC2-CBC");_IN("1.2.840.113549.2.7","hmacWithSHA1");_IN("1.2.840.113549.2.8","hmacWithSHA224");_IN("1.2.840.113549.2.9","hmacWithSHA256");_IN("1.2.840.113549.2.10","hmacWithSHA384");_IN("1.2.840.113549.2.11","hmacWithSHA512");_IN("1.2.840.113549.3.7","des-EDE3-CBC");_IN("2.16.840.1.101.3.4.1.2","aes128-CBC");_IN("2.16.840.1.101.3.4.1.22","aes192-CBC");_IN("2.16.840.1.101.3.4.1.42","aes256-CBC");_IN("2.5.4.3","commonName");_IN("2.5.4.4","surname");_IN("2.5.4.5","serialNumber");_IN("2.5.4.6","countryName");_IN("2.5.4.7","localityName");_IN("2.5.4.8","stateOrProvinceName");_IN("2.5.4.9","streetAddress");_IN("2.5.4.10","organizationName");_IN("2.5.4.11","organizationalUnitName");_IN("2.5.4.12","title");_IN("2.5.4.13","description");_IN("2.5.4.15","businessCategory");_IN("2.5.4.17","postalCode");_IN("2.5.4.42","givenName");_IN("1.3.6.1.4.1.311.60.2.1.2","jurisdictionOfIncorporationStateOrProvinceName");_IN("1.3.6.1.4.1.311.60.2.1.3","jurisdictionOfIncorporationCountryName");_IN("2.16.840.1.113730.1.1","nsCertType");_IN("2.16.840.1.113730.1.13","nsComment");_I_("2.5.29.1","authorityKeyIdentifier");_I_("2.5.29.2","keyAttributes");_I_("2.5.29.3","certificatePolicies");_I_("2.5.29.4","keyUsageRestriction");_I_("2.5.29.5","policyMapping");_I_("2.5.29.6","subtreesConstraint");_I_("2.5.29.7","subjectAltName");_I_("2.5.29.8","issuerAltName");_I_("2.5.29.9","subjectDirectoryAttributes");_I_("2.5.29.10","basicConstraints");_I_("2.5.29.11","nameConstraints");_I_("2.5.29.12","policyConstraints");_I_("2.5.29.13","basicConstraints");_IN("2.5.29.14","subjectKeyIdentifier");_IN("2.5.29.15","keyUsage");_I_("2.5.29.16","privateKeyUsagePeriod");_IN("2.5.29.17","subjectAltName");_IN("2.5.29.18","issuerAltName");_IN("2.5.29.19","basicConstraints");_I_("2.5.29.20","cRLNumber");_I_("2.5.29.21","cRLReason");_I_("2.5.29.22","expirationDate");_I_("2.5.29.23","instructionCode");_I_("2.5.29.24","invalidityDate");_I_("2.5.29.25","cRLDistributionPoints");_I_("2.5.29.26","issuingDistributionPoint");_I_("2.5.29.27","deltaCRLIndicator");_I_("2.5.29.28","issuingDistributionPoint");_I_("2.5.29.29","certificateIssuer");_I_("2.5.29.30","nameConstraints");_IN("2.5.29.31","cRLDistributionPoints");_IN("2.5.29.32","certificatePolicies");_I_("2.5.29.33","policyMappings");_I_("2.5.29.34","policyConstraints");_IN("2.5.29.35","authorityKeyIdentifier");_I_("2.5.29.36","policyConstraints");_IN("2.5.29.37","extKeyUsage");_I_("2.5.29.46","freshestCRL");_I_("2.5.29.54","inhibitAnyPolicy");_IN("1.3.6.1.4.1.11129.2.4.2","timestampList");_IN("1.3.6.1.5.5.7.1.1","authorityInfoAccess");_IN("1.3.6.1.5.5.7.3.1","serverAuth");_IN("1.3.6.1.5.5.7.3.2","clientAuth");_IN("1.3.6.1.5.5.7.3.3","codeSigning");_IN("1.3.6.1.5.5.7.3.4","emailProtection");_IN("1.3.6.1.5.5.7.3.8","timeStamping");var forge$j=forge$m,asn1$2=forge$j.asn1=forge$j.asn1||{};asn1$2.Class={UNIVERSAL:0,APPLICATION:64,CONTEXT_SPECIFIC:128,PRIVATE:192};asn1$2.Type={NONE:0,BOOLEAN:1,INTEGER:2,BITSTRING:3,OCTETSTRING:4,NULL:5,OID:6,ODESC:7,EXTERNAL:8,REAL:9,ENUMERATED:10,EMBEDDED:11,UTF8:12,ROID:13,SEQUENCE:16,SET:17,PRINTABLESTRING:19,IA5STRING:22,UTCTIME:23,GENERALIZEDTIME:24,BMPSTRING:30};asn1$2.create=function(J,E,ee,te,re){if(forge$j.util.isArray(te)){for(var ne=[],ie=0;ie<te.length;++ie)te[ie]!==void 0&&ne.push(te[ie]);te=ne}var se={tagClass:J,type:E,constructed:ee,composed:ee||forge$j.util.isArray(te),value:te};return re&&"bitStringContents"in re&&(se.bitStringContents=re.bitStringContents,se.original=asn1$2.copy(se)),se};asn1$2.copy=function(J,E){var ee;if(forge$j.util.isArray(J)){ee=[];for(var te=0;te<J.length;++te)ee.push(asn1$2.copy(J[te],E));return ee}return typeof J=="string"?J:(ee={tagClass:J.tagClass,type:J.type,constructed:J.constructed,composed:J.composed,value:asn1$2.copy(J.value,E)},E&&!E.excludeBitStringContents&&(ee.bitStringContents=J.bitStringContents),ee)};asn1$2.equals=function(J,E,ee){if(forge$j.util.isArray(J)){if(!forge$j.util.isArray(E)||J.length!==E.length)return!1;for(var te=0;te<J.length;++te)if(!asn1$2.equals(J[te],E[te]))return!1;return!0}if(typeof J!=typeof E)return!1;if(typeof J=="string")return J===E;var re=J.tagClass===E.tagClass&&J.type===E.type&&J.constructed===E.constructed&&J.composed===E.composed&&asn1$2.equals(J.value,E.value);return ee&&ee.includeBitStringContents&&(re=re&&J.bitStringContents===E.bitStringContents),re};asn1$2.getBerValueLength=function(J){var E=J.getByte();if(E!==128){var ee,te=E&128;return te?ee=J.getInt((E&127)<<3):ee=E,ee}};function _checkBufferLength(J,E,ee){if(ee>E){var te=new Error("Too few bytes to parse DER.");throw te.available=J.length(),te.remaining=E,te.requested=ee,te}}var _getValueLength=function(J,E){var ee=J.getByte();if(E--,ee!==128){var te,re=ee&128;if(!re)te=ee;else{var ne=ee&127;_checkBufferLength(J,E,ne),te=J.getInt(ne<<3)}if(te<0)throw new Error("Negative length: "+te);return te}};asn1$2.fromDer=function(J,E){E===void 0&&(E={strict:!0,parseAllBytes:!0,decodeBitStrings:!0}),typeof E=="boolean"&&(E={strict:E,parseAllBytes:!0,decodeBitStrings:!0}),"strict"in E||(E.strict=!0),"parseAllBytes"in E||(E.parseAllBytes=!0),"decodeBitStrings"in E||(E.decodeBitStrings=!0),typeof J=="string"&&(J=forge$j.util.createBuffer(J));var ee=J.length(),te=_fromDer(J,J.length(),0,E);if(E.parseAllBytes&&J.length()!==0){var re=new Error("Unparsed DER bytes remain after ASN.1 parsing.");throw re.byteCount=ee,re.remaining=J.length(),re}return te};function _fromDer(J,E,ee,te){var re;_checkBufferLength(J,E,2);var ne=J.getByte();E--;var ie=ne&192,se=ne&31;re=J.length();var oe=_getValueLength(J,E);if(E-=re-J.length(),oe!==void 0&&oe>E){if(te.strict){var ae=new Error("Too few bytes to read ASN.1 value.");throw ae.available=J.length(),ae.remaining=E,ae.requested=oe,ae}oe=E}var ce,le,he=(ne&32)===32;if(he)if(ce=[],oe===void 0)for(;;){if(_checkBufferLength(J,E,2),J.bytes(2)===String.fromCharCode(0,0)){J.getBytes(2),E-=2;break}re=J.length(),ce.push(_fromDer(J,E,ee+1,te)),E-=re-J.length()}else for(;oe>0;)re=J.length(),ce.push(_fromDer(J,oe,ee+1,te)),E-=re-J.length(),oe-=re-J.length();if(ce===void 0&&ie===asn1$2.Class.UNIVERSAL&&se===asn1$2.Type.BITSTRING&&(le=J.bytes(oe)),ce===void 0&&te.decodeBitStrings&&ie===asn1$2.Class.UNIVERSAL&&se===asn1$2.Type.BITSTRING&&oe>1){var de=J.read,ue=E,pe=0;if(se===asn1$2.Type.BITSTRING&&(_checkBufferLength(J,E,1),pe=J.getByte(),E--),pe===0)try{re=J.length();var ye={strict:!0,decodeBitStrings:!0},me=_fromDer(J,E,ee+1,ye),be=re-J.length();E-=be,se==asn1$2.Type.BITSTRING&&be++;var _e=me.tagClass;be===oe&&(_e===asn1$2.Class.UNIVERSAL||_e===asn1$2.Class.CONTEXT_SPECIFIC)&&(ce=[me])}catch{}ce===void 0&&(J.read=de,E=ue)}if(ce===void 0){if(oe===void 0){if(te.strict)throw new Error("Non-constructed ASN.1 object of indefinite length.");oe=E}if(se===asn1$2.Type.BMPSTRING)for(ce="";oe>0;oe-=2)_checkBufferLength(J,E,2),ce+=String.fromCharCode(J.getInt16()),E-=2;else ce=J.getBytes(oe),E-=oe}var we=le===void 0?null:{bitStringContents:le};return asn1$2.create(ie,se,he,ce,we)}asn1$2.toDer=function(J){var E=forge$j.util.createBuffer(),ee=J.tagClass|J.type,te=forge$j.util.createBuffer(),re=!1;if("bitStringContents"in J&&(re=!0,J.original&&(re=asn1$2.equals(J,J.original))),re)te.putBytes(J.bitStringContents);else if(J.composed){J.constructed?ee|=32:te.putByte(0);for(var ne=0;ne<J.value.length;++ne)J.value[ne]!==void 0&&te.putBuffer(asn1$2.toDer(J.value[ne]))}else if(J.type===asn1$2.Type.BMPSTRING)for(var ne=0;ne<J.value.length;++ne)te.putInt16(J.value.charCodeAt(ne));else J.type===asn1$2.Type.INTEGER&&J.value.length>1&&(J.value.charCodeAt(0)===0&&!(J.value.charCodeAt(1)&128)||J.value.charCodeAt(0)===255&&(J.value.charCodeAt(1)&128)===128)?te.putBytes(J.value.substr(1)):te.putBytes(J.value);if(E.putByte(ee),te.length()<=127)E.putByte(te.length()&127);else{var ie=te.length(),se="";do se+=String.fromCharCode(ie&255),ie=ie>>>8;while(ie>0);E.putByte(se.length|128);for(var ne=se.length-1;ne>=0;--ne)E.putByte(se.charCodeAt(ne))}return E.putBuffer(te),E};asn1$2.oidToDer=function(J){var E=J.split("."),ee=forge$j.util.createBuffer();ee.putByte(40*parseInt(E[0],10)+parseInt(E[1],10));for(var te,re,ne,ie,se=2;se<E.length;++se){te=!0,re=[],ne=parseInt(E[se],10);do ie=ne&127,ne=ne>>>7,te||(ie|=128),re.push(ie),te=!1;while(ne>0);for(var oe=re.length-1;oe>=0;--oe)ee.putByte(re[oe])}return ee};asn1$2.derToOid=function(J){var E;typeof J=="string"&&(J=forge$j.util.createBuffer(J));var ee=J.getByte();E=Math.floor(ee/40)+"."+ee%40;for(var te=0;J.length()>0;)ee=J.getByte(),te=te<<7,ee&128?te+=ee&127:(E+="."+(te+ee),te=0);return E};asn1$2.utcTimeToDate=function(J){var E=new Date,ee=parseInt(J.substr(0,2),10);ee=ee>=50?1900+ee:2e3+ee;var te=parseInt(J.substr(2,2),10)-1,re=parseInt(J.substr(4,2),10),ne=parseInt(J.substr(6,2),10),ie=parseInt(J.substr(8,2),10),se=0;if(J.length>11){var oe=J.charAt(10),ae=10;oe!=="+"&&oe!=="-"&&(se=parseInt(J.substr(10,2),10),ae+=2)}if(E.setUTCFullYear(ee,te,re),E.setUTCHours(ne,ie,se,0),ae&&(oe=J.charAt(ae),oe==="+"||oe==="-")){var ce=parseInt(J.substr(ae+1,2),10),le=parseInt(J.substr(ae+4,2),10),he=ce*60+le;he*=6e4,oe==="+"?E.setTime(+E-he):E.setTime(+E+he)}return E};asn1$2.generalizedTimeToDate=function(J){var E=new Date,ee=parseInt(J.substr(0,4),10),te=parseInt(J.substr(4,2),10)-1,re=parseInt(J.substr(6,2),10),ne=parseInt(J.substr(8,2),10),ie=parseInt(J.substr(10,2),10),se=parseInt(J.substr(12,2),10),oe=0,ae=0,ce=!1;J.charAt(J.length-1)==="Z"&&(ce=!0);var le=J.length-5,he=J.charAt(le);if(he==="+"||he==="-"){var de=parseInt(J.substr(le+1,2),10),ue=parseInt(J.substr(le+4,2),10);ae=de*60+ue,ae*=6e4,he==="+"&&(ae*=-1),ce=!0}return J.charAt(14)==="."&&(oe=parseFloat(J.substr(14),10)*1e3),ce?(E.setUTCFullYear(ee,te,re),E.setUTCHours(ne,ie,se,oe),E.setTime(+E+ae)):(E.setFullYear(ee,te,re),E.setHours(ne,ie,se,oe)),E};asn1$2.dateToUtcTime=function(J){if(typeof J=="string")return J;var E="",ee=[];ee.push((""+J.getUTCFullYear()).substr(2)),ee.push(""+(J.getUTCMonth()+1)),ee.push(""+J.getUTCDate()),ee.push(""+J.getUTCHours()),ee.push(""+J.getUTCMinutes()),ee.push(""+J.getUTCSeconds());for(var te=0;te<ee.length;++te)ee[te].length<2&&(E+="0"),E+=ee[te];return E+="Z",E};asn1$2.dateToGeneralizedTime=function(J){if(typeof J=="string")return J;var E="",ee=[];ee.push(""+J.getUTCFullYear()),ee.push(""+(J.getUTCMonth()+1)),ee.push(""+J.getUTCDate()),ee.push(""+J.getUTCHours()),ee.push(""+J.getUTCMinutes()),ee.push(""+J.getUTCSeconds());for(var te=0;te<ee.length;++te)ee[te].length<2&&(E+="0"),E+=ee[te];return E+="Z",E};asn1$2.integerToDer=function(J){var E=forge$j.util.createBuffer();if(J>=-128&&J<128)return E.putSignedInt(J,8);if(J>=-32768&&J<32768)return E.putSignedInt(J,16);if(J>=-8388608&&J<8388608)return E.putSignedInt(J,24);if(J>=-2147483648&&J<2147483648)return E.putSignedInt(J,32);var ee=new Error("Integer too large; max is 32-bits.");throw ee.integer=J,ee};asn1$2.derToInteger=function(J){typeof J=="string"&&(J=forge$j.util.createBuffer(J));var E=J.length()*8;if(E>32)throw new Error("Integer too large; max is 32-bits.");return J.getSignedInt(E)};asn1$2.validate=function(J,E,ee,te){var re=!1;if((J.tagClass===E.tagClass||typeof E.tagClass>"u")&&(J.type===E.type||typeof E.type>"u"))if(J.constructed===E.constructed||typeof E.constructed>"u"){if(re=!0,E.value&&forge$j.util.isArray(E.value))for(var ne=0,ie=0;re&&ie<E.value.length;++ie)re=E.value[ie].optional||!1,J.value[ne]&&(re=asn1$2.validate(J.value[ne],E.value[ie],ee,te),re?++ne:E.value[ie].optional&&(re=!0)),!re&&te&&te.push("["+E.name+'] Tag class "'+E.tagClass+'", type "'+E.type+'" expected value length "'+E.value.length+'", got "'+J.value.length+'"');if(re&&ee&&(E.capture&&(ee[E.capture]=J.value),E.captureAsn1&&(ee[E.captureAsn1]=J),E.captureBitStringContents&&"bitStringContents"in J&&(ee[E.captureBitStringContents]=J.bitStringContents),E.captureBitStringValue&&"bitStringContents"in J))if(J.bitStringContents.length<2)ee[E.captureBitStringValue]="";else{var se=J.bitStringContents.charCodeAt(0);if(se!==0)throw new Error("captureBitStringValue only supported for zero unused bits");ee[E.captureBitStringValue]=J.bitStringContents.slice(1)}}else te&&te.push("["+E.name+'] Expected constructed "'+E.constructed+'", got "'+J.constructed+'"');else te&&(J.tagClass!==E.tagClass&&te.push("["+E.name+'] Expected tag class "'+E.tagClass+'", got "'+J.tagClass+'"'),J.type!==E.type&&te.push("["+E.name+'] Expected type "'+E.type+'", got "'+J.type+'"'));return re};var _nonLatinRegex=/[^\\u0000-\\u00ff]/;asn1$2.prettyPrint=function(J,E,ee){var te="";E=E||0,ee=ee||2,E>0&&(te+=`
`);for(var re="",ne=0;ne<E*ee;++ne)re+=" ";switch(te+=re+"Tag: ",J.tagClass){case asn1$2.Class.UNIVERSAL:te+="Universal:";break;case asn1$2.Class.APPLICATION:te+="Application:";break;case asn1$2.Class.CONTEXT_SPECIFIC:te+="Context-Specific:";break;case asn1$2.Class.PRIVATE:te+="Private:";break}if(J.tagClass===asn1$2.Class.UNIVERSAL)switch(te+=J.type,J.type){case asn1$2.Type.NONE:te+=" (None)";break;case asn1$2.Type.BOOLEAN:te+=" (Boolean)";break;case asn1$2.Type.INTEGER:te+=" (Integer)";break;case asn1$2.Type.BITSTRING:te+=" (Bit string)";break;case asn1$2.Type.OCTETSTRING:te+=" (Octet string)";break;case asn1$2.Type.NULL:te+=" (Null)";break;case asn1$2.Type.OID:te+=" (Object Identifier)";break;case asn1$2.Type.ODESC:te+=" (Object Descriptor)";break;case asn1$2.Type.EXTERNAL:te+=" (External or Instance of)";break;case asn1$2.Type.REAL:te+=" (Real)";break;case asn1$2.Type.ENUMERATED:te+=" (Enumerated)";break;case asn1$2.Type.EMBEDDED:te+=" (Embedded PDV)";break;case asn1$2.Type.UTF8:te+=" (UTF8)";break;case asn1$2.Type.ROID:te+=" (Relative Object Identifier)";break;case asn1$2.Type.SEQUENCE:te+=" (Sequence)";break;case asn1$2.Type.SET:te+=" (Set)";break;case asn1$2.Type.PRINTABLESTRING:te+=" (Printable String)";break;case asn1$2.Type.IA5String:te+=" (IA5String (ASCII))";break;case asn1$2.Type.UTCTIME:te+=" (UTC time)";break;case asn1$2.Type.GENERALIZEDTIME:te+=" (Generalized time)";break;case asn1$2.Type.BMPSTRING:te+=" (BMP String)";break}else te+=J.type;if(te+=`
`,te+=re+"Constructed: "+J.constructed+`
`,J.composed){for(var ie=0,se="",ne=0;ne<J.value.length;++ne)J.value[ne]!==void 0&&(ie+=1,se+=asn1$2.prettyPrint(J.value[ne],E+1,ee),ne+1<J.value.length&&(se+=","));te+=re+"Sub values: "+ie+se}else{if(te+=re+"Value: ",J.type===asn1$2.Type.OID){var oe=asn1$2.derToOid(J.value);te+=oe,forge$j.pki&&forge$j.pki.oids&&oe in forge$j.pki.oids&&(te+=" ("+forge$j.pki.oids[oe]+") ")}if(J.type===asn1$2.Type.INTEGER)try{te+=asn1$2.derToInteger(J.value)}catch{te+="0x"+forge$j.util.bytesToHex(J.value)}else if(J.type===asn1$2.Type.BITSTRING){if(J.value.length>1?te+="0x"+forge$j.util.bytesToHex(J.value.slice(1)):te+="(none)",J.value.length>0){var ae=J.value.charCodeAt(0);ae==1?te+=" (1 unused bit shown)":ae>1&&(te+=" ("+ae+" unused bits shown)")}}else if(J.type===asn1$2.Type.OCTETSTRING)_nonLatinRegex.test(J.value)||(te+="("+J.value+") "),te+="0x"+forge$j.util.bytesToHex(J.value);else if(J.type===asn1$2.Type.UTF8)try{te+=forge$j.util.decodeUtf8(J.value)}catch(ce){if(ce.message==="URI malformed")te+="0x"+forge$j.util.bytesToHex(J.value)+" (malformed UTF8)";else throw ce}else J.type===asn1$2.Type.PRINTABLESTRING||J.type===asn1$2.Type.IA5String?te+=J.value:_nonLatinRegex.test(J.value)?te+="0x"+forge$j.util.bytesToHex(J.value):J.value.length===0?te+="[null]":te+=J.value}return te};var forge$i=forge$m;forge$i.cipher=forge$i.cipher||{};forge$i.cipher.algorithms=forge$i.cipher.algorithms||{};forge$i.cipher.createCipher=function(J,E){var ee=J;if(typeof ee=="string"&&(ee=forge$i.cipher.getAlgorithm(ee),ee&&(ee=ee())),!ee)throw new Error("Unsupported algorithm: "+J);return new forge$i.cipher.BlockCipher({algorithm:ee,key:E,decrypt:!1})};forge$i.cipher.createDecipher=function(J,E){var ee=J;if(typeof ee=="string"&&(ee=forge$i.cipher.getAlgorithm(ee),ee&&(ee=ee())),!ee)throw new Error("Unsupported algorithm: "+J);return new forge$i.cipher.BlockCipher({algorithm:ee,key:E,decrypt:!0})};forge$i.cipher.registerAlgorithm=function(J,E){J=J.toUpperCase(),forge$i.cipher.algorithms[J]=E};forge$i.cipher.getAlgorithm=function(J){return J=J.toUpperCase(),J in forge$i.cipher.algorithms?forge$i.cipher.algorithms[J]:null};var BlockCipher=forge$i.cipher.BlockCipher=function(J){this.algorithm=J.algorithm,this.mode=this.algorithm.mode,this.blockSize=this.mode.blockSize,this._finish=!1,this._input=null,this.output=null,this._op=J.decrypt?this.mode.decrypt:this.mode.encrypt,this._decrypt=J.decrypt,this.algorithm.initialize(J)};BlockCipher.prototype.start=function(J){J=J||{};var E={};for(var ee in J)E[ee]=J[ee];E.decrypt=this._decrypt,this._finish=!1,this._input=forge$i.util.createBuffer(),this.output=J.output||forge$i.util.createBuffer(),this.mode.start(E)};BlockCipher.prototype.update=function(J){for(J&&this._input.putBuffer(J);!this._op.call(this.mode,this._input,this.output,this._finish)&&!this._finish;);this._input.compact()};BlockCipher.prototype.finish=function(J){J&&(this.mode.name==="ECB"||this.mode.name==="CBC")&&(this.mode.pad=function(ee){return J(this.blockSize,ee,!1)},this.mode.unpad=function(ee){return J(this.blockSize,ee,!0)});var E={};return E.decrypt=this._decrypt,E.overflow=this._input.length()%this.blockSize,!(!this._decrypt&&this.mode.pad&&!this.mode.pad(this._input,E)||(this._finish=!0,this.update(),this._decrypt&&this.mode.unpad&&!this.mode.unpad(this.output,E))||this.mode.afterFinish&&!this.mode.afterFinish(this.output,E))};var forge$h=forge$m;forge$h.cipher=forge$h.cipher||{};var modes=forge$h.cipher.modes=forge$h.cipher.modes||{};modes.ecb=function(J){J=J||{},this.name="ECB",this.cipher=J.cipher,this.blockSize=J.blockSize||16,this._ints=this.blockSize/4,this._inBlock=new Array(this._ints),this._outBlock=new Array(this._ints)};modes.ecb.prototype.start=function(J){};modes.ecb.prototype.encrypt=function(J,E,ee){if(J.length()<this.blockSize&&!(ee&&J.length()>0))return!0;for(var te=0;te<this._ints;++te)this._inBlock[te]=J.getInt32();this.cipher.encrypt(this._inBlock,this._outBlock);for(var te=0;te<this._ints;++te)E.putInt32(this._outBlock[te])};modes.ecb.prototype.decrypt=function(J,E,ee){if(J.length()<this.blockSize&&!(ee&&J.length()>0))return!0;for(var te=0;te<this._ints;++te)this._inBlock[te]=J.getInt32();this.cipher.decrypt(this._inBlock,this._outBlock);for(var te=0;te<this._ints;++te)E.putInt32(this._outBlock[te])};modes.ecb.prototype.pad=function(J,E){var ee=J.length()===this.blockSize?this.blockSize:this.blockSize-J.length();return J.fillWithByte(ee,ee),!0};modes.ecb.prototype.unpad=function(J,E){if(E.overflow>0)return!1;var ee=J.length(),te=J.at(ee-1);return te>this.blockSize<<2?!1:(J.truncate(te),!0)};modes.cbc=function(J){J=J||{},this.name="CBC",this.cipher=J.cipher,this.blockSize=J.blockSize||16,this._ints=this.blockSize/4,this._inBlock=new Array(this._ints),this._outBlock=new Array(this._ints)};modes.cbc.prototype.start=function(J){if(J.iv===null){if(!this._prev)throw new Error("Invalid IV parameter.");this._iv=this._prev.slice(0)}else if("iv"in J)this._iv=transformIV(J.iv,this.blockSize),this._prev=this._iv.slice(0);else throw new Error("Invalid IV parameter.")};modes.cbc.prototype.encrypt=function(J,E,ee){if(J.length()<this.blockSize&&!(ee&&J.length()>0))return!0;for(var te=0;te<this._ints;++te)this._inBlock[te]=this._prev[te]^J.getInt32();this.cipher.encrypt(this._inBlock,this._outBlock);for(var te=0;te<this._ints;++te)E.putInt32(this._outBlock[te]);this._prev=this._outBlock};modes.cbc.prototype.decrypt=function(J,E,ee){if(J.length()<this.blockSize&&!(ee&&J.length()>0))return!0;for(var te=0;te<this._ints;++te)this._inBlock[te]=J.getInt32();this.cipher.decrypt(this._inBlock,this._outBlock);for(var te=0;te<this._ints;++te)E.putInt32(this._prev[te]^this._outBlock[te]);this._prev=this._inBlock.slice(0)};modes.cbc.prototype.pad=function(J,E){var ee=J.length()===this.blockSize?this.blockSize:this.blockSize-J.length();return J.fillWithByte(ee,ee),!0};modes.cbc.prototype.unpad=function(J,E){if(E.overflow>0)return!1;var ee=J.length(),te=J.at(ee-1);return te>this.blockSize<<2?!1:(J.truncate(te),!0)};modes.cfb=function(J){J=J||{},this.name="CFB",this.cipher=J.cipher,this.blockSize=J.blockSize||16,this._ints=this.blockSize/4,this._inBlock=null,this._outBlock=new Array(this._ints),this._partialBlock=new Array(this._ints),this._partialOutput=forge$h.util.createBuffer(),this._partialBytes=0};modes.cfb.prototype.start=function(J){if(!("iv"in J))throw new Error("Invalid IV parameter.");this._iv=transformIV(J.iv,this.blockSize),this._inBlock=this._iv.slice(0),this._partialBytes=0};modes.cfb.prototype.encrypt=function(J,E,ee){var te=J.length();if(te===0)return!0;if(this.cipher.encrypt(this._inBlock,this._outBlock),this._partialBytes===0&&te>=this.blockSize){for(var re=0;re<this._ints;++re)this._inBlock[re]=J.getInt32()^this._outBlock[re],E.putInt32(this._inBlock[re]);return}var ne=(this.blockSize-te)%this.blockSize;ne>0&&(ne=this.blockSize-ne),this._partialOutput.clear();for(var re=0;re<this._ints;++re)this._partialBlock[re]=J.getInt32()^this._outBlock[re],this._partialOutput.putInt32(this._partialBlock[re]);if(ne>0)J.read-=this.blockSize;else for(var re=0;re<this._ints;++re)this._inBlock[re]=this._partialBlock[re];if(this._partialBytes>0&&this._partialOutput.getBytes(this._partialBytes),ne>0&&!ee)return E.putBytes(this._partialOutput.getBytes(ne-this._partialBytes)),this._partialBytes=ne,!0;E.putBytes(this._partialOutput.getBytes(te-this._partialBytes)),this._partialBytes=0};modes.cfb.prototype.decrypt=function(J,E,ee){var te=J.length();if(te===0)return!0;if(this.cipher.encrypt(this._inBlock,this._outBlock),this._partialBytes===0&&te>=this.blockSize){for(var re=0;re<this._ints;++re)this._inBlock[re]=J.getInt32(),E.putInt32(this._inBlock[re]^this._outBlock[re]);return}var ne=(this.blockSize-te)%this.blockSize;ne>0&&(ne=this.blockSize-ne),this._partialOutput.clear();for(var re=0;re<this._ints;++re)this._partialBlock[re]=J.getInt32(),this._partialOutput.putInt32(this._partialBlock[re]^this._outBlock[re]);if(ne>0)J.read-=this.blockSize;else for(var re=0;re<this._ints;++re)this._inBlock[re]=this._partialBlock[re];if(this._partialBytes>0&&this._partialOutput.getBytes(this._partialBytes),ne>0&&!ee)return E.putBytes(this._partialOutput.getBytes(ne-this._partialBytes)),this._partialBytes=ne,!0;E.putBytes(this._partialOutput.getBytes(te-this._partialBytes)),this._partialBytes=0};modes.ofb=function(J){J=J||{},this.name="OFB",this.cipher=J.cipher,this.blockSize=J.blockSize||16,this._ints=this.blockSize/4,this._inBlock=null,this._outBlock=new Array(this._ints),this._partialOutput=forge$h.util.createBuffer(),this._partialBytes=0};modes.ofb.prototype.start=function(J){if(!("iv"in J))throw new Error("Invalid IV parameter.");this._iv=transformIV(J.iv,this.blockSize),this._inBlock=this._iv.slice(0),this._partialBytes=0};modes.ofb.prototype.encrypt=function(J,E,ee){var te=J.length();if(J.length()===0)return!0;if(this.cipher.encrypt(this._inBlock,this._outBlock),this._partialBytes===0&&te>=this.blockSize){for(var re=0;re<this._ints;++re)E.putInt32(J.getInt32()^this._outBlock[re]),this._inBlock[re]=this._outBlock[re];return}var ne=(this.blockSize-te)%this.blockSize;ne>0&&(ne=this.blockSize-ne),this._partialOutput.clear();for(var re=0;re<this._ints;++re)this._partialOutput.putInt32(J.getInt32()^this._outBlock[re]);if(ne>0)J.read-=this.blockSize;else for(var re=0;re<this._ints;++re)this._inBlock[re]=this._outBlock[re];if(this._partialBytes>0&&this._partialOutput.getBytes(this._partialBytes),ne>0&&!ee)return E.putBytes(this._partialOutput.getBytes(ne-this._partialBytes)),this._partialBytes=ne,!0;E.putBytes(this._partialOutput.getBytes(te-this._partialBytes)),this._partialBytes=0};modes.ofb.prototype.decrypt=modes.ofb.prototype.encrypt;modes.ctr=function(J){J=J||{},this.name="CTR",this.cipher=J.cipher,this.blockSize=J.blockSize||16,this._ints=this.blockSize/4,this._inBlock=null,this._outBlock=new Array(this._ints),this._partialOutput=forge$h.util.createBuffer(),this._partialBytes=0};modes.ctr.prototype.start=function(J){if(!("iv"in J))throw new Error("Invalid IV parameter.");this._iv=transformIV(J.iv,this.blockSize),this._inBlock=this._iv.slice(0),this._partialBytes=0};modes.ctr.prototype.encrypt=function(J,E,ee){var te=J.length();if(te===0)return!0;if(this.cipher.encrypt(this._inBlock,this._outBlock),this._partialBytes===0&&te>=this.blockSize)for(var re=0;re<this._ints;++re)E.putInt32(J.getInt32()^this._outBlock[re]);else{var ne=(this.blockSize-te)%this.blockSize;ne>0&&(ne=this.blockSize-ne),this._partialOutput.clear();for(var re=0;re<this._ints;++re)this._partialOutput.putInt32(J.getInt32()^this._outBlock[re]);if(ne>0&&(J.read-=this.blockSize),this._partialBytes>0&&this._partialOutput.getBytes(this._partialBytes),ne>0&&!ee)return E.putBytes(this._partialOutput.getBytes(ne-this._partialBytes)),this._partialBytes=ne,!0;E.putBytes(this._partialOutput.getBytes(te-this._partialBytes)),this._partialBytes=0}inc32(this._inBlock)};modes.ctr.prototype.decrypt=modes.ctr.prototype.encrypt;modes.gcm=function(J){J=J||{},this.name="GCM",this.cipher=J.cipher,this.blockSize=J.blockSize||16,this._ints=this.blockSize/4,this._inBlock=new Array(this._ints),this._outBlock=new Array(this._ints),this._partialOutput=forge$h.util.createBuffer(),this._partialBytes=0,this._R=3774873600};modes.gcm.prototype.start=function(J){if(!("iv"in J))throw new Error("Invalid IV parameter.");var E=forge$h.util.createBuffer(J.iv);this._cipherLength=0;var ee;if("additionalData"in J?ee=forge$h.util.createBuffer(J.additionalData):ee=forge$h.util.createBuffer(),"tagLength"in J?this._tagLength=J.tagLength:this._tagLength=128,this._tag=null,J.decrypt&&(this._tag=forge$h.util.createBuffer(J.tag).getBytes(),this._tag.length!==this._tagLength/8))throw new Error("Authentication tag does not match tag length.");this._hashBlock=new Array(this._ints),this.tag=null,this._hashSubkey=new Array(this._ints),this.cipher.encrypt([0,0,0,0],this._hashSubkey),this.componentBits=4,this._m=this.generateHashTable(this._hashSubkey,this.componentBits);var te=E.length();if(te===12)this._j0=[E.getInt32(),E.getInt32(),E.getInt32(),1];else{for(this._j0=[0,0,0,0];E.length()>0;)this._j0=this.ghash(this._hashSubkey,this._j0,[E.getInt32(),E.getInt32(),E.getInt32(),E.getInt32()]);this._j0=this.ghash(this._hashSubkey,this._j0,[0,0].concat(from64To32(te*8)))}this._inBlock=this._j0.slice(0),inc32(this._inBlock),this._partialBytes=0,ee=forge$h.util.createBuffer(ee),this._aDataLength=from64To32(ee.length()*8);var re=ee.length()%this.blockSize;for(re&&ee.fillWithByte(0,this.blockSize-re),this._s=[0,0,0,0];ee.length()>0;)this._s=this.ghash(this._hashSubkey,this._s,[ee.getInt32(),ee.getInt32(),ee.getInt32(),ee.getInt32()])};modes.gcm.prototype.encrypt=function(J,E,ee){var te=J.length();if(te===0)return!0;if(this.cipher.encrypt(this._inBlock,this._outBlock),this._partialBytes===0&&te>=this.blockSize){for(var re=0;re<this._ints;++re)E.putInt32(this._outBlock[re]^=J.getInt32());this._cipherLength+=this.blockSize}else{var ne=(this.blockSize-te)%this.blockSize;ne>0&&(ne=this.blockSize-ne),this._partialOutput.clear();for(var re=0;re<this._ints;++re)this._partialOutput.putInt32(J.getInt32()^this._outBlock[re]);if(ne<=0||ee){if(ee){var ie=te%this.blockSize;this._cipherLength+=ie,this._partialOutput.truncate(this.blockSize-ie)}else this._cipherLength+=this.blockSize;for(var re=0;re<this._ints;++re)this._outBlock[re]=this._partialOutput.getInt32();this._partialOutput.read-=this.blockSize}if(this._partialBytes>0&&this._partialOutput.getBytes(this._partialBytes),ne>0&&!ee)return J.read-=this.blockSize,E.putBytes(this._partialOutput.getBytes(ne-this._partialBytes)),this._partialBytes=ne,!0;E.putBytes(this._partialOutput.getBytes(te-this._partialBytes)),this._partialBytes=0}this._s=this.ghash(this._hashSubkey,this._s,this._outBlock),inc32(this._inBlock)};modes.gcm.prototype.decrypt=function(J,E,ee){var te=J.length();if(te<this.blockSize&&!(ee&&te>0))return!0;this.cipher.encrypt(this._inBlock,this._outBlock),inc32(this._inBlock),this._hashBlock[0]=J.getInt32(),this._hashBlock[1]=J.getInt32(),this._hashBlock[2]=J.getInt32(),this._hashBlock[3]=J.getInt32(),this._s=this.ghash(this._hashSubkey,this._s,this._hashBlock);for(var re=0;re<this._ints;++re)E.putInt32(this._outBlock[re]^this._hashBlock[re]);te<this.blockSize?this._cipherLength+=te%this.blockSize:this._cipherLength+=this.blockSize};modes.gcm.prototype.afterFinish=function(J,E){var ee=!0;E.decrypt&&E.overflow&&J.truncate(this.blockSize-E.overflow),this.tag=forge$h.util.createBuffer();var te=this._aDataLength.concat(from64To32(this._cipherLength*8));this._s=this.ghash(this._hashSubkey,this._s,te);var re=[];this.cipher.encrypt(this._j0,re);for(var ne=0;ne<this._ints;++ne)this.tag.putInt32(this._s[ne]^re[ne]);return this.tag.truncate(this.tag.length()%(this._tagLength/8)),E.decrypt&&this.tag.bytes()!==this._tag&&(ee=!1),ee};modes.gcm.prototype.multiply=function(J,E){for(var ee=[0,0,0,0],te=E.slice(0),re=0;re<128;++re){var ne=J[re/32|0]&1<<31-re%32;ne&&(ee[0]^=te[0],ee[1]^=te[1],ee[2]^=te[2],ee[3]^=te[3]),this.pow(te,te)}return ee};modes.gcm.prototype.pow=function(J,E){for(var ee=J[3]&1,te=3;te>0;--te)E[te]=J[te]>>>1|(J[te-1]&1)<<31;E[0]=J[0]>>>1,ee&&(E[0]^=this._R)};modes.gcm.prototype.tableMultiply=function(J){for(var E=[0,0,0,0],ee=0;ee<32;++ee){var te=ee/8|0,re=J[te]>>>(7-ee%8)*4&15,ne=this._m[ee][re];E[0]^=ne[0],E[1]^=ne[1],E[2]^=ne[2],E[3]^=ne[3]}return E};modes.gcm.prototype.ghash=function(J,E,ee){return E[0]^=ee[0],E[1]^=ee[1],E[2]^=ee[2],E[3]^=ee[3],this.tableMultiply(E)};modes.gcm.prototype.generateHashTable=function(J,E){for(var ee=8/E,te=4*ee,re=16*ee,ne=new Array(re),ie=0;ie<re;++ie){var se=[0,0,0,0],oe=ie/te|0,ae=(te-1-ie%te)*E;se[oe]=1<<E-1<<ae,ne[ie]=this.generateSubHashTable(this.multiply(se,J),E)}return ne};modes.gcm.prototype.generateSubHashTable=function(J,E){var ee=1<<E,te=ee>>>1,re=new Array(ee);re[te]=J.slice(0);for(var ne=te>>>1;ne>0;)this.pow(re[2*ne],re[ne]=[]),ne>>=1;for(ne=2;ne<te;){for(var ie=1;ie<ne;++ie){var se=re[ne],oe=re[ie];re[ne+ie]=[se[0]^oe[0],se[1]^oe[1],se[2]^oe[2],se[3]^oe[3]]}ne*=2}for(re[0]=[0,0,0,0],ne=te+1;ne<ee;++ne){var ae=re[ne^te];re[ne]=[J[0]^ae[0],J[1]^ae[1],J[2]^ae[2],J[3]^ae[3]]}return re};function transformIV(J,E){if(typeof J=="string"&&(J=forge$h.util.createBuffer(J)),forge$h.util.isArray(J)&&J.length>4){var ee=J;J=forge$h.util.createBuffer();for(var te=0;te<ee.length;++te)J.putByte(ee[te])}if(J.length()<E)throw new Error("Invalid IV length; got "+J.length()+" bytes and expected "+E+" bytes.");if(!forge$h.util.isArray(J)){for(var re=[],ne=E/4,te=0;te<ne;++te)re.push(J.getInt32());J=re}return J}function inc32(J){J[J.length-1]=J[J.length-1]+1&4294967295}function from64To32(J){return[J/4294967296|0,J&4294967295]}var forge$g=forge$m;forge$g.aes=forge$g.aes||{};forge$g.aes.startEncrypting=function(J,E,ee,te){var re=_createCipher$1({key:J,output:ee,decrypt:!1,mode:te});return re.start(E),re};forge$g.aes.createEncryptionCipher=function(J,E){return _createCipher$1({key:J,output:null,decrypt:!1,mode:E})};forge$g.aes.startDecrypting=function(J,E,ee,te){var re=_createCipher$1({key:J,output:ee,decrypt:!0,mode:te});return re.start(E),re};forge$g.aes.createDecryptionCipher=function(J,E){return _createCipher$1({key:J,output:null,decrypt:!0,mode:E})};forge$g.aes.Algorithm=function(J,E){init||initialize();var ee=this;ee.name=J,ee.mode=new E({blockSize:16,cipher:{encrypt:function(te,re){return _updateBlock$1(ee._w,te,re,!1)},decrypt:function(te,re){return _updateBlock$1(ee._w,te,re,!0)}}}),ee._init=!1};forge$g.aes.Algorithm.prototype.initialize=function(J){if(!this._init){var E=J.key,ee;if(typeof E=="string"&&(E.length===16||E.length===24||E.length===32))E=forge$g.util.createBuffer(E);else if(forge$g.util.isArray(E)&&(E.length===16||E.length===24||E.length===32)){ee=E,E=forge$g.util.createBuffer();for(var te=0;te<ee.length;++te)E.putByte(ee[te])}if(!forge$g.util.isArray(E)){ee=E,E=[];var re=ee.length();if(re===16||re===24||re===32){re=re>>>2;for(var te=0;te<re;++te)E.push(ee.getInt32())}}if(!forge$g.util.isArray(E)||!(E.length===4||E.length===6||E.length===8))throw new Error("Invalid key parameter.");var ne=this.mode.name,ie=["CFB","OFB","CTR","GCM"].indexOf(ne)!==-1;this._w=_expandKey(E,J.decrypt&&!ie),this._init=!0}};forge$g.aes._expandKey=function(J,E){return init||initialize(),_expandKey(J,E)};forge$g.aes._updateBlock=_updateBlock$1;registerAlgorithm$1("AES-ECB",forge$g.cipher.modes.ecb);registerAlgorithm$1("AES-CBC",forge$g.cipher.modes.cbc);registerAlgorithm$1("AES-CFB",forge$g.cipher.modes.cfb);registerAlgorithm$1("AES-OFB",forge$g.cipher.modes.ofb);registerAlgorithm$1("AES-CTR",forge$g.cipher.modes.ctr);registerAlgorithm$1("AES-GCM",forge$g.cipher.modes.gcm);function registerAlgorithm$1(J,E){var ee=function(){return new forge$g.aes.Algorithm(J,E)};forge$g.cipher.registerAlgorithm(J,ee)}var init=!1,Nb=4,sbox,isbox,rcon,mix,imix;function initialize(){init=!0,rcon=[0,1,2,4,8,16,32,64,128,27,54];for(var J=new Array(256),E=0;E<128;++E)J[E]=E<<1,J[E+128]=E+128<<1^283;sbox=new Array(256),isbox=new Array(256),mix=new Array(4),imix=new Array(4);for(var E=0;E<4;++E)mix[E]=new Array(256),imix[E]=new Array(256);for(var ee=0,te=0,re,ne,ie,se,oe,ae,ce,E=0;E<256;++E){se=te^te<<1^te<<2^te<<3^te<<4,se=se>>8^se&255^99,sbox[ee]=se,isbox[se]=ee,oe=J[se],re=J[ee],ne=J[re],ie=J[ne],ae=oe<<24^se<<16^se<<8^(se^oe),ce=(re^ne^ie)<<24^(ee^ie)<<16^(ee^ne^ie)<<8^(ee^re^ie);for(var le=0;le<4;++le)mix[le][ee]=ae,imix[le][se]=ce,ae=ae<<24|ae>>>8,ce=ce<<24|ce>>>8;ee===0?ee=te=1:(ee=re^J[J[J[re^ie]]],te^=J[J[te]])}}function _expandKey(J,E){for(var ee=J.slice(0),te,re=1,ne=ee.length,ie=ne+6+1,se=Nb*ie,oe=ne;oe<se;++oe)te=ee[oe-1],oe%ne===0?(te=sbox[te>>>16&255]<<24^sbox[te>>>8&255]<<16^sbox[te&255]<<8^sbox[te>>>24]^rcon[re]<<24,re++):ne>6&&oe%ne===4&&(te=sbox[te>>>24]<<24^sbox[te>>>16&255]<<16^sbox[te>>>8&255]<<8^sbox[te&255]),ee[oe]=ee[oe-ne]^te;if(E){var ae,ce=imix[0],le=imix[1],he=imix[2],de=imix[3],ue=ee.slice(0);se=ee.length;for(var oe=0,pe=se-Nb;oe<se;oe+=Nb,pe-=Nb)if(oe===0||oe===se-Nb)ue[oe]=ee[pe],ue[oe+1]=ee[pe+3],ue[oe+2]=ee[pe+2],ue[oe+3]=ee[pe+1];else for(var ye=0;ye<Nb;++ye)ae=ee[pe+ye],ue[oe+(3&-ye)]=ce[sbox[ae>>>24]]^le[sbox[ae>>>16&255]]^he[sbox[ae>>>8&255]]^de[sbox[ae&255]];ee=ue}return ee}function _updateBlock$1(J,E,ee,te){var re=J.length/4-1,ne,ie,se,oe,ae;te?(ne=imix[0],ie=imix[1],se=imix[2],oe=imix[3],ae=isbox):(ne=mix[0],ie=mix[1],se=mix[2],oe=mix[3],ae=sbox);var ce,le,he,de,ue,pe,ye;ce=E[0]^J[0],le=E[te?3:1]^J[1],he=E[2]^J[2],de=E[te?1:3]^J[3];for(var me=3,be=1;be<re;++be)ue=ne[ce>>>24]^ie[le>>>16&255]^se[he>>>8&255]^oe[de&255]^J[++me],pe=ne[le>>>24]^ie[he>>>16&255]^se[de>>>8&255]^oe[ce&255]^J[++me],ye=ne[he>>>24]^ie[de>>>16&255]^se[ce>>>8&255]^oe[le&255]^J[++me],de=ne[de>>>24]^ie[ce>>>16&255]^se[le>>>8&255]^oe[he&255]^J[++me],ce=ue,le=pe,he=ye;ee[0]=ae[ce>>>24]<<24^ae[le>>>16&255]<<16^ae[he>>>8&255]<<8^ae[de&255]^J[++me],ee[te?3:1]=ae[le>>>24]<<24^ae[he>>>16&255]<<16^ae[de>>>8&255]<<8^ae[ce&255]^J[++me],ee[2]=ae[he>>>24]<<24^ae[de>>>16&255]<<16^ae[ce>>>8&255]<<8^ae[le&255]^J[++me],ee[te?1:3]=ae[de>>>24]<<24^ae[ce>>>16&255]<<16^ae[le>>>8&255]<<8^ae[he&255]^J[++me]}function _createCipher$1(J){J=J||{};var E=(J.mode||"CBC").toUpperCase(),ee="AES-"+E,te;J.decrypt?te=forge$g.cipher.createDecipher(ee,J.key):te=forge$g.cipher.createCipher(ee,J.key);var re=te.start;return te.start=function(ne,ie){var se=null;ie instanceof forge$g.util.ByteBuffer&&(se=ie,ie={}),ie=ie||{},ie.output=se,ie.iv=ne,re.call(te,ie)},te}var forge$f=forge$m;forge$f.des=forge$f.des||{};forge$f.des.startEncrypting=function(J,E,ee,te){var re=_createCipher({key:J,output:ee,decrypt:!1,mode:te||(E===null?"ECB":"CBC")});return re.start(E),re};forge$f.des.createEncryptionCipher=function(J,E){return _createCipher({key:J,output:null,decrypt:!1,mode:E})};forge$f.des.startDecrypting=function(J,E,ee,te){var re=_createCipher({key:J,output:ee,decrypt:!0,mode:te||(E===null?"ECB":"CBC")});return re.start(E),re};forge$f.des.createDecryptionCipher=function(J,E){return _createCipher({key:J,output:null,decrypt:!0,mode:E})};forge$f.des.Algorithm=function(J,E){var ee=this;ee.name=J,ee.mode=new E({blockSize:8,cipher:{encrypt:function(te,re){return _updateBlock(ee._keys,te,re,!1)},decrypt:function(te,re){return _updateBlock(ee._keys,te,re,!0)}}}),ee._init=!1};forge$f.des.Algorithm.prototype.initialize=function(J){if(!this._init){var E=forge$f.util.createBuffer(J.key);if(this.name.indexOf("3DES")===0&&E.length()!==24)throw new Error("Invalid Triple-DES key size: "+E.length()*8);this._keys=_createKeys(E),this._init=!0}};registerAlgorithm("DES-ECB",forge$f.cipher.modes.ecb);registerAlgorithm("DES-CBC",forge$f.cipher.modes.cbc);registerAlgorithm("DES-CFB",forge$f.cipher.modes.cfb);registerAlgorithm("DES-OFB",forge$f.cipher.modes.ofb);registerAlgorithm("DES-CTR",forge$f.cipher.modes.ctr);registerAlgorithm("3DES-ECB",forge$f.cipher.modes.ecb);registerAlgorithm("3DES-CBC",forge$f.cipher.modes.cbc);registerAlgorithm("3DES-CFB",forge$f.cipher.modes.cfb);registerAlgorithm("3DES-OFB",forge$f.cipher.modes.ofb);registerAlgorithm("3DES-CTR",forge$f.cipher.modes.ctr);function registerAlgorithm(J,E){var ee=function(){return new forge$f.des.Algorithm(J,E)};forge$f.cipher.registerAlgorithm(J,ee)}var spfunction1=[16843776,0,65536,16843780,16842756,66564,4,65536,1024,16843776,16843780,1024,16778244,16842756,16777216,4,1028,16778240,16778240,66560,66560,16842752,16842752,16778244,65540,16777220,16777220,65540,0,1028,66564,16777216,65536,16843780,4,16842752,16843776,16777216,16777216,1024,16842756,65536,66560,16777220,1024,4,16778244,66564,16843780,65540,16842752,16778244,16777220,1028,66564,16843776,1028,16778240,16778240,0,65540,66560,0,16842756],spfunction2=[-2146402272,-2147450880,32768,1081376,1048576,32,-2146435040,-2147450848,-2147483616,-2146402272,-2146402304,-2147483648,-2147450880,1048576,32,-2146435040,1081344,1048608,-2147450848,0,-2147483648,32768,1081376,-2146435072,1048608,-2147483616,0,1081344,32800,-2146402304,-2146435072,32800,0,1081376,-2146435040,1048576,-2147450848,-2146435072,-2146402304,32768,-2146435072,-2147450880,32,-2146402272,1081376,32,32768,-2147483648,32800,-2146402304,1048576,-2147483616,1048608,-2147450848,-2147483616,1048608,1081344,0,-2147450880,32800,-2147483648,-2146435040,-2146402272,1081344],spfunction3=[520,134349312,0,134348808,134218240,0,131592,134218240,131080,134217736,134217736,131072,134349320,131080,134348800,520,134217728,8,134349312,512,131584,134348800,134348808,131592,134218248,131584,131072,134218248,8,134349320,512,134217728,134349312,134217728,131080,520,131072,134349312,134218240,0,512,131080,134349320,134218240,134217736,512,0,134348808,134218248,131072,134217728,134349320,8,131592,131584,134217736,134348800,134218248,520,134348800,131592,8,134348808,131584],spfunction4=[8396801,8321,8321,128,8396928,8388737,8388609,8193,0,8396800,8396800,8396929,129,0,8388736,8388609,1,8192,8388608,8396801,128,8388608,8193,8320,8388737,1,8320,8388736,8192,8396928,8396929,129,8388736,8388609,8396800,8396929,129,0,0,8396800,8320,8388736,8388737,1,8396801,8321,8321,128,8396929,129,1,8192,8388609,8193,8396928,8388737,8193,8320,8388608,8396801,128,8388608,8192,8396928],spfunction5=[256,34078976,34078720,1107296512,524288,256,1073741824,34078720,1074266368,524288,33554688,1074266368,1107296512,1107820544,524544,1073741824,33554432,1074266112,1074266112,0,1073742080,1107820800,1107820800,33554688,1107820544,1073742080,0,1107296256,34078976,33554432,1107296256,524544,524288,1107296512,256,33554432,1073741824,34078720,1107296512,1074266368,33554688,1073741824,1107820544,34078976,1074266368,256,33554432,1107820544,1107820800,524544,1107296256,1107820800,34078720,0,1074266112,1107296256,524544,33554688,1073742080,524288,0,1074266112,34078976,1073742080],spfunction6=[536870928,541065216,16384,541081616,541065216,16,541081616,4194304,536887296,4210704,4194304,536870928,4194320,536887296,536870912,16400,0,4194320,536887312,16384,4210688,536887312,16,541065232,541065232,0,4210704,541081600,16400,4210688,541081600,536870912,536887296,16,541065232,4210688,541081616,4194304,16400,536870928,4194304,536887296,536870912,16400,536870928,541081616,4210688,541065216,4210704,541081600,0,541065232,16,16384,541065216,4210704,16384,4194320,536887312,0,541081600,536870912,4194320,536887312],spfunction7=[2097152,69206018,67110914,0,2048,67110914,2099202,69208064,69208066,2097152,0,67108866,2,67108864,69206018,2050,67110912,2099202,2097154,67110912,67108866,69206016,69208064,2097154,69206016,2048,2050,69208066,2099200,2,67108864,2099200,67108864,2099200,2097152,67110914,67110914,69206018,69206018,2,2097154,67108864,67110912,2097152,69208064,2050,2099202,69208064,2050,67108866,69208066,69206016,2099200,0,2,69208066,0,2099202,69206016,2048,67108866,67110912,2048,2097154],spfunction8=[268439616,4096,262144,268701760,268435456,268439616,64,268435456,262208,268697600,268701760,266240,268701696,266304,4096,64,268697600,268435520,268439552,4160,266240,262208,268697664,268701696,4160,0,0,268697664,268435520,268439552,266304,262144,266304,262144,268701696,4096,64,268697664,4096,266304,268439552,64,268435520,268697600,268697664,268435456,262144,268439616,0,268701760,262208,268435520,268697600,268439552,268439616,0,268701760,266240,266240,4160,4160,262208,268435456,268701696];function _createKeys(J){for(var E=[0,4,536870912,536870916,65536,65540,536936448,536936452,512,516,536871424,536871428,66048,66052,536936960,536936964],ee=[0,1,1048576,1048577,67108864,67108865,68157440,68157441,256,257,1048832,1048833,67109120,67109121,68157696,68157697],te=[0,8,2048,2056,16777216,16777224,16779264,16779272,0,8,2048,2056,16777216,16777224,16779264,16779272],re=[0,2097152,134217728,136314880,8192,2105344,134225920,136323072,131072,2228224,134348800,136445952,139264,2236416,134356992,136454144],ne=[0,262144,16,262160,0,262144,16,262160,4096,266240,4112,266256,4096,266240,4112,266256],ie=[0,1024,32,1056,0,1024,32,1056,33554432,33555456,33554464,33555488,33554432,33555456,33554464,33555488],se=[0,268435456,524288,268959744,2,268435458,524290,268959746,0,268435456,524288,268959744,2,268435458,524290,268959746],oe=[0,65536,2048,67584,536870912,536936448,536872960,536938496,131072,196608,133120,198656,537001984,537067520,537004032,537069568],ae=[0,262144,0,262144,2,262146,2,262146,33554432,33816576,33554432,33816576,33554434,33816578,33554434,33816578],ce=[0,268435456,8,268435464,0,268435456,8,268435464,1024,268436480,1032,268436488,1024,268436480,1032,268436488],le=[0,32,0,32,1048576,1048608,1048576,1048608,8192,8224,8192,8224,1056768,1056800,1056768,1056800],he=[0,16777216,512,16777728,2097152,18874368,2097664,18874880,67108864,83886080,67109376,83886592,69206016,85983232,69206528,85983744],de=[0,4096,134217728,134221824,524288,528384,134742016,134746112,16,4112,134217744,134221840,524304,528400,134742032,134746128],ue=[0,4,256,260,0,4,256,260,1,5,257,261,1,5,257,261],pe=J.length()>8?3:1,ye=[],me=[0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0],be=0,_e,we=0;we<pe;we++){var $e=J.getInt32(),ve=J.getInt32();_e=($e>>>4^ve)&252645135,ve^=_e,$e^=_e<<4,_e=(ve>>>-16^$e)&65535,$e^=_e,ve^=_e<<-16,_e=($e>>>2^ve)&858993459,ve^=_e,$e^=_e<<2,_e=(ve>>>-16^$e)&65535,$e^=_e,ve^=_e<<-16,_e=($e>>>1^ve)&1431655765,ve^=_e,$e^=_e<<1,_e=(ve>>>8^$e)&16711935,$e^=_e,ve^=_e<<8,_e=($e>>>1^ve)&1431655765,ve^=_e,$e^=_e<<1,_e=$e<<8|ve>>>20&240,$e=ve<<24|ve<<8&16711680|ve>>>8&65280|ve>>>24&240,ve=_e;for(var fe=0;fe<me.length;++fe){me[fe]?($e=$e<<2|$e>>>26,ve=ve<<2|ve>>>26):($e=$e<<1|$e>>>27,ve=ve<<1|ve>>>27),$e&=-15,ve&=-15;var Ee=E[$e>>>28]|ee[$e>>>24&15]|te[$e>>>20&15]|re[$e>>>16&15]|ne[$e>>>12&15]|ie[$e>>>8&15]|se[$e>>>4&15],ke=oe[ve>>>28]|ae[ve>>>24&15]|ce[ve>>>20&15]|le[ve>>>16&15]|he[ve>>>12&15]|de[ve>>>8&15]|ue[ve>>>4&15];_e=(ke>>>16^Ee)&65535,ye[be++]=Ee^_e,ye[be++]=ke^_e<<16}}return ye}function _updateBlock(J,E,ee,te){var re=J.length===32?3:9,ne;re===3?ne=te?[30,-2,-2]:[0,32,2]:ne=te?[94,62,-2,32,64,2,30,-2,-2]:[0,32,2,62,30,-2,64,96,2];var ie,se=E[0],oe=E[1];ie=(se>>>4^oe)&252645135,oe^=ie,se^=ie<<4,ie=(se>>>16^oe)&65535,oe^=ie,se^=ie<<16,ie=(oe>>>2^se)&858993459,se^=ie,oe^=ie<<2,ie=(oe>>>8^se)&16711935,se^=ie,oe^=ie<<8,ie=(se>>>1^oe)&1431655765,oe^=ie,se^=ie<<1,se=se<<1|se>>>31,oe=oe<<1|oe>>>31;for(var ae=0;ae<re;ae+=3){for(var ce=ne[ae+1],le=ne[ae+2],he=ne[ae];he!=ce;he+=le){var de=oe^J[he],ue=(oe>>>4|oe<<28)^J[he+1];ie=se,se=oe,oe=ie^(spfunction2[de>>>24&63]|spfunction4[de>>>16&63]|spfunction6[de>>>8&63]|spfunction8[de&63]|spfunction1[ue>>>24&63]|spfunction3[ue>>>16&63]|spfunction5[ue>>>8&63]|spfunction7[ue&63])}ie=se,se=oe,oe=ie}se=se>>>1|se<<31,oe=oe>>>1|oe<<31,ie=(se>>>1^oe)&1431655765,oe^=ie,se^=ie<<1,ie=(oe>>>8^se)&16711935,se^=ie,oe^=ie<<8,ie=(oe>>>2^se)&858993459,se^=ie,oe^=ie<<2,ie=(se>>>16^oe)&65535,oe^=ie,se^=ie<<16,ie=(se>>>4^oe)&252645135,oe^=ie,se^=ie<<4,ee[0]=se,ee[1]=oe}function _createCipher(J){J=J||{};var E=(J.mode||"CBC").toUpperCase(),ee="DES-"+E,te;J.decrypt?te=forge$f.cipher.createDecipher(ee,J.key):te=forge$f.cipher.createCipher(ee,J.key);var re=te.start;return te.start=function(ne,ie){var se=null;ie instanceof forge$f.util.ByteBuffer&&(se=ie,ie={}),ie=ie||{},ie.output=se,ie.iv=ne,re.call(te,ie)},te}var forge$e=forge$m;forge$e.md=forge$e.md||{};forge$e.md.algorithms=forge$e.md.algorithms||{};var forge$d=forge$m,hmac$1=forge$d.hmac=forge$d.hmac||{};hmac$1.create=function(){var J=null,E=null,ee=null,te=null,re={};return re.start=function(ne,ie){if(ne!==null)if(typeof ne=="string")if(ne=ne.toLowerCase(),ne in forge$d.md.algorithms)E=forge$d.md.algorithms[ne].create();else throw new Error('Unknown hash algorithm "'+ne+'"');else E=ne;if(ie===null)ie=J;else{if(typeof ie=="string")ie=forge$d.util.createBuffer(ie);else if(forge$d.util.isArray(ie)){var se=ie;ie=forge$d.util.createBuffer();for(var oe=0;oe<se.length;++oe)ie.putByte(se[oe])}var ae=ie.length();ae>E.blockLength&&(E.start(),E.update(ie.bytes()),ie=E.digest()),ee=forge$d.util.createBuffer(),te=forge$d.util.createBuffer(),ae=ie.length();for(var oe=0;oe<ae;++oe){var se=ie.at(oe);ee.putByte(54^se),te.putByte(92^se)}if(ae<E.blockLength)for(var se=E.blockLength-ae,oe=0;oe<se;++oe)ee.putByte(54),te.putByte(92);J=ie,ee=ee.bytes(),te=te.bytes()}E.start(),E.update(ee)},re.update=function(ne){E.update(ne)},re.getMac=function(){var ne=E.digest().bytes();return E.start(),E.update(te),E.update(ne),E.digest()},re.digest=re.getMac,re};var forge$c=forge$m,pkcs5=forge$c.pkcs5=forge$c.pkcs5||{},crypto$3;forge$c.util.isNodejs&&!forge$c.options.usePureJavaScript&&(crypto$3=require$$8);var pbkdf2$1=forge$c.pbkdf2=pkcs5.pbkdf2=function(J,E,ee,te,re,ne){if(typeof re=="function"&&(ne=re,re=null),forge$c.util.isNodejs&&!forge$c.options.usePureJavaScript&&crypto$3.pbkdf2&&(re===null||typeof re!="object")&&(crypto$3.pbkdf2Sync.length>4||!re||re==="sha1"))return typeof re!="string"&&(re="sha1"),J=Buffer.from(J,"binary"),E=Buffer.from(E,"binary"),ne?crypto$3.pbkdf2Sync.length===4?crypto$3.pbkdf2(J,E,ee,te,function(_e,we){if(_e)return ne(_e);ne(null,we.toString("binary"))}):crypto$3.pbkdf2(J,E,ee,te,re,function(_e,we){if(_e)return ne(_e);ne(null,we.toString("binary"))}):crypto$3.pbkdf2Sync.length===4?crypto$3.pbkdf2Sync(J,E,ee,te).toString("binary"):crypto$3.pbkdf2Sync(J,E,ee,te,re).toString("binary");if((typeof re>"u"||re===null)&&(re="sha1"),typeof re=="string"){if(!(re in forge$c.md.algorithms))throw new Error("Unknown hash algorithm: "+re);re=forge$c.md[re].create()}var ie=re.digestLength;if(te>4294967295*ie){var se=new Error("Derived key is too long.");if(ne)return ne(se);throw se}var oe=Math.ceil(te/ie),ae=te-(oe-1)*ie,ce=forge$c.hmac.create();ce.start(re,J);var le="",he,de,ue;if(!ne){for(var pe=1;pe<=oe;++pe){ce.start(null,null),ce.update(E),ce.update(forge$c.util.int32ToBytes(pe)),he=ue=ce.digest().getBytes();for(var ye=2;ye<=ee;++ye)ce.start(null,null),ce.update(ue),de=ce.digest().getBytes(),he=forge$c.util.xorBytes(he,de,ie),ue=de;le+=pe<oe?he:he.substr(0,ae)}return le}var pe=1,ye;function me(){if(pe>oe)return ne(null,le);ce.start(null,null),ce.update(E),ce.update(forge$c.util.int32ToBytes(pe)),he=ue=ce.digest().getBytes(),ye=2,be()}function be(){if(ye<=ee)return ce.start(null,null),ce.update(ue),de=ce.digest().getBytes(),he=forge$c.util.xorBytes(he,de,ie),ue=de,++ye,forge$c.util.setImmediate(be);le+=pe<oe?he:he.substr(0,ae),++pe,me()}me()};const forgePbkdf2=getDefaultExportFromCjs(pbkdf2$1);var forge$b=forge$m,pem=forge$b.pem=forge$b.pem||{};pem.encode=function(J,E){E=E||{};var ee="-----BEGIN "+J.type+`-----\r
`,te;if(J.procType&&(te={name:"Proc-Type",values:[String(J.procType.version),J.procType.type]},ee+=foldHeader(te)),J.contentDomain&&(te={name:"Content-Domain",values:[J.contentDomain]},ee+=foldHeader(te)),J.dekInfo&&(te={name:"DEK-Info",values:[J.dekInfo.algorithm]},J.dekInfo.parameters&&te.values.push(J.dekInfo.parameters),ee+=foldHeader(te)),J.headers)for(var re=0;re<J.headers.length;++re)ee+=foldHeader(J.headers[re]);return J.procType&&(ee+=`\r
`),ee+=forge$b.util.encode64(J.body,E.maxline||64)+`\r
`,ee+="-----END "+J.type+`-----\r
`,ee};pem.decode=function(J){for(var E=[],ee=/\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g,te=/([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/,re=/\r?\n/,ne;ne=ee.exec(J),!!ne;){var ie=ne[1];ie==="NEW CERTIFICATE REQUEST"&&(ie="CERTIFICATE REQUEST");var se={type:ie,procType:null,contentDomain:null,dekInfo:null,headers:[],body:forge$b.util.decode64(ne[3])};if(E.push(se),!!ne[2]){for(var oe=ne[2].split(re),ae=0;ne&&ae<oe.length;){for(var ce=oe[ae].replace(/\s+$/,""),le=ae+1;le<oe.length;++le){var he=oe[le];if(!/\s/.test(he[0]))break;ce+=he,ae=le}if(ne=ce.match(te),ne){for(var de={name:ne[1],values:[]},ue=ne[2].split(","),pe=0;pe<ue.length;++pe)de.values.push(ltrim(ue[pe]));if(se.procType)if(!se.contentDomain&&de.name==="Content-Domain")se.contentDomain=ue[0]||"";else if(!se.dekInfo&&de.name==="DEK-Info"){if(de.values.length===0)throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');se.dekInfo={algorithm:ue[0],parameters:ue[1]||null}}else se.headers.push(de);else{if(de.name!=="Proc-Type")throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');if(de.values.length!==2)throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');se.procType={version:ue[0],type:ue[1]}}}++ae}if(se.procType==="ENCRYPTED"&&!se.dekInfo)throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".')}}if(E.length===0)throw new Error("Invalid PEM formatted message.");return E};function foldHeader(J){for(var E=J.name+": ",ee=[],te=function(oe,ae){return" "+ae},re=0;re<J.values.length;++re)ee.push(J.values[re].replace(/^(\S+\r\n)/,te));E+=ee.join(",")+`\r
`;for(var ne=0,ie=-1,re=0;re<E.length;++re,++ne)if(ne>65&&ie!==-1){var se=E[ie];se===","?(++ie,E=E.substr(0,ie)+`\r
 `+E.substr(ie)):E=E.substr(0,ie)+`\r
`+se+E.substr(ie+1),ne=re-ie-1,ie=-1,++re}else(E[re]===" "||E[re]==="	"||E[re]===",")&&(ie=re);return E}function ltrim(J){return J.replace(/^\s+/,"")}var forge$a=forge$m,sha256$1=forge$a.sha256=forge$a.sha256||{};forge$a.md.sha256=forge$a.md.algorithms.sha256=sha256$1;sha256$1.create=function(){_initialized$2||_init$2();var J=null,E=forge$a.util.createBuffer(),ee=new Array(64),te={algorithm:"sha256",blockLength:64,digestLength:32,messageLength:0,fullMessageLength:null,messageLengthSize:8};return te.start=function(){te.messageLength=0,te.fullMessageLength=te.messageLength64=[];for(var re=te.messageLengthSize/4,ne=0;ne<re;++ne)te.fullMessageLength.push(0);return E=forge$a.util.createBuffer(),J={h0:1779033703,h1:3144134277,h2:1013904242,h3:2773480762,h4:1359893119,h5:2600822924,h6:528734635,h7:1541459225},te},te.start(),te.update=function(re,ne){ne==="utf8"&&(re=forge$a.util.encodeUtf8(re));var ie=re.length;te.messageLength+=ie,ie=[ie/4294967296>>>0,ie>>>0];for(var se=te.fullMessageLength.length-1;se>=0;--se)te.fullMessageLength[se]+=ie[1],ie[1]=ie[0]+(te.fullMessageLength[se]/4294967296>>>0),te.fullMessageLength[se]=te.fullMessageLength[se]>>>0,ie[0]=ie[1]/4294967296>>>0;return E.putBytes(re),_update$2(J,ee,E),(E.read>2048||E.length()===0)&&E.compact(),te},te.digest=function(){var re=forge$a.util.createBuffer();re.putBytes(E.bytes());var ne=te.fullMessageLength[te.fullMessageLength.length-1]+te.messageLengthSize,ie=ne&te.blockLength-1;re.putBytes(_padding$2.substr(0,te.blockLength-ie));for(var se,oe,ae=te.fullMessageLength[0]*8,ce=0;ce<te.fullMessageLength.length-1;++ce)se=te.fullMessageLength[ce+1]*8,oe=se/4294967296>>>0,ae+=oe,re.putInt32(ae>>>0),ae=se>>>0;re.putInt32(ae);var le={h0:J.h0,h1:J.h1,h2:J.h2,h3:J.h3,h4:J.h4,h5:J.h5,h6:J.h6,h7:J.h7};_update$2(le,ee,re);var he=forge$a.util.createBuffer();return he.putInt32(le.h0),he.putInt32(le.h1),he.putInt32(le.h2),he.putInt32(le.h3),he.putInt32(le.h4),he.putInt32(le.h5),he.putInt32(le.h6),he.putInt32(le.h7),he},te};var _padding$2=null,_initialized$2=!1,_k$1=null;function _init$2(){_padding$2=String.fromCharCode(128),_padding$2+=forge$a.util.fillString(String.fromCharCode(0),64),_k$1=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298],_initialized$2=!0}function _update$2(J,E,ee){for(var te,re,ne,ie,se,oe,ae,ce,le,he,de,ue,pe,ye,me,be=ee.length();be>=64;){for(ae=0;ae<16;++ae)E[ae]=ee.getInt32();for(;ae<64;++ae)te=E[ae-2],te=(te>>>17|te<<15)^(te>>>19|te<<13)^te>>>10,re=E[ae-15],re=(re>>>7|re<<25)^(re>>>18|re<<14)^re>>>3,E[ae]=te+E[ae-7]+re+E[ae-16]|0;for(ce=J.h0,le=J.h1,he=J.h2,de=J.h3,ue=J.h4,pe=J.h5,ye=J.h6,me=J.h7,ae=0;ae<64;++ae)ie=(ue>>>6|ue<<26)^(ue>>>11|ue<<21)^(ue>>>25|ue<<7),se=ye^ue&(pe^ye),ne=(ce>>>2|ce<<30)^(ce>>>13|ce<<19)^(ce>>>22|ce<<10),oe=ce&le|he&(ce^le),te=me+ie+se+_k$1[ae]+E[ae],re=ne+oe,me=ye,ye=pe,pe=ue,ue=de+te>>>0,de=he,he=le,le=ce,ce=te+re>>>0;J.h0=J.h0+ce|0,J.h1=J.h1+le|0,J.h2=J.h2+he|0,J.h3=J.h3+de|0,J.h4=J.h4+ue|0,J.h5=J.h5+pe|0,J.h6=J.h6+ye|0,J.h7=J.h7+me|0,be-=64}}var forge$9=forge$m,_crypto$1=null;forge$9.util.isNodejs&&!forge$9.options.usePureJavaScript&&!process.versions["node-webkit"]&&(_crypto$1=require$$8);var prng=forge$9.prng=forge$9.prng||{};prng.create=function(J){for(var E={plugin:J,key:null,seed:null,time:null,reseeds:0,generated:0,keyBytes:""},ee=J.md,te=new Array(32),re=0;re<32;++re)te[re]=ee.create();E.pools=te,E.pool=0,E.generate=function(ae,ce){if(!ce)return E.generateSync(ae);var le=E.plugin.cipher,he=E.plugin.increment,de=E.plugin.formatKey,ue=E.plugin.formatSeed,pe=forge$9.util.createBuffer();E.key=null,ye();function ye(me){if(me)return ce(me);if(pe.length()>=ae)return ce(null,pe.getBytes(ae));if(E.generated>1048575&&(E.key=null),E.key===null)return forge$9.util.nextTick(function(){ne(ye)});var be=le(E.key,E.seed);E.generated+=be.length,pe.putBytes(be),E.key=de(le(E.key,he(E.seed))),E.seed=ue(le(E.key,E.seed)),forge$9.util.setImmediate(ye)}},E.generateSync=function(ae){var ce=E.plugin.cipher,le=E.plugin.increment,he=E.plugin.formatKey,de=E.plugin.formatSeed;E.key=null;for(var ue=forge$9.util.createBuffer();ue.length()<ae;){E.generated>1048575&&(E.key=null),E.key===null&&ie();var pe=ce(E.key,E.seed);E.generated+=pe.length,ue.putBytes(pe),E.key=he(ce(E.key,le(E.seed))),E.seed=de(ce(E.key,E.seed))}return ue.getBytes(ae)};function ne(ae){if(E.pools[0].messageLength>=32)return se(),ae();var ce=32-E.pools[0].messageLength<<5;E.seedFile(ce,function(le,he){if(le)return ae(le);E.collect(he),se(),ae()})}function ie(){if(E.pools[0].messageLength>=32)return se();var ae=32-E.pools[0].messageLength<<5;E.collect(E.seedFileSync(ae)),se()}function se(){E.reseeds=E.reseeds===4294967295?0:E.reseeds+1;var ae=E.plugin.md.create();ae.update(E.keyBytes);for(var ce=1,le=0;le<32;++le)E.reseeds%ce===0&&(ae.update(E.pools[le].digest().getBytes()),E.pools[le].start()),ce=ce<<1;E.keyBytes=ae.digest().getBytes(),ae.start(),ae.update(E.keyBytes);var he=ae.digest().getBytes();E.key=E.plugin.formatKey(E.keyBytes),E.seed=E.plugin.formatSeed(he),E.generated=0}function oe(ae){var ce=null,le=forge$9.util.globalScope,he=le.crypto||le.msCrypto;he&&he.getRandomValues&&(ce=function($e){return he.getRandomValues($e)});var de=forge$9.util.createBuffer();if(ce)for(;de.length()<ae;){var ue=Math.max(1,Math.min(ae-de.length(),65536)/4),pe=new Uint32Array(Math.floor(ue));try{ce(pe);for(var ye=0;ye<pe.length;++ye)de.putInt32(pe[ye])}catch($e){if(!(typeof QuotaExceededError<"u"&&$e instanceof QuotaExceededError))throw $e}}if(de.length()<ae)for(var me,be,_e,we=Math.floor(Math.random()*65536);de.length()<ae;){be=16807*(we&65535),me=16807*(we>>16),be+=(me&32767)<<16,be+=me>>15,be=(be&2147483647)+(be>>31),we=be&4294967295;for(var ye=0;ye<3;++ye)_e=we>>>(ye<<3),_e^=Math.floor(Math.random()*256),de.putByte(_e&255)}return de.getBytes(ae)}return _crypto$1?(E.seedFile=function(ae,ce){_crypto$1.randomBytes(ae,function(le,he){if(le)return ce(le);ce(null,he.toString())})},E.seedFileSync=function(ae){return _crypto$1.randomBytes(ae).toString()}):(E.seedFile=function(ae,ce){try{ce(null,oe(ae))}catch(le){ce(le)}},E.seedFileSync=oe),E.collect=function(ae){for(var ce=ae.length,le=0;le<ce;++le)E.pools[E.pool].update(ae.substr(le,1)),E.pool=E.pool===31?0:E.pool+1},E.collectInt=function(ae,ce){for(var le="",he=0;he<ce;he+=8)le+=String.fromCharCode(ae>>he&255);E.collect(le)},E.registerWorker=function(ae){if(ae===self)E.seedFile=function(le,he){function de(ue){var pe=ue.data;pe.forge&&pe.forge.prng&&(self.removeEventListener("message",de),he(pe.forge.prng.err,pe.forge.prng.bytes))}self.addEventListener("message",de),self.postMessage({forge:{prng:{needed:le}}})};else{var ce=function(le){var he=le.data;he.forge&&he.forge.prng&&E.seedFile(he.forge.prng.needed,function(de,ue){ae.postMessage({forge:{prng:{err:de,bytes:ue}}})})};ae.addEventListener("message",ce)}},E};var forge$8=forge$m;(function(){if(forge$8.random&&forge$8.random.getBytes){forge$8.random;return}(function(J){var E={},ee=new Array(4),te=forge$8.util.createBuffer();E.formatKey=function(le){var he=forge$8.util.createBuffer(le);return le=new Array(4),le[0]=he.getInt32(),le[1]=he.getInt32(),le[2]=he.getInt32(),le[3]=he.getInt32(),forge$8.aes._expandKey(le,!1)},E.formatSeed=function(le){var he=forge$8.util.createBuffer(le);return le=new Array(4),le[0]=he.getInt32(),le[1]=he.getInt32(),le[2]=he.getInt32(),le[3]=he.getInt32(),le},E.cipher=function(le,he){return forge$8.aes._updateBlock(le,he,ee,!1),te.putInt32(ee[0]),te.putInt32(ee[1]),te.putInt32(ee[2]),te.putInt32(ee[3]),te.getBytes()},E.increment=function(le){return++le[3],le},E.md=forge$8.md.sha256;function re(){var le=forge$8.prng.create(E);return le.getBytes=function(he,de){return le.generate(he,de)},le.getBytesSync=function(he){return le.generate(he)},le}var ne=re(),ie=null,se=forge$8.util.globalScope,oe=se.crypto||se.msCrypto;if(oe&&oe.getRandomValues&&(ie=function(le){return oe.getRandomValues(le)}),forge$8.options.usePureJavaScript||!forge$8.util.isNodejs&&!ie){if(ne.collectInt(+new Date,32),typeof navigator<"u"){var ae="";for(var ce in navigator)try{typeof navigator[ce]=="string"&&(ae+=navigator[ce])}catch{}ne.collect(ae),ae=null}J&&(J().mousemove(function(le){ne.collectInt(le.clientX,16),ne.collectInt(le.clientY,16)}),J().keypress(function(le){ne.collectInt(le.charCode,8)}))}if(!forge$8.random)forge$8.random=ne;else for(var ce in ne)forge$8.random[ce]=ne[ce];forge$8.random.createInstance=re,forge$8.random})(typeof jQuery<"u"?jQuery:null)})();var forge$7=forge$m,piTable=[217,120,249,196,25,221,181,237,40,233,253,121,74,160,216,157,198,126,55,131,43,118,83,142,98,76,100,136,68,139,251,162,23,154,89,245,135,179,79,19,97,69,109,141,9,129,125,50,189,143,64,235,134,183,123,11,240,149,33,34,92,107,78,130,84,214,101,147,206,96,178,28,115,86,192,20,167,140,241,220,18,117,202,31,59,190,228,209,66,61,212,48,163,60,182,38,111,191,14,218,70,105,7,87,39,242,29,155,188,148,67,3,248,17,199,246,144,239,62,231,6,195,213,47,200,102,30,215,8,232,234,222,128,82,238,247,132,170,114,172,53,77,106,42,150,26,210,113,90,21,73,116,75,159,208,94,4,24,164,236,194,224,65,110,15,81,203,204,36,145,175,80,161,244,112,57,153,124,58,133,35,184,180,122,252,2,54,91,37,85,151,49,45,93,250,152,227,138,146,174,5,223,41,16,103,108,186,201,211,0,230,207,225,158,168,44,99,22,1,63,88,226,137,169,13,56,52,27,171,51,255,176,187,72,12,95,185,177,205,46,197,243,219,71,229,165,156,119,10,166,32,104,254,127,193,173],s=[1,2,3,5],rol=function(J,E){return J<<E&65535|(J&65535)>>16-E},ror=function(J,E){return(J&65535)>>E|J<<16-E&65535};forge$7.rc2=forge$7.rc2||{};forge$7.rc2.expandKey=function(J,E){typeof J=="string"&&(J=forge$7.util.createBuffer(J)),E=E||128;var ee=J,te=J.length(),re=E,ne=Math.ceil(re/8),ie=255>>(re&7),se;for(se=te;se<128;se++)ee.putByte(piTable[ee.at(se-1)+ee.at(se-te)&255]);for(ee.setAt(128-ne,piTable[ee.at(128-ne)&ie]),se=127-ne;se>=0;se--)ee.setAt(se,piTable[ee.at(se+1)^ee.at(se+ne)]);return ee};var createCipher=function(J,E,ee){var te=!1,re=null,ne=null,ie=null,se,oe,ae,ce,le=[];for(J=forge$7.rc2.expandKey(J,E),ae=0;ae<64;ae++)le.push(J.getInt16Le());ee?(se=function(ue){for(ae=0;ae<4;ae++)ue[ae]+=le[ce]+(ue[(ae+3)%4]&ue[(ae+2)%4])+(~ue[(ae+3)%4]&ue[(ae+1)%4]),ue[ae]=rol(ue[ae],s[ae]),ce++},oe=function(ue){for(ae=0;ae<4;ae++)ue[ae]+=le[ue[(ae+3)%4]&63]}):(se=function(ue){for(ae=3;ae>=0;ae--)ue[ae]=ror(ue[ae],s[ae]),ue[ae]-=le[ce]+(ue[(ae+3)%4]&ue[(ae+2)%4])+(~ue[(ae+3)%4]&ue[(ae+1)%4]),ce--},oe=function(ue){for(ae=3;ae>=0;ae--)ue[ae]-=le[ue[(ae+3)%4]&63]});var he=function(ue){var pe=[];for(ae=0;ae<4;ae++){var ye=re.getInt16Le();ie!==null&&(ee?ye^=ie.getInt16Le():ie.putInt16Le(ye)),pe.push(ye&65535)}ce=ee?0:63;for(var me=0;me<ue.length;me++)for(var be=0;be<ue[me][0];be++)ue[me][1](pe);for(ae=0;ae<4;ae++)ie!==null&&(ee?ie.putInt16Le(pe[ae]):pe[ae]^=ie.getInt16Le()),ne.putInt16Le(pe[ae])},de=null;return de={start:function(ue,pe){ue&&typeof ue=="string"&&(ue=forge$7.util.createBuffer(ue)),te=!1,re=forge$7.util.createBuffer(),ne=pe||new forge$7.util.createBuffer,ie=ue,de.output=ne},update:function(ue){for(te||re.putBuffer(ue);re.length()>=8;)he([[5,se],[1,oe],[6,se],[1,oe],[5,se]])},finish:function(ue){var pe=!0;if(ee)if(ue)pe=ue(8,re,!ee);else{var ye=re.length()===8?8:8-re.length();re.fillWithByte(ye,ye)}if(pe&&(te=!0,de.update()),!ee&&(pe=re.length()===0,pe))if(ue)pe=ue(8,ne,!ee);else{var me=ne.length(),be=ne.at(me-1);be>me?pe=!1:ne.truncate(be)}return pe}},de};forge$7.rc2.startEncrypting=function(J,E,ee){var te=forge$7.rc2.createEncryptionCipher(J,128);return te.start(E,ee),te};forge$7.rc2.createEncryptionCipher=function(J,E){return createCipher(J,E,!0)};forge$7.rc2.startDecrypting=function(J,E,ee){var te=forge$7.rc2.createDecryptionCipher(J,128);return te.start(E,ee),te};forge$7.rc2.createDecryptionCipher=function(J,E){return createCipher(J,E,!1)};var forge$6=forge$m;forge$6.jsbn=forge$6.jsbn||{};var dbits;function BigInteger$2(J,E,ee){this.data=[],J!=null&&(typeof J=="number"?this.fromNumber(J,E,ee):E==null&&typeof J!="string"?this.fromString(J,256):this.fromString(J,E))}forge$6.jsbn.BigInteger=BigInteger$2;function nbi(){return new BigInteger$2(null)}function am1(J,E,ee,te,re,ne){for(;--ne>=0;){var ie=E*this.data[J++]+ee.data[te]+re;re=Math.floor(ie/67108864),ee.data[te++]=ie&67108863}return re}function am2(J,E,ee,te,re,ne){for(var ie=E&32767,se=E>>15;--ne>=0;){var oe=this.data[J]&32767,ae=this.data[J++]>>15,ce=se*oe+ae*ie;oe=ie*oe+((ce&32767)<<15)+ee.data[te]+(re&1073741823),re=(oe>>>30)+(ce>>>15)+se*ae+(re>>>30),ee.data[te++]=oe&1073741823}return re}function am3(J,E,ee,te,re,ne){for(var ie=E&16383,se=E>>14;--ne>=0;){var oe=this.data[J]&16383,ae=this.data[J++]>>14,ce=se*oe+ae*ie;oe=ie*oe+((ce&16383)<<14)+ee.data[te]+re,re=(oe>>28)+(ce>>14)+se*ae,ee.data[te++]=oe&268435455}return re}typeof navigator>"u"?(BigInteger$2.prototype.am=am3,dbits=28):navigator.appName=="Microsoft Internet Explorer"?(BigInteger$2.prototype.am=am2,dbits=30):navigator.appName!="Netscape"?(BigInteger$2.prototype.am=am1,dbits=26):(BigInteger$2.prototype.am=am3,dbits=28);BigInteger$2.prototype.DB=dbits;BigInteger$2.prototype.DM=(1<<dbits)-1;BigInteger$2.prototype.DV=1<<dbits;var BI_FP=52;BigInteger$2.prototype.FV=Math.pow(2,BI_FP);BigInteger$2.prototype.F1=BI_FP-dbits;BigInteger$2.prototype.F2=2*dbits-BI_FP;var BI_RM="0123456789abcdefghijklmnopqrstuvwxyz",BI_RC=new Array,rr,vv;rr="0".charCodeAt(0);for(vv=0;vv<=9;++vv)BI_RC[rr++]=vv;rr="a".charCodeAt(0);for(vv=10;vv<36;++vv)BI_RC[rr++]=vv;rr="A".charCodeAt(0);for(vv=10;vv<36;++vv)BI_RC[rr++]=vv;function int2char(J){return BI_RM.charAt(J)}function intAt(J,E){var ee=BI_RC[J.charCodeAt(E)];return ee??-1}function bnpCopyTo(J){for(var E=this.t-1;E>=0;--E)J.data[E]=this.data[E];J.t=this.t,J.s=this.s}function bnpFromInt(J){this.t=1,this.s=J<0?-1:0,J>0?this.data[0]=J:J<-1?this.data[0]=J+this.DV:this.t=0}function nbv(J){var E=nbi();return E.fromInt(J),E}function bnpFromString(J,E){var ee;if(E==16)ee=4;else if(E==8)ee=3;else if(E==256)ee=8;else if(E==2)ee=1;else if(E==32)ee=5;else if(E==4)ee=2;else{this.fromRadix(J,E);return}this.t=0,this.s=0;for(var te=J.length,re=!1,ne=0;--te>=0;){var ie=ee==8?J[te]&255:intAt(J,te);if(ie<0){J.charAt(te)=="-"&&(re=!0);continue}re=!1,ne==0?this.data[this.t++]=ie:ne+ee>this.DB?(this.data[this.t-1]|=(ie&(1<<this.DB-ne)-1)<<ne,this.data[this.t++]=ie>>this.DB-ne):this.data[this.t-1]|=ie<<ne,ne+=ee,ne>=this.DB&&(ne-=this.DB)}ee==8&&J[0]&128&&(this.s=-1,ne>0&&(this.data[this.t-1]|=(1<<this.DB-ne)-1<<ne)),this.clamp(),re&&BigInteger$2.ZERO.subTo(this,this)}function bnpClamp(){for(var J=this.s&this.DM;this.t>0&&this.data[this.t-1]==J;)--this.t}function bnToString(J){if(this.s<0)return"-"+this.negate().toString(J);var E;if(J==16)E=4;else if(J==8)E=3;else if(J==2)E=1;else if(J==32)E=5;else if(J==4)E=2;else return this.toRadix(J);var ee=(1<<E)-1,te,re=!1,ne="",ie=this.t,se=this.DB-ie*this.DB%E;if(ie-- >0)for(se<this.DB&&(te=this.data[ie]>>se)>0&&(re=!0,ne=int2char(te));ie>=0;)se<E?(te=(this.data[ie]&(1<<se)-1)<<E-se,te|=this.data[--ie]>>(se+=this.DB-E)):(te=this.data[ie]>>(se-=E)&ee,se<=0&&(se+=this.DB,--ie)),te>0&&(re=!0),re&&(ne+=int2char(te));return re?ne:"0"}function bnNegate(){var J=nbi();return BigInteger$2.ZERO.subTo(this,J),J}function bnAbs(){return this.s<0?this.negate():this}function bnCompareTo(J){var E=this.s-J.s;if(E!=0)return E;var ee=this.t;if(E=ee-J.t,E!=0)return this.s<0?-E:E;for(;--ee>=0;)if((E=this.data[ee]-J.data[ee])!=0)return E;return 0}function nbits(J){var E=1,ee;return(ee=J>>>16)!=0&&(J=ee,E+=16),(ee=J>>8)!=0&&(J=ee,E+=8),(ee=J>>4)!=0&&(J=ee,E+=4),(ee=J>>2)!=0&&(J=ee,E+=2),(ee=J>>1)!=0&&(J=ee,E+=1),E}function bnBitLength(){return this.t<=0?0:this.DB*(this.t-1)+nbits(this.data[this.t-1]^this.s&this.DM)}function bnpDLShiftTo(J,E){var ee;for(ee=this.t-1;ee>=0;--ee)E.data[ee+J]=this.data[ee];for(ee=J-1;ee>=0;--ee)E.data[ee]=0;E.t=this.t+J,E.s=this.s}function bnpDRShiftTo(J,E){for(var ee=J;ee<this.t;++ee)E.data[ee-J]=this.data[ee];E.t=Math.max(this.t-J,0),E.s=this.s}function bnpLShiftTo(J,E){var ee=J%this.DB,te=this.DB-ee,re=(1<<te)-1,ne=Math.floor(J/this.DB),ie=this.s<<ee&this.DM,se;for(se=this.t-1;se>=0;--se)E.data[se+ne+1]=this.data[se]>>te|ie,ie=(this.data[se]&re)<<ee;for(se=ne-1;se>=0;--se)E.data[se]=0;E.data[ne]=ie,E.t=this.t+ne+1,E.s=this.s,E.clamp()}function bnpRShiftTo(J,E){E.s=this.s;var ee=Math.floor(J/this.DB);if(ee>=this.t){E.t=0;return}var te=J%this.DB,re=this.DB-te,ne=(1<<te)-1;E.data[0]=this.data[ee]>>te;for(var ie=ee+1;ie<this.t;++ie)E.data[ie-ee-1]|=(this.data[ie]&ne)<<re,E.data[ie-ee]=this.data[ie]>>te;te>0&&(E.data[this.t-ee-1]|=(this.s&ne)<<re),E.t=this.t-ee,E.clamp()}function bnpSubTo(J,E){for(var ee=0,te=0,re=Math.min(J.t,this.t);ee<re;)te+=this.data[ee]-J.data[ee],E.data[ee++]=te&this.DM,te>>=this.DB;if(J.t<this.t){for(te-=J.s;ee<this.t;)te+=this.data[ee],E.data[ee++]=te&this.DM,te>>=this.DB;te+=this.s}else{for(te+=this.s;ee<J.t;)te-=J.data[ee],E.data[ee++]=te&this.DM,te>>=this.DB;te-=J.s}E.s=te<0?-1:0,te<-1?E.data[ee++]=this.DV+te:te>0&&(E.data[ee++]=te),E.t=ee,E.clamp()}function bnpMultiplyTo(J,E){var ee=this.abs(),te=J.abs(),re=ee.t;for(E.t=re+te.t;--re>=0;)E.data[re]=0;for(re=0;re<te.t;++re)E.data[re+ee.t]=ee.am(0,te.data[re],E,re,0,ee.t);E.s=0,E.clamp(),this.s!=J.s&&BigInteger$2.ZERO.subTo(E,E)}function bnpSquareTo(J){for(var E=this.abs(),ee=J.t=2*E.t;--ee>=0;)J.data[ee]=0;for(ee=0;ee<E.t-1;++ee){var te=E.am(ee,E.data[ee],J,2*ee,0,1);(J.data[ee+E.t]+=E.am(ee+1,2*E.data[ee],J,2*ee+1,te,E.t-ee-1))>=E.DV&&(J.data[ee+E.t]-=E.DV,J.data[ee+E.t+1]=1)}J.t>0&&(J.data[J.t-1]+=E.am(ee,E.data[ee],J,2*ee,0,1)),J.s=0,J.clamp()}function bnpDivRemTo(J,E,ee){var te=J.abs();if(!(te.t<=0)){var re=this.abs();if(re.t<te.t){E?.fromInt(0),ee!=null&&this.copyTo(ee);return}ee==null&&(ee=nbi());var ne=nbi(),ie=this.s,se=J.s,oe=this.DB-nbits(te.data[te.t-1]);oe>0?(te.lShiftTo(oe,ne),re.lShiftTo(oe,ee)):(te.copyTo(ne),re.copyTo(ee));var ae=ne.t,ce=ne.data[ae-1];if(ce!=0){var le=ce*(1<<this.F1)+(ae>1?ne.data[ae-2]>>this.F2:0),he=this.FV/le,de=(1<<this.F1)/le,ue=1<<this.F2,pe=ee.t,ye=pe-ae,me=E??nbi();for(ne.dlShiftTo(ye,me),ee.compareTo(me)>=0&&(ee.data[ee.t++]=1,ee.subTo(me,ee)),BigInteger$2.ONE.dlShiftTo(ae,me),me.subTo(ne,ne);ne.t<ae;)ne.data[ne.t++]=0;for(;--ye>=0;){var be=ee.data[--pe]==ce?this.DM:Math.floor(ee.data[pe]*he+(ee.data[pe-1]+ue)*de);if((ee.data[pe]+=ne.am(0,be,ee,ye,0,ae))<be)for(ne.dlShiftTo(ye,me),ee.subTo(me,ee);ee.data[pe]<--be;)ee.subTo(me,ee)}E!=null&&(ee.drShiftTo(ae,E),ie!=se&&BigInteger$2.ZERO.subTo(E,E)),ee.t=ae,ee.clamp(),oe>0&&ee.rShiftTo(oe,ee),ie<0&&BigInteger$2.ZERO.subTo(ee,ee)}}}function bnMod(J){var E=nbi();return this.abs().divRemTo(J,null,E),this.s<0&&E.compareTo(BigInteger$2.ZERO)>0&&J.subTo(E,E),E}function Classic(J){this.m=J}function cConvert(J){return J.s<0||J.compareTo(this.m)>=0?J.mod(this.m):J}function cRevert(J){return J}function cReduce(J){J.divRemTo(this.m,null,J)}function cMulTo(J,E,ee){J.multiplyTo(E,ee),this.reduce(ee)}function cSqrTo(J,E){J.squareTo(E),this.reduce(E)}Classic.prototype.convert=cConvert;Classic.prototype.revert=cRevert;Classic.prototype.reduce=cReduce;Classic.prototype.mulTo=cMulTo;Classic.prototype.sqrTo=cSqrTo;function bnpInvDigit(){if(this.t<1)return 0;var J=this.data[0];if(!(J&1))return 0;var E=J&3;return E=E*(2-(J&15)*E)&15,E=E*(2-(J&255)*E)&255,E=E*(2-((J&65535)*E&65535))&65535,E=E*(2-J*E%this.DV)%this.DV,E>0?this.DV-E:-E}function Montgomery(J){this.m=J,this.mp=J.invDigit(),this.mpl=this.mp&32767,this.mph=this.mp>>15,this.um=(1<<J.DB-15)-1,this.mt2=2*J.t}function montConvert(J){var E=nbi();return J.abs().dlShiftTo(this.m.t,E),E.divRemTo(this.m,null,E),J.s<0&&E.compareTo(BigInteger$2.ZERO)>0&&this.m.subTo(E,E),E}function montRevert(J){var E=nbi();return J.copyTo(E),this.reduce(E),E}function montReduce(J){for(;J.t<=this.mt2;)J.data[J.t++]=0;for(var E=0;E<this.m.t;++E){var ee=J.data[E]&32767,te=ee*this.mpl+((ee*this.mph+(J.data[E]>>15)*this.mpl&this.um)<<15)&J.DM;for(ee=E+this.m.t,J.data[ee]+=this.m.am(0,te,J,E,0,this.m.t);J.data[ee]>=J.DV;)J.data[ee]-=J.DV,J.data[++ee]++}J.clamp(),J.drShiftTo(this.m.t,J),J.compareTo(this.m)>=0&&J.subTo(this.m,J)}function montSqrTo(J,E){J.squareTo(E),this.reduce(E)}function montMulTo(J,E,ee){J.multiplyTo(E,ee),this.reduce(ee)}Montgomery.prototype.convert=montConvert;Montgomery.prototype.revert=montRevert;Montgomery.prototype.reduce=montReduce;Montgomery.prototype.mulTo=montMulTo;Montgomery.prototype.sqrTo=montSqrTo;function bnpIsEven(){return(this.t>0?this.data[0]&1:this.s)==0}function bnpExp(J,E){if(J>4294967295||J<1)return BigInteger$2.ONE;var ee=nbi(),te=nbi(),re=E.convert(this),ne=nbits(J)-1;for(re.copyTo(ee);--ne>=0;)if(E.sqrTo(ee,te),(J&1<<ne)>0)E.mulTo(te,re,ee);else{var ie=ee;ee=te,te=ie}return E.revert(ee)}function bnModPowInt(J,E){var ee;return J<256||E.isEven()?ee=new Classic(E):ee=new Montgomery(E),this.exp(J,ee)}BigInteger$2.prototype.copyTo=bnpCopyTo;BigInteger$2.prototype.fromInt=bnpFromInt;BigInteger$2.prototype.fromString=bnpFromString;BigInteger$2.prototype.clamp=bnpClamp;BigInteger$2.prototype.dlShiftTo=bnpDLShiftTo;BigInteger$2.prototype.drShiftTo=bnpDRShiftTo;BigInteger$2.prototype.lShiftTo=bnpLShiftTo;BigInteger$2.prototype.rShiftTo=bnpRShiftTo;BigInteger$2.prototype.subTo=bnpSubTo;BigInteger$2.prototype.multiplyTo=bnpMultiplyTo;BigInteger$2.prototype.squareTo=bnpSquareTo;BigInteger$2.prototype.divRemTo=bnpDivRemTo;BigInteger$2.prototype.invDigit=bnpInvDigit;BigInteger$2.prototype.isEven=bnpIsEven;BigInteger$2.prototype.exp=bnpExp;BigInteger$2.prototype.toString=bnToString;BigInteger$2.prototype.negate=bnNegate;BigInteger$2.prototype.abs=bnAbs;BigInteger$2.prototype.compareTo=bnCompareTo;BigInteger$2.prototype.bitLength=bnBitLength;BigInteger$2.prototype.mod=bnMod;BigInteger$2.prototype.modPowInt=bnModPowInt;BigInteger$2.ZERO=nbv(0);BigInteger$2.ONE=nbv(1);function bnClone(){var J=nbi();return this.copyTo(J),J}function bnIntValue(){if(this.s<0){if(this.t==1)return this.data[0]-this.DV;if(this.t==0)return-1}else{if(this.t==1)return this.data[0];if(this.t==0)return 0}return(this.data[1]&(1<<32-this.DB)-1)<<this.DB|this.data[0]}function bnByteValue(){return this.t==0?this.s:this.data[0]<<24>>24}function bnShortValue(){return this.t==0?this.s:this.data[0]<<16>>16}function bnpChunkSize(J){return Math.floor(Math.LN2*this.DB/Math.log(J))}function bnSigNum(){return this.s<0?-1:this.t<=0||this.t==1&&this.data[0]<=0?0:1}function bnpToRadix(J){if(J==null&&(J=10),this.signum()==0||J<2||J>36)return"0";var E=this.chunkSize(J),ee=Math.pow(J,E),te=nbv(ee),re=nbi(),ne=nbi(),ie="";for(this.divRemTo(te,re,ne);re.signum()>0;)ie=(ee+ne.intValue()).toString(J).substr(1)+ie,re.divRemTo(te,re,ne);return ne.intValue().toString(J)+ie}function bnpFromRadix(J,E){this.fromInt(0),E==null&&(E=10);for(var ee=this.chunkSize(E),te=Math.pow(E,ee),re=!1,ne=0,ie=0,se=0;se<J.length;++se){var oe=intAt(J,se);if(oe<0){J.charAt(se)=="-"&&this.signum()==0&&(re=!0);continue}ie=E*ie+oe,++ne>=ee&&(this.dMultiply(te),this.dAddOffset(ie,0),ne=0,ie=0)}ne>0&&(this.dMultiply(Math.pow(E,ne)),this.dAddOffset(ie,0)),re&&BigInteger$2.ZERO.subTo(this,this)}function bnpFromNumber(J,E,ee){if(typeof E=="number")if(J<2)this.fromInt(1);else for(this.fromNumber(J,ee),this.testBit(J-1)||this.bitwiseTo(BigInteger$2.ONE.shiftLeft(J-1),op_or,this),this.isEven()&&this.dAddOffset(1,0);!this.isProbablePrime(E);)this.dAddOffset(2,0),this.bitLength()>J&&this.subTo(BigInteger$2.ONE.shiftLeft(J-1),this);else{var te=new Array,re=J&7;te.length=(J>>3)+1,E.nextBytes(te),re>0?te[0]&=(1<<re)-1:te[0]=0,this.fromString(te,256)}}function bnToByteArray(){var J=this.t,E=new Array;E[0]=this.s;var ee=this.DB-J*this.DB%8,te,re=0;if(J-- >0)for(ee<this.DB&&(te=this.data[J]>>ee)!=(this.s&this.DM)>>ee&&(E[re++]=te|this.s<<this.DB-ee);J>=0;)ee<8?(te=(this.data[J]&(1<<ee)-1)<<8-ee,te|=this.data[--J]>>(ee+=this.DB-8)):(te=this.data[J]>>(ee-=8)&255,ee<=0&&(ee+=this.DB,--J)),te&128&&(te|=-256),re==0&&(this.s&128)!=(te&128)&&++re,(re>0||te!=this.s)&&(E[re++]=te);return E}function bnEquals(J){return this.compareTo(J)==0}function bnMin(J){return this.compareTo(J)<0?this:J}function bnMax(J){return this.compareTo(J)>0?this:J}function bnpBitwiseTo(J,E,ee){var te,re,ne=Math.min(J.t,this.t);for(te=0;te<ne;++te)ee.data[te]=E(this.data[te],J.data[te]);if(J.t<this.t){for(re=J.s&this.DM,te=ne;te<this.t;++te)ee.data[te]=E(this.data[te],re);ee.t=this.t}else{for(re=this.s&this.DM,te=ne;te<J.t;++te)ee.data[te]=E(re,J.data[te]);ee.t=J.t}ee.s=E(this.s,J.s),ee.clamp()}function op_and(J,E){return J&E}function bnAnd(J){var E=nbi();return this.bitwiseTo(J,op_and,E),E}function op_or(J,E){return J|E}function bnOr(J){var E=nbi();return this.bitwiseTo(J,op_or,E),E}function op_xor(J,E){return J^E}function bnXor(J){var E=nbi();return this.bitwiseTo(J,op_xor,E),E}function op_andnot(J,E){return J&~E}function bnAndNot(J){var E=nbi();return this.bitwiseTo(J,op_andnot,E),E}function bnNot(){for(var J=nbi(),E=0;E<this.t;++E)J.data[E]=this.DM&~this.data[E];return J.t=this.t,J.s=~this.s,J}function bnShiftLeft(J){var E=nbi();return J<0?this.rShiftTo(-J,E):this.lShiftTo(J,E),E}function bnShiftRight(J){var E=nbi();return J<0?this.lShiftTo(-J,E):this.rShiftTo(J,E),E}function lbit(J){if(J==0)return-1;var E=0;return J&65535||(J>>=16,E+=16),J&255||(J>>=8,E+=8),J&15||(J>>=4,E+=4),J&3||(J>>=2,E+=2),J&1||++E,E}function bnGetLowestSetBit(){for(var J=0;J<this.t;++J)if(this.data[J]!=0)return J*this.DB+lbit(this.data[J]);return this.s<0?this.t*this.DB:-1}function cbit(J){for(var E=0;J!=0;)J&=J-1,++E;return E}function bnBitCount(){for(var J=0,E=this.s&this.DM,ee=0;ee<this.t;++ee)J+=cbit(this.data[ee]^E);return J}function bnTestBit(J){var E=Math.floor(J/this.DB);return E>=this.t?this.s!=0:(this.data[E]&1<<J%this.DB)!=0}function bnpChangeBit(J,E){var ee=BigInteger$2.ONE.shiftLeft(J);return this.bitwiseTo(ee,E,ee),ee}function bnSetBit(J){return this.changeBit(J,op_or)}function bnClearBit(J){return this.changeBit(J,op_andnot)}function bnFlipBit(J){return this.changeBit(J,op_xor)}function bnpAddTo(J,E){for(var ee=0,te=0,re=Math.min(J.t,this.t);ee<re;)te+=this.data[ee]+J.data[ee],E.data[ee++]=te&this.DM,te>>=this.DB;if(J.t<this.t){for(te+=J.s;ee<this.t;)te+=this.data[ee],E.data[ee++]=te&this.DM,te>>=this.DB;te+=this.s}else{for(te+=this.s;ee<J.t;)te+=J.data[ee],E.data[ee++]=te&this.DM,te>>=this.DB;te+=J.s}E.s=te<0?-1:0,te>0?E.data[ee++]=te:te<-1&&(E.data[ee++]=this.DV+te),E.t=ee,E.clamp()}function bnAdd(J){var E=nbi();return this.addTo(J,E),E}function bnSubtract(J){var E=nbi();return this.subTo(J,E),E}function bnMultiply(J){var E=nbi();return this.multiplyTo(J,E),E}function bnDivide(J){var E=nbi();return this.divRemTo(J,E,null),E}function bnRemainder(J){var E=nbi();return this.divRemTo(J,null,E),E}function bnDivideAndRemainder(J){var E=nbi(),ee=nbi();return this.divRemTo(J,E,ee),new Array(E,ee)}function bnpDMultiply(J){this.data[this.t]=this.am(0,J-1,this,0,0,this.t),++this.t,this.clamp()}function bnpDAddOffset(J,E){if(J!=0){for(;this.t<=E;)this.data[this.t++]=0;for(this.data[E]+=J;this.data[E]>=this.DV;)this.data[E]-=this.DV,++E>=this.t&&(this.data[this.t++]=0),++this.data[E]}}function NullExp(){}function nNop(J){return J}function nMulTo(J,E,ee){J.multiplyTo(E,ee)}function nSqrTo(J,E){J.squareTo(E)}NullExp.prototype.convert=nNop;NullExp.prototype.revert=nNop;NullExp.prototype.mulTo=nMulTo;NullExp.prototype.sqrTo=nSqrTo;function bnPow(J){return this.exp(J,new NullExp)}function bnpMultiplyLowerTo(J,E,ee){var te=Math.min(this.t+J.t,E);for(ee.s=0,ee.t=te;te>0;)ee.data[--te]=0;var re;for(re=ee.t-this.t;te<re;++te)ee.data[te+this.t]=this.am(0,J.data[te],ee,te,0,this.t);for(re=Math.min(J.t,E);te<re;++te)this.am(0,J.data[te],ee,te,0,E-te);ee.clamp()}function bnpMultiplyUpperTo(J,E,ee){--E;var te=ee.t=this.t+J.t-E;for(ee.s=0;--te>=0;)ee.data[te]=0;for(te=Math.max(E-this.t,0);te<J.t;++te)ee.data[this.t+te-E]=this.am(E-te,J.data[te],ee,0,0,this.t+te-E);ee.clamp(),ee.drShiftTo(1,ee)}function Barrett(J){this.r2=nbi(),this.q3=nbi(),BigInteger$2.ONE.dlShiftTo(2*J.t,this.r2),this.mu=this.r2.divide(J),this.m=J}function barrettConvert(J){if(J.s<0||J.t>2*this.m.t)return J.mod(this.m);if(J.compareTo(this.m)<0)return J;var E=nbi();return J.copyTo(E),this.reduce(E),E}function barrettRevert(J){return J}function barrettReduce(J){for(J.drShiftTo(this.m.t-1,this.r2),J.t>this.m.t+1&&(J.t=this.m.t+1,J.clamp()),this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3),this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);J.compareTo(this.r2)<0;)J.dAddOffset(1,this.m.t+1);for(J.subTo(this.r2,J);J.compareTo(this.m)>=0;)J.subTo(this.m,J)}function barrettSqrTo(J,E){J.squareTo(E),this.reduce(E)}function barrettMulTo(J,E,ee){J.multiplyTo(E,ee),this.reduce(ee)}Barrett.prototype.convert=barrettConvert;Barrett.prototype.revert=barrettRevert;Barrett.prototype.reduce=barrettReduce;Barrett.prototype.mulTo=barrettMulTo;Barrett.prototype.sqrTo=barrettSqrTo;function bnModPow(J,E){var ee=J.bitLength(),te,re=nbv(1),ne;if(ee<=0)return re;ee<18?te=1:ee<48?te=3:ee<144?te=4:ee<768?te=5:te=6,ee<8?ne=new Classic(E):E.isEven()?ne=new Barrett(E):ne=new Montgomery(E);var ie=new Array,se=3,oe=te-1,ae=(1<<te)-1;if(ie[1]=ne.convert(this),te>1){var ce=nbi();for(ne.sqrTo(ie[1],ce);se<=ae;)ie[se]=nbi(),ne.mulTo(ce,ie[se-2],ie[se]),se+=2}var le=J.t-1,he,de=!0,ue=nbi(),pe;for(ee=nbits(J.data[le])-1;le>=0;){for(ee>=oe?he=J.data[le]>>ee-oe&ae:(he=(J.data[le]&(1<<ee+1)-1)<<oe-ee,le>0&&(he|=J.data[le-1]>>this.DB+ee-oe)),se=te;!(he&1);)he>>=1,--se;if((ee-=se)<0&&(ee+=this.DB,--le),de)ie[he].copyTo(re),de=!1;else{for(;se>1;)ne.sqrTo(re,ue),ne.sqrTo(ue,re),se-=2;se>0?ne.sqrTo(re,ue):(pe=re,re=ue,ue=pe),ne.mulTo(ue,ie[he],re)}for(;le>=0&&!(J.data[le]&1<<ee);)ne.sqrTo(re,ue),pe=re,re=ue,ue=pe,--ee<0&&(ee=this.DB-1,--le)}return ne.revert(re)}function bnGCD(J){var E=this.s<0?this.negate():this.clone(),ee=J.s<0?J.negate():J.clone();if(E.compareTo(ee)<0){var te=E;E=ee,ee=te}var re=E.getLowestSetBit(),ne=ee.getLowestSetBit();if(ne<0)return E;for(re<ne&&(ne=re),ne>0&&(E.rShiftTo(ne,E),ee.rShiftTo(ne,ee));E.signum()>0;)(re=E.getLowestSetBit())>0&&E.rShiftTo(re,E),(re=ee.getLowestSetBit())>0&&ee.rShiftTo(re,ee),E.compareTo(ee)>=0?(E.subTo(ee,E),E.rShiftTo(1,E)):(ee.subTo(E,ee),ee.rShiftTo(1,ee));return ne>0&&ee.lShiftTo(ne,ee),ee}function bnpModInt(J){if(J<=0)return 0;var E=this.DV%J,ee=this.s<0?J-1:0;if(this.t>0)if(E==0)ee=this.data[0]%J;else for(var te=this.t-1;te>=0;--te)ee=(E*ee+this.data[te])%J;return ee}function bnModInverse(J){var E=J.isEven();if(this.isEven()&&E||J.signum()==0)return BigInteger$2.ZERO;for(var ee=J.clone(),te=this.clone(),re=nbv(1),ne=nbv(0),ie=nbv(0),se=nbv(1);ee.signum()!=0;){for(;ee.isEven();)ee.rShiftTo(1,ee),E?((!re.isEven()||!ne.isEven())&&(re.addTo(this,re),ne.subTo(J,ne)),re.rShiftTo(1,re)):ne.isEven()||ne.subTo(J,ne),ne.rShiftTo(1,ne);for(;te.isEven();)te.rShiftTo(1,te),E?((!ie.isEven()||!se.isEven())&&(ie.addTo(this,ie),se.subTo(J,se)),ie.rShiftTo(1,ie)):se.isEven()||se.subTo(J,se),se.rShiftTo(1,se);ee.compareTo(te)>=0?(ee.subTo(te,ee),E&&re.subTo(ie,re),ne.subTo(se,ne)):(te.subTo(ee,te),E&&ie.subTo(re,ie),se.subTo(ne,se))}if(te.compareTo(BigInteger$2.ONE)!=0)return BigInteger$2.ZERO;if(se.compareTo(J)>=0)return se.subtract(J);if(se.signum()<0)se.addTo(J,se);else return se;return se.signum()<0?se.add(J):se}var lowprimes=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509],lplim=(1<<26)/lowprimes[lowprimes.length-1];function bnIsProbablePrime(J){var E,ee=this.abs();if(ee.t==1&&ee.data[0]<=lowprimes[lowprimes.length-1]){for(E=0;E<lowprimes.length;++E)if(ee.data[0]==lowprimes[E])return!0;return!1}if(ee.isEven())return!1;for(E=1;E<lowprimes.length;){for(var te=lowprimes[E],re=E+1;re<lowprimes.length&&te<lplim;)te*=lowprimes[re++];for(te=ee.modInt(te);E<re;)if(te%lowprimes[E++]==0)return!1}return ee.millerRabin(J)}function bnpMillerRabin(J){var E=this.subtract(BigInteger$2.ONE),ee=E.getLowestSetBit();if(ee<=0)return!1;for(var te=E.shiftRight(ee),re=bnGetPrng(),ne,ie=0;ie<J;++ie){do ne=new BigInteger$2(this.bitLength(),re);while(ne.compareTo(BigInteger$2.ONE)<=0||ne.compareTo(E)>=0);var se=ne.modPow(te,this);if(se.compareTo(BigInteger$2.ONE)!=0&&se.compareTo(E)!=0){for(var oe=1;oe++<ee&&se.compareTo(E)!=0;)if(se=se.modPowInt(2,this),se.compareTo(BigInteger$2.ONE)==0)return!1;if(se.compareTo(E)!=0)return!1}}return!0}function bnGetPrng(){return{nextBytes:function(J){for(var E=0;E<J.length;++E)J[E]=Math.floor(Math.random()*256)}}}BigInteger$2.prototype.chunkSize=bnpChunkSize;BigInteger$2.prototype.toRadix=bnpToRadix;BigInteger$2.prototype.fromRadix=bnpFromRadix;BigInteger$2.prototype.fromNumber=bnpFromNumber;BigInteger$2.prototype.bitwiseTo=bnpBitwiseTo;BigInteger$2.prototype.changeBit=bnpChangeBit;BigInteger$2.prototype.addTo=bnpAddTo;BigInteger$2.prototype.dMultiply=bnpDMultiply;BigInteger$2.prototype.dAddOffset=bnpDAddOffset;BigInteger$2.prototype.multiplyLowerTo=bnpMultiplyLowerTo;BigInteger$2.prototype.multiplyUpperTo=bnpMultiplyUpperTo;BigInteger$2.prototype.modInt=bnpModInt;BigInteger$2.prototype.millerRabin=bnpMillerRabin;BigInteger$2.prototype.clone=bnClone;BigInteger$2.prototype.intValue=bnIntValue;BigInteger$2.prototype.byteValue=bnByteValue;BigInteger$2.prototype.shortValue=bnShortValue;BigInteger$2.prototype.signum=bnSigNum;BigInteger$2.prototype.toByteArray=bnToByteArray;BigInteger$2.prototype.equals=bnEquals;BigInteger$2.prototype.min=bnMin;BigInteger$2.prototype.max=bnMax;BigInteger$2.prototype.and=bnAnd;BigInteger$2.prototype.or=bnOr;BigInteger$2.prototype.xor=bnXor;BigInteger$2.prototype.andNot=bnAndNot;BigInteger$2.prototype.not=bnNot;BigInteger$2.prototype.shiftLeft=bnShiftLeft;BigInteger$2.prototype.shiftRight=bnShiftRight;BigInteger$2.prototype.getLowestSetBit=bnGetLowestSetBit;BigInteger$2.prototype.bitCount=bnBitCount;BigInteger$2.prototype.testBit=bnTestBit;BigInteger$2.prototype.setBit=bnSetBit;BigInteger$2.prototype.clearBit=bnClearBit;BigInteger$2.prototype.flipBit=bnFlipBit;BigInteger$2.prototype.add=bnAdd;BigInteger$2.prototype.subtract=bnSubtract;BigInteger$2.prototype.multiply=bnMultiply;BigInteger$2.prototype.divide=bnDivide;BigInteger$2.prototype.remainder=bnRemainder;BigInteger$2.prototype.divideAndRemainder=bnDivideAndRemainder;BigInteger$2.prototype.modPow=bnModPow;BigInteger$2.prototype.modInverse=bnModInverse;BigInteger$2.prototype.pow=bnPow;BigInteger$2.prototype.gcd=bnGCD;BigInteger$2.prototype.isProbablePrime=bnIsProbablePrime;var forge$5=forge$m,sha1=forge$5.sha1=forge$5.sha1||{};forge$5.md.sha1=forge$5.md.algorithms.sha1=sha1;sha1.create=function(){_initialized$1||_init$1();var J=null,E=forge$5.util.createBuffer(),ee=new Array(80),te={algorithm:"sha1",blockLength:64,digestLength:20,messageLength:0,fullMessageLength:null,messageLengthSize:8};return te.start=function(){te.messageLength=0,te.fullMessageLength=te.messageLength64=[];for(var re=te.messageLengthSize/4,ne=0;ne<re;++ne)te.fullMessageLength.push(0);return E=forge$5.util.createBuffer(),J={h0:1732584193,h1:4023233417,h2:2562383102,h3:271733878,h4:3285377520},te},te.start(),te.update=function(re,ne){ne==="utf8"&&(re=forge$5.util.encodeUtf8(re));var ie=re.length;te.messageLength+=ie,ie=[ie/4294967296>>>0,ie>>>0];for(var se=te.fullMessageLength.length-1;se>=0;--se)te.fullMessageLength[se]+=ie[1],ie[1]=ie[0]+(te.fullMessageLength[se]/4294967296>>>0),te.fullMessageLength[se]=te.fullMessageLength[se]>>>0,ie[0]=ie[1]/4294967296>>>0;return E.putBytes(re),_update$1(J,ee,E),(E.read>2048||E.length()===0)&&E.compact(),te},te.digest=function(){var re=forge$5.util.createBuffer();re.putBytes(E.bytes());var ne=te.fullMessageLength[te.fullMessageLength.length-1]+te.messageLengthSize,ie=ne&te.blockLength-1;re.putBytes(_padding$1.substr(0,te.blockLength-ie));for(var se,oe,ae=te.fullMessageLength[0]*8,ce=0;ce<te.fullMessageLength.length-1;++ce)se=te.fullMessageLength[ce+1]*8,oe=se/4294967296>>>0,ae+=oe,re.putInt32(ae>>>0),ae=se>>>0;re.putInt32(ae);var le={h0:J.h0,h1:J.h1,h2:J.h2,h3:J.h3,h4:J.h4};_update$1(le,ee,re);var he=forge$5.util.createBuffer();return he.putInt32(le.h0),he.putInt32(le.h1),he.putInt32(le.h2),he.putInt32(le.h3),he.putInt32(le.h4),he},te};var _padding$1=null,_initialized$1=!1;function _init$1(){_padding$1=String.fromCharCode(128),_padding$1+=forge$5.util.fillString(String.fromCharCode(0),64),_initialized$1=!0}function _update$1(J,E,ee){for(var te,re,ne,ie,se,oe,ae,ce,le=ee.length();le>=64;){for(re=J.h0,ne=J.h1,ie=J.h2,se=J.h3,oe=J.h4,ce=0;ce<16;++ce)te=ee.getInt32(),E[ce]=te,ae=se^ne&(ie^se),te=(re<<5|re>>>27)+ae+oe+1518500249+te,oe=se,se=ie,ie=(ne<<30|ne>>>2)>>>0,ne=re,re=te;for(;ce<20;++ce)te=E[ce-3]^E[ce-8]^E[ce-14]^E[ce-16],te=te<<1|te>>>31,E[ce]=te,ae=se^ne&(ie^se),te=(re<<5|re>>>27)+ae+oe+1518500249+te,oe=se,se=ie,ie=(ne<<30|ne>>>2)>>>0,ne=re,re=te;for(;ce<32;++ce)te=E[ce-3]^E[ce-8]^E[ce-14]^E[ce-16],te=te<<1|te>>>31,E[ce]=te,ae=ne^ie^se,te=(re<<5|re>>>27)+ae+oe+1859775393+te,oe=se,se=ie,ie=(ne<<30|ne>>>2)>>>0,ne=re,re=te;for(;ce<40;++ce)te=E[ce-6]^E[ce-16]^E[ce-28]^E[ce-32],te=te<<2|te>>>30,E[ce]=te,ae=ne^ie^se,te=(re<<5|re>>>27)+ae+oe+1859775393+te,oe=se,se=ie,ie=(ne<<30|ne>>>2)>>>0,ne=re,re=te;for(;ce<60;++ce)te=E[ce-6]^E[ce-16]^E[ce-28]^E[ce-32],te=te<<2|te>>>30,E[ce]=te,ae=ne&ie|se&(ne^ie),te=(re<<5|re>>>27)+ae+oe+2400959708+te,oe=se,se=ie,ie=(ne<<30|ne>>>2)>>>0,ne=re,re=te;for(;ce<80;++ce)te=E[ce-6]^E[ce-16]^E[ce-28]^E[ce-32],te=te<<2|te>>>30,E[ce]=te,ae=ne^ie^se,te=(re<<5|re>>>27)+ae+oe+3395469782+te,oe=se,se=ie,ie=(ne<<30|ne>>>2)>>>0,ne=re,re=te;J.h0=J.h0+re|0,J.h1=J.h1+ne|0,J.h2=J.h2+ie|0,J.h3=J.h3+se|0,J.h4=J.h4+oe|0,le-=64}}var forge$4=forge$m,pkcs1=forge$4.pkcs1=forge$4.pkcs1||{};pkcs1.encode_rsa_oaep=function(J,E,ee){var te,re,ne,ie;typeof ee=="string"?(te=ee,re=arguments[3]||void 0,ne=arguments[4]||void 0):ee&&(te=ee.label||void 0,re=ee.seed||void 0,ne=ee.md||void 0,ee.mgf1&&ee.mgf1.md&&(ie=ee.mgf1.md)),ne?ne.start():ne=forge$4.md.sha1.create(),ie||(ie=ne);var se=Math.ceil(J.n.bitLength()/8),oe=se-2*ne.digestLength-2;if(E.length>oe){var ae=new Error("RSAES-OAEP input message length is too long.");throw ae.length=E.length,ae.maxLength=oe,ae}te||(te=""),ne.update(te,"raw");for(var ce=ne.digest(),le="",he=oe-E.length,de=0;de<he;de++)le+="\0";var ue=ce.getBytes()+le+""+E;if(!re)re=forge$4.random.getBytes(ne.digestLength);else if(re.length!==ne.digestLength){var ae=new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");throw ae.seedLength=re.length,ae.digestLength=ne.digestLength,ae}var pe=rsa_mgf1(re,se-ne.digestLength-1,ie),ye=forge$4.util.xorBytes(ue,pe,ue.length),me=rsa_mgf1(ye,ne.digestLength,ie),be=forge$4.util.xorBytes(re,me,re.length);return"\0"+be+ye};pkcs1.decode_rsa_oaep=function(J,E,ee){var te,re,ne;typeof ee=="string"?(te=ee,re=arguments[3]||void 0):ee&&(te=ee.label||void 0,re=ee.md||void 0,ee.mgf1&&ee.mgf1.md&&(ne=ee.mgf1.md));var ie=Math.ceil(J.n.bitLength()/8);if(E.length!==ie){var se=new Error("RSAES-OAEP encoded message length is invalid.");throw se.length=E.length,se.expectedLength=ie,se}if(re===void 0?re=forge$4.md.sha1.create():re.start(),ne||(ne=re),ie<2*re.digestLength+2)throw new Error("RSAES-OAEP key is too short for the hash function.");te||(te=""),re.update(te,"raw");for(var oe=re.digest().getBytes(),ae=E.charAt(0),ce=E.substring(1,re.digestLength+1),le=E.substring(1+re.digestLength),he=rsa_mgf1(le,re.digestLength,ne),de=forge$4.util.xorBytes(ce,he,ce.length),ue=rsa_mgf1(de,ie-re.digestLength-1,ne),pe=forge$4.util.xorBytes(le,ue,le.length),ye=pe.substring(0,re.digestLength),se=ae!=="\0",me=0;me<re.digestLength;++me)se|=oe.charAt(me)!==ye.charAt(me);for(var be=1,_e=re.digestLength,we=re.digestLength;we<pe.length;we++){var $e=pe.charCodeAt(we),ve=$e&1^1,fe=be?65534:0;se|=$e&fe,be=be&ve,_e+=be}if(se||pe.charCodeAt(_e)!==1)throw new Error("Invalid RSAES-OAEP padding.");return pe.substring(_e+1)};function rsa_mgf1(J,E,ee){ee||(ee=forge$4.md.sha1.create());for(var te="",re=Math.ceil(E/ee.digestLength),ne=0;ne<re;++ne){var ie=String.fromCharCode(ne>>24&255,ne>>16&255,ne>>8&255,ne&255);ee.start(),ee.update(J+ie),te+=ee.digest().getBytes()}return te.substring(0,E)}var forge$3=forge$m;(function(){if(forge$3.prime){forge$3.prime;return}var J=forge$3.prime=forge$3.prime||{},E=forge$3.jsbn.BigInteger,ee=[6,4,2,4,2,4,6,2],te=new E(null);te.fromInt(30);var re=function(le,he){return le|he};J.generateProbablePrime=function(le,he,de){typeof he=="function"&&(de=he,he={}),he=he||{};var ue=he.algorithm||"PRIMEINC";typeof ue=="string"&&(ue={name:ue}),ue.options=ue.options||{};var pe=he.prng||forge$3.random,ye={nextBytes:function(me){for(var be=pe.getBytesSync(me.length),_e=0;_e<me.length;++_e)me[_e]=be.charCodeAt(_e)}};if(ue.name==="PRIMEINC")return ne(le,ye,ue.options,de);throw new Error("Invalid prime generation algorithm: "+ue.name)};function ne(le,he,de,ue){return"workers"in de?oe(le,he,de,ue):ie(le,he,de,ue)}function ie(le,he,de,ue){var pe=ae(le,he),ye=0,me=ce(pe.bitLength());"millerRabinTests"in de&&(me=de.millerRabinTests);var be=10;"maxBlockTime"in de&&(be=de.maxBlockTime),se(pe,le,he,ye,me,be,ue)}function se(le,he,de,ue,pe,ye,me){var be=+new Date;do{if(le.bitLength()>he&&(le=ae(he,de)),le.isProbablePrime(pe))return me(null,le);le.dAddOffset(ee[ue++%8],0)}while(ye<0||+new Date-be<ye);forge$3.util.setImmediate(function(){se(le,he,de,ue,pe,ye,me)})}function oe(le,he,de,ue){if(typeof Worker>"u")return ie(le,he,de,ue);var pe=ae(le,he),ye=de.workers,me=de.workLoad||100,be=me*30/8,_e=de.workerScript||"forge/prime.worker.js";if(ye===-1)return forge$3.util.estimateCores(function($e,ve){$e&&(ve=2),ye=ve-1,we()});we();function we(){ye=Math.max(1,ye);for(var $e=[],ve=0;ve<ye;++ve)$e[ve]=new Worker(_e);for(var ve=0;ve<ye;++ve)$e[ve].addEventListener("message",Ee);var fe=!1;function Ee(ke){if(!fe){var Ne=ke.data;if(Ne.found){for(var xe=0;xe<$e.length;++xe)$e[xe].terminate();return fe=!0,ue(null,new E(Ne.prime,16))}pe.bitLength()>le&&(pe=ae(le,he));var Ue=pe.toString(16);ke.target.postMessage({hex:Ue,workLoad:me}),pe.dAddOffset(be,0)}}}}function ae(le,he){var de=new E(le,he),ue=le-1;return de.testBit(ue)||de.bitwiseTo(E.ONE.shiftLeft(ue),re,de),de.dAddOffset(31-de.mod(te).byteValue(),0),de}function ce(le){return le<=100?27:le<=150?18:le<=200?15:le<=250?12:le<=300?9:le<=350?8:le<=400?7:le<=500?6:le<=600?5:le<=800?4:le<=1250?3:2}})();var forge$2=forge$m;if(typeof BigInteger$1>"u")var BigInteger$1=forge$2.jsbn.BigInteger;var _crypto=forge$2.util.isNodejs?require$$8:null,asn1$1=forge$2.asn1,util$6=forge$2.util;forge$2.pki=forge$2.pki||{};forge$2.pki.rsa=forge$2.rsa=forge$2.rsa||{};var pki$1=forge$2.pki,GCD_30_DELTA=[6,4,2,4,2,4,6,2],privateKeyValidator={name:"PrivateKeyInfo",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.SEQUENCE,constructed:!0,value:[{name:"PrivateKeyInfo.version",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.INTEGER,constructed:!1,capture:"privateKeyVersion"},{name:"PrivateKeyInfo.privateKeyAlgorithm",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.SEQUENCE,constructed:!0,value:[{name:"AlgorithmIdentifier.algorithm",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.OID,constructed:!1,capture:"privateKeyOid"}]},{name:"PrivateKeyInfo",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.OCTETSTRING,constructed:!1,capture:"privateKey"}]},rsaPrivateKeyValidator={name:"RSAPrivateKey",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.SEQUENCE,constructed:!0,value:[{name:"RSAPrivateKey.version",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.INTEGER,constructed:!1,capture:"privateKeyVersion"},{name:"RSAPrivateKey.modulus",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.INTEGER,constructed:!1,capture:"privateKeyModulus"},{name:"RSAPrivateKey.publicExponent",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.INTEGER,constructed:!1,capture:"privateKeyPublicExponent"},{name:"RSAPrivateKey.privateExponent",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.INTEGER,constructed:!1,capture:"privateKeyPrivateExponent"},{name:"RSAPrivateKey.prime1",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.INTEGER,constructed:!1,capture:"privateKeyPrime1"},{name:"RSAPrivateKey.prime2",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.INTEGER,constructed:!1,capture:"privateKeyPrime2"},{name:"RSAPrivateKey.exponent1",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.INTEGER,constructed:!1,capture:"privateKeyExponent1"},{name:"RSAPrivateKey.exponent2",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.INTEGER,constructed:!1,capture:"privateKeyExponent2"},{name:"RSAPrivateKey.coefficient",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.INTEGER,constructed:!1,capture:"privateKeyCoefficient"}]},rsaPublicKeyValidator={name:"RSAPublicKey",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.SEQUENCE,constructed:!0,value:[{name:"RSAPublicKey.modulus",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.INTEGER,constructed:!1,capture:"publicKeyModulus"},{name:"RSAPublicKey.exponent",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.INTEGER,constructed:!1,capture:"publicKeyExponent"}]},publicKeyValidator=forge$2.pki.rsa.publicKeyValidator={name:"SubjectPublicKeyInfo",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.SEQUENCE,constructed:!0,captureAsn1:"subjectPublicKeyInfo",value:[{name:"SubjectPublicKeyInfo.AlgorithmIdentifier",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.SEQUENCE,constructed:!0,value:[{name:"AlgorithmIdentifier.algorithm",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.OID,constructed:!1,capture:"publicKeyOid"}]},{name:"SubjectPublicKeyInfo.subjectPublicKey",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.BITSTRING,constructed:!1,value:[{name:"SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.SEQUENCE,constructed:!0,optional:!0,captureAsn1:"rsaPublicKey"}]}]},digestInfoValidator={name:"DigestInfo",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.SEQUENCE,constructed:!0,value:[{name:"DigestInfo.DigestAlgorithm",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.SEQUENCE,constructed:!0,value:[{name:"DigestInfo.DigestAlgorithm.algorithmIdentifier",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.OID,constructed:!1,capture:"algorithmIdentifier"},{name:"DigestInfo.DigestAlgorithm.parameters",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.NULL,capture:"parameters",optional:!0,constructed:!1}]},{name:"DigestInfo.digest",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.OCTETSTRING,constructed:!1,capture:"digest"}]},emsaPkcs1v15encode=function(J){var E;if(J.algorithm in pki$1.oids)E=pki$1.oids[J.algorithm];else{var ee=new Error("Unknown message digest algorithm.");throw ee.algorithm=J.algorithm,ee}var te=asn1$1.oidToDer(E).getBytes(),re=asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.SEQUENCE,!0,[]),ne=asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.SEQUENCE,!0,[]);ne.value.push(asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.OID,!1,te)),ne.value.push(asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.NULL,!1,""));var ie=asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.OCTETSTRING,!1,J.digest().getBytes());return re.value.push(ne),re.value.push(ie),asn1$1.toDer(re).getBytes()},_modPow=function(J,E,ee){if(ee)return J.modPow(E.e,E.n);if(!E.p||!E.q)return J.modPow(E.d,E.n);E.dP||(E.dP=E.d.mod(E.p.subtract(BigInteger$1.ONE))),E.dQ||(E.dQ=E.d.mod(E.q.subtract(BigInteger$1.ONE))),E.qInv||(E.qInv=E.q.modInverse(E.p));var te;do te=new BigInteger$1(forge$2.util.bytesToHex(forge$2.random.getBytes(E.n.bitLength()/8)),16);while(te.compareTo(E.n)>=0||!te.gcd(E.n).equals(BigInteger$1.ONE));J=J.multiply(te.modPow(E.e,E.n)).mod(E.n);for(var re=J.mod(E.p).modPow(E.dP,E.p),ne=J.mod(E.q).modPow(E.dQ,E.q);re.compareTo(ne)<0;)re=re.add(E.p);var ie=re.subtract(ne).multiply(E.qInv).mod(E.p).multiply(E.q).add(ne);return ie=ie.multiply(te.modInverse(E.n)).mod(E.n),ie};pki$1.rsa.encrypt=function(J,E,ee){var te=ee,re,ne=Math.ceil(E.n.bitLength()/8);ee!==!1&&ee!==!0?(te=ee===2,re=_encodePkcs1_v1_5(J,E,ee)):(re=forge$2.util.createBuffer(),re.putBytes(J));for(var ie=new BigInteger$1(re.toHex(),16),se=_modPow(ie,E,te),oe=se.toString(16),ae=forge$2.util.createBuffer(),ce=ne-Math.ceil(oe.length/2);ce>0;)ae.putByte(0),--ce;return ae.putBytes(forge$2.util.hexToBytes(oe)),ae.getBytes()};pki$1.rsa.decrypt=function(J,E,ee,te){var re=Math.ceil(E.n.bitLength()/8);if(J.length!==re){var ne=new Error("Encrypted message length is invalid.");throw ne.length=J.length,ne.expected=re,ne}var ie=new BigInteger$1(forge$2.util.createBuffer(J).toHex(),16);if(ie.compareTo(E.n)>=0)throw new Error("Encrypted message is invalid.");for(var se=_modPow(ie,E,ee),oe=se.toString(16),ae=forge$2.util.createBuffer(),ce=re-Math.ceil(oe.length/2);ce>0;)ae.putByte(0),--ce;return ae.putBytes(forge$2.util.hexToBytes(oe)),te!==!1?_decodePkcs1_v1_5(ae.getBytes(),E,ee):ae.getBytes()};pki$1.rsa.createKeyPairGenerationState=function(J,E,ee){typeof J=="string"&&(J=parseInt(J,10)),J=J||2048,ee=ee||{};var te=ee.prng||forge$2.random,re={nextBytes:function(se){for(var oe=te.getBytesSync(se.length),ae=0;ae<se.length;++ae)se[ae]=oe.charCodeAt(ae)}},ne=ee.algorithm||"PRIMEINC",ie;if(ne==="PRIMEINC")ie={algorithm:ne,state:0,bits:J,rng:re,eInt:E||65537,e:new BigInteger$1(null),p:null,q:null,qBits:J>>1,pBits:J-(J>>1),pqState:0,num:null,keys:null},ie.e.fromInt(ie.eInt);else throw new Error("Invalid key generation algorithm: "+ne);return ie};pki$1.rsa.stepKeyPairGenerationState=function(J,E){"algorithm"in J||(J.algorithm="PRIMEINC");var ee=new BigInteger$1(null);ee.fromInt(30);for(var te=0,re=function(le,he){return le|he},ne=+new Date,ie,se=0;J.keys===null&&(E<=0||se<E);){if(J.state===0){var oe=J.p===null?J.pBits:J.qBits,ae=oe-1;J.pqState===0?(J.num=new BigInteger$1(oe,J.rng),J.num.testBit(ae)||J.num.bitwiseTo(BigInteger$1.ONE.shiftLeft(ae),re,J.num),J.num.dAddOffset(31-J.num.mod(ee).byteValue(),0),te=0,++J.pqState):J.pqState===1?J.num.bitLength()>oe?J.pqState=0:J.num.isProbablePrime(_getMillerRabinTests(J.num.bitLength()))?++J.pqState:J.num.dAddOffset(GCD_30_DELTA[te++%8],0):J.pqState===2?J.pqState=J.num.subtract(BigInteger$1.ONE).gcd(J.e).compareTo(BigInteger$1.ONE)===0?3:0:J.pqState===3&&(J.pqState=0,J.p===null?J.p=J.num:J.q=J.num,J.p!==null&&J.q!==null&&++J.state,J.num=null)}else if(J.state===1)J.p.compareTo(J.q)<0&&(J.num=J.p,J.p=J.q,J.q=J.num),++J.state;else if(J.state===2)J.p1=J.p.subtract(BigInteger$1.ONE),J.q1=J.q.subtract(BigInteger$1.ONE),J.phi=J.p1.multiply(J.q1),++J.state;else if(J.state===3)J.phi.gcd(J.e).compareTo(BigInteger$1.ONE)===0?++J.state:(J.p=null,J.q=null,J.state=0);else if(J.state===4)J.n=J.p.multiply(J.q),J.n.bitLength()===J.bits?++J.state:(J.q=null,J.state=0);else if(J.state===5){var ce=J.e.modInverse(J.phi);J.keys={privateKey:pki$1.rsa.setPrivateKey(J.n,J.e,ce,J.p,J.q,ce.mod(J.p1),ce.mod(J.q1),J.q.modInverse(J.p)),publicKey:pki$1.rsa.setPublicKey(J.n,J.e)}}ie=+new Date,se+=ie-ne,ne=ie}return J.keys!==null};pki$1.rsa.generateKeyPair=function(J,E,ee,te){if(arguments.length===1?typeof J=="object"?(ee=J,J=void 0):typeof J=="function"&&(te=J,J=void 0):arguments.length===2?typeof J=="number"?typeof E=="function"?(te=E,E=void 0):typeof E!="number"&&(ee=E,E=void 0):(ee=J,te=E,J=void 0,E=void 0):arguments.length===3&&(typeof E=="number"?typeof ee=="function"&&(te=ee,ee=void 0):(te=ee,ee=E,E=void 0)),ee=ee||{},J===void 0&&(J=ee.bits||2048),E===void 0&&(E=ee.e||65537),!forge$2.options.usePureJavaScript&&!ee.prng&&J>=256&&J<=16384&&(E===65537||E===3)){if(te){if(_detectNodeCrypto("generateKeyPair"))return _crypto.generateKeyPair("rsa",{modulusLength:J,publicExponent:E,publicKeyEncoding:{type:"spki",format:"pem"},privateKeyEncoding:{type:"pkcs8",format:"pem"}},function(se,oe,ae){if(se)return te(se);te(null,{privateKey:pki$1.privateKeyFromPem(ae),publicKey:pki$1.publicKeyFromPem(oe)})});if(_detectSubtleCrypto("generateKey")&&_detectSubtleCrypto("exportKey"))return util$6.globalScope.crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:J,publicExponent:_intToUint8Array(E),hash:{name:"SHA-256"}},!0,["sign","verify"]).then(function(se){return util$6.globalScope.crypto.subtle.exportKey("pkcs8",se.privateKey)}).then(void 0,function(se){te(se)}).then(function(se){if(se){var oe=pki$1.privateKeyFromAsn1(asn1$1.fromDer(forge$2.util.createBuffer(se)));te(null,{privateKey:oe,publicKey:pki$1.setRsaPublicKey(oe.n,oe.e)})}});if(_detectSubtleMsCrypto("generateKey")&&_detectSubtleMsCrypto("exportKey")){var re=util$6.globalScope.msCrypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:J,publicExponent:_intToUint8Array(E),hash:{name:"SHA-256"}},!0,["sign","verify"]);re.oncomplete=function(se){var oe=se.target.result,ae=util$6.globalScope.msCrypto.subtle.exportKey("pkcs8",oe.privateKey);ae.oncomplete=function(ce){var le=ce.target.result,he=pki$1.privateKeyFromAsn1(asn1$1.fromDer(forge$2.util.createBuffer(le)));te(null,{privateKey:he,publicKey:pki$1.setRsaPublicKey(he.n,he.e)})},ae.onerror=function(ce){te(ce)}},re.onerror=function(se){te(se)};return}}else if(_detectNodeCrypto("generateKeyPairSync")){var ne=_crypto.generateKeyPairSync("rsa",{modulusLength:J,publicExponent:E,publicKeyEncoding:{type:"spki",format:"pem"},privateKeyEncoding:{type:"pkcs8",format:"pem"}});return{privateKey:pki$1.privateKeyFromPem(ne.privateKey),publicKey:pki$1.publicKeyFromPem(ne.publicKey)}}}var ie=pki$1.rsa.createKeyPairGenerationState(J,E,ee);if(!te)return pki$1.rsa.stepKeyPairGenerationState(ie,0),ie.keys;_generateKeyPair(ie,ee,te)};pki$1.setRsaPublicKey=pki$1.rsa.setPublicKey=function(J,E){var ee={n:J,e:E};return ee.encrypt=function(te,re,ne){if(typeof re=="string"?re=re.toUpperCase():re===void 0&&(re="RSAES-PKCS1-V1_5"),re==="RSAES-PKCS1-V1_5")re={encode:function(se,oe,ae){return _encodePkcs1_v1_5(se,oe,2).getBytes()}};else if(re==="RSA-OAEP"||re==="RSAES-OAEP")re={encode:function(se,oe){return forge$2.pkcs1.encode_rsa_oaep(oe,se,ne)}};else if(["RAW","NONE","NULL",null].indexOf(re)!==-1)re={encode:function(se){return se}};else if(typeof re=="string")throw new Error('Unsupported encryption scheme: "'+re+'".');var ie=re.encode(te,ee,!0);return pki$1.rsa.encrypt(ie,ee,!0)},ee.verify=function(te,re,ne,ie){typeof ne=="string"?ne=ne.toUpperCase():ne===void 0&&(ne="RSASSA-PKCS1-V1_5"),ie===void 0&&(ie={_parseAllDigestBytes:!0}),"_parseAllDigestBytes"in ie||(ie._parseAllDigestBytes=!0),ne==="RSASSA-PKCS1-V1_5"?ne={verify:function(oe,ae){ae=_decodePkcs1_v1_5(ae,ee,!0);var ce=asn1$1.fromDer(ae,{parseAllBytes:ie._parseAllDigestBytes}),le={},he=[];if(!asn1$1.validate(ce,digestInfoValidator,le,he)){var de=new Error("ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value.");throw de.errors=he,de}var ue=asn1$1.derToOid(le.algorithmIdentifier);if(!(ue===forge$2.oids.md2||ue===forge$2.oids.md5||ue===forge$2.oids.sha1||ue===forge$2.oids.sha224||ue===forge$2.oids.sha256||ue===forge$2.oids.sha384||ue===forge$2.oids.sha512||ue===forge$2.oids["sha512-224"]||ue===forge$2.oids["sha512-256"])){var de=new Error("Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier.");throw de.oid=ue,de}if((ue===forge$2.oids.md2||ue===forge$2.oids.md5)&&!("parameters"in le))throw new Error("ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters.");return oe===le.digest}}:(ne==="NONE"||ne==="NULL"||ne===null)&&(ne={verify:function(oe,ae){return ae=_decodePkcs1_v1_5(ae,ee,!0),oe===ae}});var se=pki$1.rsa.decrypt(re,ee,!0,!1);return ne.verify(te,se,ee.n.bitLength())},ee};pki$1.setRsaPrivateKey=pki$1.rsa.setPrivateKey=function(J,E,ee,te,re,ne,ie,se){var oe={n:J,e:E,d:ee,p:te,q:re,dP:ne,dQ:ie,qInv:se};return oe.decrypt=function(ae,ce,le){typeof ce=="string"?ce=ce.toUpperCase():ce===void 0&&(ce="RSAES-PKCS1-V1_5");var he=pki$1.rsa.decrypt(ae,oe,!1,!1);if(ce==="RSAES-PKCS1-V1_5")ce={decode:_decodePkcs1_v1_5};else if(ce==="RSA-OAEP"||ce==="RSAES-OAEP")ce={decode:function(de,ue){return forge$2.pkcs1.decode_rsa_oaep(ue,de,le)}};else if(["RAW","NONE","NULL",null].indexOf(ce)!==-1)ce={decode:function(de){return de}};else throw new Error('Unsupported encryption scheme: "'+ce+'".');return ce.decode(he,oe,!1)},oe.sign=function(ae,ce){var le=!1;typeof ce=="string"&&(ce=ce.toUpperCase()),ce===void 0||ce==="RSASSA-PKCS1-V1_5"?(ce={encode:emsaPkcs1v15encode},le=1):(ce==="NONE"||ce==="NULL"||ce===null)&&(ce={encode:function(){return ae}},le=1);var he=ce.encode(ae,oe.n.bitLength());return pki$1.rsa.encrypt(he,oe,le)},oe};pki$1.wrapRsaPrivateKey=function(J){return asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.SEQUENCE,!0,[asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.INTEGER,!1,asn1$1.integerToDer(0).getBytes()),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.SEQUENCE,!0,[asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.OID,!1,asn1$1.oidToDer(pki$1.oids.rsaEncryption).getBytes()),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.NULL,!1,"")]),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.OCTETSTRING,!1,asn1$1.toDer(J).getBytes())])};pki$1.privateKeyFromAsn1=function(J){var E={},ee=[];if(asn1$1.validate(J,privateKeyValidator,E,ee)&&(J=asn1$1.fromDer(forge$2.util.createBuffer(E.privateKey))),E={},ee=[],!asn1$1.validate(J,rsaPrivateKeyValidator,E,ee)){var te=new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");throw te.errors=ee,te}var re,ne,ie,se,oe,ae,ce,le;return re=forge$2.util.createBuffer(E.privateKeyModulus).toHex(),ne=forge$2.util.createBuffer(E.privateKeyPublicExponent).toHex(),ie=forge$2.util.createBuffer(E.privateKeyPrivateExponent).toHex(),se=forge$2.util.createBuffer(E.privateKeyPrime1).toHex(),oe=forge$2.util.createBuffer(E.privateKeyPrime2).toHex(),ae=forge$2.util.createBuffer(E.privateKeyExponent1).toHex(),ce=forge$2.util.createBuffer(E.privateKeyExponent2).toHex(),le=forge$2.util.createBuffer(E.privateKeyCoefficient).toHex(),pki$1.setRsaPrivateKey(new BigInteger$1(re,16),new BigInteger$1(ne,16),new BigInteger$1(ie,16),new BigInteger$1(se,16),new BigInteger$1(oe,16),new BigInteger$1(ae,16),new BigInteger$1(ce,16),new BigInteger$1(le,16))};pki$1.privateKeyToAsn1=pki$1.privateKeyToRSAPrivateKey=function(J){return asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.SEQUENCE,!0,[asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.INTEGER,!1,asn1$1.integerToDer(0).getBytes()),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.INTEGER,!1,_bnToBytes(J.n)),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.INTEGER,!1,_bnToBytes(J.e)),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.INTEGER,!1,_bnToBytes(J.d)),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.INTEGER,!1,_bnToBytes(J.p)),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.INTEGER,!1,_bnToBytes(J.q)),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.INTEGER,!1,_bnToBytes(J.dP)),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.INTEGER,!1,_bnToBytes(J.dQ)),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.INTEGER,!1,_bnToBytes(J.qInv))])};pki$1.publicKeyFromAsn1=function(J){var E={},ee=[];if(asn1$1.validate(J,publicKeyValidator,E,ee)){var te=asn1$1.derToOid(E.publicKeyOid);if(te!==pki$1.oids.rsaEncryption){var re=new Error("Cannot read public key. Unknown OID.");throw re.oid=te,re}J=E.rsaPublicKey}if(ee=[],!asn1$1.validate(J,rsaPublicKeyValidator,E,ee)){var re=new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");throw re.errors=ee,re}var ne=forge$2.util.createBuffer(E.publicKeyModulus).toHex(),ie=forge$2.util.createBuffer(E.publicKeyExponent).toHex();return pki$1.setRsaPublicKey(new BigInteger$1(ne,16),new BigInteger$1(ie,16))};pki$1.publicKeyToAsn1=pki$1.publicKeyToSubjectPublicKeyInfo=function(J){return asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.SEQUENCE,!0,[asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.SEQUENCE,!0,[asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.OID,!1,asn1$1.oidToDer(pki$1.oids.rsaEncryption).getBytes()),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.NULL,!1,"")]),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.BITSTRING,!1,[pki$1.publicKeyToRSAPublicKey(J)])])};pki$1.publicKeyToRSAPublicKey=function(J){return asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.SEQUENCE,!0,[asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.INTEGER,!1,_bnToBytes(J.n)),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.INTEGER,!1,_bnToBytes(J.e))])};function _encodePkcs1_v1_5(J,E,ee){var te=forge$2.util.createBuffer(),re=Math.ceil(E.n.bitLength()/8);if(J.length>re-11){var ne=new Error("Message is too long for PKCS#1 v1.5 padding.");throw ne.length=J.length,ne.max=re-11,ne}te.putByte(0),te.putByte(ee);var ie=re-3-J.length,se;if(ee===0||ee===1){se=ee===0?0:255;for(var oe=0;oe<ie;++oe)te.putByte(se)}else for(;ie>0;){for(var ae=0,ce=forge$2.random.getBytes(ie),oe=0;oe<ie;++oe)se=ce.charCodeAt(oe),se===0?++ae:te.putByte(se);ie=ae}return te.putByte(0),te.putBytes(J),te}function _decodePkcs1_v1_5(J,E,ee,te){var re=Math.ceil(E.n.bitLength()/8),ne=forge$2.util.createBuffer(J),ie=ne.getByte(),se=ne.getByte();if(ie!==0||ee&&se!==0&&se!==1||!ee&&se!=2||ee&&se===0&&typeof te>"u")throw new Error("Encryption block is invalid.");var oe=0;if(se===0){oe=re-3-te;for(var ae=0;ae<oe;++ae)if(ne.getByte()!==0)throw new Error("Encryption block is invalid.")}else if(se===1)for(oe=0;ne.length()>1;){if(ne.getByte()!==255){--ne.read;break}++oe}else if(se===2)for(oe=0;ne.length()>1;){if(ne.getByte()===0){--ne.read;break}++oe}var ce=ne.getByte();if(ce!==0||oe!==re-3-ne.length())throw new Error("Encryption block is invalid.");return ne.getBytes()}function _generateKeyPair(J,E,ee){typeof E=="function"&&(ee=E,E={}),E=E||{};var te={algorithm:{name:E.algorithm||"PRIMEINC",options:{workers:E.workers||2,workLoad:E.workLoad||100,workerScript:E.workerScript}}};"prng"in E&&(te.prng=E.prng),re();function re(){ne(J.pBits,function(se,oe){if(se)return ee(se);if(J.p=oe,J.q!==null)return ie(se,J.q);ne(J.qBits,ie)})}function ne(se,oe){forge$2.prime.generateProbablePrime(se,te,oe)}function ie(se,oe){if(se)return ee(se);if(J.q=oe,J.p.compareTo(J.q)<0){var ae=J.p;J.p=J.q,J.q=ae}if(J.p.subtract(BigInteger$1.ONE).gcd(J.e).compareTo(BigInteger$1.ONE)!==0){J.p=null,re();return}if(J.q.subtract(BigInteger$1.ONE).gcd(J.e).compareTo(BigInteger$1.ONE)!==0){J.q=null,ne(J.qBits,ie);return}if(J.p1=J.p.subtract(BigInteger$1.ONE),J.q1=J.q.subtract(BigInteger$1.ONE),J.phi=J.p1.multiply(J.q1),J.phi.gcd(J.e).compareTo(BigInteger$1.ONE)!==0){J.p=J.q=null,re();return}if(J.n=J.p.multiply(J.q),J.n.bitLength()!==J.bits){J.q=null,ne(J.qBits,ie);return}var ce=J.e.modInverse(J.phi);J.keys={privateKey:pki$1.rsa.setPrivateKey(J.n,J.e,ce,J.p,J.q,ce.mod(J.p1),ce.mod(J.q1),J.q.modInverse(J.p)),publicKey:pki$1.rsa.setPublicKey(J.n,J.e)},ee(null,J.keys)}}function _bnToBytes(J){var E=J.toString(16);E[0]>="8"&&(E="00"+E);var ee=forge$2.util.hexToBytes(E);return ee.length>1&&(ee.charCodeAt(0)===0&&!(ee.charCodeAt(1)&128)||ee.charCodeAt(0)===255&&(ee.charCodeAt(1)&128)===128)?ee.substr(1):ee}function _getMillerRabinTests(J){return J<=100?27:J<=150?18:J<=200?15:J<=250?12:J<=300?9:J<=350?8:J<=400?7:J<=500?6:J<=600?5:J<=800?4:J<=1250?3:2}function _detectNodeCrypto(J){return forge$2.util.isNodejs&&typeof _crypto[J]=="function"}function _detectSubtleCrypto(J){return typeof util$6.globalScope<"u"&&typeof util$6.globalScope.crypto=="object"&&typeof util$6.globalScope.crypto.subtle=="object"&&typeof util$6.globalScope.crypto.subtle[J]=="function"}function _detectSubtleMsCrypto(J){return typeof util$6.globalScope<"u"&&typeof util$6.globalScope.msCrypto=="object"&&typeof util$6.globalScope.msCrypto.subtle=="object"&&typeof util$6.globalScope.msCrypto.subtle[J]=="function"}function _intToUint8Array(J){for(var E=forge$2.util.hexToBytes(J.toString(16)),ee=new Uint8Array(E.length),te=0;te<E.length;++te)ee[te]=E.charCodeAt(te);return ee}var forge$1=forge$m;if(typeof BigInteger>"u")var BigInteger=forge$1.jsbn.BigInteger;var asn1=forge$1.asn1,pki=forge$1.pki=forge$1.pki||{};pki.pbe=forge$1.pbe=forge$1.pbe||{};var oids=pki.oids,encryptedPrivateKeyValidator={name:"EncryptedPrivateKeyInfo",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"EncryptedPrivateKeyInfo.encryptionAlgorithm",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"AlgorithmIdentifier.algorithm",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:!1,capture:"encryptionOid"},{name:"AlgorithmIdentifier.parameters",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,captureAsn1:"encryptionParams"}]},{name:"EncryptedPrivateKeyInfo.encryptedData",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:!1,capture:"encryptedData"}]},PBES2AlgorithmsValidator={name:"PBES2Algorithms",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.keyDerivationFunc",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.keyDerivationFunc.oid",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:!1,capture:"kdfOid"},{name:"PBES2Algorithms.params",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.params.salt",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:!1,capture:"kdfSalt"},{name:"PBES2Algorithms.params.iterationCount",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:!1,capture:"kdfIterationCount"},{name:"PBES2Algorithms.params.keyLength",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:!1,optional:!0,capture:"keyLength"},{name:"PBES2Algorithms.params.prf",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,optional:!0,value:[{name:"PBES2Algorithms.params.prf.algorithm",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:!1,capture:"prfOid"}]}]}]},{name:"PBES2Algorithms.encryptionScheme",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.encryptionScheme.oid",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:!1,capture:"encOid"},{name:"PBES2Algorithms.encryptionScheme.iv",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:!1,capture:"encIv"}]}]},pkcs12PbeParamsValidator={name:"pkcs-12PbeParams",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"pkcs-12PbeParams.salt",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:!1,capture:"salt"},{name:"pkcs-12PbeParams.iterations",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:!1,capture:"iterations"}]};pki.encryptPrivateKeyInfo=function(J,E,ee){ee=ee||{},ee.saltSize=ee.saltSize||8,ee.count=ee.count||2048,ee.algorithm=ee.algorithm||"aes128",ee.prfAlgorithm=ee.prfAlgorithm||"sha1";var te=forge$1.random.getBytesSync(ee.saltSize),re=ee.count,ne=asn1.integerToDer(re),ie,se,oe;if(ee.algorithm.indexOf("aes")===0||ee.algorithm==="des"){var ae,ce,le;switch(ee.algorithm){case"aes128":ie=16,ae=16,ce=oids["aes128-CBC"],le=forge$1.aes.createEncryptionCipher;break;case"aes192":ie=24,ae=16,ce=oids["aes192-CBC"],le=forge$1.aes.createEncryptionCipher;break;case"aes256":ie=32,ae=16,ce=oids["aes256-CBC"],le=forge$1.aes.createEncryptionCipher;break;case"des":ie=8,ae=8,ce=oids.desCBC,le=forge$1.des.createEncryptionCipher;break;default:var he=new Error("Cannot encrypt private key. Unknown encryption algorithm.");throw he.algorithm=ee.algorithm,he}var de="hmacWith"+ee.prfAlgorithm.toUpperCase(),ue=prfAlgorithmToMessageDigest(de),pe=forge$1.pkcs5.pbkdf2(E,te,re,ie,ue),ye=forge$1.random.getBytesSync(ae),me=le(pe);me.start(ye),me.update(asn1.toDer(J)),me.finish(),oe=me.output.getBytes();var be=createPbkdf2Params(te,ne,ie,de);se=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,!1,asn1.oidToDer(oids.pkcs5PBES2).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,!1,asn1.oidToDer(oids.pkcs5PBKDF2).getBytes()),be]),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,!1,asn1.oidToDer(ce).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,!1,ye)])])])}else if(ee.algorithm==="3des"){ie=24;var _e=new forge$1.util.ByteBuffer(te),pe=pki.pbe.generatePkcs12Key(E,_e,1,re,ie),ye=pki.pbe.generatePkcs12Key(E,_e,2,re,ie),me=forge$1.des.createEncryptionCipher(pe);me.start(ye),me.update(asn1.toDer(J)),me.finish(),oe=me.output.getBytes(),se=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,!1,asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,!1,te),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,!1,ne.getBytes())])])}else{var he=new Error("Cannot encrypt private key. Unknown encryption algorithm.");throw he.algorithm=ee.algorithm,he}var we=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[se,asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,!1,oe)]);return we};pki.decryptPrivateKeyInfo=function(J,E){var ee=null,te={},re=[];if(!asn1.validate(J,encryptedPrivateKeyValidator,te,re)){var ne=new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");throw ne.errors=re,ne}var ie=asn1.derToOid(te.encryptionOid),se=pki.pbe.getCipher(ie,te.encryptionParams,E),oe=forge$1.util.createBuffer(te.encryptedData);return se.update(oe),se.finish()&&(ee=asn1.fromDer(se.output)),ee};pki.encryptedPrivateKeyToPem=function(J,E){var ee={type:"ENCRYPTED PRIVATE KEY",body:asn1.toDer(J).getBytes()};return forge$1.pem.encode(ee,{maxline:E})};pki.encryptedPrivateKeyFromPem=function(J){var E=forge$1.pem.decode(J)[0];if(E.type!=="ENCRYPTED PRIVATE KEY"){var ee=new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');throw ee.headerType=E.type,ee}if(E.procType&&E.procType.type==="ENCRYPTED")throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");return asn1.fromDer(E.body)};pki.encryptRsaPrivateKey=function(J,E,ee){if(ee=ee||{},!ee.legacy){var te=pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(J));return te=pki.encryptPrivateKeyInfo(te,E,ee),pki.encryptedPrivateKeyToPem(te)}var re,ne,ie,se;switch(ee.algorithm){case"aes128":re="AES-128-CBC",ie=16,ne=forge$1.random.getBytesSync(16),se=forge$1.aes.createEncryptionCipher;break;case"aes192":re="AES-192-CBC",ie=24,ne=forge$1.random.getBytesSync(16),se=forge$1.aes.createEncryptionCipher;break;case"aes256":re="AES-256-CBC",ie=32,ne=forge$1.random.getBytesSync(16),se=forge$1.aes.createEncryptionCipher;break;case"3des":re="DES-EDE3-CBC",ie=24,ne=forge$1.random.getBytesSync(8),se=forge$1.des.createEncryptionCipher;break;case"des":re="DES-CBC",ie=8,ne=forge$1.random.getBytesSync(8),se=forge$1.des.createEncryptionCipher;break;default:var oe=new Error('Could not encrypt RSA private key; unsupported encryption algorithm "'+ee.algorithm+'".');throw oe.algorithm=ee.algorithm,oe}var ae=forge$1.pbe.opensslDeriveBytes(E,ne.substr(0,8),ie),ce=se(ae);ce.start(ne),ce.update(asn1.toDer(pki.privateKeyToAsn1(J))),ce.finish();var le={type:"RSA PRIVATE KEY",procType:{version:"4",type:"ENCRYPTED"},dekInfo:{algorithm:re,parameters:forge$1.util.bytesToHex(ne).toUpperCase()},body:ce.output.getBytes()};return forge$1.pem.encode(le)};pki.decryptRsaPrivateKey=function(J,E){var ee=null,te=forge$1.pem.decode(J)[0];if(te.type!=="ENCRYPTED PRIVATE KEY"&&te.type!=="PRIVATE KEY"&&te.type!=="RSA PRIVATE KEY"){var re=new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');throw re.headerType=re,re}if(te.procType&&te.procType.type==="ENCRYPTED"){var ne,ie;switch(te.dekInfo.algorithm){case"DES-CBC":ne=8,ie=forge$1.des.createDecryptionCipher;break;case"DES-EDE3-CBC":ne=24,ie=forge$1.des.createDecryptionCipher;break;case"AES-128-CBC":ne=16,ie=forge$1.aes.createDecryptionCipher;break;case"AES-192-CBC":ne=24,ie=forge$1.aes.createDecryptionCipher;break;case"AES-256-CBC":ne=32,ie=forge$1.aes.createDecryptionCipher;break;case"RC2-40-CBC":ne=5,ie=function(le){return forge$1.rc2.createDecryptionCipher(le,40)};break;case"RC2-64-CBC":ne=8,ie=function(le){return forge$1.rc2.createDecryptionCipher(le,64)};break;case"RC2-128-CBC":ne=16,ie=function(le){return forge$1.rc2.createDecryptionCipher(le,128)};break;default:var re=new Error('Could not decrypt private key; unsupported encryption algorithm "'+te.dekInfo.algorithm+'".');throw re.algorithm=te.dekInfo.algorithm,re}var se=forge$1.util.hexToBytes(te.dekInfo.parameters),oe=forge$1.pbe.opensslDeriveBytes(E,se.substr(0,8),ne),ae=ie(oe);if(ae.start(se),ae.update(forge$1.util.createBuffer(te.body)),ae.finish())ee=ae.output.getBytes();else return ee}else ee=te.body;return te.type==="ENCRYPTED PRIVATE KEY"?ee=pki.decryptPrivateKeyInfo(asn1.fromDer(ee),E):ee=asn1.fromDer(ee),ee!==null&&(ee=pki.privateKeyFromAsn1(ee)),ee};pki.pbe.generatePkcs12Key=function(J,E,ee,te,re,ne){var ie,se;if(typeof ne>"u"||ne===null){if(!("sha1"in forge$1.md))throw new Error('"sha1" hash algorithm unavailable.');ne=forge$1.md.sha1.create()}var oe=ne.digestLength,ae=ne.blockLength,ce=new forge$1.util.ByteBuffer,le=new forge$1.util.ByteBuffer;if(J!=null){for(se=0;se<J.length;se++)le.putInt16(J.charCodeAt(se));le.putInt16(0)}var he=le.length(),de=E.length(),ue=new forge$1.util.ByteBuffer;ue.fillWithByte(ee,ae);var pe=ae*Math.ceil(de/ae),ye=new forge$1.util.ByteBuffer;for(se=0;se<pe;se++)ye.putByte(E.at(se%de));var me=ae*Math.ceil(he/ae),be=new forge$1.util.ByteBuffer;for(se=0;se<me;se++)be.putByte(le.at(se%he));var _e=ye;_e.putBuffer(be);for(var we=Math.ceil(re/oe),$e=1;$e<=we;$e++){var ve=new forge$1.util.ByteBuffer;ve.putBytes(ue.bytes()),ve.putBytes(_e.bytes());for(var fe=0;fe<te;fe++)ne.start(),ne.update(ve.getBytes()),ve=ne.digest();var Ee=new forge$1.util.ByteBuffer;for(se=0;se<ae;se++)Ee.putByte(ve.at(se%oe));var ke=Math.ceil(de/ae)+Math.ceil(he/ae),Ne=new forge$1.util.ByteBuffer;for(ie=0;ie<ke;ie++){var xe=new forge$1.util.ByteBuffer(_e.getBytes(ae)),Ue=511;for(se=Ee.length()-1;se>=0;se--)Ue=Ue>>8,Ue+=Ee.at(se)+xe.at(se),xe.setAt(se,Ue&255);Ne.putBuffer(xe)}_e=Ne,ce.putBuffer(ve)}return ce.truncate(ce.length()-re),ce};pki.pbe.getCipher=function(J,E,ee){switch(J){case pki.oids.pkcs5PBES2:return pki.pbe.getCipherForPBES2(J,E,ee);case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:return pki.pbe.getCipherForPKCS12PBE(J,E,ee);default:var te=new Error("Cannot read encrypted PBE data block. Unsupported OID.");throw te.oid=J,te.supportedOids=["pkcs5PBES2","pbeWithSHAAnd3-KeyTripleDES-CBC","pbewithSHAAnd40BitRC2-CBC"],te}};pki.pbe.getCipherForPBES2=function(J,E,ee){var te={},re=[];if(!asn1.validate(E,PBES2AlgorithmsValidator,te,re)){var ne=new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");throw ne.errors=re,ne}if(J=asn1.derToOid(te.kdfOid),J!==pki.oids.pkcs5PBKDF2){var ne=new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");throw ne.oid=J,ne.supportedOids=["pkcs5PBKDF2"],ne}if(J=asn1.derToOid(te.encOid),J!==pki.oids["aes128-CBC"]&&J!==pki.oids["aes192-CBC"]&&J!==pki.oids["aes256-CBC"]&&J!==pki.oids["des-EDE3-CBC"]&&J!==pki.oids.desCBC){var ne=new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");throw ne.oid=J,ne.supportedOids=["aes128-CBC","aes192-CBC","aes256-CBC","des-EDE3-CBC","desCBC"],ne}var ie=te.kdfSalt,se=forge$1.util.createBuffer(te.kdfIterationCount);se=se.getInt(se.length()<<3);var oe,ae;switch(pki.oids[J]){case"aes128-CBC":oe=16,ae=forge$1.aes.createDecryptionCipher;break;case"aes192-CBC":oe=24,ae=forge$1.aes.createDecryptionCipher;break;case"aes256-CBC":oe=32,ae=forge$1.aes.createDecryptionCipher;break;case"des-EDE3-CBC":oe=24,ae=forge$1.des.createDecryptionCipher;break;case"desCBC":oe=8,ae=forge$1.des.createDecryptionCipher;break}var ce=prfOidToMessageDigest(te.prfOid),le=forge$1.pkcs5.pbkdf2(ee,ie,se,oe,ce),he=te.encIv,de=ae(le);return de.start(he),de};pki.pbe.getCipherForPKCS12PBE=function(J,E,ee){var te={},re=[];if(!asn1.validate(E,pkcs12PbeParamsValidator,te,re)){var ne=new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");throw ne.errors=re,ne}var ie=forge$1.util.createBuffer(te.salt),se=forge$1.util.createBuffer(te.iterations);se=se.getInt(se.length()<<3);var oe,ae,ce;switch(J){case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:oe=24,ae=8,ce=forge$1.des.startDecrypting;break;case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:oe=5,ae=8,ce=function(pe,ye){var me=forge$1.rc2.createDecryptionCipher(pe,40);return me.start(ye,null),me};break;default:var ne=new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");throw ne.oid=J,ne}var le=prfOidToMessageDigest(te.prfOid),he=pki.pbe.generatePkcs12Key(ee,ie,1,se,oe,le);le.start();var de=pki.pbe.generatePkcs12Key(ee,ie,2,se,ae,le);return ce(he,de)};pki.pbe.opensslDeriveBytes=function(J,E,ee,te){if(typeof te>"u"||te===null){if(!("md5"in forge$1.md))throw new Error('"md5" hash algorithm unavailable.');te=forge$1.md.md5.create()}E===null&&(E="");for(var re=[hash$1(te,J+E)],ne=16,ie=1;ne<ee;++ie,ne+=16)re.push(hash$1(te,re[ie-1]+J+E));return re.join("").substr(0,ee)};function hash$1(J,E){return J.start().update(E).digest().getBytes()}function prfOidToMessageDigest(J){var E;if(!J)E="hmacWithSHA1";else if(E=pki.oids[asn1.derToOid(J)],!E){var ee=new Error("Unsupported PRF OID.");throw ee.oid=J,ee.supported=["hmacWithSHA1","hmacWithSHA224","hmacWithSHA256","hmacWithSHA384","hmacWithSHA512"],ee}return prfAlgorithmToMessageDigest(E)}function prfAlgorithmToMessageDigest(J){var E=forge$1.md;switch(J){case"hmacWithSHA224":E=forge$1.md.sha512;case"hmacWithSHA1":case"hmacWithSHA256":case"hmacWithSHA384":case"hmacWithSHA512":J=J.substr(8).toLowerCase();break;default:var ee=new Error("Unsupported PRF algorithm.");throw ee.algorithm=J,ee.supported=["hmacWithSHA1","hmacWithSHA224","hmacWithSHA256","hmacWithSHA384","hmacWithSHA512"],ee}if(!E||!(J in E))throw new Error("Unknown hash algorithm: "+J);return E[J].create()}function createPbkdf2Params(J,E,ee,te){var re=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,!1,J),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,!1,E.getBytes())]);return te!=="hmacWithSHA1"&&re.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,!1,forge$1.util.hexToBytes(ee.toString(16))),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,!1,asn1.oidToDer(pki.oids[te]).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,!1,"")])),re}/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */const _0n$1=BigInt(0),_1n$1=BigInt(1),_2n$1=BigInt(2),_8n$1=BigInt(8),CU_O=BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),CURVE$1=Object.freeze({a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),P:BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),l:CU_O,n:CU_O,h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")}),POW_2_256$1=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000"),SQRT_M1=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");const SQRT_AD_MINUS_ONE=BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),INVSQRT_A_MINUS_D=BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),ONE_MINUS_D_SQ=BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),D_MINUS_ONE_SQ=BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");class ExtendedPoint{constructor(E,ee,te,re){this.x=E,this.y=ee,this.z=te,this.t=re}static fromAffine(E){if(!(E instanceof Point$1))throw new TypeError("ExtendedPoint#fromAffine: expected Point");return E.equals(Point$1.ZERO)?ExtendedPoint.ZERO:new ExtendedPoint(E.x,E.y,_1n$1,mod$1(E.x*E.y))}static toAffineBatch(E){const ee=invertBatch$1(E.map(te=>te.z));return E.map((te,re)=>te.toAffine(ee[re]))}static normalizeZ(E){return this.toAffineBatch(E).map(this.fromAffine)}equals(E){assertExtPoint(E);const{x:ee,y:te,z:re}=this,{x:ne,y:ie,z:se}=E,oe=mod$1(ee*se),ae=mod$1(ne*re),ce=mod$1(te*se),le=mod$1(ie*re);return oe===ae&&ce===le}negate(){return new ExtendedPoint(mod$1(-this.x),this.y,this.z,mod$1(-this.t))}double(){const{x:E,y:ee,z:te}=this,{a:re}=CURVE$1,ne=mod$1(E*E),ie=mod$1(ee*ee),se=mod$1(_2n$1*mod$1(te*te)),oe=mod$1(re*ne),ae=E+ee,ce=mod$1(mod$1(ae*ae)-ne-ie),le=oe+ie,he=le-se,de=oe-ie,ue=mod$1(ce*he),pe=mod$1(le*de),ye=mod$1(ce*de),me=mod$1(he*le);return new ExtendedPoint(ue,pe,me,ye)}add(E){assertExtPoint(E);const{x:ee,y:te,z:re,t:ne}=this,{x:ie,y:se,z:oe,t:ae}=E,ce=mod$1((te-ee)*(se+ie)),le=mod$1((te+ee)*(se-ie)),he=mod$1(le-ce);if(he===_0n$1)return this.double();const de=mod$1(re*_2n$1*ae),ue=mod$1(ne*_2n$1*oe),pe=ue+de,ye=le+ce,me=ue-de,be=mod$1(pe*he),_e=mod$1(ye*me),we=mod$1(pe*me),$e=mod$1(he*ye);return new ExtendedPoint(be,_e,$e,we)}subtract(E){return this.add(E.negate())}precomputeWindow(E){const ee=1+256/E,te=[];let re=this,ne=re;for(let ie=0;ie<ee;ie++){ne=re,te.push(ne);for(let se=1;se<2**(E-1);se++)ne=ne.add(re),te.push(ne);re=ne.double()}return te}wNAF(E,ee){!ee&&this.equals(ExtendedPoint.BASE)&&(ee=Point$1.BASE);const te=ee&&ee._WINDOW_SIZE||1;if(256%te)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let re=ee&&pointPrecomputes$1.get(ee);re||(re=this.precomputeWindow(te),ee&&te!==1&&(re=ExtendedPoint.normalizeZ(re),pointPrecomputes$1.set(ee,re)));let ne=ExtendedPoint.ZERO,ie=ExtendedPoint.BASE;const se=1+256/te,oe=2**(te-1),ae=BigInt(2**te-1),ce=2**te,le=BigInt(te);for(let he=0;he<se;he++){const de=he*oe;let ue=Number(E&ae);E>>=le,ue>oe&&(ue-=ce,E+=_1n$1);const pe=de,ye=de+Math.abs(ue)-1,me=he%2!==0,be=ue<0;ue===0?ie=ie.add(constTimeNegate$1(me,re[pe])):ne=ne.add(constTimeNegate$1(be,re[ye]))}return ExtendedPoint.normalizeZ([ne,ie])[0]}multiply(E,ee){return this.wNAF(normalizeScalar$1(E,CURVE$1.l),ee)}multiplyUnsafe(E){let ee=normalizeScalar$1(E,CURVE$1.l,!1);const te=ExtendedPoint.BASE,re=ExtendedPoint.ZERO;if(ee===_0n$1)return re;if(this.equals(re)||ee===_1n$1)return this;if(this.equals(te))return this.wNAF(ee);let ne=re,ie=this;for(;ee>_0n$1;)ee&_1n$1&&(ne=ne.add(ie)),ie=ie.double(),ee>>=_1n$1;return ne}isSmallOrder(){return this.multiplyUnsafe(CURVE$1.h).equals(ExtendedPoint.ZERO)}isTorsionFree(){let E=this.multiplyUnsafe(CURVE$1.l/_2n$1).double();return CURVE$1.l%_2n$1&&(E=E.add(this)),E.equals(ExtendedPoint.ZERO)}toAffine(E){const{x:ee,y:te,z:re}=this,ne=this.equals(ExtendedPoint.ZERO);E==null&&(E=ne?_8n$1:invert$1(re));const ie=mod$1(ee*E),se=mod$1(te*E),oe=mod$1(re*E);if(ne)return Point$1.ZERO;if(oe!==_1n$1)throw new Error("invZ was invalid");return new Point$1(ie,se)}fromRistrettoBytes(){legacyRist()}toRistrettoBytes(){legacyRist()}fromRistrettoHash(){legacyRist()}}ExtendedPoint.BASE=new ExtendedPoint(CURVE$1.Gx,CURVE$1.Gy,_1n$1,mod$1(CURVE$1.Gx*CURVE$1.Gy));ExtendedPoint.ZERO=new ExtendedPoint(_0n$1,_1n$1,_1n$1,_0n$1);function constTimeNegate$1(J,E){const ee=E.negate();return J?ee:E}function assertExtPoint(J){if(!(J instanceof ExtendedPoint))throw new TypeError("ExtendedPoint expected")}function assertRstPoint(J){if(!(J instanceof RistrettoPoint))throw new TypeError("RistrettoPoint expected")}function legacyRist(){throw new Error("Legacy method: switch to RistrettoPoint")}class RistrettoPoint{constructor(E){this.ep=E}static calcElligatorRistrettoMap(E){const{d:ee}=CURVE$1,te=mod$1(SQRT_M1*E*E),re=mod$1((te+_1n$1)*ONE_MINUS_D_SQ);let ne=BigInt(-1);const ie=mod$1((ne-ee*te)*mod$1(te+ee));let{isValid:se,value:oe}=uvRatio(re,ie),ae=mod$1(oe*E);edIsNegative(ae)||(ae=mod$1(-ae)),se||(oe=ae),se||(ne=te);const ce=mod$1(ne*(te-_1n$1)*D_MINUS_ONE_SQ-ie),le=oe*oe,he=mod$1((oe+oe)*ie),de=mod$1(ce*SQRT_AD_MINUS_ONE),ue=mod$1(_1n$1-le),pe=mod$1(_1n$1+le);return new ExtendedPoint(mod$1(he*pe),mod$1(ue*de),mod$1(de*pe),mod$1(he*ue))}static hashToCurve(E){E=ensureBytes$1(E,64);const ee=bytes255ToNumberLE(E.slice(0,32)),te=this.calcElligatorRistrettoMap(ee),re=bytes255ToNumberLE(E.slice(32,64)),ne=this.calcElligatorRistrettoMap(re);return new RistrettoPoint(te.add(ne))}static fromHex(E){E=ensureBytes$1(E,32);const{a:ee,d:te}=CURVE$1,re="RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint",ne=bytes255ToNumberLE(E);if(!equalBytes(numberTo32BytesLE(ne),E)||edIsNegative(ne))throw new Error(re);const ie=mod$1(ne*ne),se=mod$1(_1n$1+ee*ie),oe=mod$1(_1n$1-ee*ie),ae=mod$1(se*se),ce=mod$1(oe*oe),le=mod$1(ee*te*ae-ce),{isValid:he,value:de}=invertSqrt(mod$1(le*ce)),ue=mod$1(de*oe),pe=mod$1(de*ue*le);let ye=mod$1((ne+ne)*ue);edIsNegative(ye)&&(ye=mod$1(-ye));const me=mod$1(se*pe),be=mod$1(ye*me);if(!he||edIsNegative(be)||me===_0n$1)throw new Error(re);return new RistrettoPoint(new ExtendedPoint(ye,me,_1n$1,be))}toRawBytes(){let{x:E,y:ee,z:te,t:re}=this.ep;const ne=mod$1(mod$1(te+ee)*mod$1(te-ee)),ie=mod$1(E*ee),se=mod$1(ie*ie),{value:oe}=invertSqrt(mod$1(ne*se)),ae=mod$1(oe*ne),ce=mod$1(oe*ie),le=mod$1(ae*ce*re);let he;if(edIsNegative(re*le)){let ue=mod$1(ee*SQRT_M1),pe=mod$1(E*SQRT_M1);E=ue,ee=pe,he=mod$1(ae*INVSQRT_A_MINUS_D)}else he=ce;edIsNegative(E*le)&&(ee=mod$1(-ee));let de=mod$1((te-ee)*he);return edIsNegative(de)&&(de=mod$1(-de)),numberTo32BytesLE(de)}toHex(){return bytesToHex$1(this.toRawBytes())}toString(){return this.toHex()}equals(E){assertRstPoint(E);const ee=this.ep,te=E.ep,re=mod$1(ee.x*te.y)===mod$1(ee.y*te.x),ne=mod$1(ee.y*te.y)===mod$1(ee.x*te.x);return re||ne}add(E){return assertRstPoint(E),new RistrettoPoint(this.ep.add(E.ep))}subtract(E){return assertRstPoint(E),new RistrettoPoint(this.ep.subtract(E.ep))}multiply(E){return new RistrettoPoint(this.ep.multiply(E))}multiplyUnsafe(E){return new RistrettoPoint(this.ep.multiplyUnsafe(E))}}RistrettoPoint.BASE=new RistrettoPoint(ExtendedPoint.BASE);RistrettoPoint.ZERO=new RistrettoPoint(ExtendedPoint.ZERO);const pointPrecomputes$1=new WeakMap;let Point$1=class Ut{constructor(E,ee){this.x=E,this.y=ee}_setWindowSize(E){this._WINDOW_SIZE=E,pointPrecomputes$1.delete(this)}static fromHex(E,ee=!0){const{d:te,P:re}=CURVE$1;E=ensureBytes$1(E,32);const ne=E.slice();ne[31]=E[31]&-129;const ie=bytesToNumberLE(ne);if(ee&&ie>=re)throw new Error("Expected 0 < hex < P");if(!ee&&ie>=POW_2_256$1)throw new Error("Expected 0 < hex < 2**256");const se=mod$1(ie*ie),oe=mod$1(se-_1n$1),ae=mod$1(te*se+_1n$1);let{isValid:ce,value:le}=uvRatio(oe,ae);if(!ce)throw new Error("Point.fromHex: invalid y coordinate");const he=(le&_1n$1)===_1n$1;return(E[31]&128)!==0!==he&&(le=mod$1(-le)),new Ut(le,ie)}static async fromPrivateKey(E){return(await getExtendedPublicKey(E)).point}toRawBytes(){const E=numberTo32BytesLE(this.y);return E[31]|=this.x&_1n$1?128:0,E}toHex(){return bytesToHex$1(this.toRawBytes())}toX25519(){const{y:E}=this,ee=mod$1((_1n$1+E)*invert$1(_1n$1-E));return numberTo32BytesLE(ee)}isTorsionFree(){return ExtendedPoint.fromAffine(this).isTorsionFree()}equals(E){return this.x===E.x&&this.y===E.y}negate(){return new Ut(mod$1(-this.x),this.y)}add(E){return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(E)).toAffine()}subtract(E){return this.add(E.negate())}multiply(E){return ExtendedPoint.fromAffine(this).multiply(E,this).toAffine()}};Point$1.BASE=new Point$1(CURVE$1.Gx,CURVE$1.Gy);Point$1.ZERO=new Point$1(_0n$1,_1n$1);let Signature$1=class Vt{constructor(E,ee){this.r=E,this.s=ee,this.assertValidity()}static fromHex(E){const ee=ensureBytes$1(E,64),te=Point$1.fromHex(ee.slice(0,32),!1),re=bytesToNumberLE(ee.slice(32,64));return new Vt(te,re)}assertValidity(){const{r:E,s:ee}=this;if(!(E instanceof Point$1))throw new Error("Expected Point instance");return normalizeScalar$1(ee,CURVE$1.l,!1),this}toRawBytes(){const E=new Uint8Array(64);return E.set(this.r.toRawBytes()),E.set(numberTo32BytesLE(this.s),32),E}toHex(){return bytesToHex$1(this.toRawBytes())}};function concatBytes$1(...J){if(!J.every(te=>te instanceof Uint8Array))throw new Error("Expected Uint8Array list");if(J.length===1)return J[0];const E=J.reduce((te,re)=>te+re.length,0),ee=new Uint8Array(E);for(let te=0,re=0;te<J.length;te++){const ne=J[te];ee.set(ne,re),re+=ne.length}return ee}const hexes$1=Array.from({length:256},(J,E)=>E.toString(16).padStart(2,"0"));function bytesToHex$1(J){if(!(J instanceof Uint8Array))throw new Error("Uint8Array expected");let E="";for(let ee=0;ee<J.length;ee++)E+=hexes$1[J[ee]];return E}function hexToBytes$1(J){if(typeof J!="string")throw new TypeError("hexToBytes: expected string, got "+typeof J);if(J.length%2)throw new Error("hexToBytes: received invalid unpadded hex");const E=new Uint8Array(J.length/2);for(let ee=0;ee<E.length;ee++){const te=ee*2,re=J.slice(te,te+2),ne=Number.parseInt(re,16);if(Number.isNaN(ne)||ne<0)throw new Error("Invalid byte sequence");E[ee]=ne}return E}function numberTo32BytesBE(J){const E=J.toString(16).padStart(64,"0");return hexToBytes$1(E)}function numberTo32BytesLE(J){return numberTo32BytesBE(J).reverse()}function edIsNegative(J){return(mod$1(J)&_1n$1)===_1n$1}function bytesToNumberLE(J){if(!(J instanceof Uint8Array))throw new Error("Expected Uint8Array");return BigInt("0x"+bytesToHex$1(Uint8Array.from(J).reverse()))}const MAX_255B=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");function bytes255ToNumberLE(J){return mod$1(bytesToNumberLE(J)&MAX_255B)}function mod$1(J,E=CURVE$1.P){const ee=J%E;return ee>=_0n$1?ee:E+ee}function invert$1(J,E=CURVE$1.P){if(J===_0n$1||E<=_0n$1)throw new Error(`invert: expected positive integers, got n=${J} mod=${E}`);let ee=mod$1(J,E),te=E,re=_0n$1,ne=_1n$1;for(;ee!==_0n$1;){const ie=te/ee,se=te%ee,oe=re-ne*ie;te=ee,ee=se,re=ne,ne=oe}if(te!==_1n$1)throw new Error("invert: does not exist");return mod$1(re,E)}function invertBatch$1(J,E=CURVE$1.P){const ee=new Array(J.length),te=J.reduce((ne,ie,se)=>ie===_0n$1?ne:(ee[se]=ne,mod$1(ne*ie,E)),_1n$1),re=invert$1(te,E);return J.reduceRight((ne,ie,se)=>ie===_0n$1?ne:(ee[se]=mod$1(ne*ee[se],E),mod$1(ne*ie,E)),re),ee}function pow2$1(J,E){const{P:ee}=CURVE$1;let te=J;for(;E-- >_0n$1;)te*=te,te%=ee;return te}function pow_2_252_3(J){const{P:E}=CURVE$1,ee=BigInt(5),te=BigInt(10),re=BigInt(20),ne=BigInt(40),ie=BigInt(80),se=J*J%E*J%E,oe=pow2$1(se,_2n$1)*se%E,ae=pow2$1(oe,_1n$1)*J%E,ce=pow2$1(ae,ee)*ae%E,le=pow2$1(ce,te)*ce%E,he=pow2$1(le,re)*le%E,de=pow2$1(he,ne)*he%E,ue=pow2$1(de,ie)*de%E,pe=pow2$1(ue,ie)*de%E,ye=pow2$1(pe,te)*ce%E;return{pow_p_5_8:pow2$1(ye,_2n$1)*J%E,b2:se}}function uvRatio(J,E){const ee=mod$1(E*E*E),te=mod$1(ee*ee*E),re=pow_2_252_3(J*te).pow_p_5_8;let ne=mod$1(J*ee*re);const ie=mod$1(E*ne*ne),se=ne,oe=mod$1(ne*SQRT_M1),ae=ie===J,ce=ie===mod$1(-J),le=ie===mod$1(-J*SQRT_M1);return ae&&(ne=se),(ce||le)&&(ne=oe),edIsNegative(ne)&&(ne=mod$1(-ne)),{isValid:ae||ce,value:ne}}function invertSqrt(J){return uvRatio(_1n$1,J)}function modlLE(J){return mod$1(bytesToNumberLE(J),CURVE$1.l)}function equalBytes(J,E){if(J.length!==E.length)return!1;for(let ee=0;ee<J.length;ee++)if(J[ee]!==E[ee])return!1;return!0}function ensureBytes$1(J,E){const ee=J instanceof Uint8Array?Uint8Array.from(J):hexToBytes$1(J);if(typeof E=="number"&&ee.length!==E)throw new Error(`Expected ${E} bytes`);return ee}function normalizeScalar$1(J,E,ee=!0){if(!E)throw new TypeError("Specify max value");if(typeof J=="number"&&Number.isSafeInteger(J)&&(J=BigInt(J)),typeof J=="bigint"&&J<E){if(ee){if(_0n$1<J)return J}else if(_0n$1<=J)return J}throw new TypeError("Expected valid scalar: 0 < scalar < max")}function adjustBytes25519(J){return J[0]&=248,J[31]&=127,J[31]|=64,J}function checkPrivateKey(J){if(J=typeof J=="bigint"||typeof J=="number"?numberTo32BytesBE(normalizeScalar$1(J,POW_2_256$1)):ensureBytes$1(J),J.length!==32)throw new Error("Expected 32 bytes");return J}function getKeyFromHash(J){const E=adjustBytes25519(J.slice(0,32)),ee=J.slice(32,64),te=modlLE(E),re=Point$1.BASE.multiply(te),ne=re.toRawBytes();return{head:E,prefix:ee,scalar:te,point:re,pointBytes:ne}}let _sha512Sync;async function getExtendedPublicKey(J){return getKeyFromHash(await utils$1$1.sha512(checkPrivateKey(J)))}async function getPublicKey$1(J){return(await getExtendedPublicKey(J)).pointBytes}async function sign$1(J,E){J=ensureBytes$1(J);const{prefix:ee,scalar:te,pointBytes:re}=await getExtendedPublicKey(E),ne=modlLE(await utils$1$1.sha512(ee,J)),ie=Point$1.BASE.multiply(ne),se=modlLE(await utils$1$1.sha512(ie.toRawBytes(),re,J)),oe=mod$1(ne+se*te,CURVE$1.l);return new Signature$1(ie,oe).toRawBytes()}function prepareVerification(J,E,ee){E=ensureBytes$1(E),ee instanceof Point$1||(ee=Point$1.fromHex(ee,!1));const{r:te,s:re}=J instanceof Signature$1?J.assertValidity():Signature$1.fromHex(J),ne=ExtendedPoint.BASE.multiplyUnsafe(re);return{r:te,s:re,SB:ne,pub:ee,msg:E}}function finishVerification(J,E,ee,te){const re=modlLE(te),ne=ExtendedPoint.fromAffine(J).multiplyUnsafe(re);return ExtendedPoint.fromAffine(E).add(ne).subtract(ee).multiplyUnsafe(CURVE$1.h).equals(ExtendedPoint.ZERO)}async function verify$1(J,E,ee){const{r:te,SB:re,msg:ne,pub:ie}=prepareVerification(J,E,ee),se=await utils$1$1.sha512(te.toRawBytes(),ie.toRawBytes(),ne);return finishVerification(ie,te,re,se)}Point$1.BASE._setWindowSize(8);const crypto$2={node:nodeCrypto,web:typeof self=="object"&&"crypto"in self?self.crypto:void 0},utils$1$1={bytesToHex:bytesToHex$1,hexToBytes:hexToBytes$1,concatBytes:concatBytes$1,getExtendedPublicKey,mod:mod$1,invert:invert$1,TORSION_SUBGROUP:["0100000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a","0000000000000000000000000000000000000000000000000000000000000080","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05","ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85","0000000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"],hashToPrivateScalar:J=>{if(J=ensureBytes$1(J),J.length<40||J.length>1024)throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");return mod$1(bytesToNumberLE(J),CURVE$1.l-_1n$1)+_1n$1},randomBytes:(J=32)=>{if(crypto$2.web)return crypto$2.web.getRandomValues(new Uint8Array(J));if(crypto$2.node){const{randomBytes:E}=crypto$2.node;return new Uint8Array(E(J).buffer)}else throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>utils$1$1.randomBytes(32),sha512:async(...J)=>{const E=concatBytes$1(...J);if(crypto$2.web){const ee=await crypto$2.web.subtle.digest("SHA-512",E.buffer);return new Uint8Array(ee)}else{if(crypto$2.node)return Uint8Array.from(crypto$2.node.createHash("sha512").update(E).digest());throw new Error("The environment doesn't have sha512 function")}},precompute(J=8,E=Point$1.BASE){const ee=E.equals(Point$1.BASE)?E:new Point$1(E.x,E.y);return ee._setWindowSize(J),ee.multiply(_2n$1),ee},sha512Sync:void 0};Object.defineProperties(utils$1$1,{sha512Sync:{configurable:!1,get(){return _sha512Sync},set(J){_sha512Sync||(_sha512Sync=J)}}});const PUBLIC_KEY_BYTE_LENGTH=32,PRIVATE_KEY_BYTE_LENGTH=64,KEYS_BYTE_LENGTH=32;async function generateKey$2(){const J=utils$1$1.randomPrivateKey(),E=await getPublicKey$1(J);return{privateKey:concatKeys(J,E),publicKey:E}}async function generateKeyFromSeed(J){if(J.length!==KEYS_BYTE_LENGTH)throw new TypeError('"seed" must be 32 bytes in length.');if(!(J instanceof Uint8Array))throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');const E=J,ee=await getPublicKey$1(E);return{privateKey:concatKeys(E,ee),publicKey:ee}}async function hashAndSign$2(J,E){const ee=J.subarray(0,KEYS_BYTE_LENGTH);return sign$1(E,ee)}async function hashAndVerify$2(J,E,ee){return verify$1(E,ee,J)}function concatKeys(J,E){const ee=new Uint8Array(PRIVATE_KEY_BYTE_LENGTH);for(let te=0;te<KEYS_BYTE_LENGTH;te++)ee[te]=J[te],ee[KEYS_BYTE_LENGTH+te]=E[te];return ee}const webcrypto={get(J=globalThis){const E=J.crypto;if(E==null||E.subtle==null)throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"),{code:"ERR_MISSING_WEB_CRYPTO"});return E}},derivedEmptyPasswordKey={alg:"A128GCM",ext:!0,k:"scm9jmO_4BJAgdwWGVulLg",key_ops:["encrypt","decrypt"],kty:"oct"};function create$2(J){const E=J?.algorithm??"AES-GCM";let ee=J?.keyLength??16;const te=J?.nonceLength??12,re=J?.digest??"SHA-256",ne=J?.saltLength??16,ie=J?.iterations??32767,se=webcrypto.get();ee*=8;async function oe(ce,le){const he=se.getRandomValues(new Uint8Array(ne)),de=se.getRandomValues(new Uint8Array(te)),ue={name:E,iv:de};typeof le=="string"&&(le=fromString$4(le));let pe;if(le.length===0){pe=await se.subtle.importKey("jwk",derivedEmptyPasswordKey,{name:"AES-GCM"},!0,["encrypt"]);try{const me={name:"PBKDF2",salt:he,iterations:ie,hash:{name:re}},be=await se.subtle.importKey("raw",le,{name:"PBKDF2"},!1,["deriveKey"]);pe=await se.subtle.deriveKey(me,be,{name:E,length:ee},!0,["encrypt"])}catch{pe=await se.subtle.importKey("jwk",derivedEmptyPasswordKey,{name:"AES-GCM"},!0,["encrypt"])}}else{const me={name:"PBKDF2",salt:he,iterations:ie,hash:{name:re}},be=await se.subtle.importKey("raw",le,{name:"PBKDF2"},!1,["deriveKey"]);pe=await se.subtle.deriveKey(me,be,{name:E,length:ee},!0,["encrypt"])}const ye=await se.subtle.encrypt(ue,pe,ce);return concat$3([he,ue.iv,new Uint8Array(ye)])}async function ae(ce,le){const he=ce.subarray(0,ne),de=ce.subarray(ne,ne+te),ue=ce.subarray(ne+te),pe={name:E,iv:de};typeof le=="string"&&(le=fromString$4(le));let ye;if(le.length===0)try{const be={name:"PBKDF2",salt:he,iterations:ie,hash:{name:re}},_e=await se.subtle.importKey("raw",le,{name:"PBKDF2"},!1,["deriveKey"]);ye=await se.subtle.deriveKey(be,_e,{name:E,length:ee},!0,["decrypt"])}catch{ye=await se.subtle.importKey("jwk",derivedEmptyPasswordKey,{name:"AES-GCM"},!0,["decrypt"])}else{const be={name:"PBKDF2",salt:he,iterations:ie,hash:{name:re}},_e=await se.subtle.importKey("raw",le,{name:"PBKDF2"},!1,["deriveKey"]);ye=await se.subtle.deriveKey(be,_e,{name:E,length:ee},!0,["decrypt"])}const me=await se.subtle.decrypt(pe,ye,ue);return new Uint8Array(me)}return{encrypt:oe,decrypt:ae}}async function exporter(J,E){const ee=await create$2().encrypt(J,E);return base64$4.encode(ee)}var minimal={},aspromise=asPromise;function asPromise(J,E){for(var ee=new Array(arguments.length-1),te=0,re=2,ne=!0;re<arguments.length;)ee[te++]=arguments[re++];return new Promise(function(ie,se){ee[te]=function(oe){if(ne)if(ne=!1,oe)se(oe);else{for(var ae=new Array(arguments.length-1),ce=0;ce<ae.length;)ae[ce++]=arguments[ce];ie.apply(null,ae)}};try{J.apply(E||null,ee)}catch(oe){ne&&(ne=!1,se(oe))}})}var base64$3={};(function(J){var E=J;E.length=function(ie){var se=ie.length;if(!se)return 0;for(var oe=0;--se%4>1&&ie.charAt(se)==="=";)++oe;return Math.ceil(ie.length*3)/4-oe};for(var ee=new Array(64),te=new Array(123),re=0;re<64;)te[ee[re]=re<26?re+65:re<52?re+71:re<62?re-4:re-59|43]=re++;E.encode=function(ie,se,oe){for(var ae=null,ce=[],le=0,he=0,de;se<oe;){var ue=ie[se++];switch(he){case 0:ce[le++]=ee[ue>>2],de=(ue&3)<<4,he=1;break;case 1:ce[le++]=ee[de|ue>>4],de=(ue&15)<<2,he=2;break;case 2:ce[le++]=ee[de|ue>>6],ce[le++]=ee[ue&63],he=0;break}le>8191&&((ae||(ae=[])).push(String.fromCharCode.apply(String,ce)),le=0)}return he&&(ce[le++]=ee[de],ce[le++]=61,he===1&&(ce[le++]=61)),ae?(le&&ae.push(String.fromCharCode.apply(String,ce.slice(0,le))),ae.join("")):String.fromCharCode.apply(String,ce.slice(0,le))};var ne="invalid encoding";E.decode=function(ie,se,oe){for(var ae=oe,ce=0,le,he=0;he<ie.length;){var de=ie.charCodeAt(he++);if(de===61&&ce>1)break;if((de=te[de])===void 0)throw Error(ne);switch(ce){case 0:le=de,ce=1;break;case 1:se[oe++]=le<<2|(de&48)>>4,le=de,ce=2;break;case 2:se[oe++]=(le&15)<<4|(de&60)>>2,le=de,ce=3;break;case 3:se[oe++]=(le&3)<<6|de,ce=0;break}}if(ce===1)throw Error(ne);return oe-ae},E.test=function(ie){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(ie)}})(base64$3);var eventemitter=EventEmitter;function EventEmitter(){this._listeners={}}EventEmitter.prototype.on=function(J,E,ee){return(this._listeners[J]||(this._listeners[J]=[])).push({fn:E,ctx:ee||this}),this};EventEmitter.prototype.off=function(J,E){if(J===void 0)this._listeners={};else if(E===void 0)this._listeners[J]=[];else for(var ee=this._listeners[J],te=0;te<ee.length;)ee[te].fn===E?ee.splice(te,1):++te;return this};EventEmitter.prototype.emit=function(J){var E=this._listeners[J];if(E){for(var ee=[],te=1;te<arguments.length;)ee.push(arguments[te++]);for(te=0;te<E.length;)E[te].fn.apply(E[te++].ctx,ee)}return this};var float=factory(factory);function factory(J){return typeof Float32Array<"u"?function(){var E=new Float32Array([-0]),ee=new Uint8Array(E.buffer),te=ee[3]===128;function re(oe,ae,ce){E[0]=oe,ae[ce]=ee[0],ae[ce+1]=ee[1],ae[ce+2]=ee[2],ae[ce+3]=ee[3]}function ne(oe,ae,ce){E[0]=oe,ae[ce]=ee[3],ae[ce+1]=ee[2],ae[ce+2]=ee[1],ae[ce+3]=ee[0]}J.writeFloatLE=te?re:ne,J.writeFloatBE=te?ne:re;function ie(oe,ae){return ee[0]=oe[ae],ee[1]=oe[ae+1],ee[2]=oe[ae+2],ee[3]=oe[ae+3],E[0]}function se(oe,ae){return ee[3]=oe[ae],ee[2]=oe[ae+1],ee[1]=oe[ae+2],ee[0]=oe[ae+3],E[0]}J.readFloatLE=te?ie:se,J.readFloatBE=te?se:ie}():function(){function E(te,re,ne,ie){var se=re<0?1:0;if(se&&(re=-re),re===0)te(1/re>0?0:2147483648,ne,ie);else if(isNaN(re))te(2143289344,ne,ie);else if(re>34028234663852886e22)te((se<<31|2139095040)>>>0,ne,ie);else if(re<11754943508222875e-54)te((se<<31|Math.round(re/1401298464324817e-60))>>>0,ne,ie);else{var oe=Math.floor(Math.log(re)/Math.LN2),ae=Math.round(re*Math.pow(2,-oe)*8388608)&8388607;te((se<<31|oe+127<<23|ae)>>>0,ne,ie)}}J.writeFloatLE=E.bind(null,writeUintLE),J.writeFloatBE=E.bind(null,writeUintBE);function ee(te,re,ne){var ie=te(re,ne),se=(ie>>31)*2+1,oe=ie>>>23&255,ae=ie&8388607;return oe===255?ae?NaN:se*(1/0):oe===0?se*1401298464324817e-60*ae:se*Math.pow(2,oe-150)*(ae+8388608)}J.readFloatLE=ee.bind(null,readUintLE),J.readFloatBE=ee.bind(null,readUintBE)}(),typeof Float64Array<"u"?function(){var E=new Float64Array([-0]),ee=new Uint8Array(E.buffer),te=ee[7]===128;function re(oe,ae,ce){E[0]=oe,ae[ce]=ee[0],ae[ce+1]=ee[1],ae[ce+2]=ee[2],ae[ce+3]=ee[3],ae[ce+4]=ee[4],ae[ce+5]=ee[5],ae[ce+6]=ee[6],ae[ce+7]=ee[7]}function ne(oe,ae,ce){E[0]=oe,ae[ce]=ee[7],ae[ce+1]=ee[6],ae[ce+2]=ee[5],ae[ce+3]=ee[4],ae[ce+4]=ee[3],ae[ce+5]=ee[2],ae[ce+6]=ee[1],ae[ce+7]=ee[0]}J.writeDoubleLE=te?re:ne,J.writeDoubleBE=te?ne:re;function ie(oe,ae){return ee[0]=oe[ae],ee[1]=oe[ae+1],ee[2]=oe[ae+2],ee[3]=oe[ae+3],ee[4]=oe[ae+4],ee[5]=oe[ae+5],ee[6]=oe[ae+6],ee[7]=oe[ae+7],E[0]}function se(oe,ae){return ee[7]=oe[ae],ee[6]=oe[ae+1],ee[5]=oe[ae+2],ee[4]=oe[ae+3],ee[3]=oe[ae+4],ee[2]=oe[ae+5],ee[1]=oe[ae+6],ee[0]=oe[ae+7],E[0]}J.readDoubleLE=te?ie:se,J.readDoubleBE=te?se:ie}():function(){function E(te,re,ne,ie,se,oe){var ae=ie<0?1:0;if(ae&&(ie=-ie),ie===0)te(0,se,oe+re),te(1/ie>0?0:2147483648,se,oe+ne);else if(isNaN(ie))te(0,se,oe+re),te(2146959360,se,oe+ne);else if(ie>17976931348623157e292)te(0,se,oe+re),te((ae<<31|2146435072)>>>0,se,oe+ne);else{var ce;if(ie<22250738585072014e-324)ce=ie/5e-324,te(ce>>>0,se,oe+re),te((ae<<31|ce/4294967296)>>>0,se,oe+ne);else{var le=Math.floor(Math.log(ie)/Math.LN2);le===1024&&(le=1023),ce=ie*Math.pow(2,-le),te(ce*4503599627370496>>>0,se,oe+re),te((ae<<31|le+1023<<20|ce*1048576&1048575)>>>0,se,oe+ne)}}}J.writeDoubleLE=E.bind(null,writeUintLE,0,4),J.writeDoubleBE=E.bind(null,writeUintBE,4,0);function ee(te,re,ne,ie,se){var oe=te(ie,se+re),ae=te(ie,se+ne),ce=(ae>>31)*2+1,le=ae>>>20&2047,he=4294967296*(ae&1048575)+oe;return le===2047?he?NaN:ce*(1/0):le===0?ce*5e-324*he:ce*Math.pow(2,le-1075)*(he+4503599627370496)}J.readDoubleLE=ee.bind(null,readUintLE,0,4),J.readDoubleBE=ee.bind(null,readUintBE,4,0)}(),J}function writeUintLE(J,E,ee){E[ee]=J&255,E[ee+1]=J>>>8&255,E[ee+2]=J>>>16&255,E[ee+3]=J>>>24}function writeUintBE(J,E,ee){E[ee]=J>>>24,E[ee+1]=J>>>16&255,E[ee+2]=J>>>8&255,E[ee+3]=J&255}function readUintLE(J,E){return(J[E]|J[E+1]<<8|J[E+2]<<16|J[E+3]<<24)>>>0}function readUintBE(J,E){return(J[E]<<24|J[E+1]<<16|J[E+2]<<8|J[E+3])>>>0}var inquire_1=inquire;function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(J){}return null}var utf8$2={};(function(J){var E=J;E.length=function(ee){for(var te=0,re=0,ne=0;ne<ee.length;++ne)re=ee.charCodeAt(ne),re<128?te+=1:re<2048?te+=2:(re&64512)===55296&&(ee.charCodeAt(ne+1)&64512)===56320?(++ne,te+=4):te+=3;return te},E.read=function(ee,te,re){var ne=re-te;if(ne<1)return"";for(var ie=null,se=[],oe=0,ae;te<re;)ae=ee[te++],ae<128?se[oe++]=ae:ae>191&&ae<224?se[oe++]=(ae&31)<<6|ee[te++]&63:ae>239&&ae<365?(ae=((ae&7)<<18|(ee[te++]&63)<<12|(ee[te++]&63)<<6|ee[te++]&63)-65536,se[oe++]=55296+(ae>>10),se[oe++]=56320+(ae&1023)):se[oe++]=(ae&15)<<12|(ee[te++]&63)<<6|ee[te++]&63,oe>8191&&((ie||(ie=[])).push(String.fromCharCode.apply(String,se)),oe=0);return ie?(oe&&ie.push(String.fromCharCode.apply(String,se.slice(0,oe))),ie.join("")):String.fromCharCode.apply(String,se.slice(0,oe))},E.write=function(ee,te,re){for(var ne=re,ie,se,oe=0;oe<ee.length;++oe)ie=ee.charCodeAt(oe),ie<128?te[re++]=ie:ie<2048?(te[re++]=ie>>6|192,te[re++]=ie&63|128):(ie&64512)===55296&&((se=ee.charCodeAt(oe+1))&64512)===56320?(ie=65536+((ie&1023)<<10)+(se&1023),++oe,te[re++]=ie>>18|240,te[re++]=ie>>12&63|128,te[re++]=ie>>6&63|128,te[re++]=ie&63|128):(te[re++]=ie>>12|224,te[re++]=ie>>6&63|128,te[re++]=ie&63|128);return re-ne}})(utf8$2);var pool_1=pool;function pool(J,E,ee){var te=ee||8192,re=te>>>1,ne=null,ie=te;return function(se){if(se<1||se>re)return J(se);ie+se>te&&(ne=J(te),ie=0);var oe=E.call(ne,ie,ie+=se);return ie&7&&(ie=(ie|7)+1),oe}}var longbits,hasRequiredLongbits;function requireLongbits(){if(hasRequiredLongbits)return longbits;hasRequiredLongbits=1,longbits=E;var J=requireMinimal();function E(ne,ie){this.lo=ne>>>0,this.hi=ie>>>0}var ee=E.zero=new E(0,0);ee.toNumber=function(){return 0},ee.zzEncode=ee.zzDecode=function(){return this},ee.length=function(){return 1};var te=E.zeroHash="\0\0\0\0\0\0\0\0";E.fromNumber=function(ne){if(ne===0)return ee;var ie=ne<0;ie&&(ne=-ne);var se=ne>>>0,oe=(ne-se)/4294967296>>>0;return ie&&(oe=~oe>>>0,se=~se>>>0,++se>4294967295&&(se=0,++oe>4294967295&&(oe=0))),new E(se,oe)},E.from=function(ne){if(typeof ne=="number")return E.fromNumber(ne);if(J.isString(ne))if(J.Long)ne=J.Long.fromString(ne);else return E.fromNumber(parseInt(ne,10));return ne.low||ne.high?new E(ne.low>>>0,ne.high>>>0):ee},E.prototype.toNumber=function(ne){if(!ne&&this.hi>>>31){var ie=~this.lo+1>>>0,se=~this.hi>>>0;return ie||(se=se+1>>>0),-(ie+se*4294967296)}return this.lo+this.hi*4294967296},E.prototype.toLong=function(ne){return J.Long?new J.Long(this.lo|0,this.hi|0,!!ne):{low:this.lo|0,high:this.hi|0,unsigned:!!ne}};var re=String.prototype.charCodeAt;return E.fromHash=function(ne){return ne===te?ee:new E((re.call(ne,0)|re.call(ne,1)<<8|re.call(ne,2)<<16|re.call(ne,3)<<24)>>>0,(re.call(ne,4)|re.call(ne,5)<<8|re.call(ne,6)<<16|re.call(ne,7)<<24)>>>0)},E.prototype.toHash=function(){return String.fromCharCode(this.lo&255,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,this.hi&255,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},E.prototype.zzEncode=function(){var ne=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^ne)>>>0,this.lo=(this.lo<<1^ne)>>>0,this},E.prototype.zzDecode=function(){var ne=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^ne)>>>0,this.hi=(this.hi>>>1^ne)>>>0,this},E.prototype.length=function(){var ne=this.lo,ie=(this.lo>>>28|this.hi<<4)>>>0,se=this.hi>>>24;return se===0?ie===0?ne<16384?ne<128?1:2:ne<2097152?3:4:ie<16384?ie<128?5:6:ie<2097152?7:8:se<128?9:10},longbits}var hasRequiredMinimal;function requireMinimal(){return hasRequiredMinimal||(hasRequiredMinimal=1,function(J){var E=J;E.asPromise=aspromise,E.base64=base64$3,E.EventEmitter=eventemitter,E.float=float,E.inquire=inquire_1,E.utf8=utf8$2,E.pool=pool_1,E.LongBits=requireLongbits(),E.isNode=!!(typeof commonjsGlobal<"u"&&commonjsGlobal&&commonjsGlobal.process&&commonjsGlobal.process.versions&&commonjsGlobal.process.versions.node),E.global=E.isNode&&commonjsGlobal||typeof window<"u"&&window||typeof self<"u"&&self||commonjsGlobal,E.emptyArray=Object.freeze?Object.freeze([]):[],E.emptyObject=Object.freeze?Object.freeze({}):{},E.isInteger=Number.isInteger||function(re){return typeof re=="number"&&isFinite(re)&&Math.floor(re)===re},E.isString=function(re){return typeof re=="string"||re instanceof String},E.isObject=function(re){return re&&typeof re=="object"},E.isset=E.isSet=function(re,ne){var ie=re[ne];return ie!=null&&re.hasOwnProperty(ne)?typeof ie!="object"||(Array.isArray(ie)?ie.length:Object.keys(ie).length)>0:!1},E.Buffer=function(){try{var re=E.inquire("buffer").Buffer;return re.prototype.utf8Write?re:null}catch{return null}}(),E._Buffer_from=null,E._Buffer_allocUnsafe=null,E.newBuffer=function(re){return typeof re=="number"?E.Buffer?E._Buffer_allocUnsafe(re):new E.Array(re):E.Buffer?E._Buffer_from(re):typeof Uint8Array>"u"?re:new Uint8Array(re)},E.Array=typeof Uint8Array<"u"?Uint8Array:Array,E.Long=E.global.dcodeIO&&E.global.dcodeIO.Long||E.global.Long||E.inquire("long"),E.key2Re=/^true|false|0|1$/,E.key32Re=/^-?(?:0|[1-9][0-9]*)$/,E.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,E.longToHash=function(re){return re?E.LongBits.from(re).toHash():E.LongBits.zeroHash},E.longFromHash=function(re,ne){var ie=E.LongBits.fromHash(re);return E.Long?E.Long.fromBits(ie.lo,ie.hi,ne):ie.toNumber(!!ne)};function ee(re,ne,ie){for(var se=Object.keys(ne),oe=0;oe<se.length;++oe)(re[se[oe]]===void 0||!ie)&&(re[se[oe]]=ne[se[oe]]);return re}E.merge=ee,E.lcFirst=function(re){return re.charAt(0).toLowerCase()+re.substring(1)};function te(re){function ne(ie,se){if(!(this instanceof ne))return new ne(ie,se);Object.defineProperty(this,"message",{get:function(){return ie}}),Error.captureStackTrace?Error.captureStackTrace(this,ne):Object.defineProperty(this,"stack",{value:new Error().stack||""}),se&&ee(this,se)}return ne.prototype=Object.create(Error.prototype,{constructor:{value:ne,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return re},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),ne}E.newError=te,E.ProtocolError=te("ProtocolError"),E.oneOfGetter=function(re){for(var ne={},ie=0;ie<re.length;++ie)ne[re[ie]]=1;return function(){for(var se=Object.keys(this),oe=se.length-1;oe>-1;--oe)if(ne[se[oe]]===1&&this[se[oe]]!==void 0&&this[se[oe]]!==null)return se[oe]}},E.oneOfSetter=function(re){return function(ne){for(var ie=0;ie<re.length;++ie)re[ie]!==ne&&delete this[re[ie]]}},E.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},E._configure=function(){var re=E.Buffer;if(!re){E._Buffer_from=E._Buffer_allocUnsafe=null;return}E._Buffer_from=re.from!==Uint8Array.from&&re.from||function(ne,ie){return new re(ne,ie)},E._Buffer_allocUnsafe=re.allocUnsafe||function(ne){return new re(ne)}}}(minimal)),minimal}var reader$2=Reader$1,util$5=requireMinimal(),BufferReader$1,LongBits$2=util$5.LongBits,utf8$1=util$5.utf8;function indexOutOfRange(J,E){return RangeError("index out of range: "+J.pos+" + "+(E||1)+" > "+J.len)}function Reader$1(J){this.buf=J,this.pos=0,this.len=J.length}var create_array=typeof Uint8Array<"u"?function J(E){if(E instanceof Uint8Array||Array.isArray(E))return new Reader$1(E);throw Error("illegal buffer")}:function J(E){if(Array.isArray(E))return new Reader$1(E);throw Error("illegal buffer")},create$1=function J(){return util$5.Buffer?function(E){return(Reader$1.create=function(ee){return util$5.Buffer.isBuffer(ee)?new BufferReader$1(ee):create_array(ee)})(E)}:create_array};Reader$1.create=create$1();Reader$1.prototype._slice=util$5.Array.prototype.subarray||util$5.Array.prototype.slice;Reader$1.prototype.uint32=function J(){var E=4294967295;return function(){if(E=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(E=(E|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(E=(E|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(E=(E|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(E=(E|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return E;if((this.pos+=5)>this.len)throw this.pos=this.len,indexOutOfRange(this,10);return E}}();Reader$1.prototype.int32=function J(){return this.uint32()|0};Reader$1.prototype.sint32=function J(){var E=this.uint32();return E>>>1^-(E&1)|0};function readLongVarint(){var J=new LongBits$2(0,0),E=0;if(this.len-this.pos>4){for(;E<4;++E)if(J.lo=(J.lo|(this.buf[this.pos]&127)<<E*7)>>>0,this.buf[this.pos++]<128)return J;if(J.lo=(J.lo|(this.buf[this.pos]&127)<<28)>>>0,J.hi=(J.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return J;E=0}else{for(;E<3;++E){if(this.pos>=this.len)throw indexOutOfRange(this);if(J.lo=(J.lo|(this.buf[this.pos]&127)<<E*7)>>>0,this.buf[this.pos++]<128)return J}return J.lo=(J.lo|(this.buf[this.pos++]&127)<<E*7)>>>0,J}if(this.len-this.pos>4){for(;E<5;++E)if(J.hi=(J.hi|(this.buf[this.pos]&127)<<E*7+3)>>>0,this.buf[this.pos++]<128)return J}else for(;E<5;++E){if(this.pos>=this.len)throw indexOutOfRange(this);if(J.hi=(J.hi|(this.buf[this.pos]&127)<<E*7+3)>>>0,this.buf[this.pos++]<128)return J}throw Error("invalid varint encoding")}Reader$1.prototype.bool=function J(){return this.uint32()!==0};function readFixed32_end(J,E){return(J[E-4]|J[E-3]<<8|J[E-2]<<16|J[E-1]<<24)>>>0}Reader$1.prototype.fixed32=function J(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);return readFixed32_end(this.buf,this.pos+=4)};Reader$1.prototype.sfixed32=function J(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);return readFixed32_end(this.buf,this.pos+=4)|0};function readFixed64(){if(this.pos+8>this.len)throw indexOutOfRange(this,8);return new LongBits$2(readFixed32_end(this.buf,this.pos+=4),readFixed32_end(this.buf,this.pos+=4))}Reader$1.prototype.float=function J(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);var E=util$5.float.readFloatLE(this.buf,this.pos);return this.pos+=4,E};Reader$1.prototype.double=function J(){if(this.pos+8>this.len)throw indexOutOfRange(this,4);var E=util$5.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,E};Reader$1.prototype.bytes=function J(){var E=this.uint32(),ee=this.pos,te=this.pos+E;if(te>this.len)throw indexOutOfRange(this,E);return this.pos+=E,Array.isArray(this.buf)?this.buf.slice(ee,te):ee===te?new this.buf.constructor(0):this._slice.call(this.buf,ee,te)};Reader$1.prototype.string=function J(){var E=this.bytes();return utf8$1.read(E,0,E.length)};Reader$1.prototype.skip=function J(E){if(typeof E=="number"){if(this.pos+E>this.len)throw indexOutOfRange(this,E);this.pos+=E}else do if(this.pos>=this.len)throw indexOutOfRange(this);while(this.buf[this.pos++]&128);return this};Reader$1.prototype.skipType=function(J){switch(J){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(J=this.uint32()&7)!==4;)this.skipType(J);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+J+" at offset "+this.pos)}return this};Reader$1._configure=function(J){BufferReader$1=J,Reader$1.create=create$1(),BufferReader$1._configure();var E=util$5.Long?"toLong":"toNumber";util$5.merge(Reader$1.prototype,{int64:function(){return readLongVarint.call(this)[E](!1)},uint64:function(){return readLongVarint.call(this)[E](!0)},sint64:function(){return readLongVarint.call(this).zzDecode()[E](!1)},fixed64:function(){return readFixed64.call(this)[E](!0)},sfixed64:function(){return readFixed64.call(this)[E](!1)}})};const ReaderClass=getDefaultExportFromCjs(reader$2);var reader_buffer=BufferReader,Reader=reader$2;(BufferReader.prototype=Object.create(Reader.prototype)).constructor=BufferReader;var util$4=requireMinimal();function BufferReader(J){Reader.call(this,J)}BufferReader._configure=function(){util$4.Buffer&&(BufferReader.prototype._slice=util$4.Buffer.prototype.slice)};BufferReader.prototype.string=function J(){var E=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+E,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+E,this.len))};BufferReader._configure();const ReaderBufferClass=getDefaultExportFromCjs(reader_buffer);var minimalExports=requireMinimal();const util$3=getDefaultExportFromCjs(minimalExports);var writer$1=Writer$1,util$2=requireMinimal(),BufferWriter$1,LongBits$1=util$2.LongBits,base64$2=util$2.base64,utf8=util$2.utf8;function Op(J,E,ee){this.fn=J,this.len=E,this.next=void 0,this.val=ee}function noop$1(){}function State(J){this.head=J.head,this.tail=J.tail,this.len=J.len,this.next=J.states}function Writer$1(){this.len=0,this.head=new Op(noop$1,0,0),this.tail=this.head,this.states=null}var create=function J(){return util$2.Buffer?function(){return(Writer$1.create=function(){return new BufferWriter$1})()}:function(){return new Writer$1}};Writer$1.create=create();Writer$1.alloc=function J(E){return new util$2.Array(E)};util$2.Array!==Array&&(Writer$1.alloc=util$2.pool(Writer$1.alloc,util$2.Array.prototype.subarray));Writer$1.prototype._push=function J(E,ee,te){return this.tail=this.tail.next=new Op(E,ee,te),this.len+=ee,this};function writeByte(J,E,ee){E[ee]=J&255}function writeVarint32(J,E,ee){for(;J>127;)E[ee++]=J&127|128,J>>>=7;E[ee]=J}function VarintOp(J,E){this.len=J,this.next=void 0,this.val=E}VarintOp.prototype=Object.create(Op.prototype);VarintOp.prototype.fn=writeVarint32;Writer$1.prototype.uint32=function J(E){return this.len+=(this.tail=this.tail.next=new VarintOp((E=E>>>0)<128?1:E<16384?2:E<2097152?3:E<268435456?4:5,E)).len,this};Writer$1.prototype.int32=function J(E){return E<0?this._push(writeVarint64,10,LongBits$1.fromNumber(E)):this.uint32(E)};Writer$1.prototype.sint32=function J(E){return this.uint32((E<<1^E>>31)>>>0)};function writeVarint64(J,E,ee){for(;J.hi;)E[ee++]=J.lo&127|128,J.lo=(J.lo>>>7|J.hi<<25)>>>0,J.hi>>>=7;for(;J.lo>127;)E[ee++]=J.lo&127|128,J.lo=J.lo>>>7;E[ee++]=J.lo}Writer$1.prototype.uint64=function J(E){var ee=LongBits$1.from(E);return this._push(writeVarint64,ee.length(),ee)};Writer$1.prototype.int64=Writer$1.prototype.uint64;Writer$1.prototype.sint64=function J(E){var ee=LongBits$1.from(E).zzEncode();return this._push(writeVarint64,ee.length(),ee)};Writer$1.prototype.bool=function J(E){return this._push(writeByte,1,E?1:0)};function writeFixed32(J,E,ee){E[ee]=J&255,E[ee+1]=J>>>8&255,E[ee+2]=J>>>16&255,E[ee+3]=J>>>24}Writer$1.prototype.fixed32=function J(E){return this._push(writeFixed32,4,E>>>0)};Writer$1.prototype.sfixed32=Writer$1.prototype.fixed32;Writer$1.prototype.fixed64=function J(E){var ee=LongBits$1.from(E);return this._push(writeFixed32,4,ee.lo)._push(writeFixed32,4,ee.hi)};Writer$1.prototype.sfixed64=Writer$1.prototype.fixed64;Writer$1.prototype.float=function J(E){return this._push(util$2.float.writeFloatLE,4,E)};Writer$1.prototype.double=function J(E){return this._push(util$2.float.writeDoubleLE,8,E)};var writeBytes=util$2.Array.prototype.set?function J(E,ee,te){ee.set(E,te)}:function J(E,ee,te){for(var re=0;re<E.length;++re)ee[te+re]=E[re]};Writer$1.prototype.bytes=function J(E){var ee=E.length>>>0;if(!ee)return this._push(writeByte,1,0);if(util$2.isString(E)){var te=Writer$1.alloc(ee=base64$2.length(E));base64$2.decode(E,te,0),E=te}return this.uint32(ee)._push(writeBytes,ee,E)};Writer$1.prototype.string=function J(E){var ee=utf8.length(E);return ee?this.uint32(ee)._push(utf8.write,ee,E):this._push(writeByte,1,0)};Writer$1.prototype.fork=function J(){return this.states=new State(this),this.head=this.tail=new Op(noop$1,0,0),this.len=0,this};Writer$1.prototype.reset=function J(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Op(noop$1,0,0),this.len=0),this};Writer$1.prototype.ldelim=function J(){var E=this.head,ee=this.tail,te=this.len;return this.reset().uint32(te),te&&(this.tail.next=E.next,this.tail=ee,this.len+=te),this};Writer$1.prototype.finish=function J(){for(var E=this.head.next,ee=this.constructor.alloc(this.len),te=0;E;)E.fn(E.val,ee,te),te+=E.len,E=E.next;return ee};Writer$1._configure=function(J){BufferWriter$1=J,Writer$1.create=create(),BufferWriter$1._configure()};const WriterClass=getDefaultExportFromCjs(writer$1);var writer_buffer=BufferWriter,Writer=writer$1;(BufferWriter.prototype=Object.create(Writer.prototype)).constructor=BufferWriter;var util$1=requireMinimal();function BufferWriter(){Writer.call(this)}BufferWriter._configure=function(){BufferWriter.alloc=util$1._Buffer_allocUnsafe,BufferWriter.writeBytesBuffer=util$1.Buffer&&util$1.Buffer.prototype instanceof Uint8Array&&util$1.Buffer.prototype.set.name==="set"?function(J,E,ee){E.set(J,ee)}:function(J,E,ee){if(J.copy)J.copy(E,ee,0,J.length);else for(var te=0;te<J.length;)E[ee++]=J[te++]}};BufferWriter.prototype.bytes=function J(E){util$1.isString(E)&&(E=util$1._Buffer_from(E,"base64"));var ee=E.length>>>0;return this.uint32(ee),ee&&this._push(BufferWriter.writeBytesBuffer,ee,E),this};function writeStringBuffer(J,E,ee){J.length<40?util$1.utf8.write(J,E,ee):E.utf8Write?E.utf8Write(J,ee):E.write(J,ee)}BufferWriter.prototype.string=function J(E){var ee=util$1.Buffer.byteLength(E);return this.uint32(ee),ee&&this._push(writeStringBuffer,ee,E),this};BufferWriter._configure();const WriterBufferClass=getDefaultExportFromCjs(writer_buffer);function configure(){util$3._configure(),ReaderClass._configure(ReaderBufferClass),WriterClass._configure(WriterBufferClass)}configure();const methods=["uint64","int64","sint64","fixed64","sfixed64"];function patchReader(J){for(const E of methods){if(J[E]==null)continue;const ee=J[E];J[E]=function(){return BigInt(ee.call(this).toString())}}return J}function reader$1(J){return patchReader(new ReaderClass(J))}function patchWriter(J){for(const E of methods){if(J[E]==null)continue;const ee=J[E];J[E]=function(te){return ee.call(this,te.toString())}}return J}function writer(){return patchWriter(WriterClass.create())}function decodeMessage(J,E){const ee=reader$1(J instanceof Uint8Array?J:J.subarray());return E.decode(ee)}function encodeMessage(J,E){const ee=writer();return E.encode(J,ee,{lengthDelimited:!1}),ee.finish()}var CODEC_TYPES;(function(J){J[J.VARINT=0]="VARINT",J[J.BIT64=1]="BIT64",J[J.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",J[J.START_GROUP=3]="START_GROUP",J[J.END_GROUP=4]="END_GROUP",J[J.BIT32=5]="BIT32"})(CODEC_TYPES||(CODEC_TYPES={}));function createCodec$1(J,E,ee,te){return{name:J,type:E,encode:ee,decode:te}}function enumeration(J){function E(re){if(J[re.toString()]==null)throw new Error("Invalid enum value");return J[re]}const ee=function(re,ne){const ie=E(re);ne.int32(ie)},te=function(re){const ne=re.int32();return E(ne)};return createCodec$1("enum",CODEC_TYPES.VARINT,ee,te)}function message(J,E){return createCodec$1("message",CODEC_TYPES.LENGTH_DELIMITED,J,E)}var KeyType;(function(J){J.RSA="RSA",J.Ed25519="Ed25519",J.Secp256k1="Secp256k1"})(KeyType||(KeyType={}));var __KeyTypeValues;(function(J){J[J.RSA=0]="RSA",J[J.Ed25519=1]="Ed25519",J[J.Secp256k1=2]="Secp256k1"})(__KeyTypeValues||(__KeyTypeValues={}));(function(J){J.codec=()=>enumeration(__KeyTypeValues)})(KeyType||(KeyType={}));var PublicKey;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{re.lengthDelimited!==!1&&te.fork(),ee.Type!=null&&(te.uint32(8),KeyType.codec().encode(ee.Type,te)),ee.Data!=null&&(te.uint32(18),te.bytes(ee.Data)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.Type=KeyType.codec().decode(ee);break;case 2:re.Data=ee.bytes();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage(ee,J.codec())})(PublicKey||(PublicKey={}));var PrivateKey;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{re.lengthDelimited!==!1&&te.fork(),ee.Type!=null&&(te.uint32(8),KeyType.codec().encode(ee.Type,te)),ee.Data!=null&&(te.uint32(18),te.bytes(ee.Data)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.Type=KeyType.codec().decode(ee);break;case 2:re.Data=ee.bytes();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage(ee,J.codec())})(PrivateKey||(PrivateKey={}));class Ed25519PublicKey{_key;constructor(E){this._key=ensureKey(E,PUBLIC_KEY_BYTE_LENGTH)}async verify(E,ee){return hashAndVerify$2(this._key,ee,E)}marshal(){return this._key}get bytes(){return PublicKey.encode({Type:KeyType.Ed25519,Data:this.marshal()}).subarray()}equals(E){return equals(this.bytes,E.bytes)}async hash(){const{bytes:E}=await sha256$2.digest(this.bytes);return E}}class Ed25519PrivateKey{_key;_publicKey;constructor(E,ee){this._key=ensureKey(E,PRIVATE_KEY_BYTE_LENGTH),this._publicKey=ensureKey(ee,PUBLIC_KEY_BYTE_LENGTH)}async sign(E){return hashAndSign$2(this._key,E)}get public(){return new Ed25519PublicKey(this._publicKey)}marshal(){return this._key}get bytes(){return PrivateKey.encode({Type:KeyType.Ed25519,Data:this.marshal()}).subarray()}equals(E){return equals(this.bytes,E.bytes)}async hash(){const{bytes:E}=await sha256$2.digest(this.bytes);return E}async id(){const E=identity$2.digest(this.public.bytes);return base58btc$1.encode(E.bytes).substring(1)}async export(E,ee="libp2p-key"){if(ee==="libp2p-key")return exporter(this.bytes,E);throw new CodeError(`export format '${ee}' is not supported`,"ERR_INVALID_EXPORT_FORMAT")}}function unmarshalEd25519PrivateKey(J){if(J.length>PRIVATE_KEY_BYTE_LENGTH){J=ensureKey(J,PRIVATE_KEY_BYTE_LENGTH+PUBLIC_KEY_BYTE_LENGTH);const te=J.subarray(0,PRIVATE_KEY_BYTE_LENGTH),re=J.subarray(PRIVATE_KEY_BYTE_LENGTH,J.length);return new Ed25519PrivateKey(te,re)}J=ensureKey(J,PRIVATE_KEY_BYTE_LENGTH);const E=J.subarray(0,PRIVATE_KEY_BYTE_LENGTH),ee=J.subarray(PUBLIC_KEY_BYTE_LENGTH);return new Ed25519PrivateKey(E,ee)}function unmarshalEd25519PublicKey(J){return J=ensureKey(J,PUBLIC_KEY_BYTE_LENGTH),new Ed25519PublicKey(J)}async function generateKeyPair$3(){const{privateKey:J,publicKey:E}=await generateKey$2();return new Ed25519PrivateKey(J,E)}async function generateKeyPairFromSeed(J){const{privateKey:E,publicKey:ee}=await generateKeyFromSeed(J);return new Ed25519PrivateKey(E,ee)}function ensureKey(J,E){if(J=Uint8Array.from(J??[]),J.length!==E)throw new CodeError(`Key must be a Uint8Array of length ${E}, got ${J.length}`,"ERR_INVALID_KEY_TYPE");return J}const Ed25519=Object.freeze(Object.defineProperty({__proto__:null,Ed25519PrivateKey,Ed25519PublicKey,generateKeyPair:generateKeyPair$3,generateKeyPairFromSeed,unmarshalEd25519PrivateKey,unmarshalEd25519PublicKey},Symbol.toStringTag,{value:"Module"}));function bigIntegerToUintBase64url(J,E){let ee=Uint8Array.from(J.abs().toByteArray());if(ee=ee[0]===0?ee.subarray(1):ee,E!=null){if(ee.length>E)throw new Error("byte array longer than desired length");ee=concat$3([new Uint8Array(E-ee.length),ee])}return toString$4(ee,"base64url")}function base64urlToBigInteger(J){const E=base64urlToBuffer(J);return new forge$n.jsbn.BigInteger(toString$4(E,"base16"),16)}function base64urlToBuffer(J,E){let ee=fromString$4(J,"base64urlpad");if(E!=null){if(ee.length>E)throw new Error("byte array longer than desired length");ee=concat$3([new Uint8Array(E-ee.length),ee])}return ee}const bits={"P-256":256,"P-384":384,"P-521":521},curveTypes=Object.keys(bits);curveTypes.join(" / ");async function importer(J,E){const ee=base64$4.decode(J);return create$2().decrypt(ee,E)}var forge=forge$m,sha512=forge.sha512=forge.sha512||{};forge.md.sha512=forge.md.algorithms.sha512=sha512;var sha384=forge.sha384=forge.sha512.sha384=forge.sha512.sha384||{};sha384.create=function(){return sha512.create("SHA-384")};forge.md.sha384=forge.md.algorithms.sha384=sha384;forge.sha512.sha256=forge.sha512.sha256||{create:function(){return sha512.create("SHA-512/256")}};forge.md["sha512/256"]=forge.md.algorithms["sha512/256"]=forge.sha512.sha256;forge.sha512.sha224=forge.sha512.sha224||{create:function(){return sha512.create("SHA-512/224")}};forge.md["sha512/224"]=forge.md.algorithms["sha512/224"]=forge.sha512.sha224;sha512.create=function(J){if(_initialized||_init(),typeof J>"u"&&(J="SHA-512"),!(J in _states))throw new Error("Invalid SHA-512 algorithm: "+J);for(var E=_states[J],ee=null,te=forge.util.createBuffer(),re=new Array(80),ne=0;ne<80;++ne)re[ne]=new Array(2);var ie=64;switch(J){case"SHA-384":ie=48;break;case"SHA-512/256":ie=32;break;case"SHA-512/224":ie=28;break}var se={algorithm:J.replace("-","").toLowerCase(),blockLength:128,digestLength:ie,messageLength:0,fullMessageLength:null,messageLengthSize:16};return se.start=function(){se.messageLength=0,se.fullMessageLength=se.messageLength128=[];for(var oe=se.messageLengthSize/4,ae=0;ae<oe;++ae)se.fullMessageLength.push(0);te=forge.util.createBuffer(),ee=new Array(E.length);for(var ae=0;ae<E.length;++ae)ee[ae]=E[ae].slice(0);return se},se.start(),se.update=function(oe,ae){ae==="utf8"&&(oe=forge.util.encodeUtf8(oe));var ce=oe.length;se.messageLength+=ce,ce=[ce/4294967296>>>0,ce>>>0];for(var le=se.fullMessageLength.length-1;le>=0;--le)se.fullMessageLength[le]+=ce[1],ce[1]=ce[0]+(se.fullMessageLength[le]/4294967296>>>0),se.fullMessageLength[le]=se.fullMessageLength[le]>>>0,ce[0]=ce[1]/4294967296>>>0;return te.putBytes(oe),_update(ee,re,te),(te.read>2048||te.length()===0)&&te.compact(),se},se.digest=function(){var oe=forge.util.createBuffer();oe.putBytes(te.bytes());var ae=se.fullMessageLength[se.fullMessageLength.length-1]+se.messageLengthSize,ce=ae&se.blockLength-1;oe.putBytes(_padding.substr(0,se.blockLength-ce));for(var le,he,de=se.fullMessageLength[0]*8,ue=0;ue<se.fullMessageLength.length-1;++ue)le=se.fullMessageLength[ue+1]*8,he=le/4294967296>>>0,de+=he,oe.putInt32(de>>>0),de=le>>>0;oe.putInt32(de);for(var pe=new Array(ee.length),ue=0;ue<ee.length;++ue)pe[ue]=ee[ue].slice(0);_update(pe,re,oe);var ye=forge.util.createBuffer(),me;J==="SHA-512"?me=pe.length:J==="SHA-384"?me=pe.length-2:me=pe.length-4;for(var ue=0;ue<me;++ue)ye.putInt32(pe[ue][0]),(ue!==me-1||J!=="SHA-512/224")&&ye.putInt32(pe[ue][1]);return ye},se};var _padding=null,_initialized=!1,_k=null,_states=null;function _init(){_padding=String.fromCharCode(128),_padding+=forge.util.fillString(String.fromCharCode(0),128),_k=[[1116352408,3609767458],[1899447441,602891725],[3049323471,3964484399],[3921009573,2173295548],[961987163,4081628472],[1508970993,3053834265],[2453635748,2937671579],[2870763221,3664609560],[3624381080,2734883394],[310598401,1164996542],[607225278,1323610764],[1426881987,3590304994],[1925078388,4068182383],[2162078206,991336113],[2614888103,633803317],[3248222580,3479774868],[3835390401,2666613458],[4022224774,944711139],[264347078,2341262773],[604807628,2007800933],[770255983,1495990901],[1249150122,1856431235],[1555081692,3175218132],[1996064986,2198950837],[2554220882,3999719339],[2821834349,766784016],[2952996808,2566594879],[3210313671,3203337956],[3336571891,1034457026],[3584528711,2466948901],[113926993,3758326383],[338241895,168717936],[666307205,1188179964],[773529912,1546045734],[1294757372,1522805485],[1396182291,2643833823],[1695183700,2343527390],[1986661051,1014477480],[2177026350,1206759142],[2456956037,344077627],[2730485921,1290863460],[2820302411,3158454273],[3259730800,3505952657],[3345764771,106217008],[3516065817,3606008344],[3600352804,1432725776],[4094571909,1467031594],[275423344,851169720],[430227734,3100823752],[506948616,1363258195],[659060556,3750685593],[883997877,3785050280],[958139571,3318307427],[1322822218,3812723403],[1537002063,2003034995],[1747873779,3602036899],[1955562222,1575990012],[2024104815,1125592928],[2227730452,2716904306],[2361852424,442776044],[2428436474,593698344],[2756734187,3733110249],[3204031479,2999351573],[3329325298,3815920427],[3391569614,3928383900],[3515267271,566280711],[3940187606,3454069534],[4118630271,4000239992],[116418474,1914138554],[174292421,2731055270],[289380356,3203993006],[460393269,320620315],[685471733,587496836],[852142971,1086792851],[1017036298,365543100],[1126000580,2618297676],[1288033470,3409855158],[1501505948,4234509866],[1607167915,987167468],[1816402316,1246189591]],_states={},_states["SHA-512"]=[[1779033703,4089235720],[3144134277,2227873595],[1013904242,4271175723],[2773480762,1595750129],[1359893119,2917565137],[2600822924,725511199],[528734635,4215389547],[1541459225,327033209]],_states["SHA-384"]=[[3418070365,3238371032],[1654270250,914150663],[2438529370,812702999],[355462360,4144912697],[1731405415,4290775857],[2394180231,1750603025],[3675008525,1694076839],[1203062813,3204075428]],_states["SHA-512/256"]=[[573645204,4230739756],[2673172387,3360449730],[596883563,1867755857],[2520282905,1497426621],[2519219938,2827943907],[3193839141,1401305490],[721525244,746961066],[246885852,2177182882]],_states["SHA-512/224"]=[[2352822216,424955298],[1944164710,2312950998],[502970286,855612546],[1738396948,1479516111],[258812777,2077511080],[2011393907,79989058],[1067287976,1780299464],[286451373,2446758561]],_initialized=!0}function _update(J,E,ee){for(var te,re,ne,ie,se,oe,ae,ce,le,he,de,ue,pe,ye,me,be,_e,we,$e,ve,fe,Ee,ke,Ne,xe,Ue,Ke,Te,Ce,Ve,Re,Le,De,Be,Oe,Ge=ee.length();Ge>=128;){for(Ce=0;Ce<16;++Ce)E[Ce][0]=ee.getInt32()>>>0,E[Ce][1]=ee.getInt32()>>>0;for(;Ce<80;++Ce)Le=E[Ce-2],Ve=Le[0],Re=Le[1],te=((Ve>>>19|Re<<13)^(Re>>>29|Ve<<3)^Ve>>>6)>>>0,re=((Ve<<13|Re>>>19)^(Re<<3|Ve>>>29)^(Ve<<26|Re>>>6))>>>0,Be=E[Ce-15],Ve=Be[0],Re=Be[1],ne=((Ve>>>1|Re<<31)^(Ve>>>8|Re<<24)^Ve>>>7)>>>0,ie=((Ve<<31|Re>>>1)^(Ve<<24|Re>>>8)^(Ve<<25|Re>>>7))>>>0,De=E[Ce-7],Oe=E[Ce-16],Re=re+De[1]+ie+Oe[1],E[Ce][0]=te+De[0]+ne+Oe[0]+(Re/4294967296>>>0)>>>0,E[Ce][1]=Re>>>0;for(pe=J[0][0],ye=J[0][1],me=J[1][0],be=J[1][1],_e=J[2][0],we=J[2][1],$e=J[3][0],ve=J[3][1],fe=J[4][0],Ee=J[4][1],ke=J[5][0],Ne=J[5][1],xe=J[6][0],Ue=J[6][1],Ke=J[7][0],Te=J[7][1],Ce=0;Ce<80;++Ce)ae=((fe>>>14|Ee<<18)^(fe>>>18|Ee<<14)^(Ee>>>9|fe<<23))>>>0,ce=((fe<<18|Ee>>>14)^(fe<<14|Ee>>>18)^(Ee<<23|fe>>>9))>>>0,le=(xe^fe&(ke^xe))>>>0,he=(Ue^Ee&(Ne^Ue))>>>0,se=((pe>>>28|ye<<4)^(ye>>>2|pe<<30)^(ye>>>7|pe<<25))>>>0,oe=((pe<<4|ye>>>28)^(ye<<30|pe>>>2)^(ye<<25|pe>>>7))>>>0,de=(pe&me|_e&(pe^me))>>>0,ue=(ye&be|we&(ye^be))>>>0,Re=Te+ce+he+_k[Ce][1]+E[Ce][1],te=Ke+ae+le+_k[Ce][0]+E[Ce][0]+(Re/4294967296>>>0)>>>0,re=Re>>>0,Re=oe+ue,ne=se+de+(Re/4294967296>>>0)>>>0,ie=Re>>>0,Ke=xe,Te=Ue,xe=ke,Ue=Ne,ke=fe,Ne=Ee,Re=ve+re,fe=$e+te+(Re/4294967296>>>0)>>>0,Ee=Re>>>0,$e=_e,ve=we,_e=me,we=be,me=pe,be=ye,Re=re+ie,pe=te+ne+(Re/4294967296>>>0)>>>0,ye=Re>>>0;Re=J[0][1]+ye,J[0][0]=J[0][0]+pe+(Re/4294967296>>>0)>>>0,J[0][1]=Re>>>0,Re=J[1][1]+be,J[1][0]=J[1][0]+me+(Re/4294967296>>>0)>>>0,J[1][1]=Re>>>0,Re=J[2][1]+we,J[2][0]=J[2][0]+_e+(Re/4294967296>>>0)>>>0,J[2][1]=Re>>>0,Re=J[3][1]+ve,J[3][0]=J[3][0]+$e+(Re/4294967296>>>0)>>>0,J[3][1]=Re>>>0,Re=J[4][1]+Ee,J[4][0]=J[4][0]+fe+(Re/4294967296>>>0)>>>0,J[4][1]=Re>>>0,Re=J[5][1]+Ne,J[5][0]=J[5][0]+ke+(Re/4294967296>>>0)>>>0,J[5][1]=Re>>>0,Re=J[6][1]+Ue,J[6][0]=J[6][0]+xe+(Re/4294967296>>>0)>>>0,J[6][1]=Re>>>0,Re=J[7][1]+Te,J[7][0]=J[7][0]+Ke+(Re/4294967296>>>0)>>>0,J[7][1]=Re>>>0,Ge-=128}}/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */const _0n=BigInt(0),_1n=BigInt(1),_2n=BigInt(2),_3n=BigInt(3),_8n=BigInt(8),CURVE=Object.freeze({a:_0n,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:_1n,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")}),divNearest=(J,E)=>(J+E/_2n)/E,endo={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar(J){const{n:E}=CURVE,ee=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),te=-_1n*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),re=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),ne=ee,ie=BigInt("0x100000000000000000000000000000000"),se=divNearest(ne*J,E),oe=divNearest(-te*J,E);let ae=mod(J-se*ee-oe*re,E),ce=mod(-se*te-oe*ne,E);const le=ae>ie,he=ce>ie;if(le&&(ae=E-ae),he&&(ce=E-ce),ae>ie||ce>ie)throw new Error("splitScalarEndo: Endomorphism failed, k="+J);return{k1neg:le,k1:ae,k2neg:he,k2:ce}}},fieldLen=32,groupLen=32,hashLen=32,compressedLen=fieldLen+1,uncompressedLen=2*fieldLen+1;function weierstrass(J){const{a:E,b:ee}=CURVE,te=mod(J*J),re=mod(te*J);return mod(re+E*J+ee)}const USE_ENDOMORPHISM=CURVE.a===_0n;class ShaError extends Error{constructor(E){super(E)}}function assertJacPoint(J){if(!(J instanceof JacobianPoint))throw new TypeError("JacobianPoint expected")}class JacobianPoint{constructor(E,ee,te){this.x=E,this.y=ee,this.z=te}static fromAffine(E){if(!(E instanceof Point))throw new TypeError("JacobianPoint#fromAffine: expected Point");return E.equals(Point.ZERO)?JacobianPoint.ZERO:new JacobianPoint(E.x,E.y,_1n)}static toAffineBatch(E){const ee=invertBatch(E.map(te=>te.z));return E.map((te,re)=>te.toAffine(ee[re]))}static normalizeZ(E){return JacobianPoint.toAffineBatch(E).map(JacobianPoint.fromAffine)}equals(E){assertJacPoint(E);const{x:ee,y:te,z:re}=this,{x:ne,y:ie,z:se}=E,oe=mod(re*re),ae=mod(se*se),ce=mod(ee*ae),le=mod(ne*oe),he=mod(mod(te*se)*ae),de=mod(mod(ie*re)*oe);return ce===le&&he===de}negate(){return new JacobianPoint(this.x,mod(-this.y),this.z)}double(){const{x:E,y:ee,z:te}=this,re=mod(E*E),ne=mod(ee*ee),ie=mod(ne*ne),se=E+ne,oe=mod(_2n*(mod(se*se)-re-ie)),ae=mod(_3n*re),ce=mod(ae*ae),le=mod(ce-_2n*oe),he=mod(ae*(oe-le)-_8n*ie),de=mod(_2n*ee*te);return new JacobianPoint(le,he,de)}add(E){assertJacPoint(E);const{x:ee,y:te,z:re}=this,{x:ne,y:ie,z:se}=E;if(ne===_0n||ie===_0n)return this;if(ee===_0n||te===_0n)return E;const oe=mod(re*re),ae=mod(se*se),ce=mod(ee*ae),le=mod(ne*oe),he=mod(mod(te*se)*ae),de=mod(mod(ie*re)*oe),ue=mod(le-ce),pe=mod(de-he);if(ue===_0n)return pe===_0n?this.double():JacobianPoint.ZERO;const ye=mod(ue*ue),me=mod(ue*ye),be=mod(ce*ye),_e=mod(pe*pe-me-_2n*be),we=mod(pe*(be-_e)-he*me),$e=mod(re*se*ue);return new JacobianPoint(_e,we,$e)}subtract(E){return this.add(E.negate())}multiplyUnsafe(E){const ee=JacobianPoint.ZERO;if(typeof E=="bigint"&&E===_0n)return ee;let te=normalizeScalar(E);if(te===_1n)return this;if(!USE_ENDOMORPHISM){let le=ee,he=this;for(;te>_0n;)te&_1n&&(le=le.add(he)),he=he.double(),te>>=_1n;return le}let{k1neg:re,k1:ne,k2neg:ie,k2:se}=endo.splitScalar(te),oe=ee,ae=ee,ce=this;for(;ne>_0n||se>_0n;)ne&_1n&&(oe=oe.add(ce)),se&_1n&&(ae=ae.add(ce)),ce=ce.double(),ne>>=_1n,se>>=_1n;return re&&(oe=oe.negate()),ie&&(ae=ae.negate()),ae=new JacobianPoint(mod(ae.x*endo.beta),ae.y,ae.z),oe.add(ae)}precomputeWindow(E){const ee=USE_ENDOMORPHISM?128/E+1:256/E+1,te=[];let re=this,ne=re;for(let ie=0;ie<ee;ie++){ne=re,te.push(ne);for(let se=1;se<2**(E-1);se++)ne=ne.add(re),te.push(ne);re=ne.double()}return te}wNAF(E,ee){!ee&&this.equals(JacobianPoint.BASE)&&(ee=Point.BASE);const te=ee&&ee._WINDOW_SIZE||1;if(256%te)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let re=ee&&pointPrecomputes.get(ee);re||(re=this.precomputeWindow(te),ee&&te!==1&&(re=JacobianPoint.normalizeZ(re),pointPrecomputes.set(ee,re)));let ne=JacobianPoint.ZERO,ie=JacobianPoint.BASE;const se=1+(USE_ENDOMORPHISM?128/te:256/te),oe=2**(te-1),ae=BigInt(2**te-1),ce=2**te,le=BigInt(te);for(let he=0;he<se;he++){const de=he*oe;let ue=Number(E&ae);E>>=le,ue>oe&&(ue-=ce,E+=_1n);const pe=de,ye=de+Math.abs(ue)-1,me=he%2!==0,be=ue<0;ue===0?ie=ie.add(constTimeNegate(me,re[pe])):ne=ne.add(constTimeNegate(be,re[ye]))}return{p:ne,f:ie}}multiply(E,ee){let te=normalizeScalar(E),re,ne;if(USE_ENDOMORPHISM){const{k1neg:ie,k1:se,k2neg:oe,k2:ae}=endo.splitScalar(te);let{p:ce,f:le}=this.wNAF(se,ee),{p:he,f:de}=this.wNAF(ae,ee);ce=constTimeNegate(ie,ce),he=constTimeNegate(oe,he),he=new JacobianPoint(mod(he.x*endo.beta),he.y,he.z),re=ce.add(he),ne=le.add(de)}else{const{p:ie,f:se}=this.wNAF(te,ee);re=ie,ne=se}return JacobianPoint.normalizeZ([re,ne])[0]}toAffine(E){const{x:ee,y:te,z:re}=this,ne=this.equals(JacobianPoint.ZERO);E==null&&(E=ne?_8n:invert(re));const ie=E,se=mod(ie*ie),oe=mod(se*ie),ae=mod(ee*se),ce=mod(te*oe),le=mod(re*ie);if(ne)return Point.ZERO;if(le!==_1n)throw new Error("invZ was invalid");return new Point(ae,ce)}}JacobianPoint.BASE=new JacobianPoint(CURVE.Gx,CURVE.Gy,_1n);JacobianPoint.ZERO=new JacobianPoint(_0n,_1n,_0n);function constTimeNegate(J,E){const ee=E.negate();return J?ee:E}const pointPrecomputes=new WeakMap;class Point{constructor(E,ee){this.x=E,this.y=ee}_setWindowSize(E){this._WINDOW_SIZE=E,pointPrecomputes.delete(this)}hasEvenY(){return this.y%_2n===_0n}static fromCompressedHex(E){const ee=E.length===32,te=bytesToNumber(ee?E:E.subarray(1));if(!isValidFieldElement(te))throw new Error("Point is not on curve");const re=weierstrass(te);let ne=sqrtMod(re);const ie=(ne&_1n)===_1n;ee?ie&&(ne=mod(-ne)):(E[0]&1)===1!==ie&&(ne=mod(-ne));const se=new Point(te,ne);return se.assertValidity(),se}static fromUncompressedHex(E){const ee=bytesToNumber(E.subarray(1,fieldLen+1)),te=bytesToNumber(E.subarray(fieldLen+1,fieldLen*2+1)),re=new Point(ee,te);return re.assertValidity(),re}static fromHex(E){const ee=ensureBytes(E),te=ee.length,re=ee[0];if(te===fieldLen)return this.fromCompressedHex(ee);if(te===compressedLen&&(re===2||re===3))return this.fromCompressedHex(ee);if(te===uncompressedLen&&re===4)return this.fromUncompressedHex(ee);throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${te}`)}static fromPrivateKey(E){return Point.BASE.multiply(normalizePrivateKey(E))}static fromSignature(E,ee,te){const{r:re,s:ne}=normalizeSignature(ee);if(![0,1,2,3].includes(te))throw new Error("Cannot recover: invalid recovery bit");const ie=truncateHash(ensureBytes(E)),{n:se}=CURVE,oe=te===2||te===3?re+se:re,ae=invert(oe,se),ce=mod(-ie*ae,se),le=mod(ne*ae,se),he=te&1?"03":"02",de=Point.fromHex(he+numTo32bStr(oe)),ue=Point.BASE.multiplyAndAddUnsafe(de,ce,le);if(!ue)throw new Error("Cannot recover signature: point at infinify");return ue.assertValidity(),ue}toRawBytes(E=!1){return hexToBytes(this.toHex(E))}toHex(E=!1){const ee=numTo32bStr(this.x);return E?`${this.hasEvenY()?"02":"03"}${ee}`:`04${ee}${numTo32bStr(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const E="Point is not on elliptic curve",{x:ee,y:te}=this;if(!isValidFieldElement(ee)||!isValidFieldElement(te))throw new Error(E);const re=mod(te*te),ne=weierstrass(ee);if(mod(re-ne)!==_0n)throw new Error(E)}equals(E){return this.x===E.x&&this.y===E.y}negate(){return new Point(this.x,mod(-this.y))}double(){return JacobianPoint.fromAffine(this).double().toAffine()}add(E){return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(E)).toAffine()}subtract(E){return this.add(E.negate())}multiply(E){return JacobianPoint.fromAffine(this).multiply(E,this).toAffine()}multiplyAndAddUnsafe(E,ee,te){const re=JacobianPoint.fromAffine(this),ne=ee===_0n||ee===_1n||this!==Point.BASE?re.multiplyUnsafe(ee):re.multiply(ee),ie=JacobianPoint.fromAffine(E).multiplyUnsafe(te),se=ne.add(ie);return se.equals(JacobianPoint.ZERO)?void 0:se.toAffine()}}Point.BASE=new Point(CURVE.Gx,CURVE.Gy);Point.ZERO=new Point(_0n,_0n);function sliceDER(J){return Number.parseInt(J[0],16)>=8?"00"+J:J}function parseDERInt(J){if(J.length<2||J[0]!==2)throw new Error(`Invalid signature integer tag: ${bytesToHex(J)}`);const E=J[1],ee=J.subarray(2,E+2);if(!E||ee.length!==E)throw new Error("Invalid signature integer: wrong length");if(ee[0]===0&&ee[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:bytesToNumber(ee),left:J.subarray(E+2)}}function parseDERSignature(J){if(J.length<2||J[0]!=48)throw new Error(`Invalid signature tag: ${bytesToHex(J)}`);if(J[1]!==J.length-2)throw new Error("Invalid signature: incorrect length");const{data:E,left:ee}=parseDERInt(J.subarray(2)),{data:te,left:re}=parseDERInt(ee);if(re.length)throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(re)}`);return{r:E,s:te}}class Signature{constructor(E,ee){this.r=E,this.s=ee,this.assertValidity()}static fromCompact(E){const ee=E instanceof Uint8Array,te="Signature.fromCompact";if(typeof E!="string"&&!ee)throw new TypeError(`${te}: Expected string or Uint8Array`);const re=ee?bytesToHex(E):E;if(re.length!==128)throw new Error(`${te}: Expected 64-byte hex`);return new Signature(hexToNumber(re.slice(0,64)),hexToNumber(re.slice(64,128)))}static fromDER(E){const ee=E instanceof Uint8Array;if(typeof E!="string"&&!ee)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r:te,s:re}=parseDERSignature(ee?E:hexToBytes(E));return new Signature(te,re)}static fromHex(E){return this.fromDER(E)}assertValidity(){const{r:E,s:ee}=this;if(!isWithinCurveOrder(E))throw new Error("Invalid Signature: r must be 0 < r < n");if(!isWithinCurveOrder(ee))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const E=CURVE.n>>_1n;return this.s>E}normalizeS(){return this.hasHighS()?new Signature(this.r,mod(-this.s,CURVE.n)):this}toDERRawBytes(){return hexToBytes(this.toDERHex())}toDERHex(){const E=sliceDER(numberToHexUnpadded(this.s)),ee=sliceDER(numberToHexUnpadded(this.r)),te=E.length/2,re=ee.length/2,ne=numberToHexUnpadded(te),ie=numberToHexUnpadded(re);return`30${numberToHexUnpadded(re+te+4)}02${ie}${ee}02${ne}${E}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return hexToBytes(this.toCompactHex())}toCompactHex(){return numTo32bStr(this.r)+numTo32bStr(this.s)}}function concatBytes(...J){if(!J.every(te=>te instanceof Uint8Array))throw new Error("Uint8Array list expected");if(J.length===1)return J[0];const E=J.reduce((te,re)=>te+re.length,0),ee=new Uint8Array(E);for(let te=0,re=0;te<J.length;te++){const ne=J[te];ee.set(ne,re),re+=ne.length}return ee}const hexes=Array.from({length:256},(J,E)=>E.toString(16).padStart(2,"0"));function bytesToHex(J){if(!(J instanceof Uint8Array))throw new Error("Expected Uint8Array");let E="";for(let ee=0;ee<J.length;ee++)E+=hexes[J[ee]];return E}const POW_2_256=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function numTo32bStr(J){if(typeof J!="bigint")throw new Error("Expected bigint");if(!(_0n<=J&&J<POW_2_256))throw new Error("Expected number 0 <= n < 2^256");return J.toString(16).padStart(64,"0")}function numTo32b(J){const E=hexToBytes(numTo32bStr(J));if(E.length!==32)throw new Error("Error: expected 32 bytes");return E}function numberToHexUnpadded(J){const E=J.toString(16);return E.length&1?`0${E}`:E}function hexToNumber(J){if(typeof J!="string")throw new TypeError("hexToNumber: expected string, got "+typeof J);return BigInt(`0x${J}`)}function hexToBytes(J){if(typeof J!="string")throw new TypeError("hexToBytes: expected string, got "+typeof J);if(J.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+J.length);const E=new Uint8Array(J.length/2);for(let ee=0;ee<E.length;ee++){const te=ee*2,re=J.slice(te,te+2),ne=Number.parseInt(re,16);if(Number.isNaN(ne)||ne<0)throw new Error("Invalid byte sequence");E[ee]=ne}return E}function bytesToNumber(J){return hexToNumber(bytesToHex(J))}function ensureBytes(J){return J instanceof Uint8Array?Uint8Array.from(J):hexToBytes(J)}function normalizeScalar(J){if(typeof J=="number"&&Number.isSafeInteger(J)&&J>0)return BigInt(J);if(typeof J=="bigint"&&isWithinCurveOrder(J))return J;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function mod(J,E=CURVE.P){const ee=J%E;return ee>=_0n?ee:E+ee}function pow2(J,E){const{P:ee}=CURVE;let te=J;for(;E-- >_0n;)te*=te,te%=ee;return te}function sqrtMod(J){const{P:E}=CURVE,ee=BigInt(6),te=BigInt(11),re=BigInt(22),ne=BigInt(23),ie=BigInt(44),se=BigInt(88),oe=J*J*J%E,ae=oe*oe*J%E,ce=pow2(ae,_3n)*ae%E,le=pow2(ce,_3n)*ae%E,he=pow2(le,_2n)*oe%E,de=pow2(he,te)*he%E,ue=pow2(de,re)*de%E,pe=pow2(ue,ie)*ue%E,ye=pow2(pe,se)*pe%E,me=pow2(ye,ie)*ue%E,be=pow2(me,_3n)*ae%E,_e=pow2(be,ne)*de%E,we=pow2(_e,ee)*oe%E,$e=pow2(we,_2n);if($e*$e%E!==J)throw new Error("Cannot find square root");return $e}function invert(J,E=CURVE.P){if(J===_0n||E<=_0n)throw new Error(`invert: expected positive integers, got n=${J} mod=${E}`);let ee=mod(J,E),te=E,re=_0n,ne=_1n;for(;ee!==_0n;){const ie=te/ee,se=te%ee,oe=re-ne*ie;te=ee,ee=se,re=ne,ne=oe}if(te!==_1n)throw new Error("invert: does not exist");return mod(re,E)}function invertBatch(J,E=CURVE.P){const ee=new Array(J.length),te=J.reduce((ne,ie,se)=>ie===_0n?ne:(ee[se]=ne,mod(ne*ie,E)),_1n),re=invert(te,E);return J.reduceRight((ne,ie,se)=>ie===_0n?ne:(ee[se]=mod(ne*ee[se],E),mod(ne*ie,E)),re),ee}function bits2int_2(J){const E=J.length*8-groupLen*8,ee=bytesToNumber(J);return E>0?ee>>BigInt(E):ee}function truncateHash(J,E=!1){const ee=bits2int_2(J);if(E)return ee;const{n:te}=CURVE;return ee>=te?ee-te:ee}let _sha256Sync,_hmacSha256Sync;class HmacDrbg{constructor(E,ee){if(this.hashLen=E,this.qByteLen=ee,typeof E!="number"||E<2)throw new Error("hashLen must be a number");if(typeof ee!="number"||ee<2)throw new Error("qByteLen must be a number");this.v=new Uint8Array(E).fill(1),this.k=new Uint8Array(E).fill(0),this.counter=0}hmac(...E){return utils$2.hmacSha256(this.k,...E)}hmacSync(...E){return _hmacSha256Sync(this.k,...E)}checkSync(){if(typeof _hmacSha256Sync!="function")throw new ShaError("hmacSha256Sync needs to be set")}incr(){if(this.counter>=1e3)throw new Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(E=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),E),this.v=await this.hmac(this.v),E.length!==0&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),E),this.v=await this.hmac(this.v))}reseedSync(E=new Uint8Array){this.checkSync(),this.k=this.hmacSync(this.v,Uint8Array.from([0]),E),this.v=this.hmacSync(this.v),E.length!==0&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),E),this.v=this.hmacSync(this.v))}async generate(){this.incr();let E=0;const ee=[];for(;E<this.qByteLen;){this.v=await this.hmac(this.v);const te=this.v.slice();ee.push(te),E+=this.v.length}return concatBytes(...ee)}generateSync(){this.checkSync(),this.incr();let E=0;const ee=[];for(;E<this.qByteLen;){this.v=this.hmacSync(this.v);const te=this.v.slice();ee.push(te),E+=this.v.length}return concatBytes(...ee)}}function isWithinCurveOrder(J){return _0n<J&&J<CURVE.n}function isValidFieldElement(J){return _0n<J&&J<CURVE.P}function kmdToSig(J,E,ee,te=!0){const{n:re}=CURVE,ne=truncateHash(J,!0);if(!isWithinCurveOrder(ne))return;const ie=invert(ne,re),se=Point.BASE.multiply(ne),oe=mod(se.x,re);if(oe===_0n)return;const ae=mod(ie*mod(E+ee*oe,re),re);if(ae===_0n)return;let ce=new Signature(oe,ae),le=(se.x===ce.r?0:2)|Number(se.y&_1n);return te&&ce.hasHighS()&&(ce=ce.normalizeS(),le^=1),{sig:ce,recovery:le}}function normalizePrivateKey(J){let E;if(typeof J=="bigint")E=J;else if(typeof J=="number"&&Number.isSafeInteger(J)&&J>0)E=BigInt(J);else if(typeof J=="string"){if(J.length!==2*groupLen)throw new Error("Expected 32 bytes of private key");E=hexToNumber(J)}else if(J instanceof Uint8Array){if(J.length!==groupLen)throw new Error("Expected 32 bytes of private key");E=bytesToNumber(J)}else throw new TypeError("Expected valid private key");if(!isWithinCurveOrder(E))throw new Error("Expected private key: 0 < key < n");return E}function normalizePublicKey(J){return J instanceof Point?(J.assertValidity(),J):Point.fromHex(J)}function normalizeSignature(J){if(J instanceof Signature)return J.assertValidity(),J;try{return Signature.fromDER(J)}catch{return Signature.fromCompact(J)}}function getPublicKey(J,E=!1){return Point.fromPrivateKey(J).toRawBytes(E)}function bits2int(J){const E=J.length>fieldLen?J.slice(0,fieldLen):J;return bytesToNumber(E)}function bits2octets(J){const E=bits2int(J),ee=mod(E,CURVE.n);return int2octets(ee<_0n?E:ee)}function int2octets(J){return numTo32b(J)}function initSigArgs(J,E,ee){if(J==null)throw new Error(`sign: expected valid message hash, not "${J}"`);const te=ensureBytes(J),re=normalizePrivateKey(E),ne=[int2octets(re),bits2octets(te)];if(ee!=null){ee===!0&&(ee=utils$2.randomBytes(fieldLen));const oe=ensureBytes(ee);if(oe.length!==fieldLen)throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);ne.push(oe)}const ie=concatBytes(...ne),se=bits2int(te);return{seed:ie,m:se,d:re}}function finalizeSig(J,E){const{sig:ee,recovery:te}=J,{der:re,recovered:ne}=Object.assign({canonical:!0,der:!0},E),ie=re?ee.toDERRawBytes():ee.toCompactRawBytes();return ne?[ie,te]:ie}async function sign(J,E,ee={}){const{seed:te,m:re,d:ne}=initSigArgs(J,E,ee.extraEntropy),ie=new HmacDrbg(hashLen,groupLen);await ie.reseed(te);let se;for(;!(se=kmdToSig(await ie.generate(),re,ne,ee.canonical));)await ie.reseed();return finalizeSig(se,ee)}const vopts={strict:!0};function verify(J,E,ee,te=vopts){let re;try{re=normalizeSignature(J),E=ensureBytes(E)}catch{return!1}const{r:ne,s:ie}=re;if(te.strict&&re.hasHighS())return!1;const se=truncateHash(E);let oe;try{oe=normalizePublicKey(ee)}catch{return!1}const{n:ae}=CURVE,ce=invert(ie,ae),le=mod(se*ce,ae),he=mod(ne*ce,ae),de=Point.BASE.multiplyAndAddUnsafe(oe,le,he);return de?mod(de.x,ae)===ne:!1}Point.BASE._setWindowSize(8);const crypto$1={node:nodeCrypto,web:typeof self=="object"&&"crypto"in self?self.crypto:void 0},TAGGED_HASH_PREFIXES={},utils$2={bytesToHex,hexToBytes,concatBytes,mod,invert,isValidPrivateKey(J){try{return normalizePrivateKey(J),!0}catch{return!1}},_bigintTo32Bytes:numTo32b,_normalizePrivateKey:normalizePrivateKey,hashToPrivateKey:J=>{J=ensureBytes(J);const E=groupLen+8;if(J.length<E||J.length>1024)throw new Error("Expected valid bytes of private key as per FIPS 186");const ee=mod(bytesToNumber(J),CURVE.n-_1n)+_1n;return numTo32b(ee)},randomBytes:(J=32)=>{if(crypto$1.web)return crypto$1.web.getRandomValues(new Uint8Array(J));if(crypto$1.node){const{randomBytes:E}=crypto$1.node;return Uint8Array.from(E(J))}else throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>utils$2.hashToPrivateKey(utils$2.randomBytes(groupLen+8)),precompute(J=8,E=Point.BASE){const ee=E===Point.BASE?E:new Point(E.x,E.y);return ee._setWindowSize(J),ee.multiply(_3n),ee},sha256:async(...J)=>{if(crypto$1.web){const E=await crypto$1.web.subtle.digest("SHA-256",concatBytes(...J));return new Uint8Array(E)}else if(crypto$1.node){const{createHash:E}=crypto$1.node,ee=E("sha256");return J.forEach(te=>ee.update(te)),Uint8Array.from(ee.digest())}else throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(J,...E)=>{if(crypto$1.web){const ee=await crypto$1.web.subtle.importKey("raw",J,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),te=concatBytes(...E),re=await crypto$1.web.subtle.sign("HMAC",ee,te);return new Uint8Array(re)}else if(crypto$1.node){const{createHmac:ee}=crypto$1.node,te=ee("sha256",J);return E.forEach(re=>te.update(re)),Uint8Array.from(te.digest())}else throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(J,...E)=>{let ee=TAGGED_HASH_PREFIXES[J];if(ee===void 0){const te=await utils$2.sha256(Uint8Array.from(J,re=>re.charCodeAt(0)));ee=concatBytes(te,te),TAGGED_HASH_PREFIXES[J]=ee}return utils$2.sha256(ee,...E)},taggedHashSync:(J,...E)=>{if(typeof _sha256Sync!="function")throw new ShaError("sha256Sync is undefined, you need to set it");let ee=TAGGED_HASH_PREFIXES[J];if(ee===void 0){const te=_sha256Sync(Uint8Array.from(J,re=>re.charCodeAt(0)));ee=concatBytes(te,te),TAGGED_HASH_PREFIXES[J]=ee}return _sha256Sync(ee,...E)},_JacobianPoint:JacobianPoint};Object.defineProperties(utils$2,{sha256Sync:{configurable:!1,get(){return _sha256Sync},set(J){_sha256Sync||(_sha256Sync=J)}},hmacSha256Sync:{configurable:!1,get(){return _hmacSha256Sync},set(J){_hmacSha256Sync||(_hmacSha256Sync=J)}}});function randomBytes(J){if(isNaN(J)||J<=0)throw new CodeError("random bytes length must be a Number bigger than 0","ERR_INVALID_LENGTH");return utils$2.randomBytes(J)}function convert(J,E){return E.map(ee=>base64urlToBigInteger(J[ee]))}function jwk2priv(J){return forge$n.pki.setRsaPrivateKey(...convert(J,["n","e","d","p","q","dp","dq","qi"]))}function jwk2pub(J){return forge$n.pki.setRsaPublicKey(...convert(J,["n","e"]))}function pkcs1ToJwk(J){const E=forge$n.asn1.fromDer(toString$4(J,"ascii")),ee=forge$n.pki.privateKeyFromAsn1(E);return{kty:"RSA",n:bigIntegerToUintBase64url(ee.n),e:bigIntegerToUintBase64url(ee.e),d:bigIntegerToUintBase64url(ee.d),p:bigIntegerToUintBase64url(ee.p),q:bigIntegerToUintBase64url(ee.q),dp:bigIntegerToUintBase64url(ee.dP),dq:bigIntegerToUintBase64url(ee.dQ),qi:bigIntegerToUintBase64url(ee.qInv),alg:"RS256"}}function jwkToPkcs1(J){if(J.n==null||J.e==null||J.d==null||J.p==null||J.q==null||J.dp==null||J.dq==null||J.qi==null)throw new CodeError("JWK was missing components","ERR_INVALID_PARAMETERS");const E=forge$n.pki.privateKeyToAsn1({n:base64urlToBigInteger(J.n),e:base64urlToBigInteger(J.e),d:base64urlToBigInteger(J.d),p:base64urlToBigInteger(J.p),q:base64urlToBigInteger(J.q),dP:base64urlToBigInteger(J.dp),dQ:base64urlToBigInteger(J.dq),qInv:base64urlToBigInteger(J.qi)});return fromString$4(forge$n.asn1.toDer(E).getBytes(),"ascii")}function pkixToJwk(J){const E=forge$n.asn1.fromDer(toString$4(J,"ascii")),ee=forge$n.pki.publicKeyFromAsn1(E);return{kty:"RSA",n:bigIntegerToUintBase64url(ee.n),e:bigIntegerToUintBase64url(ee.e)}}function jwkToPkix(J){if(J.n==null||J.e==null)throw new CodeError("JWK was missing components","ERR_INVALID_PARAMETERS");const E=forge$n.pki.publicKeyToAsn1({n:base64urlToBigInteger(J.n),e:base64urlToBigInteger(J.e)});return fromString$4(forge$n.asn1.toDer(E).getBytes(),"ascii")}async function generateKey$1(J){const E=await webcrypto.get().subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:J,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),ee=await exportKey(E);return{privateKey:ee[0],publicKey:ee[1]}}async function unmarshalPrivateKey$1(J){const E=[await webcrypto.get().subtle.importKey("jwk",J,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["sign"]),await derivePublicFromPrivate(J)],ee=await exportKey({privateKey:E[0],publicKey:E[1]});return{privateKey:ee[0],publicKey:ee[1]}}async function hashAndSign$1(J,E){const ee=await webcrypto.get().subtle.importKey("jwk",J,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["sign"]),te=await webcrypto.get().subtle.sign({name:"RSASSA-PKCS1-v1_5"},ee,Uint8Array.from(E));return new Uint8Array(te,0,te.byteLength)}async function hashAndVerify$1(J,E,ee){const te=await webcrypto.get().subtle.importKey("jwk",J,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);return webcrypto.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},te,E,ee)}async function exportKey(J){if(J.privateKey==null||J.publicKey==null)throw new CodeError("Private and public key are required","ERR_INVALID_PARAMETERS");return Promise.all([webcrypto.get().subtle.exportKey("jwk",J.privateKey),webcrypto.get().subtle.exportKey("jwk",J.publicKey)])}async function derivePublicFromPrivate(J){return webcrypto.get().subtle.importKey("jwk",{kty:J.kty,n:J.n,e:J.e},{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["verify"])}function convertKey(J,E,ee,te){const re=E?jwk2pub(J):jwk2priv(J),ne=toString$4(Uint8Array.from(ee),"ascii"),ie=te(ne,re);return fromString$4(ie,"ascii")}function encrypt(J,E){return convertKey(J,!0,E,(ee,te)=>te.encrypt(ee))}function decrypt(J,E){return convertKey(J,!1,E,(ee,te)=>te.decrypt(ee))}class RsaPublicKey{_key;constructor(E){this._key=E}async verify(E,ee){return hashAndVerify$1(this._key,ee,E)}marshal(){return jwkToPkix(this._key)}get bytes(){return PublicKey.encode({Type:KeyType.RSA,Data:this.marshal()}).subarray()}encrypt(E){return encrypt(this._key,E)}equals(E){return equals(this.bytes,E.bytes)}async hash(){const{bytes:E}=await sha256$2.digest(this.bytes);return E}}class RsaPrivateKey{_key;_publicKey;constructor(E,ee){this._key=E,this._publicKey=ee}genSecret(){return randomBytes(16)}async sign(E){return hashAndSign$1(this._key,E)}get public(){if(this._publicKey==null)throw new CodeError("public key not provided","ERR_PUBKEY_NOT_PROVIDED");return new RsaPublicKey(this._publicKey)}decrypt(E){return decrypt(this._key,E)}marshal(){return jwkToPkcs1(this._key)}get bytes(){return PrivateKey.encode({Type:KeyType.RSA,Data:this.marshal()}).subarray()}equals(E){return equals(this.bytes,E.bytes)}async hash(){const{bytes:E}=await sha256$2.digest(this.bytes);return E}async id(){const E=await this.public.hash();return toString$4(E,"base58btc")}async export(E,ee="pkcs-8"){if(ee==="pkcs-8"){const te=new forge$n.util.ByteBuffer(this.marshal()),re=forge$n.asn1.fromDer(te),ne=forge$n.pki.privateKeyFromAsn1(re),ie={algorithm:"aes256",count:1e4,saltSize:128/8,prfAlgorithm:"sha512"};return forge$n.pki.encryptRsaPrivateKey(ne,E,ie)}else{if(ee==="libp2p-key")return exporter(this.bytes,E);throw new CodeError(`export format '${ee}' is not supported`,"ERR_INVALID_EXPORT_FORMAT")}}}async function unmarshalRsaPrivateKey(J){const E=pkcs1ToJwk(J),ee=await unmarshalPrivateKey$1(E);return new RsaPrivateKey(ee.privateKey,ee.publicKey)}function unmarshalRsaPublicKey(J){const E=pkixToJwk(J);return new RsaPublicKey(E)}async function fromJwk(J){const E=await unmarshalPrivateKey$1(J);return new RsaPrivateKey(E.privateKey,E.publicKey)}async function generateKeyPair$2(J){const E=await generateKey$1(J);return new RsaPrivateKey(E.privateKey,E.publicKey)}const RSA=Object.freeze(Object.defineProperty({__proto__:null,RsaPrivateKey,RsaPublicKey,fromJwk,generateKeyPair:generateKeyPair$2,unmarshalRsaPrivateKey,unmarshalRsaPublicKey},Symbol.toStringTag,{value:"Module"}));function generateKey(){return utils$2.randomPrivateKey()}async function hashAndSign(J,E){const{digest:ee}=await sha256$2.digest(E);try{return await sign(ee,J)}catch(te){throw new CodeError(String(te),"ERR_INVALID_INPUT")}}async function hashAndVerify(J,E,ee){try{const{digest:te}=await sha256$2.digest(ee);return verify(E,te,J)}catch(te){throw new CodeError(String(te),"ERR_INVALID_INPUT")}}function compressPublicKey(J){return Point.fromHex(J).toRawBytes(!0)}function validatePrivateKey(J){try{getPublicKey(J,!0)}catch(E){throw new CodeError(String(E),"ERR_INVALID_PRIVATE_KEY")}}function validatePublicKey(J){try{Point.fromHex(J)}catch(E){throw new CodeError(String(E),"ERR_INVALID_PUBLIC_KEY")}}function computePublicKey(J){try{return getPublicKey(J,!0)}catch(E){throw new CodeError(String(E),"ERR_INVALID_PRIVATE_KEY")}}class Secp256k1PublicKey{_key;constructor(E){validatePublicKey(E),this._key=E}async verify(E,ee){return hashAndVerify(this._key,ee,E)}marshal(){return compressPublicKey(this._key)}get bytes(){return PublicKey.encode({Type:KeyType.Secp256k1,Data:this.marshal()}).subarray()}equals(E){return equals(this.bytes,E.bytes)}async hash(){const{bytes:E}=await sha256$2.digest(this.bytes);return E}}class Secp256k1PrivateKey{_key;_publicKey;constructor(E,ee){this._key=E,this._publicKey=ee??computePublicKey(E),validatePrivateKey(this._key),validatePublicKey(this._publicKey)}async sign(E){return hashAndSign(this._key,E)}get public(){return new Secp256k1PublicKey(this._publicKey)}marshal(){return this._key}get bytes(){return PrivateKey.encode({Type:KeyType.Secp256k1,Data:this.marshal()}).subarray()}equals(E){return equals(this.bytes,E.bytes)}async hash(){const{bytes:E}=await sha256$2.digest(this.bytes);return E}async id(){const E=await this.public.hash();return toString$4(E,"base58btc")}async export(E,ee="libp2p-key"){if(ee==="libp2p-key")return exporter(this.bytes,E);throw new CodeError(`export format '${ee}' is not supported`,"ERR_INVALID_EXPORT_FORMAT")}}function unmarshalSecp256k1PrivateKey(J){return new Secp256k1PrivateKey(J)}function unmarshalSecp256k1PublicKey(J){return new Secp256k1PublicKey(J)}async function generateKeyPair$1(){const J=generateKey();return new Secp256k1PrivateKey(J)}const Secp256k1=Object.freeze(Object.defineProperty({__proto__:null,Secp256k1PrivateKey,Secp256k1PublicKey,generateKeyPair:generateKeyPair$1,unmarshalSecp256k1PrivateKey,unmarshalSecp256k1PublicKey},Symbol.toStringTag,{value:"Module"})),supportedKeys={rsa:RSA,ed25519:Ed25519,secp256k1:Secp256k1};function unsupportedKey(J){const E=Object.keys(supportedKeys).join(" / ");return new CodeError(`invalid or unsupported key type ${J}. Must be ${E}`,"ERR_UNSUPPORTED_KEY_TYPE")}function typeToKey(J){if(J=J.toLowerCase(),J==="rsa"||J==="ed25519"||J==="secp256k1")return supportedKeys[J];throw unsupportedKey(J)}async function generateKeyPair(J,E){return typeToKey(J).generateKeyPair(E??2048)}function unmarshalPublicKey(J){const E=PublicKey.decode(J),ee=E.Data??new Uint8Array;switch(E.Type){case KeyType.RSA:return supportedKeys.rsa.unmarshalRsaPublicKey(ee);case KeyType.Ed25519:return supportedKeys.ed25519.unmarshalEd25519PublicKey(ee);case KeyType.Secp256k1:return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(ee);default:throw unsupportedKey(E.Type??"RSA")}}function marshalPublicKey(J,E){return E=(E??"rsa").toLowerCase(),typeToKey(E),J.bytes}async function unmarshalPrivateKey(J){const E=PrivateKey.decode(J),ee=E.Data??new Uint8Array;switch(E.Type){case KeyType.RSA:return supportedKeys.rsa.unmarshalRsaPrivateKey(ee);case KeyType.Ed25519:return supportedKeys.ed25519.unmarshalEd25519PrivateKey(ee);case KeyType.Secp256k1:return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(ee);default:throw unsupportedKey(E.Type??"RSA")}}function marshalPrivateKey(J,E){return E=(E??"rsa").toLowerCase(),typeToKey(E),J.bytes}async function importKey(J,E){try{const re=await importer(J,E);return await unmarshalPrivateKey(re)}catch{}const ee=forge$n.pki.decryptRsaPrivateKey(J,E);if(ee===null)throw new CodeError("Cannot read the key, most likely the password is wrong or not a RSA key","ERR_CANNOT_DECRYPT_PEM");let te=forge$n.asn1.toDer(forge$n.pki.privateKeyToAsn1(ee));return te=fromString$4(te.getBytes(),"ascii"),supportedKeys.rsa.unmarshalRsaPrivateKey(te)}const hashName={sha1:"sha1","sha2-256":"sha256","sha2-512":"sha512"};function pbkdf2(J,E,ee,te,re){if(re!=="sha1"&&re!=="sha2-256"&&re!=="sha2-512"){const se=Object.keys(hashName).join(" / ");throw new CodeError(`Hash '${re}' is unknown or not supported. Must be ${se}`,"ERR_UNSUPPORTED_HASH_TYPE")}const ne=hashName[re],ie=forgePbkdf2(J,E,ee,te,ne);return forgeUtil.encode64(ie,null)}const log$s=logger("libp2p:keychain"),keyPrefix="/pkcs8/",infoPrefix="/info/",privates=new WeakMap,NIST={minKeyLength:112/8,minSaltLength:128/8,minIterationCount:1e3},defaultOptions$2={dek:{keyLength:512/8,iterationCount:1e4,salt:"you should override this value with a crypto secure random number",hash:"sha2-512"}};function validateKeyName(J){return J==null||typeof J!="string"?!1:J===sanitize$1(J.trim())&&J.length>0}async function randomDelay(){const J=Math.random()*800+200;await new Promise(E=>setTimeout(E,J))}function DsName(J){return new Key(keyPrefix+J)}function DsInfoName(J){return new Key(infoPrefix+J)}class DefaultKeyChain{constructor(E,ee){if(this.components=E,this.init=mergeOptions$1(defaultOptions$2,ee),this.init.pass!=null&&this.init.pass?.length<20)throw new Error("pass must be least 20 characters");if(this.init.dek?.keyLength!=null&&this.init.dek.keyLength<NIST.minKeyLength)throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`);if(this.init.dek?.salt?.length!=null&&this.init.dek.salt.length<NIST.minSaltLength)throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`);if(this.init.dek?.iterationCount!=null&&this.init.dek.iterationCount<NIST.minIterationCount)throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`);const te=this.init.pass!=null&&this.init.dek?.salt!=null?pbkdf2(this.init.pass,this.init.dek?.salt,this.init.dek?.iterationCount,this.init.dek?.keyLength,this.init.dek?.hash):"";privates.set(this,{dek:te})}static generateOptions(){const E=Object.assign({},defaultOptions$2),ee=Math.ceil(NIST.minSaltLength/3)*3;return E.dek.salt=toString$4(randomBytes(ee),"base64"),E}static get options(){return defaultOptions$2}async createKey(E,ee,te=2048){if(!validateKeyName(E)||E==="self")throw await randomDelay(),new CodeError("Invalid key name",codes$5.ERR_INVALID_KEY_NAME);if(typeof ee!="string")throw await randomDelay(),new CodeError("Invalid key type",codes$5.ERR_INVALID_KEY_TYPE);const re=DsName(E);if(await this.components.datastore.has(re))throw await randomDelay(),new CodeError("Key name already exists",codes$5.ERR_KEY_ALREADY_EXISTS);switch(ee.toLowerCase()){case"rsa":if(!Number.isSafeInteger(te)||te<2048)throw await randomDelay(),new CodeError("Invalid RSA key size",codes$5.ERR_INVALID_KEY_SIZE);break}let ne;try{const ie=await generateKeyPair(ee,te),se=await ie.id(),oe=privates.get(this);if(oe==null)throw new CodeError("dek missing",codes$5.ERR_INVALID_PARAMETERS);const ae=oe.dek,ce=await ie.export(ae);ne={name:E,id:se};const le=this.components.datastore.batch();le.put(re,fromString$4(ce)),le.put(DsInfoName(E),fromString$4(JSON.stringify(ne))),await le.commit()}catch(ie){throw await randomDelay(),ie}return ne}async listKeys(){const E={prefix:infoPrefix},ee=[];for await(const te of this.components.datastore.query(E))ee.push(JSON.parse(toString$4(te.value)));return ee}async findKeyById(E){try{const ee=(await this.listKeys()).find(te=>te.id===E);if(ee==null)throw new CodeError(`Key with id '${E}' does not exist.`,codes$5.ERR_KEY_NOT_FOUND);return ee}catch(ee){throw await randomDelay(),ee}}async findKeyByName(E){if(!validateKeyName(E))throw await randomDelay(),new CodeError(`Invalid key name '${E}'`,codes$5.ERR_INVALID_KEY_NAME);const ee=DsInfoName(E);try{const te=await this.components.datastore.get(ee);return JSON.parse(toString$4(te))}catch(te){throw await randomDelay(),log$s.error(te),new CodeError(`Key '${E}' does not exist.`,codes$5.ERR_KEY_NOT_FOUND)}}async removeKey(E){if(!validateKeyName(E)||E==="self")throw await randomDelay(),new CodeError(`Invalid key name '${E}'`,codes$5.ERR_INVALID_KEY_NAME);const ee=DsName(E),te=await this.findKeyByName(E),re=this.components.datastore.batch();return re.delete(ee),re.delete(DsInfoName(E)),await re.commit(),te}async renameKey(E,ee){if(!validateKeyName(E)||E==="self")throw await randomDelay(),new CodeError(`Invalid old key name '${E}'`,codes$5.ERR_OLD_KEY_NAME_INVALID);if(!validateKeyName(ee)||ee==="self")throw await randomDelay(),new CodeError(`Invalid new key name '${ee}'`,codes$5.ERR_NEW_KEY_NAME_INVALID);const te=DsName(E),re=DsName(ee),ne=DsInfoName(E),ie=DsInfoName(ee);if(await this.components.datastore.has(re))throw await randomDelay(),new CodeError(`Key '${ee}' already exists`,codes$5.ERR_KEY_ALREADY_EXISTS);try{const se=await this.components.datastore.get(te),oe=await this.components.datastore.get(ne),ae=JSON.parse(toString$4(oe));ae.name=ee;const ce=this.components.datastore.batch();return ce.put(re,se),ce.put(ie,fromString$4(JSON.stringify(ae))),ce.delete(te),ce.delete(ne),await ce.commit(),ae}catch(se){throw await randomDelay(),se}}async exportKey(E,ee){if(!validateKeyName(E))throw await randomDelay(),new CodeError(`Invalid key name '${E}'`,codes$5.ERR_INVALID_KEY_NAME);if(ee==null)throw await randomDelay(),new CodeError("Password is required",codes$5.ERR_PASSWORD_REQUIRED);const te=DsName(E);try{const re=await this.components.datastore.get(te),ne=toString$4(re),ie=privates.get(this);if(ie==null)throw new CodeError("dek missing",codes$5.ERR_INVALID_PARAMETERS);const se=ie.dek;return await(await importKey(ne,se)).export(ee)}catch(re){throw await randomDelay(),re}}async exportPeerId(E){const ee="temporary-password",te=await this.exportKey(E,ee),re=await importKey(te,ee);return await peerIdFromKeys(re.public.bytes,re.bytes)}async importKey(E,ee,te){if(!validateKeyName(E)||E==="self")throw await randomDelay(),new CodeError(`Invalid key name '${E}'`,codes$5.ERR_INVALID_KEY_NAME);if(ee==null)throw await randomDelay(),new CodeError("PEM encoded key is required",codes$5.ERR_PEM_REQUIRED);const re=DsName(E);if(await this.components.datastore.has(re))throw await randomDelay(),new CodeError(`Key '${E}' already exists`,codes$5.ERR_KEY_ALREADY_EXISTS);let ne;try{ne=await importKey(ee,te)}catch{throw await randomDelay(),new CodeError("Cannot read the key, most likely the password is wrong",codes$5.ERR_CANNOT_READ_KEY)}let ie;try{ie=await ne.id();const ae=privates.get(this);if(ae==null)throw new CodeError("dek missing",codes$5.ERR_INVALID_PARAMETERS);const ce=ae.dek;ee=await ne.export(ce)}catch(ae){throw await randomDelay(),ae}const se={name:E,id:ie},oe=this.components.datastore.batch();return oe.put(re,fromString$4(ee)),oe.put(DsInfoName(E),fromString$4(JSON.stringify(se))),await oe.commit(),se}async importPeer(E,ee){try{if(!validateKeyName(E))throw new CodeError(`Invalid key name '${E}'`,codes$5.ERR_INVALID_KEY_NAME);if(ee==null)throw new CodeError("PeerId is required",codes$5.ERR_MISSING_PRIVATE_KEY);if(ee.privateKey==null)throw new CodeError("PeerId.privKey is required",codes$5.ERR_MISSING_PRIVATE_KEY);const te=await unmarshalPrivateKey(ee.privateKey),re=DsName(E);if(await this.components.datastore.has(re))throw await randomDelay(),new CodeError(`Key '${E}' already exists`,codes$5.ERR_KEY_ALREADY_EXISTS);const ne=privates.get(this);if(ne==null)throw new CodeError("dek missing",codes$5.ERR_INVALID_PARAMETERS);const ie=ne.dek,se=await te.export(ie),oe={name:E,id:ee.toString()},ae=this.components.datastore.batch();return ae.put(re,fromString$4(se)),ae.put(DsInfoName(E),fromString$4(JSON.stringify(oe))),await ae.commit(),oe}catch(te){throw await randomDelay(),te}}async getPrivateKey(E){if(!validateKeyName(E))throw await randomDelay(),new CodeError(`Invalid key name '${E}'`,codes$5.ERR_INVALID_KEY_NAME);try{const ee=DsName(E),te=await this.components.datastore.get(ee);return toString$4(te)}catch(ee){throw await randomDelay(),log$s.error(ee),new CodeError(`Key '${E}' does not exist.`,codes$5.ERR_KEY_NOT_FOUND)}}async rotateKeychainPass(E,ee){if(typeof E!="string")throw await randomDelay(),new CodeError(`Invalid old pass type '${typeof E}'`,codes$5.ERR_INVALID_OLD_PASS_TYPE);if(typeof ee!="string")throw await randomDelay(),new CodeError(`Invalid new pass type '${typeof ee}'`,codes$5.ERR_INVALID_NEW_PASS_TYPE);if(ee.length<20)throw await randomDelay(),new CodeError(`Invalid pass length ${ee.length}`,codes$5.ERR_INVALID_PASS_LENGTH);log$s("recreating keychain");const te=privates.get(this);if(te==null)throw new CodeError("dek missing",codes$5.ERR_INVALID_PARAMETERS);const re=te.dek;this.init.pass=ee;const ne=ee!=null&&this.init.dek?.salt!=null?pbkdf2(ee,this.init.dek.salt,this.init.dek?.iterationCount,this.init.dek?.keyLength,this.init.dek?.hash):"";privates.set(this,{dek:ne});const ie=await this.listKeys();for(const se of ie){const oe=await this.components.datastore.get(DsName(se.name)),ae=toString$4(oe),ce=await importKey(ae,re),le=ne.toString(),he=await ce.export(le),de=this.components.datastore.batch(),ue={name:se.name,id:se.id};de.put(DsName(se.name),fromString$4(he)),de.put(DsInfoName(se.name),fromString$4(JSON.stringify(ue))),await de.commit()}log$s("keychain reconstructed")}}const symbol$2=Symbol.for("@libp2p/transport");var FaultTolerance;(function(J){J[J.FATAL_ALL=0]="FATAL_ALL",J[J.NO_FATAL=1]="NO_FATAL"})(FaultTolerance||(FaultTolerance={}));class TrackedMap extends Map{constructor(E){super();const{name:ee,metrics:te}=E;this.metric=te.registerMetric(ee),this.updateComponentMetric()}set(E,ee){return super.set(E,ee),this.updateComponentMetric(),this}delete(E){const ee=super.delete(E);return this.updateComponentMetric(),ee}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function trackedMap(J){const{name:E,metrics:ee}=J;let te;return ee!=null?te=new TrackedMap({name:E,metrics:ee}):te=new Map,te}const log$r=logger("libp2p:transports");class DefaultTransportManager{constructor(E,ee={}){this.components=E,this.started=!1,this.transports=new Map,this.listeners=trackedMap({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=ee.faultTolerance??FaultTolerance.FATAL_ALL}add(E){const ee=E[Symbol.toStringTag];if(ee==null)throw new CodeError("Transport must have a valid tag",codes$6.ERR_INVALID_KEY);if(this.transports.has(ee))throw new CodeError(`There is already a transport with the tag ${ee}`,codes$6.ERR_DUPLICATE_TRANSPORT);log$r("adding transport %s",ee),this.transports.set(ee,E),this.listeners.has(ee)||this.listeners.set(ee,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const E=this.components.addressManager.getListenAddrs();await this.listen(E)}async stop(){const E=[];for(const[ee,te]of this.listeners)for(log$r("closing listeners for %s",ee);te.length>0;){const re=te.pop();re!=null&&E.push(re.close())}await Promise.all(E),log$r("all listeners closed");for(const ee of this.listeners.keys())this.listeners.set(ee,[]);this.started=!1}async dial(E,ee){const te=this.transportForMultiaddr(E);if(te==null)throw new CodeError(`No transport available for address ${String(E)}`,codes$6.ERR_TRANSPORT_UNAVAILABLE);try{return await te.dial(E,{...ee,upgrader:this.components.upgrader})}catch(re){throw re.code==null&&(re.code=codes$6.ERR_TRANSPORT_DIAL_FAILED),re}}getAddrs(){let E=[];for(const ee of this.listeners.values())for(const te of ee)E=[...E,...te.getAddrs()];return E}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}transportForMultiaddr(E){for(const ee of this.transports.values())if(ee.filter([E]).length>0)return ee}async listen(E){if(E==null||E.length===0){log$r("no addresses were provided for listening, this node is dial only");return}const ee=[];for(const[te,re]of this.transports.entries()){const ne=re.filter(E),ie=[];for(const se of ne){log$r("creating listener for %s on %s",te,se);const oe=re.createListener({upgrader:this.components.upgrader});let ae=this.listeners.get(te)??[];ae==null&&(ae=[],this.listeners.set(te,ae)),ae.push(oe),oe.addEventListener("listening",()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:oe})}),oe.addEventListener("close",()=>{const ce=ae.findIndex(le=>le===oe);ae.splice(ce,1),this.components.events.safeDispatchEvent("transport:close",{detail:oe})}),ie.push(oe.listen(se))}if(ie.length===0){ee.push(te);continue}if((await Promise.allSettled(ie)).find(se=>se.status==="fulfilled")==null&&this.faultTolerance!==FaultTolerance.NO_FATAL)throw new CodeError(`Transport (${te}) could not listen on any available address`,codes$6.ERR_NO_VALID_ADDRESSES)}if(ee.length===this.transports.size){const te=`no valid addresses were provided for transports [${ee.join(", ")}]`;if(this.faultTolerance===FaultTolerance.FATAL_ALL)throw new CodeError(te,codes$6.ERR_NO_VALID_ADDRESSES);log$r(`libp2p in dial mode only: ${te}`)}}async remove(E){log$r("removing %s",E);for(const ee of this.listeners.get(E)??[])await ee.close();this.transports.delete(E),this.listeners.delete(E)}async removeAll(){const E=[];for(const ee of this.transports.keys())E.push(this.remove(ee));await Promise.all(E)}}const PROTOCOL_ID="/multistream/1.0.0",MAX_PROTOCOL_LENGTH=1024,symbol$1=Symbol.for("@achingbrain/uint8arraylist");function findBufAndOffset(J,E){if(E==null||E<0)throw new RangeError("index is out of bounds");let ee=0;for(const te of J){const re=ee+te.byteLength;if(E<re)return{buf:te,index:E-ee};ee=re}throw new RangeError("index is out of bounds")}function isUint8ArrayList(J){return!!J?.[symbol$1]}class Uint8ArrayList{constructor(...E){Object.defineProperty(this,symbol$1,{value:!0}),this.bufs=[],this.length=0,E.length>0&&this.appendAll(E)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...E){this.appendAll(E)}appendAll(E){let ee=0;for(const te of E)if(te instanceof Uint8Array)ee+=te.byteLength,this.bufs.push(te);else if(isUint8ArrayList(te))ee+=te.byteLength,this.bufs.push(...te.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=ee}prepend(...E){this.prependAll(E)}prependAll(E){let ee=0;for(const te of E.reverse())if(te instanceof Uint8Array)ee+=te.byteLength,this.bufs.unshift(te);else if(isUint8ArrayList(te))ee+=te.byteLength,this.bufs.unshift(...te.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=ee}get(E){const ee=findBufAndOffset(this.bufs,E);return ee.buf[ee.index]}set(E,ee){const te=findBufAndOffset(this.bufs,E);te.buf[te.index]=ee}write(E,ee=0){if(E instanceof Uint8Array)for(let te=0;te<E.length;te++)this.set(ee+te,E[te]);else if(isUint8ArrayList(E))for(let te=0;te<E.length;te++)this.set(ee+te,E.get(te));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(E){if(E=Math.trunc(E),!(Number.isNaN(E)||E<=0)){if(E===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(E>=this.bufs[0].byteLength)E-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(E),this.length-=E;break}}}slice(E,ee){const{bufs:te,length:re}=this._subList(E,ee);return concat$3(te,re)}subarray(E,ee){const{bufs:te,length:re}=this._subList(E,ee);return te.length===1?te[0]:concat$3(te,re)}sublist(E,ee){const{bufs:te,length:re}=this._subList(E,ee),ne=new Uint8ArrayList;return ne.length=re,ne.bufs=te,ne}_subList(E,ee){if(E=E??0,ee=ee??this.length,E<0&&(E=this.length+E),ee<0&&(ee=this.length+ee),E<0||ee>this.length)throw new RangeError("index is out of bounds");if(E===ee)return{bufs:[],length:0};if(E===0&&ee===this.length)return{bufs:[...this.bufs],length:this.length};const te=[];let re=0;for(let ne=0;ne<this.bufs.length;ne++){const ie=this.bufs[ne],se=re,oe=se+ie.byteLength;if(re=oe,E>=oe)continue;const ae=E>=se&&E<oe,ce=ee>se&&ee<=oe;if(ae&&ce){if(E===se&&ee===oe){te.push(ie);break}const le=E-se;te.push(ie.subarray(le,le+(ee-E)));break}if(ae){if(E===0){te.push(ie);continue}te.push(ie.subarray(E-se));continue}if(ce){if(ee===oe){te.push(ie);break}te.push(ie.subarray(0,ee-se));break}te.push(ie)}return{bufs:te,length:ee-E}}indexOf(E,ee=0){if(!isUint8ArrayList(E)&&!(E instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const te=E instanceof Uint8Array?E:E.subarray();if(ee=Number(ee??0),isNaN(ee)&&(ee=0),ee<0&&(ee=this.length+ee),ee<0&&(ee=0),E.length===0)return ee>this.length?this.length:ee;const re=te.byteLength;if(re===0)throw new TypeError("search must be at least 1 byte long");const ne=256,ie=new Int32Array(ne);for(let le=0;le<ne;le++)ie[le]=-1;for(let le=0;le<re;le++)ie[te[le]]=le;const se=ie,oe=this.byteLength-te.byteLength,ae=te.byteLength-1;let ce;for(let le=ee;le<=oe;le+=ce){ce=0;for(let he=ae;he>=0;he--){const de=this.get(le+he);if(te[he]!==de){ce=Math.max(1,he-se[de]);break}}if(ce===0)return le}return-1}getInt8(E){const ee=this.subarray(E,E+1);return new DataView(ee.buffer,ee.byteOffset,ee.byteLength).getInt8(0)}setInt8(E,ee){const te=allocUnsafe$3(1);new DataView(te.buffer,te.byteOffset,te.byteLength).setInt8(0,ee),this.write(te,E)}getInt16(E,ee){const te=this.subarray(E,E+2);return new DataView(te.buffer,te.byteOffset,te.byteLength).getInt16(0,ee)}setInt16(E,ee,te){const re=alloc(2);new DataView(re.buffer,re.byteOffset,re.byteLength).setInt16(0,ee,te),this.write(re,E)}getInt32(E,ee){const te=this.subarray(E,E+4);return new DataView(te.buffer,te.byteOffset,te.byteLength).getInt32(0,ee)}setInt32(E,ee,te){const re=alloc(4);new DataView(re.buffer,re.byteOffset,re.byteLength).setInt32(0,ee,te),this.write(re,E)}getBigInt64(E,ee){const te=this.subarray(E,E+8);return new DataView(te.buffer,te.byteOffset,te.byteLength).getBigInt64(0,ee)}setBigInt64(E,ee,te){const re=alloc(8);new DataView(re.buffer,re.byteOffset,re.byteLength).setBigInt64(0,ee,te),this.write(re,E)}getUint8(E){const ee=this.subarray(E,E+1);return new DataView(ee.buffer,ee.byteOffset,ee.byteLength).getUint8(0)}setUint8(E,ee){const te=allocUnsafe$3(1);new DataView(te.buffer,te.byteOffset,te.byteLength).setUint8(0,ee),this.write(te,E)}getUint16(E,ee){const te=this.subarray(E,E+2);return new DataView(te.buffer,te.byteOffset,te.byteLength).getUint16(0,ee)}setUint16(E,ee,te){const re=alloc(2);new DataView(re.buffer,re.byteOffset,re.byteLength).setUint16(0,ee,te),this.write(re,E)}getUint32(E,ee){const te=this.subarray(E,E+4);return new DataView(te.buffer,te.byteOffset,te.byteLength).getUint32(0,ee)}setUint32(E,ee,te){const re=alloc(4);new DataView(re.buffer,re.byteOffset,re.byteLength).setUint32(0,ee,te),this.write(re,E)}getBigUint64(E,ee){const te=this.subarray(E,E+8);return new DataView(te.buffer,te.byteOffset,te.byteLength).getBigUint64(0,ee)}setBigUint64(E,ee,te){const re=alloc(8);new DataView(re.buffer,re.byteOffset,re.byteLength).setBigUint64(0,ee,te),this.write(re,E)}getFloat32(E,ee){const te=this.subarray(E,E+4);return new DataView(te.buffer,te.byteOffset,te.byteLength).getFloat32(0,ee)}setFloat32(E,ee,te){const re=alloc(4);new DataView(re.buffer,re.byteOffset,re.byteLength).setFloat32(0,ee,te),this.write(re,E)}getFloat64(E,ee){const te=this.subarray(E,E+8);return new DataView(te.buffer,te.byteOffset,te.byteLength).getFloat64(0,ee)}setFloat64(E,ee,te){const re=alloc(8);new DataView(re.buffer,re.byteOffset,re.byteLength).setFloat64(0,ee,te),this.write(re,E)}equals(E){if(E==null||!(E instanceof Uint8ArrayList)||E.bufs.length!==this.bufs.length)return!1;for(let ee=0;ee<this.bufs.length;ee++)if(!equals(this.bufs[ee],E.bufs[ee]))return!1;return!0}static fromUint8Arrays(E,ee){const te=new Uint8ArrayList;return te.bufs=E,ee==null&&(ee=E.reduce((re,ne)=>re+ne.byteLength,0)),te.length=ee,te}}function accessor(J){return J instanceof Uint8Array?{get(E){return J[E]},set(E,ee){J[E]=ee}}:{get(E){return J.get(E)},set(E,ee){J.set(E,ee)}}}const TWO_32=4294967296;class LongBits{constructor(E=0,ee=0){this.hi=E,this.lo=ee}toBigInt(E){if(E===!0)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const ee=~this.lo+1>>>0;let te=~this.hi>>>0;return ee===0&&(te=te+1>>>0),-(BigInt(ee)+(BigInt(te)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toNumber(E){return Number(this.toBigInt(E))}zzDecode(){const E=-(this.lo&1),ee=((this.lo>>>1|this.hi<<31)^E)>>>0,te=(this.hi>>>1^E)>>>0;return new LongBits(te,ee)}zzEncode(){const E=this.hi>>31,ee=((this.hi<<1|this.lo>>>31)^E)>>>0,te=(this.lo<<1^E)>>>0;return new LongBits(ee,te)}toBytes(E,ee=0){const te=accessor(E);for(;this.hi>0;)te.set(ee++,this.lo&127|128),this.lo=(this.lo>>>7|this.hi<<25)>>>0,this.hi>>>=7;for(;this.lo>127;)te.set(ee++,this.lo&127|128),this.lo=this.lo>>>7;te.set(ee++,this.lo)}static fromBigInt(E){if(E===0n)return new LongBits;const ee=E<0;ee&&(E=-E);let te=Number(E>>32n)|0,re=Number(E-(BigInt(te)<<32n))|0;return ee&&(te=~te>>>0,re=~re>>>0,++re>TWO_32&&(re=0,++te>TWO_32&&(te=0))),new LongBits(te,re)}static fromNumber(E){if(E===0)return new LongBits;const ee=E<0;ee&&(E=-E);let te=E>>>0,re=(E-te)/4294967296>>>0;return ee&&(re=~re>>>0,te=~te>>>0,++te>4294967295&&(te=0,++re>4294967295&&(re=0))),new LongBits(re,te)}static fromBytes(E,ee=0){const te=accessor(E),re=new LongBits;let ne=0;if(E.length-ee>4){for(;ne<4;++ne)if(re.lo=(re.lo|(te.get(ee)&127)<<ne*7)>>>0,te.get(ee++)<128)return re;if(re.lo=(re.lo|(te.get(ee)&127)<<28)>>>0,re.hi=(re.hi|(te.get(ee)&127)>>4)>>>0,te.get(ee++)<128)return re;ne=0}else for(;ne<4;++ne){if(ee>=E.length)throw RangeError(`index out of range: ${ee} > ${E.length}`);if(re.lo=(re.lo|(te.get(ee)&127)<<ne*7)>>>0,te.get(ee++)<128)return re}if(E.length-ee>4){for(;ne<5;++ne)if(re.hi=(re.hi|(te.get(ee)&127)<<ne*7+3)>>>0,te.get(ee++)<128)return re}else if(ee<E.byteLength)for(;ne<5;++ne){if(ee>=E.length)throw RangeError(`index out of range: ${ee} > ${E.length}`);if(re.hi=(re.hi|(te.get(ee)&127)<<ne*7+3)>>>0,te.get(ee++)<128)return re}throw RangeError("invalid varint encoding")}}const N1$1=Math.pow(2,7),N2$1=Math.pow(2,14),N3$1=Math.pow(2,21),N4$1=Math.pow(2,28),N5$1=Math.pow(2,35),N6$1=Math.pow(2,42),N7$1=Math.pow(2,49),N8$1=Math.pow(2,56),N9$1=Math.pow(2,63),unsigned={encodingLength(J){return J<N1$1?1:J<N2$1?2:J<N3$1?3:J<N4$1?4:J<N5$1?5:J<N6$1?6:J<N7$1?7:J<N8$1?8:J<N9$1?9:10},encode(J,E,ee=0){if(Number.MAX_SAFE_INTEGER!=null&&J>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return E==null&&(E=allocUnsafe$3(unsigned.encodingLength(J))),LongBits.fromNumber(J).toBytes(E,ee),E},decode(J,E=0){return LongBits.fromBytes(J,E).toNumber(!0)}};function isAsyncIterable$1(J){return J[Symbol.asyncIterator]!=null}const defaultEncoder=J=>{const E=unsigned.encodingLength(J),ee=allocUnsafe$3(E);return unsigned.encode(J,ee),defaultEncoder.bytes=E,ee};defaultEncoder.bytes=0;function encode$8(J,E){E=E??{};const ee=E.lengthEncoder??defaultEncoder;function*te(re){const ne=ee(re.byteLength);ne instanceof Uint8Array?yield ne:yield*ne,re instanceof Uint8Array?yield re:yield*re}return isAsyncIterable$1(J)?async function*(){for await(const re of J)yield*te(re)}():function*(){for(const re of J)yield*te(re)}()}encode$8.single=(J,E)=>{E=E??{};const ee=E.lengthEncoder??defaultEncoder;return new Uint8ArrayList(ee(J.byteLength),J)};const MAX_LENGTH_LENGTH=8,MAX_DATA_LENGTH=1024*1024*4;var ReadMode;(function(J){J[J.LENGTH=0]="LENGTH",J[J.DATA=1]="DATA"})(ReadMode||(ReadMode={}));const defaultDecoder=J=>{const E=unsigned.decode(J);return defaultDecoder.bytes=unsigned.encodingLength(E),E};defaultDecoder.bytes=0;function decode$6(J,E){const ee=new Uint8ArrayList;let te=ReadMode.LENGTH,re=-1;const ne=E?.lengthDecoder??defaultDecoder,ie=E?.maxLengthLength??MAX_LENGTH_LENGTH,se=E?.maxDataLength??MAX_DATA_LENGTH;function*oe(){for(;ee.byteLength>0;){if(te===ReadMode.LENGTH)try{if(re=ne(ee),re<0)throw errCode$1(new Error("invalid message length"),"ERR_INVALID_MSG_LENGTH");if(re>se)throw errCode$1(new Error("message length too long"),"ERR_MSG_DATA_TOO_LONG");const ae=ne.bytes;ee.consume(ae),E?.onLength!=null&&E.onLength(re),te=ReadMode.DATA}catch(ae){if(ae instanceof RangeError){if(ee.byteLength>ie)throw errCode$1(new Error("message length length too long"),"ERR_MSG_LENGTH_TOO_LONG");break}throw ae}if(te===ReadMode.DATA){if(ee.byteLength<re)break;const ae=ee.sublist(0,re);ee.consume(re),E?.onData!=null&&E.onData(ae),yield ae,te=ReadMode.LENGTH}}}return isAsyncIterable$1(J)?async function*(){for await(const ae of J)ee.append(ae),yield*oe();if(ee.byteLength>0)throw errCode$1(new Error("unexpected end of input"),"ERR_UNEXPECTED_EOF")}():function*(){for(const ae of J)ee.append(ae),yield*oe();if(ee.byteLength>0)throw errCode$1(new Error("unexpected end of input"),"ERR_UNEXPECTED_EOF")}()}decode$6.fromReader=(J,E)=>{let ee=1;const te=async function*(){for(;;)try{const{done:re,value:ne}=await J.next(ee);if(re===!0)return;ne!=null&&(yield ne)}catch(re){if(re.code==="ERR_UNDER_READ")return{done:!0,value:null};throw re}finally{ee=1}}();return decode$6(te,{...E??{},onLength:re=>{ee=re}})};let AbortError$2=class extends Error{constructor(J,E){super(J??"The operation was aborted"),this.type="aborted",this.code=E??"ABORT_ERR"}};function getIterator(J){if(J!=null){if(typeof J[Symbol.iterator]=="function")return J[Symbol.iterator]();if(typeof J[Symbol.asyncIterator]=="function")return J[Symbol.asyncIterator]();if(typeof J.next=="function")return J}throw new Error("argument is not an iterator or iterable")}function abortableSource$1(J,E,ee){const te=ee??{},re=getIterator(J);async function*ne(){let ie;const se=()=>{ie?.()};for(E.addEventListener("abort",se);;){let oe;try{if(E.aborted){const{abortMessage:ce,abortCode:le}=te;throw new AbortError$2(ce,le)}const ae=new Promise((ce,le)=>{ie=()=>{const{abortMessage:he,abortCode:de}=te;le(new AbortError$2(he,de))}});oe=await Promise.race([ae,re.next()]),ie=null}catch(ae){E.removeEventListener("abort",se);const ce=ae.type==="aborted"&&E.aborted;if(ce&&te.onAbort!=null&&te.onAbort(J),typeof re.return=="function")try{const le=re.return();le instanceof Promise&&le.catch(he=>{te.onReturnError!=null&&te.onReturnError(he)})}catch(le){te.onReturnError!=null&&te.onReturnError(le)}if(ce&&te.returnOnAbort===!0)return;throw ae}if(oe.done===!0)break;yield oe.value}E.removeEventListener("abort",se)}return ne()}function abortableSink(J,E,ee){return te=>J(abortableSource$1(te,E,ee))}function abortableDuplex(J,E,ee){return{sink:abortableSink(J.sink,E,{...ee,onAbort:void 0}),source:abortableSource$1(J.source,E,ee)}}const log$q=logger("libp2p:mss"),NewLine=fromString$4(`
`);function encode$7(J){const E=new Uint8ArrayList(J,NewLine);return encode$8.single(E)}function write(J,E,ee={}){const te=encode$7(E);ee.writeBytes===!0?J.push(te.subarray()):J.push(te)}function writeAll(J,E,ee={}){const te=new Uint8ArrayList;for(const re of E)te.append(encode$7(re));ee.writeBytes===!0?J.push(te.subarray()):J.push(te)}async function read$1(J,E){let ee=1;const te={[Symbol.asyncIterator]:()=>te,next:async()=>await J.next(ee)};let re=te;E?.signal!=null&&(re=abortableSource$1(te,E.signal));const ne=se=>{ee=se},ie=await pipe(re,se=>decode$6(se,{onLength:ne,maxDataLength:MAX_PROTOCOL_LENGTH}),async se=>await first(se));if(ie==null||ie.length===0)throw new CodeError("no buffer returned","ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");if(ie.get(ie.byteLength-1)!==NewLine[0])throw log$q.error("Invalid mss message - missing newline - %s",ie.subarray()),new CodeError("missing newline","ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");return ie.sublist(0,-1)}async function readString(J,E){const ee=await read$1(J,E);return toString$4(ee.subarray())}function reader(J){const E=async function*(){let ee=yield,te=new Uint8ArrayList;for await(const re of J){if(ee==null){te.append(re),ee=yield te,te=new Uint8ArrayList;continue}for(te.append(re);te.length>=ee;){const ne=te.sublist(0,ee);if(te.consume(ee),ee=yield ne,ee==null){te.length>0&&(ee=yield te,te=new Uint8ArrayList);break}}}if(ee!=null)throw Object.assign(new Error(`stream ended before ${ee} bytes became available`),{code:"ERR_UNDER_READ",buffer:te})}();return E.next(),E}function handshake(J){const E=pushable(),ee=reader(J.source),te=pDefer();let re;const ne=J.sink(async function*(){yield*E,yield*await te.promise}());return ne.catch(ie=>{re=ie}),{reader:ee,writer:E,stream:{sink:async ie=>{if(re!=null){await Promise.reject(re);return}te.resolve(ie),await ne},source:ee},rest:()=>E.end(),write:E.push,read:async()=>{const ie=await ee.next();if(ie.value!=null)return ie.value}}}const log$p=logger("libp2p:mss:select");async function select$1(J,E,ee={}){E=Array.isArray(E)?[...E]:[E];const{reader:te,writer:re,rest:ne,stream:ie}=handshake(J),se=E.shift();if(se==null)throw new Error("At least one protocol must be specified");log$p.trace('select: write ["%s", "%s"]',PROTOCOL_ID,se);const oe=fromString$4(PROTOCOL_ID),ae=fromString$4(se);writeAll(re,[oe,ae],ee);let ce=await readString(te,ee);if(log$p.trace('select: read "%s"',ce),ce===PROTOCOL_ID&&(ce=await readString(te,ee),log$p.trace('select: read "%s"',ce)),ce===se)return ne(),{stream:ie,protocol:se};for(const le of E){log$p.trace('select: write "%s"',le),write(re,fromString$4(le),ee);const he=await readString(te,ee);if(log$p.trace('select: read "%s" for "%s"',he,le),he===le)return ne(),{stream:ie,protocol:le}}throw ne(),new CodeError("protocol selection failed","ERR_UNSUPPORTED_PROTOCOL")}const log$o=logger("libp2p:mss:handle");async function handle(J,E,ee){E=Array.isArray(E)?E:[E];const{writer:te,reader:re,rest:ne,stream:ie}=handshake(J);for(;;){const se=await readString(re,ee);if(log$o.trace('read "%s"',se),se===PROTOCOL_ID){log$o.trace('respond with "%s" for "%s"',PROTOCOL_ID,se),write(te,fromString$4(PROTOCOL_ID),ee);continue}if(E.includes(se))return write(te,fromString$4(se),ee),log$o.trace('respond with "%s" for "%s"',se,se),ne(),{stream:ie,protocol:se};if(se==="ls"){write(te,new Uint8ArrayList(...E.map(oe=>encode$7(fromString$4(oe)))),ee),log$o.trace('respond with "%s" for %s',E,se);continue}write(te,fromString$4("na"),ee),log$o('respond with "na" for "%s"',se)}}const OPEN="OPEN",CLOSING="CLOSING",CLOSED="CLOSED",symbol=Symbol.for("@libp2p/connection"),log$n=logger("libp2p:connection");class ConnectionImpl{constructor(E){const{remoteAddr:ee,remotePeer:te,newStream:re,close:ne,getStreams:ie,stat:se}=E;this.id=`${parseInt(String(Math.random()*1e9)).toString(36)}${Date.now()}`,this.remoteAddr=ee,this.remotePeer=te,this.stat={...se,status:OPEN},this._newStream=re,this._close=ne,this._getStreams=ie,this.tags=[],this._closing=!1}get[Symbol.toStringTag](){return"Connection"}get[symbol](){return!0}get streams(){return this._getStreams()}async newStream(E,ee){if(this.stat.status===CLOSING)throw new CodeError("the connection is being closed","ERR_CONNECTION_BEING_CLOSED");if(this.stat.status===CLOSED)throw new CodeError("the connection is closed","ERR_CONNECTION_CLOSED");Array.isArray(E)||(E=[E]);const te=await this._newStream(E,ee);return te.stat.direction="outbound",te}addStream(E){E.stat.direction="inbound"}removeStream(E){}async close(){if(!(this.stat.status===CLOSED||this._closing)){this.stat.status=CLOSING;try{this.streams.forEach(E=>{E.close()})}catch(E){log$n.error(E)}this._closing=!0,await this._close(),this._closing=!1,this.stat.timeline.close=Date.now(),this.stat.status=CLOSED}}}function createConnection(J){return new ConnectionImpl(J)}const topologySymbol=Symbol.for("@libp2p/topology");function isTopology(J){return J!=null&&!!J[topologySymbol]}const log$m=logger("libp2p:registrar"),DEFAULT_MAX_INBOUND_STREAMS=32,DEFAULT_MAX_OUTBOUND_STREAMS=64;class DefaultRegistrar{constructor(E){this.topologies=new Map,this.handlers=new Map,this.components=E,this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onConnect=this._onConnect.bind(this),this.components.events.addEventListener("connection:close",this._onDisconnect),this.components.events.addEventListener("connection:open",this._onConnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate)}getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(E){const ee=this.handlers.get(E);if(ee==null)throw new CodeError(`No handler registered for protocol ${E}`,codes$6.ERR_NO_HANDLER_FOR_PROTOCOL);return ee}getTopologies(E){const ee=this.topologies.get(E);return ee==null?[]:[...ee.values()]}async handle(E,ee,te){if(this.handlers.has(E))throw new CodeError(`Handler already registered for protocol ${E}`,codes$6.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED);const re=mergeOptions$1.bind({ignoreUndefined:!0})({maxInboundStreams:DEFAULT_MAX_INBOUND_STREAMS,maxOutboundStreams:DEFAULT_MAX_OUTBOUND_STREAMS},te);this.handlers.set(E,{handler:ee,options:re}),await this.components.peerStore.merge(this.components.peerId,{protocols:[E]})}async unhandle(E){const ee=Array.isArray(E)?E:[E];ee.forEach(te=>{this.handlers.delete(te)}),await this.components.peerStore.patch(this.components.peerId,{protocols:ee})}async register(E,ee){if(!isTopology(ee))throw log$m.error("topology must be an instance of interfaces/topology"),new CodeError("topology must be an instance of interfaces/topology",codes$6.ERR_INVALID_PARAMETERS);const te=`${(Math.random()*1e9).toString(36)}${Date.now()}`;let re=this.topologies.get(E);return re==null&&(re=new Map,this.topologies.set(E,re)),re.set(te,ee),await ee.setRegistrar(this),te}unregister(E){for(const[ee,te]of this.topologies.entries())te.has(E)&&(te.delete(E),te.size===0&&this.topologies.delete(ee))}_onDisconnect(E){const ee=E.detail;this.components.peerStore.get(ee.remotePeer).then(te=>{for(const re of te.protocols){const ne=this.topologies.get(re);if(ne!=null)for(const ie of ne.values())ie.onDisconnect(ee.remotePeer)}}).catch(te=>{log$m.error("could not inform topologies of disconnecting peer %p",ee.remotePeer,te)})}_onConnect(E){const ee=E.detail;this.components.peerStore.get(ee.remotePeer).then(te=>{for(const re of te.protocols){const ne=this.topologies.get(re);if(ne!=null)for(const ie of ne.values())ie.onConnect(ee.remotePeer,ee)}}).catch(te=>{log$m.error("could not inform topologies of connecting peer %p",ee.remotePeer,te)})}_onPeerUpdate(E){const{peer:ee,previous:te}=E.detail,re=(te?.protocols??[]).filter(ie=>!ee.protocols.includes(ie)),ne=ee.protocols.filter(ie=>!(te?.protocols??[]).includes(ie));for(const ie of re){const se=this.topologies.get(ie);if(se!=null)for(const oe of se.values())oe.onDisconnect(ee.id)}for(const ie of ne){const se=this.topologies.get(ie);if(se!=null)for(const oe of se.values()){const ae=this.components.connectionManager.getConnections(ee.id)[0];ae!=null&&oe.onConnect(ee.id,ae)}}}}const log$l=logger("libp2p:upgrader");function findIncomingStreamLimit(J,E){try{const{options:ee}=E.getHandler(J);return ee.maxInboundStreams}catch(ee){if(ee.code!==codes$6.ERR_NO_HANDLER_FOR_PROTOCOL)throw ee}return DEFAULT_MAX_INBOUND_STREAMS}function findOutgoingStreamLimit(J,E){try{const{options:ee}=E.getHandler(J);return ee.maxOutboundStreams}catch(ee){if(ee.code!==codes$6.ERR_NO_HANDLER_FOR_PROTOCOL)throw ee}return DEFAULT_MAX_OUTBOUND_STREAMS}function countStreams(J,E,ee){let te=0;return ee.streams.forEach(re=>{re.stat.direction===E&&re.stat.protocol===J&&te++}),te}class DefaultUpgrader{constructor(E,ee){this.components=E,this.connectionEncryption=new Map,ee.connectionEncryption.forEach(te=>{this.connectionEncryption.set(te.protocol,te)}),this.muxers=new Map,ee.muxers.forEach(te=>{this.muxers.set(te.protocol,te)}),this.inboundUpgradeTimeout=ee.inboundUpgradeTimeout??INBOUND_UPGRADE_TIMEOUT,this.events=E.events}async shouldBlockConnection(E,ee,te){const re=this.components.connectionGater[te];if(re!==void 0&&await re(E,ee))throw new CodeError(`The multiaddr connection is blocked by gater.${te}`,codes$6.ERR_CONNECTION_INTERCEPTED)}async upgradeInbound(E,ee){if(!await this.components.connectionManager.acceptIncomingConnection(E))throw new CodeError("connection denied",codes$6.ERR_CONNECTION_DENIED);let te,re,ne,ie,se;const oe=anySignal([AbortSignal.timeout(this.inboundUpgradeTimeout)]);try{setMaxListeners?.(1/0,oe)}catch{}try{const ae=abortableDuplex(E,oe);if(E.source=ae.source,E.sink=ae.sink,await this.components.connectionGater.denyInboundConnection?.(E)===!0)throw new CodeError("The multiaddr connection is blocked by gater.acceptConnection",codes$6.ERR_CONNECTION_INTERCEPTED);this.components.metrics?.trackMultiaddrConnection(E),log$l("starting the inbound connection upgrade");let ce=E;if(ee?.skipProtection!==!0){const le=this.components.connectionProtector;le!=null&&(log$l("protecting the inbound connection"),ce=await le.protect(E))}try{if(te=ce,ee?.skipEncryption!==!0){({conn:te,remotePeer:re,protocol:se}=await this._encryptInbound(ce));const le={...ce,...te};await this.shouldBlockConnection(re,le,"denyInboundEncryptedConnection")}else{const le=E.remoteAddr.getPeerId();if(le==null)throw new CodeError("inbound connection that skipped encryption must have a peer id",codes$6.ERR_INVALID_MULTIADDR);const he=peerIdFromString(le);se="native",re=he}if(ne=te,ee?.muxerFactory!=null)ie=ee.muxerFactory;else if(this.muxers.size>0){const le=await this._multiplexInbound({...ce,...te},this.muxers);ie=le.muxerFactory,ne=le.stream}}catch(le){throw log$l.error("Failed to upgrade inbound connection",le),le}return await this.shouldBlockConnection(re,E,"denyInboundUpgradedConnection"),log$l("Successfully upgraded inbound connection"),this._createConnection({cryptoProtocol:se,direction:"inbound",maConn:E,upgradedConn:ne,muxerFactory:ie,remotePeer:re})}finally{this.components.connectionManager.afterUpgradeInbound(),oe.clear()}}async upgradeOutbound(E,ee){const te=E.remoteAddr.getPeerId();let re;te!=null&&(re=peerIdFromString(te),await this.shouldBlockConnection(re,E,"denyOutboundConnection"));let ne,ie,se,oe,ae;this.components.metrics?.trackMultiaddrConnection(E),log$l("Starting the outbound connection upgrade");let ce=E;if(ee?.skipProtection!==!0){const le=this.components.connectionProtector;le!=null&&(ce=await le.protect(E))}try{if(ne=ce,ee?.skipEncryption!==!0){({conn:ne,remotePeer:ie,protocol:oe}=await this._encryptOutbound(ce,re));const le={...ce,...ne};await this.shouldBlockConnection(ie,le,"denyOutboundEncryptedConnection")}else{if(re==null)throw new CodeError("Encryption was skipped but no peer id was passed",codes$6.ERR_INVALID_PEER);oe="native",ie=re}if(se=ne,ee?.muxerFactory!=null)ae=ee.muxerFactory;else if(this.muxers.size>0){const le=await this._multiplexOutbound({...ce,...ne},this.muxers);ae=le.muxerFactory,se=le.stream}}catch(le){throw log$l.error("Failed to upgrade outbound connection",le),await E.close(le),le}return await this.shouldBlockConnection(ie,E,"denyOutboundUpgradedConnection"),log$l("Successfully upgraded outbound connection"),this._createConnection({cryptoProtocol:oe,direction:"outbound",maConn:E,upgradedConn:se,muxerFactory:ae,remotePeer:ie})}_createConnection(E){const{cryptoProtocol:ee,direction:te,maConn:re,upgradedConn:ne,remotePeer:ie,muxerFactory:se}=E;let oe,ae,ce;se!=null&&(oe=se.createStreamMuxer({direction:te,onIncomingStream:de=>{ce!=null&&Promise.resolve().then(async()=>{const ue=this.components.registrar.getProtocols(),{stream:pe,protocol:ye}=await handle(de,ue);if(log$l("%s: incoming stream opened on %s",te,ye),ce==null)return;const me=findIncomingStreamLimit(ye,this.components.registrar);if(countStreams(ye,"inbound",ce)===me){const be=new CodeError(`Too many inbound protocol streams for protocol "${ye}" - limit ${me}`,codes$6.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS);throw de.abort(be),be}de.source=pe.source,de.sink=pe.sink,de.stat.protocol=ye,await this.components.peerStore.merge(ie,{protocols:[ye]}),ce.addStream(de),this.components.metrics?.trackProtocolStream(de,ce),this._onStream({connection:ce,stream:de,protocol:ye})}).catch(ue=>{log$l.error(ue),de.stat.timeline.close==null&&de.close()})},onStreamEnd:de=>{ce?.removeStream(de.id)}}),ae=async(de,ue={})=>{if(oe==null)throw new CodeError("Stream is not multiplexed",codes$6.ERR_MUXER_UNAVAILABLE);log$l("%s: starting new stream on %s",te,de);const pe=await oe.newStream();try{if(ue.signal==null){log$l("No abort signal was passed while trying to negotiate protocols %s falling back to default timeout",de),ue.signal=AbortSignal.timeout(3e4);try{setMaxListeners?.(1/0,ue.signal)}catch{}}const{stream:ye,protocol:me}=await select$1(pe,de,ue),be=findOutgoingStreamLimit(me,this.components.registrar);if(countStreams(me,"outbound",ce)===be){const _e=new CodeError(`Too many outbound protocol streams for protocol "${me}" - limit ${be}`,codes$6.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS);throw pe.abort(_e),_e}return await this.components.peerStore.merge(ie,{protocols:[me]}),pe.source=ye.source,pe.sink=ye.sink,pe.stat.protocol=me,this.components.metrics?.trackProtocolStream(pe,ce),pe}catch(ye){throw log$l.error("could not create new stream",ye),pe.stat.timeline.close==null&&pe.close(),ye.code!=null?ye:new CodeError(String(ye),codes$6.ERR_UNSUPPORTED_PROTOCOL)}},Promise.all([oe.sink(ne.source),ne.sink(oe.source)]).catch(de=>{log$l.error(de)}));const le=re.timeline;re.timeline=new Proxy(le,{set:(...de)=>(ce!=null&&de[1]==="close"&&de[2]!=null&&le.close==null&&(async()=>{try{ce.stat.status==="OPEN"&&await ce.close()}catch(ue){log$l.error(ue)}finally{this.events.safeDispatchEvent("connection:close",{detail:ce})}})().catch(ue=>{log$l.error(ue)}),Reflect.set(...de))}),re.timeline.upgraded=Date.now();const he=()=>{throw new CodeError("connection is not multiplexed",codes$6.ERR_CONNECTION_NOT_MULTIPLEXED)};return ce=createConnection({remoteAddr:re.remoteAddr,remotePeer:ie,stat:{status:"OPEN",direction:te,timeline:re.timeline,multiplexer:oe?.protocol,encryption:ee},newStream:ae??he,getStreams:()=>oe!=null?oe.streams:he(),close:async()=>{await re.close(),oe?.close()}}),this.events.safeDispatchEvent("connection:open",{detail:ce}),ce}_onStream(E){const{connection:ee,stream:te,protocol:re}=E,{handler:ne}=this.components.registrar.getHandler(re);ne({connection:ee,stream:te})}async _encryptInbound(E){const ee=Array.from(this.connectionEncryption.keys());log$l("handling inbound crypto protocol selection",ee);try{const{stream:te,protocol:re}=await handle(E,ee,{writeBytes:!0}),ne=this.connectionEncryption.get(re);if(ne==null)throw new Error(`no crypto module found for ${re}`);return log$l("encrypting inbound connection..."),{...await ne.secureInbound(this.components.peerId,te),protocol:re}}catch(te){throw new CodeError(String(te),codes$6.ERR_ENCRYPTION_FAILED)}}async _encryptOutbound(E,ee){const te=Array.from(this.connectionEncryption.keys());log$l("selecting outbound crypto protocol",te);try{const{stream:re,protocol:ne}=await select$1(E,te,{writeBytes:!0}),ie=this.connectionEncryption.get(ne);if(ie==null)throw new Error(`no crypto module found for ${ne}`);return log$l("encrypting outbound connection to %p",ee),{...await ie.secureOutbound(this.components.peerId,re,ee),protocol:ne}}catch(re){throw new CodeError(String(re),codes$6.ERR_ENCRYPTION_FAILED)}}async _multiplexOutbound(E,ee){const te=Array.from(ee.keys());log$l("outbound selecting muxer %s",te);try{const{stream:re,protocol:ne}=await select$1(E,te,{writeBytes:!0});log$l("%s selected as muxer protocol",ne);const ie=ee.get(ne);return{stream:re,muxerFactory:ie}}catch(re){throw log$l.error("error multiplexing outbound stream",re),new CodeError(String(re),codes$6.ERR_MUXER_UNAVAILABLE)}}async _multiplexInbound(E,ee){const te=Array.from(ee.keys());log$l("inbound handling muxers %s",te);try{const{stream:re,protocol:ne}=await handle(E,te,{writeBytes:!0}),ie=ee.get(ne);return{stream:re,muxerFactory:ie}}catch(re){throw log$l.error("error multiplexing inbound stream",re),new CodeError(String(re),codes$6.ERR_MUXER_UNAVAILABLE)}}}const codes$4={ERR_SIGNATURE_NOT_VALID:"ERR_SIGNATURE_NOT_VALID"};var Envelope;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{re.lengthDelimited!==!1&&te.fork(),ee.publicKey!=null&&ee.publicKey.byteLength>0&&(te.uint32(10),te.bytes(ee.publicKey)),ee.payloadType!=null&&ee.payloadType.byteLength>0&&(te.uint32(18),te.bytes(ee.payloadType)),ee.payload!=null&&ee.payload.byteLength>0&&(te.uint32(26),te.bytes(ee.payload)),ee.signature!=null&&ee.signature.byteLength>0&&(te.uint32(42),te.bytes(ee.signature)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={publicKey:new Uint8Array(0),payloadType:new Uint8Array(0),payload:new Uint8Array(0),signature:new Uint8Array(0)},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.publicKey=ee.bytes();break;case 2:re.payloadType=ee.bytes();break;case 3:re.payload=ee.bytes();break;case 5:re.signature=ee.bytes();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage(ee,J.codec())})(Envelope||(Envelope={}));class RecordEnvelope{constructor(E){const{peerId:ee,payloadType:te,payload:re,signature:ne}=E;this.peerId=ee,this.payloadType=te,this.payload=re,this.signature=ne}marshal(){if(this.peerId.publicKey==null)throw new Error("Missing public key");return this.marshaled==null&&(this.marshaled=Envelope.encode({publicKey:this.peerId.publicKey,payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(E){return equals(this.marshal(),E.marshal())}async validate(E){const ee=formatSignaturePayload(E,this.payloadType,this.payload);if(this.peerId.publicKey==null)throw new Error("Missing public key");return await unmarshalPublicKey(this.peerId.publicKey).verify(ee.subarray(),this.signature)}}RecordEnvelope.createFromProtobuf=async J=>{const E=Envelope.decode(J),ee=await peerIdFromKeys(E.publicKey);return new RecordEnvelope({peerId:ee,payloadType:E.payloadType,payload:E.payload,signature:E.signature})};RecordEnvelope.seal=async(J,E)=>{if(E.privateKey==null)throw new Error("Missing private key");const ee=J.domain,te=J.codec,re=J.marshal(),ne=formatSignaturePayload(ee,te,re),ie=await(await unmarshalPrivateKey(E.privateKey)).sign(ne.subarray());return new RecordEnvelope({peerId:E,payloadType:te,payload:re,signature:ie})};RecordEnvelope.openAndCertify=async(J,E)=>{const ee=await RecordEnvelope.createFromProtobuf(J);if(!await ee.validate(E))throw new CodeError("envelope signature is not valid for the given domain",codes$4.ERR_SIGNATURE_NOT_VALID);return ee};const formatSignaturePayload=(J,E,ee)=>{const te=fromString$4(J),re=unsigned.encode(te.byteLength),ne=unsigned.encode(E.length),ie=unsigned.encode(ee.length);return new Uint8ArrayList(re,te,ne,E,ie,ee)};function arrayEquals(J,E){const ee=(te,re)=>te.toString().localeCompare(re.toString());return J.length!==E.length?!1:(E.sort(ee),J.sort(ee).every((te,re)=>E[re].equals(te)))}var PeerRecord$1;(function(J){(function(ee){let te;ee.codec=()=>(te==null&&(te=message((re,ne,ie={})=>{ie.lengthDelimited!==!1&&ne.fork(),re.multiaddr!=null&&re.multiaddr.byteLength>0&&(ne.uint32(10),ne.bytes(re.multiaddr)),ie.lengthDelimited!==!1&&ne.ldelim()},(re,ne)=>{const ie={multiaddr:new Uint8Array(0)},se=ne==null?re.len:re.pos+ne;for(;re.pos<se;){const oe=re.uint32();switch(oe>>>3){case 1:ie.multiaddr=re.bytes();break;default:re.skipType(oe&7);break}}return ie})),te),ee.encode=re=>encodeMessage(re,ee.codec()),ee.decode=re=>decodeMessage(re,ee.codec())})(J.AddressInfo||(J.AddressInfo={}));let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{if(re.lengthDelimited!==!1&&te.fork(),ee.peerId!=null&&ee.peerId.byteLength>0&&(te.uint32(10),te.bytes(ee.peerId)),ee.seq!=null&&ee.seq!==0n&&(te.uint32(16),te.uint64(ee.seq)),ee.addresses!=null)for(const ne of ee.addresses)te.uint32(26),J.AddressInfo.codec().encode(ne,te);re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={peerId:new Uint8Array(0),seq:0n,addresses:[]},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.peerId=ee.bytes();break;case 2:re.seq=ee.uint64();break;case 3:re.addresses.push(J.AddressInfo.codec().decode(ee,ee.uint32()));break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage(ee,J.codec())})(PeerRecord$1||(PeerRecord$1={}));const ENVELOPE_DOMAIN_PEER_RECORD="libp2p-peer-record",ENVELOPE_PAYLOAD_TYPE_PEER_RECORD=Uint8Array.from([3,1]);class PeerRecord{constructor(E){this.domain=PeerRecord.DOMAIN,this.codec=PeerRecord.CODEC;const{peerId:ee,multiaddrs:te,seqNumber:re}=E;this.peerId=ee,this.multiaddrs=te??[],this.seqNumber=re??BigInt(Date.now())}marshal(){return this.marshaled==null&&(this.marshaled=PeerRecord$1.encode({peerId:this.peerId.toBytes(),seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map(E=>({multiaddr:E.bytes}))})),this.marshaled}equals(E){return!(!(E instanceof PeerRecord)||!this.peerId.equals(E.peerId)||this.seqNumber!==E.seqNumber||!arrayEquals(this.multiaddrs,E.multiaddrs))}}PeerRecord.createFromProtobuf=J=>{const E=PeerRecord$1.decode(J),ee=peerIdFromBytes(E.peerId),te=(E.addresses??[]).map(ne=>multiaddr(ne.multiaddr)),re=E.seq;return new PeerRecord({peerId:ee,multiaddrs:te,seqNumber:re})};PeerRecord.DOMAIN=ENVELOPE_DOMAIN_PEER_RECORD;PeerRecord.CODEC=ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;class TimeoutError extends Error{constructor(E){super(E),this.name="TimeoutError"}}let AbortError$1=class extends Error{constructor(J){super(),this.name="AbortError",this.message=J}};const getDOMException=J=>globalThis.DOMException===void 0?new AbortError$1(J):new DOMException(J),getAbortedReason=J=>{const E=J.reason===void 0?getDOMException("This operation was aborted."):J.reason;return E instanceof Error?E:getDOMException(E)};function pTimeout(J,E){const{milliseconds:ee,fallback:te,message:re,customTimers:ne={setTimeout,clearTimeout}}=E;let ie;const se=new Promise((oe,ae)=>{if(typeof ee!="number"||Math.sign(ee)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${ee}\``);if(ee===Number.POSITIVE_INFINITY){oe(J);return}if(E.signal){const{signal:le}=E;le.aborted&&ae(getAbortedReason(le)),le.addEventListener("abort",()=>{ae(getAbortedReason(le))})}const ce=new TimeoutError;ie=ne.setTimeout.call(void 0,()=>{if(te){try{oe(te())}catch(le){ae(le)}return}typeof J.cancel=="function"&&J.cancel(),re===!1?oe():re instanceof Error?ae(re):(ce.message=re??`Promise timed out after ${ee} milliseconds`,ae(ce))},ee),(async()=>{try{oe(await J)}catch(le){ae(le)}finally{ne.clearTimeout.call(void 0,ie)}})()});return se.clear=()=>{ne.clearTimeout.call(void 0,ie),ie=void 0},se}const WORKER_REQUEST_READ_LOCK="lock:worker:request-read",WORKER_RELEASE_READ_LOCK="lock:worker:release-read",MASTER_GRANT_READ_LOCK="lock:master:grant-read",WORKER_REQUEST_WRITE_LOCK="lock:worker:request-write",WORKER_RELEASE_WRITE_LOCK="lock:worker:release-write",MASTER_GRANT_WRITE_LOCK="lock:master:grant-write",events={},observable=J=>{J.addEventListener("message",E=>{observable.dispatchEvent("message",J,E)}),J.port!=null&&J.port.addEventListener("message",E=>{observable.dispatchEvent("message",J,E)})};observable.addEventListener=(J,E)=>{events[J]==null&&(events[J]=[]),events[J].push(E)};observable.removeEventListener=(J,E)=>{events[J]!=null&&(events[J]=events[J].filter(ee=>ee===E))};observable.dispatchEvent=function(J,E,ee){events[J]!=null&&events[J].forEach(te=>te(E,ee))};const handleWorkerLockRequest=(J,E,ee,te,re)=>(ne,ie)=>{if(ie.data.type!==ee)return;const se={type:ie.data.type,name:ie.data.name,identifier:ie.data.identifier};J.dispatchEvent(new MessageEvent(E,{data:{name:se.name,handler:async()=>(ne.postMessage({type:re,name:se.name,identifier:se.identifier}),await new Promise(oe=>{const ae=ce=>{if(ce==null||ce.data==null)return;const le={type:ce.data.type,name:ce.data.name,identifier:ce.data.identifier};le.type===te&&le.identifier===se.identifier&&(ne.removeEventListener("message",ae),oe())};ne.addEventListener("message",ae)}))}}))},makeWorkerLockRequest=(J,E,ee,te)=>async()=>{const re=nanoid();return globalThis.postMessage({type:E,identifier:re,name:J}),await new Promise(ne=>{const ie=se=>{if(se==null||se.data==null)return;const oe={type:se.data.type,identifier:se.data.identifier};oe.type===ee&&oe.identifier===re&&(globalThis.removeEventListener("message",ie),ne(()=>{globalThis.postMessage({type:te,identifier:re,name:J})}))};globalThis.addEventListener("message",ie)})},defaultOptions$1={singleProcess:!1},impl=J=>{if(J=Object.assign({},defaultOptions$1,J),!!globalThis.document||J.singleProcess){const E=new EventTarget;return observable.addEventListener("message",handleWorkerLockRequest(E,"requestReadLock",WORKER_REQUEST_READ_LOCK,WORKER_RELEASE_READ_LOCK,MASTER_GRANT_READ_LOCK)),observable.addEventListener("message",handleWorkerLockRequest(E,"requestWriteLock",WORKER_REQUEST_WRITE_LOCK,WORKER_RELEASE_WRITE_LOCK,MASTER_GRANT_WRITE_LOCK)),E}return{isWorker:!0,readLock:E=>makeWorkerLockRequest(E,WORKER_REQUEST_READ_LOCK,MASTER_GRANT_READ_LOCK,WORKER_RELEASE_READ_LOCK),writeLock:E=>makeWorkerLockRequest(E,WORKER_REQUEST_WRITE_LOCK,MASTER_GRANT_WRITE_LOCK,WORKER_RELEASE_WRITE_LOCK)}},mutexes={};let implementation;async function createReleaseable(J,E){let ee;const te=new Promise(re=>{ee=re});return J.add(async()=>await pTimeout((async()=>await new Promise(re=>{ee(()=>{re()})}))(),{milliseconds:E.timeout})),await te}const createMutex=(J,E)=>{if(implementation.isWorker===!0)return{readLock:implementation.readLock(J,E),writeLock:implementation.writeLock(J,E)};const ee=new PQueue({concurrency:1});let te;return{async readLock(){if(te!=null)return await createReleaseable(te,E);te=new PQueue({concurrency:E.concurrency,autoStart:!1});const re=te,ne=createReleaseable(te,E);return ee.add(async()=>(re.start(),await re.onIdle().then(()=>{te===re&&(te=null)}))),await ne},async writeLock(){return te=null,await createReleaseable(ee,E)}}},defaultOptions={name:"lock",concurrency:1/0,timeout:846e5,singleProcess:!1};function createMortice(J){const E=Object.assign({},defaultOptions,J);return implementation==null&&(implementation=impl(E),implementation.isWorker!==!0&&(implementation.addEventListener("requestReadLock",ee=>{mutexes[ee.data.name]!=null&&mutexes[ee.data.name].readLock().then(async te=>await ee.data.handler().finally(()=>te()))}),implementation.addEventListener("requestWriteLock",async ee=>{mutexes[ee.data.name]!=null&&mutexes[ee.data.name].writeLock().then(async te=>await ee.data.handler().finally(()=>te()))}))),mutexes[E.name]==null&&(mutexes[E.name]=createMutex(E.name,E)),mutexes[E.name]}const codes$3={ERR_INVALID_PARAMETERS:"ERR_INVALID_PARAMETERS"};var Peer$1;(function(J){(function(ee){let te;ee.codec=()=>(te==null&&(te=message((re,ne,ie={})=>{ie.lengthDelimited!==!1&&ne.fork(),re.key!=null&&re.key!==""&&(ne.uint32(10),ne.string(re.key)),re.value!=null&&re.value.byteLength>0&&(ne.uint32(18),ne.bytes(re.value)),ie.lengthDelimited!==!1&&ne.ldelim()},(re,ne)=>{const ie={key:"",value:new Uint8Array(0)},se=ne==null?re.len:re.pos+ne;for(;re.pos<se;){const oe=re.uint32();switch(oe>>>3){case 1:ie.key=re.string();break;case 2:ie.value=re.bytes();break;default:re.skipType(oe&7);break}}return ie})),te),ee.encode=re=>encodeMessage(re,ee.codec()),ee.decode=re=>decodeMessage(re,ee.codec())})(J.Peer$metadataEntry||(J.Peer$metadataEntry={})),function(ee){let te;ee.codec=()=>(te==null&&(te=message((re,ne,ie={})=>{ie.lengthDelimited!==!1&&ne.fork(),re.key!=null&&re.key!==""&&(ne.uint32(10),ne.string(re.key)),re.value!=null&&(ne.uint32(18),Tag.codec().encode(re.value,ne)),ie.lengthDelimited!==!1&&ne.ldelim()},(re,ne)=>{const ie={key:""},se=ne==null?re.len:re.pos+ne;for(;re.pos<se;){const oe=re.uint32();switch(oe>>>3){case 1:ie.key=re.string();break;case 2:ie.value=Tag.codec().decode(re,re.uint32());break;default:re.skipType(oe&7);break}}return ie})),te),ee.encode=re=>encodeMessage(re,ee.codec()),ee.decode=re=>decodeMessage(re,ee.codec())}(J.Peer$tagsEntry||(J.Peer$tagsEntry={}));let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{if(re.lengthDelimited!==!1&&te.fork(),ee.addresses!=null)for(const ne of ee.addresses)te.uint32(10),Address.codec().encode(ne,te);if(ee.protocols!=null)for(const ne of ee.protocols)te.uint32(18),te.string(ne);if(ee.publicKey!=null&&(te.uint32(34),te.bytes(ee.publicKey)),ee.peerRecordEnvelope!=null&&(te.uint32(42),te.bytes(ee.peerRecordEnvelope)),ee.metadata!=null&&ee.metadata.size!==0)for(const[ne,ie]of ee.metadata.entries())te.uint32(50),J.Peer$metadataEntry.codec().encode({key:ne,value:ie},te);if(ee.tags!=null&&ee.tags.size!==0)for(const[ne,ie]of ee.tags.entries())te.uint32(58),J.Peer$tagsEntry.codec().encode({key:ne,value:ie},te);re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={addresses:[],protocols:[],metadata:new Map,tags:new Map},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.addresses.push(Address.codec().decode(ee,ee.uint32()));break;case 2:re.protocols.push(ee.string());break;case 4:re.publicKey=ee.bytes();break;case 5:re.peerRecordEnvelope=ee.bytes();break;case 6:{const se=J.Peer$metadataEntry.codec().decode(ee,ee.uint32());re.metadata.set(se.key,se.value);break}case 7:{const se=J.Peer$tagsEntry.codec().decode(ee,ee.uint32());re.tags.set(se.key,se.value);break}default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage(ee,J.codec())})(Peer$1||(Peer$1={}));var Address;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{re.lengthDelimited!==!1&&te.fork(),ee.multiaddr!=null&&ee.multiaddr.byteLength>0&&(te.uint32(10),te.bytes(ee.multiaddr)),ee.isCertified!=null&&(te.uint32(16),te.bool(ee.isCertified)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={multiaddr:new Uint8Array(0)},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.multiaddr=ee.bytes();break;case 2:re.isCertified=ee.bool();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage(ee,J.codec())})(Address||(Address={}));var Tag;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{re.lengthDelimited!==!1&&te.fork(),ee.value!=null&&ee.value!==0&&(te.uint32(8),te.uint32(ee.value)),ee.expiry!=null&&(te.uint32(16),te.uint64(ee.expiry)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={value:0},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.value=ee.uint32();break;case 2:re.expiry=ee.uint64();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage(ee,J.codec())})(Tag||(Tag={}));var PeerIdProto;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{re.lengthDelimited!==!1&&te.fork(),ee.id!=null&&(te.uint32(10),te.bytes(ee.id)),ee.pubKey!=null&&(te.uint32(18),te.bytes(ee.pubKey)),ee.privKey!=null&&(te.uint32(26),te.bytes(ee.privKey)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.id=ee.bytes();break;case 2:re.pubKey=ee.bytes();break;case 3:re.privKey=ee.bytes();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage(ee,J.codec())})(PeerIdProto||(PeerIdProto={}));const createEd25519PeerId=async()=>{const J=await generateKeyPair("Ed25519"),E=await createFromPrivKey(J);if(E.type==="Ed25519")return E;throw new Error(`Generated unexpected PeerId type "${E.type}"`)};async function createFromPubKey(J){return await peerIdFromKeys(marshalPublicKey(J))}async function createFromPrivKey(J){return await peerIdFromKeys(marshalPublicKey(J.public),marshalPrivateKey(J))}async function bytesToPeer(J,E){const ee=Peer$1.decode(E);ee.publicKey!=null&&J.publicKey==null&&(J=await createFromPubKey(unmarshalPublicKey(ee.publicKey)));const te=new Map,re=BigInt(Date.now());for(const[ne,ie]of ee.tags.entries())ie.expiry!=null&&ie.expiry<re||te.set(ne,ie);return{...ee,id:J,addresses:ee.addresses.map(({multiaddr:ne,isCertified:ie})=>({multiaddr:multiaddr(ne),isCertified:ie??!1})),metadata:ee.metadata,peerRecordEnvelope:ee.peerRecordEnvelope??void 0,tags:te}}const NAMESPACE_COMMON="/peers/";function peerIdToDatastoreKey(J){if(!isPeerId(J)||J.type==null)throw new CodeError("Invalid PeerId",codes$3.ERR_INVALID_PARAMETERS);const E=J.toCID().toString();return new Key(`${NAMESPACE_COMMON}${E}`)}async function dedupeFilterAndSortAddresses(J,E,ee){const te=new Map;for(const re of ee){if(re==null)continue;if(re.multiaddr instanceof Uint8Array&&(re.multiaddr=multiaddr(re.multiaddr)),!isMultiaddr(re.multiaddr))throw new CodeError("Multiaddr was invalid",codes$3.ERR_INVALID_PARAMETERS);if(!await E(J,re.multiaddr))continue;const ne=re.isCertified??!1,ie=re.multiaddr.toString(),se=te.get(ie);se!=null?re.isCertified=se.isCertified||ne:te.set(ie,{multiaddr:re.multiaddr,isCertified:ne})}return[...te.values()].sort((re,ne)=>re.multiaddr.toString().localeCompare(ne.multiaddr.toString())).map(({isCertified:re,multiaddr:ne})=>({isCertified:re,multiaddr:ne.bytes}))}async function toPeerPB(J,E,ee,te){if(E==null)throw new CodeError("Invalid PeerData",codes$3.ERR_INVALID_PARAMETERS);if(E.publicKey!=null&&J.publicKey!=null&&!equals(E.publicKey,J.publicKey))throw new CodeError("publicKey bytes do not match peer id publicKey bytes",codes$3.ERR_INVALID_PARAMETERS);const re=te.existingPeer;if(re!=null&&!J.equals(re.id))throw new CodeError("peer id did not match existing peer id",codes$3.ERR_INVALID_PARAMETERS);let ne=re?.addresses??[],ie=new Set(re?.protocols??[]),se=re?.metadata??new Map,oe=re?.tags??new Map,ae=re?.peerRecordEnvelope;if(ee==="patch"){if((E.multiaddrs!=null||E.addresses!=null)&&(ne=[],E.multiaddrs!=null&&ne.push(...E.multiaddrs.map(le=>({isCertified:!1,multiaddr:le}))),E.addresses!=null&&ne.push(...E.addresses)),E.protocols!=null&&(ie=new Set(E.protocols)),E.metadata!=null){const le=E.metadata instanceof Map?[...E.metadata.entries()]:Object.entries(E.metadata);se=createSortedMap(le,{validate:validateMetadata})}if(E.tags!=null){const le=E.tags instanceof Map?[...E.tags.entries()]:Object.entries(E.tags);oe=createSortedMap(le,{validate:validateTag,map:mapTag})}E.peerRecordEnvelope!=null&&(ae=E.peerRecordEnvelope)}if(ee==="merge"){if(E.multiaddrs!=null&&ne.push(...E.multiaddrs.map(le=>({isCertified:!1,multiaddr:le}))),E.addresses!=null&&ne.push(...E.addresses),E.protocols!=null&&(ie=new Set([...ie,...E.protocols])),E.metadata!=null){const le=E.metadata instanceof Map?[...E.metadata.entries()]:Object.entries(E.metadata);for(const[he,de]of le)de==null?se.delete(he):se.set(he,de);se=createSortedMap([...se.entries()],{validate:validateMetadata})}if(E.tags!=null){const le=E.tags instanceof Map?[...E.tags.entries()]:Object.entries(E.tags),he=new Map(oe);for(const[de,ue]of le)ue==null?he.delete(de):he.set(de,ue);oe=createSortedMap([...he.entries()],{validate:validateTag,map:mapTag})}E.peerRecordEnvelope!=null&&(ae=E.peerRecordEnvelope)}const ce={addresses:await dedupeFilterAndSortAddresses(J,te.addressFilter??(async()=>!0),ne),protocols:[...ie.values()].sort((le,he)=>le.localeCompare(he)),metadata:se,tags:oe,publicKey:re?.id.publicKey??E.publicKey??J.publicKey,peerRecordEnvelope:ae};return J.type!=="RSA"&&delete ce.publicKey,ce}function createSortedMap(J,E){const ee=new Map;for(const[te,re]of J)re!=null&&E.validate(te,re);for(const[te,re]of J.sort(([ne],[ie])=>ne.localeCompare(ie)))re!=null&&ee.set(te,E.map?.(te,re)??re);return ee}function validateMetadata(J,E){if(typeof J!="string")throw new CodeError("Metadata key must be a string",codes$3.ERR_INVALID_PARAMETERS);if(!(E instanceof Uint8Array))throw new CodeError("Metadata value must be a Uint8Array",codes$3.ERR_INVALID_PARAMETERS)}function validateTag(J,E){if(typeof J!="string")throw new CodeError("Tag name must be a string",codes$3.ERR_INVALID_PARAMETERS);if(E.value!=null){if(parseInt(`${E.value}`,10)!==E.value)throw new CodeError("Tag value must be an integer",codes$3.ERR_INVALID_PARAMETERS);if(E.value<0||E.value>100)throw new CodeError("Tag value must be between 0-100",codes$3.ERR_INVALID_PARAMETERS)}if(E.ttl!=null){if(parseInt(`${E.ttl}`,10)!==E.ttl)throw new CodeError("Tag ttl must be an integer",codes$3.ERR_INVALID_PARAMETERS);if(E.ttl<0)throw new CodeError("Tag ttl must be between greater than 0",codes$3.ERR_INVALID_PARAMETERS)}}function mapTag(J,E){let ee;return E.expiry!=null&&(ee=E.expiry),E.ttl!=null&&(ee=BigInt(Date.now()+Number(E.ttl))),{value:E.value??0,expiry:ee}}class PersistentStore{peerId;datastore;lock;addressFilter;constructor(E,ee={}){this.peerId=E.peerId,this.datastore=E.datastore,this.addressFilter=ee.addressFilter,this.lock=createMortice({name:"peer-store",singleProcess:!0})}async has(E){return this.datastore.has(peerIdToDatastoreKey(E))}async delete(E){if(this.peerId.equals(E))throw new CodeError("Cannot delete self peer",codes$3.ERR_INVALID_PARAMETERS);await this.datastore.delete(peerIdToDatastoreKey(E))}async load(E){const ee=await this.datastore.get(peerIdToDatastoreKey(E));return bytesToPeer(E,ee)}async save(E,ee){const{existingBuf:te,existingPeer:re}=await this.#e(E),ne=await toPeerPB(E,ee,"patch",{addressFilter:this.addressFilter});return this.#t(E,ne,te,re)}async patch(E,ee){const{existingBuf:te,existingPeer:re}=await this.#e(E),ne=await toPeerPB(E,ee,"patch",{addressFilter:this.addressFilter,existingPeer:re});return this.#t(E,ne,te,re)}async merge(E,ee){const{existingBuf:te,existingPeer:re}=await this.#e(E),ne=await toPeerPB(E,ee,"merge",{addressFilter:this.addressFilter,existingPeer:re});return this.#t(E,ne,te,re)}async*all(){for await(const{key:E,value:ee}of this.datastore.query({prefix:NAMESPACE_COMMON})){const te=E.toString().split("/")[2],re=base32$2.decode(te),ne=peerIdFromBytes(re);ne.equals(this.peerId)||(yield bytesToPeer(ne,ee))}}async#e(E){try{const ee=await this.datastore.get(peerIdToDatastoreKey(E)),te=await bytesToPeer(E,ee);return{existingBuf:ee,existingPeer:te}}catch(ee){if(ee.code!=="ERR_NOT_FOUND")throw ee}return{}}async#t(E,ee,te,re){const ne=Peer$1.encode(ee);return te!=null&&equals(ne,te)?{peer:await bytesToPeer(E,ne),previous:re,updated:!1}:(await this.datastore.put(peerIdToDatastoreKey(E),ne),{peer:await bytesToPeer(E,ne),previous:re,updated:!0})}}const log$k=logger("libp2p:peer-store");class PersistentPeerStore{store;events;peerId;constructor(E,ee={}){this.events=E.events,this.peerId=E.peerId,this.store=new PersistentStore(E,ee)}async forEach(E){log$k.trace("forEach await read lock");const ee=await this.store.lock.readLock();log$k.trace("forEach got read lock");try{for await(const te of this.store.all())E(te)}finally{log$k.trace("forEach release read lock"),ee()}}async all(){log$k.trace("all await read lock");const E=await this.store.lock.readLock();log$k.trace("all got read lock");try{const ee=[];for await(const te of this.store.all())ee.push(te);return ee}finally{log$k.trace("all release read lock"),E()}}async delete(E){log$k.trace("delete await write lock");const ee=await this.store.lock.writeLock();log$k.trace("delete got write lock");try{await this.store.delete(E)}finally{log$k.trace("delete release write lock"),ee()}}async has(E){log$k.trace("has await read lock");const ee=await this.store.lock.readLock();log$k.trace("has got read lock");try{return await this.store.has(E)}finally{log$k.trace("has release read lock"),ee()}}async get(E){log$k.trace("get await read lock");const ee=await this.store.lock.readLock();log$k.trace("get got read lock");try{return await this.store.load(E)}finally{log$k.trace("get release read lock"),ee()}}async save(E,ee){log$k.trace("save await write lock");const te=await this.store.lock.writeLock();log$k.trace("save got write lock");try{const re=await this.store.save(E,ee);return this.#e(E,re),re.peer}finally{log$k.trace("save release write lock"),te()}}async patch(E,ee){log$k.trace("patch await write lock");const te=await this.store.lock.writeLock();log$k.trace("patch got write lock");try{const re=await this.store.patch(E,ee);return this.#e(E,re),re.peer}finally{log$k.trace("patch release write lock"),te()}}async merge(E,ee){log$k.trace("merge await write lock");const te=await this.store.lock.writeLock();log$k.trace("merge got write lock");try{const re=await this.store.merge(E,ee);return this.#e(E,re),re.peer}finally{log$k.trace("merge release write lock"),te()}}async consumePeerRecord(E,ee){const te=await RecordEnvelope.openAndCertify(E,PeerRecord.DOMAIN);if(ee?.equals(te.peerId)===!1)return log$k("envelope peer id was not the expected peer id - expected: %p received: %p",ee,te.peerId),!1;const re=PeerRecord.createFromProtobuf(te.payload);let ne;try{ne=await this.get(te.peerId)}catch(ie){if(ie.code!=="ERR_NOT_FOUND")throw ie}if(ne?.peerRecordEnvelope!=null){const ie=await RecordEnvelope.createFromProtobuf(ne.peerRecordEnvelope),se=PeerRecord.createFromProtobuf(ie.payload);if(se.seqNumber>=re.seqNumber)return log$k("sequence number was lower or equal to existing sequence number - stored: %d received: %d",se.seqNumber,re.seqNumber),!1}return await this.patch(re.peerId,{peerRecordEnvelope:E,addresses:re.multiaddrs.map(ie=>({isCertified:!0,multiaddr:ie}))}),!0}#e(E,ee){ee.updated&&(this.peerId.equals(E)?this.events.safeDispatchEvent("self:peer:update",{detail:ee}):this.events.safeDispatchEvent("peer:update",{detail:ee}))}}function isStartable(J){return J!=null&&typeof J.start=="function"&&typeof J.stop=="function"}class DefaultComponents{constructor(E={}){this.components={},this._started=!1,this.components={};for(const[ee,te]of Object.entries(E))this.components[ee]=te}isStarted(){return this._started}async _invokeStartableMethod(E){await Promise.all(Object.values(this.components).filter(ee=>isStartable(ee)).map(async ee=>{await ee[E]?.()}))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const OPTIONAL_SERVICES=["metrics","connectionProtector"],NON_SERVICE_PROPERTIES=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function defaultComponents(J={}){const E=new DefaultComponents(J);return new Proxy(E,{get(ee,te,re){if(typeof te=="string"&&!NON_SERVICE_PROPERTIES.includes(te)){const ne=E.components[te];if(ne==null&&!OPTIONAL_SERVICES.includes(te))throw new CodeError(`${te} not set`,"ERR_SERVICE_MISSING");return ne}return Reflect.get(ee,te,re)},set(ee,te,re){return typeof te=="string"?E.components[te]=re:Reflect.set(ee,te,re),!0}})}const DefaultConfig={addresses:{listen:[],announce:[],noAnnounce:[],announceFilter:J=>J},connectionManager:{resolvers:{dnsaddr:dnsaddrResolver},addressSorter:publicAddressesFirst},transportManager:{faultTolerance:FaultTolerance.FATAL_ALL}};function validateConfig(J){const E=mergeOptions$1(DefaultConfig,J);if(E.transports==null||E.transports.length<1)throw new CodeError(messages.ERR_TRANSPORTS_REQUIRED,codes$6.ERR_TRANSPORTS_REQUIRED);if(E.connectionEncryption==null||E.connectionEncryption.length===0)throw new CodeError(messages.CONN_ENCRYPTION_REQUIRED,codes$6.CONN_ENCRYPTION_REQUIRED);if(E.connectionProtector===null&&globalThis.process?.env?.LIBP2P_FORCE_PNET!=null)throw new CodeError(messages.ERR_PROTECTOR_REQUIRED,codes$6.ERR_PROTECTOR_REQUIRED);return E}const contentRouting=Symbol.for("@libp2p/content-routing"),peerRouting=Symbol.for("@libp2p/peer-routing"),peerDiscovery=Symbol.for("@libp2p/peer-discovery");function connectionGater(J={}){return{denyDialPeer:async()=>!1,denyDialMultiaddr:async E=>{const ee=E.stringTuples();return ee[0][0]===4||ee[0][0]===41?!!is_ip_private(`${ee[0][1]}`):!1},denyInboundConnection:async()=>!1,denyOutboundConnection:async()=>!1,denyInboundEncryptedConnection:async()=>!1,denyOutboundEncryptedConnection:async()=>!1,denyInboundUpgradedConnection:async()=>!1,denyOutboundUpgradedConnection:async()=>!1,filterMultiaddrForPeer:async()=>!0,...J}}var __classPrivateFieldSet=globalThis&&globalThis.__classPrivateFieldSet||function(J,E,ee,te,re){if(te==="m")throw new TypeError("Private method is not writable");if(te==="a"&&!re)throw new TypeError("Private accessor was defined without a setter");if(typeof E=="function"?J!==E||!re:!E.has(J))throw new TypeError("Cannot write private member to an object whose class did not declare it");return te==="a"?re.call(J,ee):re?re.value=ee:E.set(J,ee),ee},__classPrivateFieldGet$3=globalThis&&globalThis.__classPrivateFieldGet||function(J,E,ee,te){if(ee==="a"&&!te)throw new TypeError("Private accessor was defined without a getter");if(typeof E=="function"?J!==E||!te:!E.has(J))throw new TypeError("Cannot read private member from an object whose class did not declare it");return ee==="m"?te:ee==="a"?te.call(J):te?te.value:E.get(J)},_Libp2pNode_instances,_Libp2pNode_started,_Libp2pNode_onDiscoveryPeer;const log$j=logger("libp2p");class Libp2pNode extends EventEmitter$3{constructor(E){super(),_Libp2pNode_instances.add(this),_Libp2pNode_started.set(this,void 0);const ee=new EventEmitter$3,te=ee.dispatchEvent.bind(ee);ee.dispatchEvent=oe=>{const ae=te(oe),ce=this.dispatchEvent(new CustomEvent$1(oe.type,{detail:oe.detail}));return ae||ce};try{setMaxListeners?.(1/0,ee)}catch{}__classPrivateFieldSet(this,_Libp2pNode_started,!1,"f"),this.peerId=E.peerId,this.services={};const re=this.components=defaultComponents({peerId:E.peerId,events:ee,datastore:E.datastore??new MemoryDatastore,connectionGater:connectionGater(E.connectionGater)});this.peerStore=this.configureComponent("peerStore",new PersistentPeerStore(re,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...E.peerStore})),E.metrics!=null&&(this.metrics=this.configureComponent("metrics",E.metrics(this.components))),re.events.addEventListener("peer:update",oe=>{oe.detail.previous==null&&this.safeDispatchEvent("peer:discovery",{detail:oe.detail.peer})}),E.connectionProtector!=null&&this.configureComponent("connectionProtector",E.connectionProtector(re)),this.components.upgrader=new DefaultUpgrader(this.components,{connectionEncryption:(E.connectionEncryption??[]).map((oe,ae)=>this.configureComponent(`connection-encryption-${ae}`,oe(this.components))),muxers:(E.streamMuxers??[]).map((oe,ae)=>this.configureComponent(`stream-muxers-${ae}`,oe(this.components))),inboundUpgradeTimeout:E.connectionManager.inboundUpgradeTimeout}),this.configureComponent("transportManager",new DefaultTransportManager(this.components,E.transportManager)),this.configureComponent("connectionManager",new DefaultConnectionManager(this.components,E.connectionManager)),this.configureComponent("registrar",new DefaultRegistrar(this.components)),this.configureComponent("addressManager",new DefaultAddressManager(this.components,E.addresses));const ne=DefaultKeyChain.generateOptions();this.keychain=this.configureComponent("keyChain",new DefaultKeyChain(this.components,{...ne,...E.keychain}));const ie=(E.peerRouters??[]).map((oe,ae)=>this.configureComponent(`peer-router-${ae}`,oe(this.components)));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new DefaultPeerRouting(this.components,{routers:ie}));const se=(E.contentRouters??[]).map((oe,ae)=>this.configureComponent(`content-router-${ae}`,oe(this.components)));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new CompoundContentRouting(this.components,{routers:se})),(E.peerDiscovery??[]).forEach((oe,ae)=>{this.configureComponent(`peer-discovery-${ae}`,oe(this.components)).addEventListener("peer",ce=>{__classPrivateFieldGet$3(this,_Libp2pNode_instances,"m",_Libp2pNode_onDiscoveryPeer).call(this,ce)})}),E.transports.forEach((oe,ae)=>{this.components.transportManager.add(this.configureComponent(`transport-${ae}`,oe(this.components)))}),E.services!=null)for(const oe of Object.keys(E.services)){const ae=E.services[oe],ce=ae(this.components);if(ce==null){log$j.error("service factory %s returned null or undefined instance",oe);continue}this.services[oe]=ce,this.configureComponent(oe,ce),ce[contentRouting]!=null&&(log$j("registering service %s for content routing",oe),se.push(ce[contentRouting])),ce[peerRouting]!=null&&(log$j("registering service %s for peer routing",oe),ie.push(ce[peerRouting])),ce[peerDiscovery]!=null&&(log$j("registering service %s for peer discovery",oe),ce[peerDiscovery].addEventListener("peer",le=>{__classPrivateFieldGet$3(this,_Libp2pNode_instances,"m",_Libp2pNode_onDiscoveryPeer).call(this,le)}))}}configureComponent(E,ee){return ee==null&&log$j.error("component %s was null or undefined",E),this.components[E]=ee,ee}async start(){if(!__classPrivateFieldGet$3(this,_Libp2pNode_started,"f")){__classPrivateFieldSet(this,_Libp2pNode_started,!0,"f"),log$j("libp2p is starting"),(await this.keychain.listKeys()).find(E=>E.name==="self")==null&&(log$j("importing self key into keychain"),await this.keychain.importPeer("self",this.components.peerId));try{await this.components.beforeStart?.(),await this.components.start(),await this.components.afterStart?.(),log$j("libp2p has started")}catch(E){throw log$j.error("An error occurred starting libp2p",E),await this.stop(),E}}}async stop(){__classPrivateFieldGet$3(this,_Libp2pNode_started,"f")&&(log$j("libp2p is stopping"),__classPrivateFieldSet(this,_Libp2pNode_started,!1,"f"),await this.components.beforeStop?.(),await this.components.stop(),await this.components.afterStop?.(),log$j("libp2p has stopped"))}isStarted(){return __classPrivateFieldGet$3(this,_Libp2pNode_started,"f")}getConnections(E){return this.components.connectionManager.getConnections(E)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const E=new PeerSet;for(const ee of this.components.connectionManager.getConnections())E.add(ee.remotePeer);return Array.from(E)}async dial(E,ee={}){return await this.components.connectionManager.openConnection(E,ee)}async dialProtocol(E,ee,te={}){if(ee==null)throw new CodeError("no protocols were provided to open a stream",codes$6.ERR_INVALID_PROTOCOLS_FOR_STREAM);if(ee=Array.isArray(ee)?ee:[ee],ee.length===0)throw new CodeError("no protocols were provided to open a stream",codes$6.ERR_INVALID_PROTOCOLS_FOR_STREAM);return await(await this.dial(E,te)).newStream(ee,te)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(E){isMultiaddr(E)&&(E=peerIdFromString(E.getPeerId()??"")),await this.components.connectionManager.closeConnections(E)}async getPublicKey(E,ee={}){if(log$j("getPublicKey %p",E),E.publicKey!=null)return E.publicKey;const te=await this.peerStore.get(E);if(te.id.publicKey!=null)return te.id.publicKey;const re=concat$3([fromString$4("/pk/"),E.multihash.digest]),ne=await this.contentRouting.get(re,ee);return unmarshalPublicKey(ne),await this.peerStore.patch(E,{publicKey:ne}),ne}async handle(E,ee,te){Array.isArray(E)||(E=[E]),await Promise.all(E.map(async re=>{await this.components.registrar.handle(re,ee,te)}))}async unhandle(E){Array.isArray(E)||(E=[E]),await Promise.all(E.map(async ee=>{await this.components.registrar.unhandle(ee)}))}async register(E,ee){return await this.components.registrar.register(E,ee)}unregister(E){this.components.registrar.unregister(E)}}_Libp2pNode_started=new WeakMap,_Libp2pNode_instances=new WeakSet,_Libp2pNode_onDiscoveryPeer=function J(E){const{detail:ee}=E;if(ee.id.toString()===this.peerId.toString()){log$j.error(new Error(codes$6.ERR_DISCOVERED_SELF));return}this.components.peerStore.merge(ee.id,{multiaddrs:ee.multiaddrs,protocols:ee.protocols}).catch(te=>{log$j.error(te)})};async function createLibp2pNode(J){if(J.peerId==null){const E=J.datastore;if(E!=null)try{const ee=new DefaultKeyChain({datastore:E},mergeOptions$1(DefaultKeyChain.generateOptions(),J.keychain));J.peerId=await ee.exportPeerId("self")}catch(ee){if(ee.code!=="ERR_NOT_FOUND")throw ee}}return J.peerId==null&&(J.peerId=await createEd25519PeerId()),new Libp2pNode(validateConfig(J))}async function createLibp2p(J){const E=await createLibp2pNode(J);return J.start!==!1&&await E.start(),E}const DNS4=base$3("dns4"),DNS6=base$3("dns6"),DNSADDR=base$3("dnsaddr"),DNS=or$1(base$3("dns"),DNSADDR,DNS4,DNS6),IP=or$1(base$3("ip4"),base$3("ip6")),TCP$1=or$1(and(IP,base$3("tcp")),and(DNS,base$3("tcp"))),UDP=and(IP,base$3("udp")),UTP=and(UDP,base$3("utp")),QUIC=and(UDP,base$3("quic")),QUICV1=and(UDP,base$3("quic-v1")),WebSockets$1=or$1(and(TCP$1,base$3("ws")),and(DNS,base$3("ws"))),WebSocketsSecure=or$1(and(TCP$1,base$3("wss")),and(DNS,base$3("wss")),and(TCP$1,base$3("tls"),base$3("ws")),and(DNS,base$3("tls"),base$3("ws"))),HTTP=or$1(and(TCP$1,base$3("http")),and(IP,base$3("http")),and(DNS,base$3("http"))),HTTPS=or$1(and(TCP$1,base$3("https")),and(IP,base$3("https")),and(DNS,base$3("https"))),_WebRTCDirect=and(UDP,base$3("webrtc-direct"),base$3("certhash")),WebRTCDirect=or$1(and(_WebRTCDirect,base$3("p2p")),_WebRTCDirect),_WebTransport=and(QUICV1,base$3("webtransport"),base$3("certhash"),base$3("certhash")),WebTransport=or$1(and(_WebTransport,base$3("p2p")),_WebTransport),P2PWebRTCStar=or$1(and(WebSockets$1,base$3("p2p-webrtc-star"),base$3("p2p")),and(WebSocketsSecure,base$3("p2p-webrtc-star"),base$3("p2p")),and(WebSockets$1,base$3("p2p-webrtc-star")),and(WebSocketsSecure,base$3("p2p-webrtc-star"))),P2PWebRTCDirect=or$1(and(HTTP,base$3("p2p-webrtc-direct"),base$3("p2p")),and(HTTPS,base$3("p2p-webrtc-direct"),base$3("p2p")),and(HTTP,base$3("p2p-webrtc-direct")),and(HTTPS,base$3("p2p-webrtc-direct"))),Reliable=or$1(WebSockets$1,WebSocketsSecure,HTTP,HTTPS,P2PWebRTCStar,P2PWebRTCDirect,TCP$1,UTP,QUIC,DNS,WebRTCDirect,WebTransport),_P2P=or$1(and(Reliable,base$3("p2p")),P2PWebRTCStar,P2PWebRTCDirect,WebRTCDirect,WebTransport,base$3("p2p")),_Circuit=or$1(and(_P2P,base$3("p2p-circuit"),_P2P),and(_P2P,base$3("p2p-circuit")),and(base$3("p2p-circuit"),_P2P),and(Reliable,base$3("p2p-circuit")),and(base$3("p2p-circuit"),Reliable),base$3("p2p-circuit")),CircuitRecursive=()=>or$1(and(_Circuit,CircuitRecursive),_Circuit),Circuit=CircuitRecursive(),P2P=or$1(and(Circuit,_P2P,Circuit),and(_P2P,Circuit),and(Circuit,_P2P),Circuit,_P2P);function makeMatchesFunction(J){function E(ee){let te;try{te=multiaddr(ee)}catch{return!1}const re=J(te.protoNames());return re===null?!1:re===!0||re===!1?re:re.length===0}return E}function and(...J){function E(ee){if(ee.length<J.length)return null;let te=ee;return J.some(re=>(te=typeof re=="function"?re().partialMatch(ee):re.partialMatch(ee),Array.isArray(te)&&(ee=te),te===null)),te}return{toString:function(){return"{ "+J.join(" ")+" }"},input:J,matches:makeMatchesFunction(E),partialMatch:E}}function or$1(...J){function E(ee){let te=null;return J.some(re=>{const ne=typeof re=="function"?re().partialMatch(ee):re.partialMatch(ee);return ne!=null?(te=ne,!0):!1}),te}return{toString:function(){return"{ "+J.join(" ")+" }"},input:J,matches:makeMatchesFunction(E),partialMatch:E}}function base$3(J){const E=J;function ee(re){let ne;try{ne=multiaddr(re)}catch{return!1}const ie=ne.protoNames();return ie.length===1&&ie[0]===E}function te(re){return re.length===0?null:re[0]===E?re.slice(1):null}return{toString:function(){return E},matches:ee,partialMatch:te}}const log$i=logger("libp2p:bootstrap"),DEFAULT_BOOTSTRAP_TAG_NAME="bootstrap",DEFAULT_BOOTSTRAP_TAG_VALUE=50,DEFAULT_BOOTSTRAP_TAG_TTL=12e4,DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT=1e3;class Bootstrap extends EventEmitter$3{static tag="bootstrap";timer;list;timeout;components;_init;constructor(E,ee={list:[]}){if(ee.list==null||ee.list.length===0)throw new Error("Bootstrap requires a list of peer addresses");super(),this.components=E,this.timeout=ee.timeout??DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT,this.list=[];for(const te of ee.list){if(!P2P.matches(te)){log$i.error("Invalid multiaddr");continue}const re=multiaddr(te),ne=re.getPeerId();if(ne==null){log$i.error("Invalid bootstrap multiaddr without peer id");continue}const ie={id:peerIdFromString(ne),multiaddrs:[re],protocols:[]};this.list.push(ie)}this._init=ee}[peerDiscovery]=this;[Symbol.toStringTag]="@libp2p/bootstrap";isStarted(){return!!this.timer}start(){this.isStarted()||(log$i("Starting bootstrap node discovery, discovering peers after %s ms",this.timeout),this.timer=setTimeout(()=>{this._discoverBootstrapPeers().catch(E=>{log$i.error(E)})},this.timeout))}async _discoverBootstrapPeers(){if(this.timer!=null)for(const E of this.list){if(await this.components.peerStore.merge(E.id,{tags:{[this._init.tagName??DEFAULT_BOOTSTRAP_TAG_NAME]:{value:this._init.tagValue??DEFAULT_BOOTSTRAP_TAG_VALUE,ttl:this._init.tagTTL??DEFAULT_BOOTSTRAP_TAG_TTL}}}),this.timer==null)return;this.safeDispatchEvent("peer",{detail:E})}}stop(){this.timer!=null&&clearTimeout(this.timer),this.timer=void 0}}function bootstrap(J){return E=>new Bootstrap(E,J)}class AbortError extends Error{constructor(E,ee){super(E??"The operation was aborted"),this.type="aborted",this.code=ee??"ABORT_ERR"}}function abortableSource(J,E,ee){const te=ee??{},re=getIterator(J);async function*ne(){let ie;const se=()=>{ie?.()};for(E.addEventListener("abort",se);;){let oe;try{if(E.aborted){const{abortMessage:ce,abortCode:le}=te;throw new AbortError(ce,le)}const ae=new Promise((ce,le)=>{ie=()=>{const{abortMessage:he,abortCode:de}=te;le(new AbortError(he,de))}});oe=await Promise.race([ae,re.next()]),ie=null}catch(ae){E.removeEventListener("abort",se);const ce=ae.type==="aborted"&&E.aborted;if(ce&&te.onAbort!=null&&await te.onAbort(J),typeof re.return=="function")try{const le=re.return();le instanceof Promise&&le.catch(he=>{te.onReturnError!=null&&te.onReturnError(he)})}catch(le){te.onReturnError!=null&&te.onReturnError(le)}if(ce&&te.returnOnAbort===!0)return;throw ae}if(oe.done===!0)break;yield oe.value}E.removeEventListener("abort",se)}return ne()}var FrameType;(function(J){J[J.Data=0]="Data",J[J.WindowUpdate=1]="WindowUpdate",J[J.Ping=2]="Ping",J[J.GoAway=3]="GoAway"})(FrameType||(FrameType={}));var Flag;(function(J){J[J.SYN=1]="SYN",J[J.ACK=2]="ACK",J[J.FIN=4]="FIN",J[J.RST=8]="RST"})(Flag||(Flag={}));const flagCodes=Object.values(Flag).filter(J=>typeof J!="string"),YAMUX_VERSION=0;var GoAwayCode;(function(J){J[J.NormalTermination=0]="NormalTermination",J[J.ProtocolError=1]="ProtocolError",J[J.InternalError=2]="InternalError"})(GoAwayCode||(GoAwayCode={}));const HEADER_LENGTH=12;function stringifyHeader(J){const E=flagCodes.filter(ee=>(J.flag&ee)===ee).map(ee=>Flag[ee]).join("|");return`streamID=${J.streamID} type=${FrameType[J.type]} flag=${E} length=${J.length}`}const ERR_INVALID_FRAME="ERR_INVALID_FRAME",ERR_UNREQUESTED_PING="ERR_UNREQUESTED_PING",ERR_NOT_MATCHING_PING="ERR_NOT_MATCHING_PING",ERR_STREAM_ALREADY_EXISTS="ERR_STREAM_ALREADY_EXISTS",ERR_DECODE_INVALID_VERSION="ERR_DECODE_INVALID_VERSION",ERR_BOTH_CLIENTS="ERR_BOTH_CLIENTS",ERR_RECV_WINDOW_EXCEEDED="ERR_RECV_WINDOW_EXCEEDED",PROTOCOL_ERRORS=new Set([ERR_INVALID_FRAME,ERR_UNREQUESTED_PING,ERR_NOT_MATCHING_PING,ERR_STREAM_ALREADY_EXISTS,ERR_DECODE_INVALID_VERSION,ERR_BOTH_CLIENTS,ERR_RECV_WINDOW_EXCEEDED]),ERR_INVALID_CONFIG="ERR_INVALID_CONFIG",ERR_MUXER_LOCAL_CLOSED="ERR_MUXER_LOCAL_CLOSED",ERR_MUXER_REMOTE_CLOSED="ERR_MUXER_REMOTE_CLOSED",ERR_STREAM_RESET$1="ERR_STREAM_RESET",ERR_STREAM_ABORT$1="ERR_STREAM_ABORT",ERR_MAX_OUTBOUND_STREAMS_EXCEEDED="ERROR_MAX_OUTBOUND_STREAMS_EXCEEDED",ERR_DECODE_IN_PROGRESS="ERR_DECODE_IN_PROGRESS",INITIAL_STREAM_WINDOW=256*1024,MAX_STREAM_WINDOW=16*1024*1024;var StreamState$1;(function(J){J[J.Init=0]="Init",J[J.SYNSent=1]="SYNSent",J[J.SYNReceived=2]="SYNReceived",J[J.Established=3]="Established",J[J.Finished=4]="Finished"})(StreamState$1||(StreamState$1={}));var HalfStreamState;(function(J){J[J.Open=0]="Open",J[J.Closed=1]="Closed",J[J.Reset=2]="Reset"})(HalfStreamState||(HalfStreamState={}));class YamuxStream{constructor(E){this.config=E.config,this.log=E.log,this._id=E.id,this.id=String(E.id),this.name=E.name,this.stat={direction:E.direction,timeline:{open:Date.now()}},this.metadata={},this.state=E.state,this.readState=HalfStreamState.Open,this.writeState=HalfStreamState.Open,this.sendWindowCapacity=INITIAL_STREAM_WINDOW,this.recvWindow=this.config.initialStreamWindowSize,this.recvWindowCapacity=this.recvWindow,this.epochStart=Date.now(),this.getRTT=E.getRTT,this.abortController=new AbortController,this.sendFrame=E.sendFrame,this.onStreamEnd=E.onStreamEnd,this.sourceInput=pushable({onEnd:ee=>{ee!=null?this.log?.error("stream source ended id=%s",this._id,ee):this.log?.trace("stream source ended id=%s",this._id),this.closeRead()}}),this.source=this.createSource(),this.sink=async ee=>{if(this.writeState!==HalfStreamState.Open)throw new Error("stream closed for writing");ee=abortableSource(ee,this.abortController.signal,{returnOnAbort:!0});try{for await(let te of ee)for(;te.length!==0;){this.sendWindowCapacity===0&&await this.waitForSendWindowCapacity();const re=Math.min(this.sendWindowCapacity,this.config.maxMessageSize-HEADER_LENGTH,te.length);this.sendData(te.subarray(0,re)),this.sendWindowCapacity-=re,te=te.subarray(re)}}catch(te){this.log?.error("stream sink error id=%s",this._id,te)}finally{this.log?.trace("stream sink ended id=%s",this._id),this.closeWrite()}}}async*createSource(){try{for await(const E of this.sourceInput)this.sendWindowUpdate(),yield E}catch(E){if(E.code!==ERR_STREAM_ABORT$1)throw this.log?.error("stream source error id=%s",this._id,E),E}}close(){this.log?.trace("stream close id=%s",this._id),this.closeRead(),this.closeWrite()}closeRead(){this.state!==StreamState$1.Finished&&this.readState===HalfStreamState.Open&&(this.log?.trace("stream close read id=%s",this._id),this.readState=HalfStreamState.Closed,this.sourceInput.end(),this.writeState!==HalfStreamState.Open&&this.finish())}closeWrite(){this.state!==StreamState$1.Finished&&this.writeState===HalfStreamState.Open&&(this.log?.trace("stream close write id=%s",this._id),this.writeState=HalfStreamState.Closed,this.sendClose(),this.abortController.abort(),this.readState!==HalfStreamState.Open&&this.finish())}abort(E){switch(this.state){case StreamState$1.Finished:return;case StreamState$1.Init:break;case StreamState$1.SYNSent:case StreamState$1.SYNReceived:case StreamState$1.Established:this.sendReset();break;default:throw new Error("unreachable")}E!=null?this.log?.error("stream abort id=%s error=%s",this._id,E):this.log?.trace("stream abort id=%s",this._id),this.onReset(new CodeError(String(E)??"stream aborted",ERR_STREAM_ABORT$1))}reset(){this.state!==StreamState$1.Finished&&(this.log?.trace("stream reset id=%s",this._id),this.onReset(new CodeError("stream reset",ERR_STREAM_RESET$1)))}onReset(E){this.writeState===HalfStreamState.Open&&(this.writeState=HalfStreamState.Reset),this.readState===HalfStreamState.Open&&(this.readState=HalfStreamState.Reset),this.state=StreamState$1.Finished,this.sourceInput.end(E),this.abortController.abort(),this.finish()}async waitForSendWindowCapacity(){if(this.abortController.signal.aborted)throw new CodeError("stream aborted",ERR_STREAM_ABORT$1);if(this.sendWindowCapacity>0)return;let E;const ee=()=>{E(new CodeError("stream aborted",ERR_STREAM_ABORT$1))};this.abortController.signal.addEventListener("abort",ee),await new Promise((te,re)=>{this.sendWindowCapacityUpdate=()=>{this.abortController.signal.removeEventListener("abort",ee),te(void 0)},E=re})}handleWindowUpdate(E){this.log?.trace("stream received window update id=%s",this._id),this.processFlags(E.flag);const ee=this.sendWindowCapacity;this.sendWindowCapacity+=E.length,ee===0&&E.length>0&&this.sendWindowCapacityUpdate?.()}async handleData(E,ee){if(this.log?.trace("stream received data id=%s",this._id),this.processFlags(E.flag),this.recvWindowCapacity<E.length)throw new CodeError("receive window exceeded",ERR_RECV_WINDOW_EXCEEDED,{available:this.recvWindowCapacity,recv:E.length});const te=await ee();this.recvWindowCapacity-=E.length,this.sourceInput.push(te)}processFlags(E){(E&Flag.ACK)===Flag.ACK&&this.state===StreamState$1.SYNSent&&(this.state=StreamState$1.Established),(E&Flag.FIN)===Flag.FIN&&this.closeRead(),(E&Flag.RST)===Flag.RST&&this.reset()}finish(){this.log?.trace("stream finished id=%s",this._id),this.state=StreamState$1.Finished,this.stat.timeline.close=Date.now(),this.onStreamEnd()}getSendFlags(){switch(this.state){case StreamState$1.Init:return this.state=StreamState$1.SYNSent,Flag.SYN;case StreamState$1.SYNReceived:return this.state=StreamState$1.Established,Flag.ACK;default:return 0}}sendWindowUpdate(){const E=this.getSendFlags(),ee=Date.now(),te=this.getRTT();if(E===0&&te>0&&ee-this.epochStart<te*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.config.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&E===0)return;const re=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=ee,this.sendFrame({type:FrameType.WindowUpdate,flag:E,streamID:this._id,length:re})}sendData(E){const ee=this.getSendFlags();this.sendFrame({type:FrameType.Data,flag:ee,streamID:this._id,length:E.length},E)}sendClose(){const E=this.getSendFlags()|Flag.FIN;this.sendFrame({type:FrameType.WindowUpdate,flag:E,streamID:this._id,length:0})}sendReset(){this.sendFrame({type:FrameType.WindowUpdate,flag:Flag.RST,streamID:this._id,length:0})}}function encodeHeader(J){const E=new Uint8Array(HEADER_LENGTH);return E[1]=J.type,E[2]=J.flag>>>8,E[3]=J.flag,E[4]=J.streamID>>>24,E[5]=J.streamID>>>16,E[6]=J.streamID>>>8,E[7]=J.streamID,E[8]=J.length>>>24,E[9]=J.length>>>16,E[10]=J.length>>>8,E[11]=J.length,E}const defaultConfig={log:logger("libp2p:yamux"),enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3,initialStreamWindowSize:INITIAL_STREAM_WINDOW,maxStreamWindowSize:MAX_STREAM_WINDOW,maxMessageSize:64*1024};function verifyConfig(J){if(J.keepAliveInterval<=0)throw new CodeError("keep-alive interval must be positive",ERR_INVALID_CONFIG);if(J.maxInboundStreams<0)throw new CodeError("max inbound streams must be larger or equal 0",ERR_INVALID_CONFIG);if(J.maxOutboundStreams<0)throw new CodeError("max outbound streams must be larger or equal 0",ERR_INVALID_CONFIG);if(J.initialStreamWindowSize<INITIAL_STREAM_WINDOW)throw new CodeError("InitialStreamWindowSize must be larger or equal 256 kB",ERR_INVALID_CONFIG);if(J.maxStreamWindowSize<J.initialStreamWindowSize)throw new CodeError("MaxStreamWindowSize must be larger than the InitialStreamWindowSize",ERR_INVALID_CONFIG);if(J.maxStreamWindowSize>2**32-1)throw new CodeError("MaxStreamWindowSize must be less than equal MAX_UINT32",ERR_INVALID_CONFIG);if(J.maxMessageSize<1024)throw new CodeError("MaxMessageSize must be greater than a kilobyte",ERR_INVALID_CONFIG)}const twoPow24=2**24;function decodeHeader(J){if(J[0]!==YAMUX_VERSION)throw new CodeError("Invalid frame version",ERR_DECODE_INVALID_VERSION);return{type:J[1],flag:(J[2]<<8)+J[3],streamID:J[4]*twoPow24+(J[5]<<16)+(J[6]<<8)+J[7],length:J[8]*twoPow24+(J[9]<<16)+(J[10]<<8)+J[11]}}let Decoder$2=class{constructor(J){this.source=returnlessSource(J),this.buffer=new Uint8ArrayList,this.frameInProgress=!1}async*emitFrames(){for await(const J of this.source)for(this.buffer.append(J);;){const E=this.readHeader();if(E===void 0)break;const{type:ee,length:te}=E;ee===FrameType.Data?(this.frameInProgress=!0,yield{header:E,readData:this.readBytes.bind(this,te)}):yield{header:E}}}readHeader(){if(this.frameInProgress)throw new CodeError("decoding frame already in progress",ERR_DECODE_IN_PROGRESS);if(this.buffer.length<HEADER_LENGTH)return;const J=decodeHeader(this.buffer.slice(0,HEADER_LENGTH));return this.buffer.consume(HEADER_LENGTH),J}async readBytes(J){if(this.buffer.length<J){for await(const ee of this.source)if(this.buffer.append(ee),this.buffer.length>=J)break}const E=this.buffer.sublist(0,J);return this.buffer.consume(J),this.frameInProgress=!1,E}};function returnlessSource(J){if(J[Symbol.iterator]!==void 0){const E=J[Symbol.iterator]();return E.return=void 0,{[Symbol.iterator](){return E}}}else if(J[Symbol.asyncIterator]!==void 0){const E=J[Symbol.asyncIterator]();return E.return=void 0,{[Symbol.asyncIterator](){return E}}}else throw new Error("a source must be either an iterable or an async iterable")}const YAMUX_PROTOCOL_ID="/yamux/1.0.0";class Yamux{constructor(E={}){this.protocol=YAMUX_PROTOCOL_ID,this._init=E}createStreamMuxer(E){return new YamuxMuxer({...this._init,...E})}}class YamuxMuxer{constructor(E){this.protocol=YAMUX_PROTOCOL_ID,this._init=E,this.client=E.direction==="outbound",this.config={...defaultConfig,...E},this.log=this.config.log,verifyConfig(this.config),this.closeController=new AbortController,this.onIncomingStream=E.onIncomingStream,this.onStreamEnd=E.onStreamEnd,this._streams=new Map,this.source=pushable({onEnd:ee=>{this.log?.trace("muxer source ended"),this.close(ee)}}),this.sink=async ee=>{let te;this._init.signal!=null&&(te=anySignal([this.closeController.signal,this._init.signal])),ee=abortableSource(ee,te??this.closeController.signal,{returnOnAbort:!0});let re,ne;try{const ie=new Decoder$2(ee);await pipe(ie.emitFrames.bind(ie),async se=>{for await(const{header:oe,readData:ae}of se)await this.handleFrame(oe,ae)}),re=GoAwayCode.NormalTermination}catch(ie){const se=ie.code;PROTOCOL_ERRORS.has(se)?(this.log?.error("protocol error in sink",ie),re=GoAwayCode.ProtocolError):(this.log?.error("internal error in sink",ie),re=GoAwayCode.InternalError),ne=ie}finally{te?.clear()}this.log?.trace("muxer sink ended"),this.close(ne,re)},this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=0,this.log?.trace("muxer created"),this.config.enableKeepAlive&&this.keepAliveLoop().catch(ee=>this.log?.error("keepalive error: %s",ee))}get streams(){return Array.from(this._streams.values())}newStream(E){if(this.remoteGoAway!==void 0)throw new CodeError("muxer closed remotely",ERR_MUXER_REMOTE_CLOSED);if(this.localGoAway!==void 0)throw new CodeError("muxer closed locally",ERR_MUXER_LOCAL_CLOSED);const ee=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.config.maxOutboundStreams)throw new CodeError("max outbound streams exceeded",ERR_MAX_OUTBOUND_STREAMS_EXCEEDED);this.log?.trace("new outgoing stream id=%s",ee);const te=this._newStream(ee,E,StreamState$1.Init,"outbound");return this._streams.set(ee,te),this.numOutboundStreams++,te.sendWindowUpdate(),te}async ping(){if(this.remoteGoAway!==void 0)throw new CodeError("muxer closed remotely",ERR_MUXER_REMOTE_CLOSED);if(this.localGoAway!==void 0)throw new CodeError("muxer closed locally",ERR_MUXER_LOCAL_CLOSED);if(this.activePing===void 0){let E=()=>{};this.activePing={id:this.nextPingID++,promise:new Promise((re,ne)=>{const ie=()=>{ne(new CodeError("muxer closed locally",ERR_MUXER_LOCAL_CLOSED))};this.closeController.signal.addEventListener("abort",ie,{once:!0}),E=()=>{this.closeController.signal.removeEventListener("abort",ie),re()}}),resolve:E};const ee=Date.now();this.sendPing(this.activePing.id);try{await this.activePing.promise}finally{delete this.activePing}const te=Date.now();this.rtt=te-ee}else await this.activePing.promise;return this.rtt}getRTT(){return this.rtt}close(E,ee){if(!this.closeController.signal.aborted){if(ee=ee??(E===void 0?GoAwayCode.InternalError:GoAwayCode.NormalTermination),E!=null?this.log?.error("muxer close reason=%s error=%s",GoAwayCode[ee],E):this.log?.trace("muxer close reason=%s",GoAwayCode[ee]),E===void 0)for(const te of this._streams.values())te.close();else for(const te of this._streams.values())te.abort(E);this.sendGoAway(ee),this._closeMuxer()}}isClosed(){return this.closeController.signal.aborted}_closeMuxer(){this.closeController.abort(),this.source.end()}_newStream(E,ee,te,re){if(this._streams.get(E)!=null)throw new CodeError("Stream already exists",ERR_STREAM_ALREADY_EXISTS,{id:E});const ne=new YamuxStream({id:E,name:ee,state:te,direction:re,sendFrame:this.sendFrame.bind(this),onStreamEnd:()=>{this.closeStream(E),this.onStreamEnd?.(ne)},log:this.log,config:this.config,getRTT:this.getRTT.bind(this)});return ne}closeStream(E){this.client===(E%2===0)?this.numInboundStreams--:this.numOutboundStreams--,this._streams.delete(E)}async keepAliveLoop(){const E=new Promise((ee,te)=>{this.closeController.signal.addEventListener("abort",te,{once:!0})});for(this.log?.trace("muxer keepalive enabled interval=%s",this.config.keepAliveInterval);;){let ee;try{await Promise.race([E,new Promise(te=>{ee=setTimeout(te,this.config.keepAliveInterval)})]),this.ping().catch(te=>this.log?.error("ping error: %s",te))}catch{clearInterval(ee);return}}}async handleFrame(E,ee){const{streamID:te,type:re,length:ne}=E;if(this.log?.trace("received frame %s",stringifyHeader(E)),te===0)switch(re){case FrameType.Ping:{this.handlePing(E);return}case FrameType.GoAway:{this.handleGoAway(ne);return}default:throw new CodeError("Invalid frame type",ERR_INVALID_FRAME,{header:E})}else switch(E.type){case FrameType.Data:case FrameType.WindowUpdate:{await this.handleStreamMessage(E,ee);return}default:throw new CodeError("Invalid frame type",ERR_INVALID_FRAME,{header:E})}}handlePing(E){if(E.flag===Flag.SYN)this.log?.trace("received ping request pingId=%s",E.length),this.sendPing(E.length,Flag.ACK);else if(E.flag===Flag.ACK)this.log?.trace("received ping response pingId=%s",E.length),this.handlePingResponse(E.length);else throw new CodeError("Invalid frame flag",ERR_INVALID_FRAME,{header:E})}handlePingResponse(E){if(this.activePing===void 0)throw new CodeError("ping not requested",ERR_UNREQUESTED_PING);if(this.activePing.id!==E)throw new CodeError("ping doesn't match our id",ERR_NOT_MATCHING_PING);this.activePing.resolve()}handleGoAway(E){this.log?.trace("received GoAway reason=%s",GoAwayCode[E]??"unknown"),this.remoteGoAway=E;for(const ee of this._streams.values())ee.reset();this._closeMuxer()}async handleStreamMessage(E,ee){const{streamID:te,flag:re,type:ne}=E;(re&Flag.SYN)===Flag.SYN&&this.incomingStream(te);const ie=this._streams.get(te);if(ie===void 0){if(ne===FrameType.Data){if(this.log?.("discarding data for stream id=%s",te),ee===void 0)throw new Error("unreachable");await ee()}else this.log?.("frame for missing stream id=%s",te);return}switch(ne){case FrameType.WindowUpdate:{ie.handleWindowUpdate(E);return}case FrameType.Data:{if(ee===void 0)throw new Error("unreachable");await ie.handleData(E,ee);return}default:throw new Error("unreachable")}}incomingStream(E){if(this.client!==(E%2===0))throw new CodeError("both endpoints are clients",ERR_BOTH_CLIENTS);if(this._streams.has(E))return;if(this.log?.trace("new incoming stream id=%s",E),this.localGoAway!==void 0){this.sendFrame({type:FrameType.WindowUpdate,flag:Flag.RST,streamID:E,length:0});return}if(this.numInboundStreams>=this.config.maxInboundStreams){this.log?.("maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:FrameType.WindowUpdate,flag:Flag.RST,streamID:E,length:0});return}const ee=this._newStream(E,void 0,StreamState$1.SYNReceived,"inbound");this.numInboundStreams++,this._streams.set(E,ee),this.onIncomingStream?.(ee)}sendFrame(E,ee){if(this.log?.trace("sending frame %s",stringifyHeader(E)),E.type===FrameType.Data){if(ee===void 0)throw new CodeError("invalid frame",ERR_INVALID_FRAME);this.source.push(encodeHeader(E)),this.source.push(ee)}else this.source.push(encodeHeader(E))}sendPing(E,ee=Flag.SYN){ee===Flag.SYN?this.log?.trace("sending ping request pingId=%s",E):this.log?.trace("sending ping response pingId=%s",E),this.sendFrame({type:FrameType.Ping,flag:ee,streamID:0,length:E})}sendGoAway(E=GoAwayCode.NormalTermination){this.log?.("sending GoAway reason=%s",GoAwayCode[E]),this.localGoAway=E,this.sendFrame({type:FrameType.GoAway,flag:0,streamID:0,length:E})}}function yamux(J={}){return()=>new Yamux(J)}var codes$2;(function(J){J.ERR_ALREADY_ABORTED="ERR_ALREADY_ABORTED",J.ERR_DATA_CHANNEL="ERR_DATA_CHANNEL",J.ERR_CONNECTION_CLOSED="ERR_CONNECTION_CLOSED",J.ERR_HASH_NOT_SUPPORTED="ERR_HASH_NOT_SUPPORTED",J.ERR_INVALID_MULTIADDR="ERR_INVALID_MULTIADDR",J.ERR_INVALID_FINGERPRINT="ERR_INVALID_FINGERPRINT",J.ERR_INVALID_PARAMETERS="ERR_INVALID_PARAMETERS",J.ERR_NOT_IMPLEMENTED="ERR_NOT_IMPLEMENTED",J.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS="ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS",J.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS="ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS"})(codes$2||(codes$2={}));class WebRTCTransportError extends CodeError{constructor(E,ee){super(`WebRTC transport error: ${E}`,ee??""),this.name="WebRTCTransportError"}}class DataChannelError extends WebRTCTransportError{constructor(E,ee){super(`[stream: ${E}] data channel error: ${ee}`,codes$2.ERR_DATA_CHANNEL),this.name="WebRTC/DataChannelError"}}function dataChannelError(J,E){return new DataChannelError(J,E)}class InappropriateMultiaddrError extends WebRTCTransportError{constructor(E){super(`There was a problem with the Multiaddr which was passed in: ${E}`,codes$2.ERR_INVALID_MULTIADDR),this.name="WebRTC/InappropriateMultiaddrError"}}function inappropriateMultiaddr(J){return new InappropriateMultiaddrError(J)}class InvalidArgumentError extends WebRTCTransportError{constructor(E){super(`There was a problem with a provided argument: ${E}`,codes$2.ERR_INVALID_PARAMETERS),this.name="WebRTC/InvalidArgumentError"}}function invalidArgument(J){return new InvalidArgumentError(J)}class InvalidFingerprintError extends WebRTCTransportError{constructor(E,ee){super(`Invalid fingerprint "${E}" within ${ee}`,codes$2.ERR_INVALID_FINGERPRINT),this.name="WebRTC/InvalidFingerprintError"}}function invalidFingerprint(J,E){return new InvalidFingerprintError(J,E)}class UnimplementedError extends WebRTCTransportError{constructor(E){super(`A method (${E}) was called though it has been intentionally left unimplemented.`,codes$2.ERR_NOT_IMPLEMENTED),this.name="WebRTC/UnimplementedError"}}function unimplemented(J){return new UnimplementedError(J)}class UnsupportedHashAlgorithmError extends WebRTCTransportError{constructor(E){super(`unsupported hash algorithm: ${E}`,codes$2.ERR_HASH_NOT_SUPPORTED),this.name="WebRTC/UnsupportedHashAlgorithmError"}}function unsupportedHashAlgorithm(J){return new UnsupportedHashAlgorithmError(J)}var __spreadArray=globalThis&&globalThis.__spreadArray||function(J,E,ee){if(ee||arguments.length===2)for(var te=0,re=E.length,ne;te<re;te++)(ne||!(te in E))&&(ne||(ne=Array.prototype.slice.call(E,0,te)),ne[te]=E[te]);return J.concat(ne||Array.prototype.slice.call(E))},BrowserInfo=function(){function J(E,ee,te){this.name=E,this.version=ee,this.os=te,this.type="browser"}return J}(),NodeInfo=function(){function J(E){this.version=E,this.type="node",this.name="node",this.os=process.platform}return J}(),SearchBotDeviceInfo=function(){function J(E,ee,te,re){this.name=E,this.version=ee,this.os=te,this.bot=re,this.type="bot-device"}return J}(),BotInfo=function(){function J(){this.type="bot",this.bot=!0,this.name="bot",this.version=null,this.os=null}return J}(),ReactNativeInfo=function(){function J(){this.type="react-native",this.name="react-native",this.version=null,this.os=null}return J}(),SEARCHBOX_UA_REGEX=/alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,SEARCHBOT_OS_REGEX=/(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,REQUIRED_VERSION_PARTS=3,userAgentRules=[["aol",/AOLShield\/([0-9\._]+)/],["edge",/Edge\/([0-9\._]+)/],["edge-ios",/EdgiOS\/([0-9\._]+)/],["yandexbrowser",/YaBrowser\/([0-9\._]+)/],["kakaotalk",/KAKAOTALK\s([0-9\.]+)/],["samsung",/SamsungBrowser\/([0-9\.]+)/],["silk",/\bSilk\/([0-9._-]+)\b/],["miui",/MiuiBrowser\/([0-9\.]+)$/],["beaker",/BeakerBrowser\/([0-9\.]+)/],["edge-chromium",/EdgA?\/([0-9\.]+)/],["chromium-webview",/(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["chrome",/(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["phantomjs",/PhantomJS\/([0-9\.]+)(:?\s|$)/],["crios",/CriOS\/([0-9\.]+)(:?\s|$)/],["firefox",/Firefox\/([0-9\.]+)(?:\s|$)/],["fxios",/FxiOS\/([0-9\.]+)/],["opera-mini",/Opera Mini.*Version\/([0-9\.]+)/],["opera",/Opera\/([0-9\.]+)(?:\s|$)/],["opera",/OPR\/([0-9\.]+)(:?\s|$)/],["pie",/^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],["pie",/^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],["netfront",/^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],["ie",/Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],["ie",/MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],["ie",/MSIE\s(7\.0)/],["bb10",/BB10;\sTouch.*Version\/([0-9\.]+)/],["android",/Android\s([0-9\.]+)/],["ios",/Version\/([0-9\._]+).*Mobile.*Safari.*/],["safari",/Version\/([0-9\._]+).*Safari/],["facebook",/FB[AS]V\/([0-9\.]+)/],["instagram",/Instagram\s([0-9\.]+)/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Mobile/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Gecko\)$/],["curl",/^curl\/([0-9\.]+)$/],["searchbot",SEARCHBOX_UA_REGEX]],operatingSystemRules=[["iOS",/iP(hone|od|ad)/],["Android OS",/Android/],["BlackBerry OS",/BlackBerry|BB10/],["Windows Mobile",/IEMobile/],["Amazon OS",/Kindle/],["Windows 3.11",/Win16/],["Windows 95",/(Windows 95)|(Win95)|(Windows_95)/],["Windows 98",/(Windows 98)|(Win98)/],["Windows 2000",/(Windows NT 5.0)|(Windows 2000)/],["Windows XP",/(Windows NT 5.1)|(Windows XP)/],["Windows Server 2003",/(Windows NT 5.2)/],["Windows Vista",/(Windows NT 6.0)/],["Windows 7",/(Windows NT 6.1)/],["Windows 8",/(Windows NT 6.2)/],["Windows 8.1",/(Windows NT 6.3)/],["Windows 10",/(Windows NT 10.0)/],["Windows ME",/Windows ME/],["Windows CE",/Windows CE|WinCE|Microsoft Pocket Internet Explorer/],["Open BSD",/OpenBSD/],["Sun OS",/SunOS/],["Chrome OS",/CrOS/],["Linux",/(Linux)|(X11)/],["Mac OS",/(Mac_PowerPC)|(Macintosh)/],["QNX",/QNX/],["BeOS",/BeOS/],["OS/2",/OS\/2/]];function detect(J){return J?parseUserAgent(J):typeof document>"u"&&typeof navigator<"u"&&navigator.product==="ReactNative"?new ReactNativeInfo:typeof navigator<"u"?parseUserAgent(navigator.userAgent):getNodeVersion()}function matchUserAgent(J){return J!==""&&userAgentRules.reduce(function(E,ee){var te=ee[0],re=ee[1];if(E)return E;var ne=re.exec(J);return!!ne&&[te,ne]},!1)}function parseUserAgent(J){var E=matchUserAgent(J);if(!E)return null;var ee=E[0],te=E[1];if(ee==="searchbot")return new BotInfo;var re=te[1]&&te[1].split(".").join("_").split("_").slice(0,3);re?re.length<REQUIRED_VERSION_PARTS&&(re=__spreadArray(__spreadArray([],re,!0),createVersionParts(REQUIRED_VERSION_PARTS-re.length),!0)):re=[];var ne=re.join("."),ie=detectOS(J),se=SEARCHBOT_OS_REGEX.exec(J);return se&&se[1]?new SearchBotDeviceInfo(ee,ne,ie,se[1]):new BrowserInfo(ee,ne,ie)}function detectOS(J){for(var E=0,ee=operatingSystemRules.length;E<ee;E++){var te=operatingSystemRules[E],re=te[0],ne=te[1],ie=ne.exec(J);if(ie)return re}return null}function getNodeVersion(){var J=typeof process<"u"&&process.version;return J?new NodeInfo(process.version.slice(1)):null}function createVersionParts(J){for(var E=[],ee=0;ee<J;ee++)E.push("0");return E}const browser$5=detect(),isFirefox=browser$5!=null&&browser$5.name==="firefox",nopSource=async function*J(){},nopSink=async J=>{},log$h=logger("libp2p:webrtc:connection");class WebRTCMultiaddrConnection{peerConnection;remoteAddr;timeline;metrics;source=nopSource();sink=nopSink;constructor(E){this.remoteAddr=E.remoteAddr,this.timeline=E.timeline,this.peerConnection=E.peerConnection,this.peerConnection.onconnectionstatechange=()=>{(this.peerConnection.connectionState==="closed"||this.peerConnection.connectionState==="disconnected"||this.peerConnection.connectionState==="failed")&&(this.timeline.close=Date.now())}}async close(E){E!==void 0&&log$h.error("error closing connection",E),log$h.trace("closing connection"),this.timeline.close=Date.now(),this.peerConnection.close(),this.metrics?.increment({close:!0})}}const defaultLengthDecoder=J=>unsigned.decode(J);defaultLengthDecoder.bytes=0;function pbStream(J,E){const ee=pushable();J.sink(ee).catch(ie=>{ee.end(ie)}),J.sink=async ie=>{for await(const se of ie)ee.push(se);ee.end()};let te=J.source;J.source[Symbol.iterator]!=null?te=J.source[Symbol.iterator]():J.source[Symbol.asyncIterator]!=null&&(te=J.source[Symbol.asyncIterator]());const re=new Uint8ArrayList,ne={read:async ie=>{if(ie==null){const{done:oe,value:ae}=await te.next();return oe===!0?new Uint8ArrayList:ae}for(;re.byteLength<ie;){const{value:oe,done:ae}=await te.next();if(ae===!0)throw errCode$1(new Error("unexpected end of input"),"ERR_UNEXPECTED_EOF");re.append(oe)}const se=re.sublist(0,ie);return re.consume(ie),se},readLP:async()=>{let ie=-1;const se=new Uint8ArrayList,oe=E?.lengthDecoder??defaultLengthDecoder;for(;;){se.append(await ne.read(1));try{ie=oe(se)}catch(ae){if(ae instanceof RangeError)continue;throw ae}if(ie>-1)break;if(E?.maxLengthLength!=null&&se.byteLength>E.maxLengthLength)throw errCode$1(new Error("message length length too long"),"ERR_MSG_LENGTH_TOO_LONG")}if(E?.maxDataLength!=null&&ie>E.maxDataLength)throw errCode$1(new Error("message length too long"),"ERR_MSG_DATA_TOO_LONG");return await ne.read(ie)},readPB:async ie=>{const se=await ne.readLP();if(se==null)throw new Error("Value is null");const oe=se instanceof Uint8Array?se:se.subarray();return ie.decode(oe)},write:ie=>{ie instanceof Uint8Array?ee.push(ie):ee.push(ie.subarray())},writeLP:ie=>{ne.write(encode$8.single(ie,E))},writePB:(ie,se)=>{ne.writeLP(se.encode(ie))},pb:ie=>({read:async()=>await ne.readPB(ie),write:se=>{ne.writePB(se,ie)},unwrap:()=>ne}),unwrap:()=>{const ie=J.source;return J.source=async function*(){yield*re,yield*ie}(),J}};return ne}var Message$1;(function(J){(function(te){te.FIN="FIN",te.STOP_SENDING="STOP_SENDING",te.RESET="RESET"})(J.Flag||(J.Flag={}));let E;(function(te){te[te.FIN=0]="FIN",te[te.STOP_SENDING=1]="STOP_SENDING",te[te.RESET=2]="RESET"})(E||(E={})),function(te){te.codec=()=>enumeration(E)}(J.Flag||(J.Flag={}));let ee;J.codec=()=>(ee==null&&(ee=message((te,re,ne={})=>{ne.lengthDelimited!==!1&&re.fork(),te.flag!=null&&(re.uint32(8),J.Flag.codec().encode(te.flag,re)),te.message!=null&&(re.uint32(18),re.bytes(te.message)),ne.lengthDelimited!==!1&&re.ldelim()},(te,re)=>{const ne={},ie=re==null?te.len:te.pos+re;for(;te.pos<ie;){const se=te.uint32();switch(se>>>3){case 1:ne.flag=J.Flag.codec().decode(te);break;case 2:ne.message=te.bytes();break;default:te.skipType(se&7);break}}return ne})),ee),J.encode=te=>encodeMessage(te,J.codec()),J.decode=te=>decodeMessage(te,J.codec())})(Message$1||(Message$1={}));const log$g=logger("libp2p:webrtc:stream");var StreamStates;(function(J){J[J.OPEN=0]="OPEN",J[J.READ_CLOSED=1]="READ_CLOSED",J[J.WRITE_CLOSED=2]="WRITE_CLOSED",J[J.CLOSED=3]="CLOSED"})(StreamStates||(StreamStates={}));function unreachableBranch(J){throw new Error("Case not handled in switch")}class StreamState{state=StreamStates.OPEN;isWriteClosed(){return this.state===StreamStates.CLOSED||this.state===StreamStates.WRITE_CLOSED}transition({direction:E,flag:ee}){const te=this.state;if(this.state===StreamStates.CLOSED)return[te,StreamStates.CLOSED];if(E==="inbound")switch(ee){case Message$1.Flag.FIN:this.state===StreamStates.OPEN?this.state=StreamStates.READ_CLOSED:this.state===StreamStates.WRITE_CLOSED&&(this.state=StreamStates.CLOSED);break;case Message$1.Flag.STOP_SENDING:this.state===StreamStates.OPEN?this.state=StreamStates.WRITE_CLOSED:this.state===StreamStates.READ_CLOSED&&(this.state=StreamStates.CLOSED);break;case Message$1.Flag.RESET:this.state=StreamStates.CLOSED;break;default:unreachableBranch()}else switch(ee){case Message$1.Flag.FIN:this.state===StreamStates.OPEN?this.state=StreamStates.WRITE_CLOSED:this.state===StreamStates.READ_CLOSED&&(this.state=StreamStates.CLOSED);break;case Message$1.Flag.STOP_SENDING:this.state===StreamStates.OPEN?this.state=StreamStates.READ_CLOSED:this.state===StreamStates.WRITE_CLOSED&&(this.state=StreamStates.CLOSED);break;case Message$1.Flag.RESET:this.state=StreamStates.CLOSED;break;default:unreachableBranch()}return[te,this.state]}}class WebRTCStream{id;stat;metadata;channel;streamState=new StreamState;_src;_innersrc=pushable();opened=pDefer();_sinkCalled=!1;closeWritePromise=pDefer();closeCb;constructor(E){switch(this.channel=E.channel,this.channel.binaryType="arraybuffer",this.id=this.channel.label,this.stat=E.stat,this.channel.readyState){case"open":this.opened.resolve();break;case"closed":case"closing":this.streamState.state=StreamStates.CLOSED,(this.stat.timeline.close===void 0||this.stat.timeline.close===0)&&(this.stat.timeline.close=new Date().getTime()),this.opened.resolve();break;case"connecting":break;default:unreachableBranch(this.channel.readyState)}this.metadata=E.metadata??{},this.channel.onopen=te=>{this.stat.timeline.open=new Date().getTime(),this.opened.resolve()},this.channel.onclose=te=>{this.close()},this.channel.onerror=te=>{const re=te.error;this.abort(re)};const ee=this;this.channel.onmessage=async({data:te})=>{te===null||te.length===0||this._innersrc.push(new Uint8Array(te))},this._src=pipe(this._innersrc,te=>decode$6(te),te=>async function*(){for await(const re of te){const ne=ee.processIncomingProtobuf(re.subarray());ne!=null&&(yield new Uint8ArrayList(ne))}}())}set source(E){}get source(){return this._src}async sink(E){if(this._sinkCalled)throw new Error("sink already called on this stream");await this.opened.promise;try{await this._sink(E)}finally{this.closeWrite()}}async _sink(E){const ee=this._closeWriteIterable();for await(const te of merge$1(ee,E)){if(this.streamState.isWriteClosed())return;const re=Message$1.encode({message:te.subarray()}),ne=encode$8.single(re);this.channel.send(ne.subarray())}}processIncomingProtobuf(E){const ee=Message$1.decode(E);if(ee.flag!==void 0){const[te,re]=this.streamState.transition({direction:"inbound",flag:ee.flag});if(te!==re)switch(re){case StreamStates.READ_CLOSED:this._innersrc.end();break;case StreamStates.WRITE_CLOSED:this.closeWritePromise.resolve();break;case StreamStates.CLOSED:this.close();break;case StreamStates.OPEN:break;default:unreachableBranch()}}return ee.message}close(){this.stat.timeline.close=new Date().getTime(),this.streamState.state=StreamStates.CLOSED,this._innersrc.end(),this.closeWritePromise.resolve(),this.channel.close(),this.closeCb!==void 0&&this.closeCb(this)}closeRead(){const[E,ee]=this.streamState.transition({direction:"outbound",flag:Message$1.Flag.STOP_SENDING});E!==ee&&((E===StreamStates.OPEN||E===StreamStates.WRITE_CLOSED)&&(this._sendFlag(Message$1.Flag.STOP_SENDING),this._innersrc.end()),ee===StreamStates.CLOSED&&this.close())}closeWrite(){const[E,ee]=this.streamState.transition({direction:"outbound",flag:Message$1.Flag.FIN});E!==ee&&((E===StreamStates.OPEN||E===StreamStates.READ_CLOSED)&&(this._sendFlag(Message$1.Flag.FIN),this.closeWritePromise.resolve()),ee===StreamStates.CLOSED&&this.close())}abort(E){log$g.error(`An error occurred, closing the stream for reading and writing: ${E.message}`),this.close()}reset(){const[E,ee]=this.streamState.transition({direction:"outbound",flag:Message$1.Flag.RESET});E!==ee&&(this._sendFlag(Message$1.Flag.RESET),this.close())}_sendFlag(E){try{log$g.trace("Sending flag: %s",E.toString());const ee=Message$1.encode({flag:E});this.channel.send(encode$8.single(ee).subarray())}catch(ee){ee instanceof Error&&log$g.error(`Exception while sending flag ${E}: ${ee.message}`)}}_closeWriteIterable(){const E=this;return{async*[Symbol.asyncIterator](){await E.closeWritePromise.promise,yield new Uint8Array(0)}}}eq(E){return E instanceof WebRTCStream?E.channel.id===this.channel.id:!1}}class DataChannelMuxerFactory{protocol;peerConnection;streamBuffer=[];metrics;constructor(E,ee,te="/webrtc"){this.protocol=te,this.peerConnection=E,this.peerConnection.ondatachannel=({channel:re})=>{const ne=new WebRTCStream({channel:re,stat:{direction:"inbound",timeline:{open:0}},closeCb:ie=>{this.streamBuffer=this.streamBuffer.filter(se=>!ie.eq(se))}});this.streamBuffer.push(ne)},this.metrics=ee}createStreamMuxer(E){return new DataChannelMuxer(this.peerConnection,this.streamBuffer,this.protocol,E,this.metrics)}}class DataChannelMuxer{protocol;peerConnection;metrics;streams=[];init;close=()=>{};source=nopSource();sink=nopSink;constructor(E,ee,te="/webrtc",re,ne){this.protocol=te,this.init=re,this.peerConnection=E,this.peerConnection.ondatachannel=({channel:se})=>{const oe=new WebRTCStream({channel:se,stat:{direction:"inbound",timeline:{open:0}},closeCb:this.wrapStreamEnd(re?.onIncomingStream)});this.streams.push(oe),re?.onIncomingStream!=null&&(this.metrics?.increment({incoming_stream:!0}),re.onIncomingStream(oe))},this.streams=ee.filter(se=>se.stat.timeline.close==null).map(se=>(se.closeCb=this.wrapStreamEnd(re?.onStreamEnd),se));const ie=re?.onIncomingStream;ie!=null&&this.streams.forEach(se=>{ie(se)})}newStream(){const E=this.peerConnection.createDataChannel(""),ee=re=>{this.metrics?.increment({stream_end:!0}),this.init?.onStreamEnd?.(re)},te=new WebRTCStream({channel:E,stat:{direction:"outbound",timeline:{open:0}},closeCb:this.wrapStreamEnd(ee)});return this.streams.push(te),this.metrics?.increment({outgoing_stream:!0}),te}wrapStreamEnd(E){const ee=this;return te=>{ee.streams=ee.streams.filter(re=>!(te instanceof WebRTCStream&&te.eq(re))),E?.(te)}}}var Message;(function(J){(function(te){te.SDP_OFFER="SDP_OFFER",te.SDP_ANSWER="SDP_ANSWER",te.ICE_CANDIDATE="ICE_CANDIDATE"})(J.Type||(J.Type={}));let E;(function(te){te[te.SDP_OFFER=0]="SDP_OFFER",te[te.SDP_ANSWER=1]="SDP_ANSWER",te[te.ICE_CANDIDATE=2]="ICE_CANDIDATE"})(E||(E={})),function(te){te.codec=()=>enumeration(E)}(J.Type||(J.Type={}));let ee;J.codec=()=>(ee==null&&(ee=message((te,re,ne={})=>{ne.lengthDelimited!==!1&&re.fork(),te.type!=null&&(re.uint32(8),J.Type.codec().encode(te.type,re)),te.data!=null&&(re.uint32(18),re.string(te.data)),ne.lengthDelimited!==!1&&re.ldelim()},(te,re)=>{const ne={},ie=re==null?te.len:te.pos+re;for(;te.pos<ie;){const se=te.uint32();switch(se>>>3){case 1:ne.type=J.Type.codec().decode(te);break;case 2:ne.data=te.string();break;default:te.skipType(se&7);break}}return ne})),ee),J.encode=te=>encodeMessage(te,J.codec()),J.decode=te=>decodeMessage(te,J.codec())})(Message||(Message={}));const log$f=logger("libp2p:webrtc:peer:util"),readCandidatesUntilConnected=async(J,E,ee)=>{for(;;){const te=await Promise.race([J.promise,ee.read()]);if(te instanceof Object){const re=te;if(re.type!==Message.Type.ICE_CANDIDATE)throw new Error("expected only ice candidates");if(re.data==null||re.data===""){log$f.trace("end-of-candidates received");break}log$f.trace("received new ICE candidate: %s",re.data);try{await E.addIceCandidate(new RTCIceCandidate(JSON.parse(re.data)))}catch(ne){throw log$f.error("bad candidate received: ",ne),new Error("bad candidate received")}}else break}await J.promise};function resolveOnConnected(J,E){J[isFirefox?"oniceconnectionstatechange":"onconnectionstatechange"]=ee=>{switch(log$f.trace("receiver peerConnectionState state: ",J.connectionState),isFirefox?J.iceConnectionState:J.connectionState){case"connected":E.resolve();break;case"failed":case"disconnected":case"closed":E.reject(new Error("RTCPeerConnection was closed"));break}}}const DEFAULT_TIMEOUT=30*1e3,log$e=logger("libp2p:webrtc:peer");async function handleIncomingStream({rtcConfiguration:J,stream:E}){const ee=AbortSignal.timeout(DEFAULT_TIMEOUT),te=pbStream(abortableDuplex(E,ee)).pb(Message),re=new RTCPeerConnection(J),ne=new DataChannelMuxerFactory(re),ie=pDefer(),se=pDefer();ee.onabort=()=>{ie.reject()},re.onicecandidate=({candidate:he})=>{se.promise.then(()=>{te.write({type:Message.Type.ICE_CANDIDATE,data:he!=null?JSON.stringify(he.toJSON()):""})},de=>{log$e.error("cannot set candidate since sending answer failed",de)})},resolveOnConnected(re,ie);const oe=await te.read();if(oe.type!==Message.Type.SDP_OFFER)throw new Error(`expected message type SDP_OFFER, received: ${oe.type??"undefined"} `);const ae=new RTCSessionDescription({type:"offer",sdp:oe.data});await re.setRemoteDescription(ae).catch(he=>{throw log$e.error("could not execute setRemoteDescription",he),new Error("Failed to set remoteDescription")});const ce=await re.createAnswer().catch(he=>{throw log$e.error("could not execute createAnswer",he),se.reject(he),new Error("Failed to create answer")});te.write({type:Message.Type.SDP_ANSWER,data:ce.sdp}),await re.setLocalDescription(ce).catch(he=>{throw log$e.error("could not execute setLocalDescription",he),se.reject(he),new Error("Failed to set localDescription")}),se.resolve(),await readCandidatesUntilConnected(ie,re,te);const le=parseRemoteAddress(re.currentRemoteDescription?.sdp??"");return{pc:re,muxerFactory:ne,remoteAddress:le}}async function initiateConnection({rtcConfiguration:J,signal:E,stream:ee}){const te=pbStream(abortableDuplex(ee,E)).pb(Message),re=new RTCPeerConnection(J),ne=new DataChannelMuxerFactory(re),ie=pDefer();resolveOnConnected(re,ie),E.onabort=ie.reject;const se=re.createDataChannel("init");re.onicecandidate=({candidate:he})=>{te.write({type:Message.Type.ICE_CANDIDATE,data:he!=null?JSON.stringify(he.toJSON()):""})};const oe=await re.createOffer();te.write({type:Message.Type.SDP_OFFER,data:oe.sdp}),await re.setLocalDescription(oe).catch(he=>{throw log$e.error("could not execute setLocalDescription",he),new Error("Failed to set localDescription")});const ae=await te.read();if(ae.type!==Message.Type.SDP_ANSWER)throw new Error("remote should send an SDP answer");const ce=new RTCSessionDescription({type:"answer",sdp:ae.data});await re.setRemoteDescription(ce).catch(he=>{throw log$e.error("could not execute setRemoteDescription",he),new Error("Failed to set remoteDescription")}),await readCandidatesUntilConnected(ie,re,te),se.close();const le=parseRemoteAddress(re.currentRemoteDescription?.sdp??"");return{pc:re,muxerFactory:ne,remoteAddress:le}}function parseRemoteAddress(J){const E=J.split(`\r
`).filter(te=>te.startsWith("a=candidate")).pop(),ee=E?.split(" ");return E==null||ee==null||ee.length<5?(log$e("could not parse remote address from",E),"/webrtc"):`/dnsaddr/${ee[4]}/${ee[2]}/${ee[3]}/webrtc`}class WebRTCPeerListener extends EventEmitter$3{peerId;transportManager;constructor(E){super(),this.peerId=E.peerId,this.transportManager=E.transportManager}async listen(){this.safeDispatchEvent("listening",{})}getAddrs(){return this.transportManager.getListeners().filter(E=>E!==this).map(E=>E.getAddrs().filter(ee=>Circuit.matches(ee)).map(ee=>ee.encapsulate(`/webrtc/p2p/${this.peerId}`))).flat()}async close(){this.safeDispatchEvent("close",{})}}const log$d=logger("libp2p:webrtc:peer"),WEBRTC_TRANSPORT="/webrtc",CIRCUIT_RELAY_TRANSPORT="/p2p-circuit",SIGNALING_PROTO_ID="/webrtc-signaling/0.0.1",WEBRTC_CODE$1=getProtocol("webrtc").code;class WebRTCTransport{components;init;_started=!1;constructor(E,ee){this.components=E,this.init=ee}isStarted(){return this._started}async start(){await this.components.registrar.handle(SIGNALING_PROTO_ID,E=>{this._onProtocol(E).catch(ee=>{log$d.error("failed to handle incoming connect from %p",E.connection.remotePeer,ee)})}),this._started=!0}async stop(){await this.components.registrar.unhandle(SIGNALING_PROTO_ID),this._started=!1}createListener(E){return new WebRTCPeerListener(this.components)}[Symbol.toStringTag]="@libp2p/webrtc";[symbol$2]=!0;filter(E){return E.filter(ee=>ee.protoCodes().includes(WEBRTC_CODE$1))}splitAddr(E){const ee=E.toString().split(WEBRTC_TRANSPORT);if(ee.length!==2)throw new CodeError("webrtc protocol was not present in multiaddr",codes$2.ERR_INVALID_MULTIADDR);if(!ee[0].includes(CIRCUIT_RELAY_TRANSPORT))throw new CodeError("p2p-circuit protocol was not present in multiaddr",codes$2.ERR_INVALID_MULTIADDR);let te=multiaddr(ee[0]);const re=multiaddr(ee[1]).getPeerId();if(re==null)throw new CodeError("destination peer id was missing",codes$2.ERR_INVALID_MULTIADDR);const ne=te.protos().pop();if(ne===void 0)throw new CodeError("invalid multiaddr",codes$2.ERR_INVALID_MULTIADDR);return ne.name!=="p2p"&&(te=te.encapsulate(`/p2p/${re}`)),{baseAddr:te,peerId:peerIdFromString(re)}}async dial(E,ee){log$d.trace("dialing address: ",E);const{baseAddr:te,peerId:re}=this.splitAddr(E);if(ee.signal==null){const ie=new AbortController;ee.signal=ie.signal}const ne=await(await this.components.transportManager.dial(te,ee)).newStream([SIGNALING_PROTO_ID],ee);try{const{pc:ie,muxerFactory:se,remoteAddress:oe}=await initiateConnection({stream:ne,rtcConfiguration:this.init.rtcConfiguration,signal:ee.signal}),ae=await ee.upgrader.upgradeOutbound(new WebRTCMultiaddrConnection({peerConnection:ie,timeline:{open:Date.now()},remoteAddr:multiaddr(oe).encapsulate(`/p2p/${re.toString()}`)}),{skipProtection:!0,skipEncryption:!0,muxerFactory:se});return ne.close(),ae}catch(ie){throw ne.reset(),ie}}async _onProtocol({connection:E,stream:ee}){try{const{pc:te,muxerFactory:re,remoteAddress:ne}=await handleIncomingStream({rtcConfiguration:this.init.rtcConfiguration,connection:E,stream:ee});await this.components.upgrader.upgradeInbound(new WebRTCMultiaddrConnection({peerConnection:te,timeline:{open:new Date().getTime()},remoteAddr:multiaddr(ne).encapsulate(`/p2p/${E.remotePeer.toString()}`)}),{skipEncryption:!0,skipProtection:!0,muxerFactory:re})}catch(te){throw ee.reset(),te}}}function pair(){const J=pDefer();let E=!1;return{sink:async ee=>{if(E)throw new Error("already piped");E=!0,J.resolve(ee)},source:async function*(){yield*await J.promise}()}}function duplexPair(){const J=pair(),E=pair();return[{source:J.source,sink:E.sink},{source:E.source,sink:J.sink}]}const NOISE_MSG_MAX_LENGTH_BYTES=65535,NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG=NOISE_MSG_MAX_LENGTH_BYTES-16,DUMP_SESSION_KEYS=!!globalThis.process?.env?.DUMP_SESSION_KEYS;function number(J){if(!Number.isSafeInteger(J)||J<0)throw new Error(`Wrong positive integer: ${J}`)}function bool(J){if(typeof J!="boolean")throw new Error(`Expected boolean, not ${J}`)}function bytes(J,...E){if(!(J instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(E.length>0&&!E.includes(J.length))throw new TypeError(`Expected Uint8Array of length ${E}, not of length=${J.length}`)}function hash(J){if(typeof J!="function"||typeof J.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");number(J.outputLen),number(J.blockLen)}function exists(J,E=!0){if(J.destroyed)throw new Error("Hash instance has been destroyed");if(E&&J.finished)throw new Error("Hash#digest() has already been called")}function output(J,E){bytes(J);const ee=E.outputLen;if(J.length<ee)throw new Error(`digestInto() expects output buffer of length at least ${ee}`)}const assert={number,bool,bytes,hash,exists,output};/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const createView=J=>new DataView(J.buffer,J.byteOffset,J.byteLength),rotr=(J,E)=>J<<32-E|J>>>E,isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE)throw new Error("Non little-endian hardware is not supported");Array.from({length:256},(J,E)=>E.toString(16).padStart(2,"0"));function utf8ToBytes(J){if(typeof J!="string")throw new TypeError(`utf8ToBytes expected string, got ${typeof J}`);return new TextEncoder().encode(J)}function toBytes(J){if(typeof J=="string"&&(J=utf8ToBytes(J)),!(J instanceof Uint8Array))throw new TypeError(`Expected input type is Uint8Array (got ${typeof J})`);return J}class Hash{clone(){return this._cloneInto()}}function wrapConstructor(J){const E=te=>J().update(toBytes(te)).digest(),ee=J();return E.outputLen=ee.outputLen,E.blockLen=ee.blockLen,E.create=()=>J(),E}class HMAC extends Hash{constructor(E,ee){super(),this.finished=!1,this.destroyed=!1,assert.hash(E);const te=toBytes(ee);if(this.iHash=E.create(),typeof this.iHash.update!="function")throw new TypeError("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const re=this.blockLen,ne=new Uint8Array(re);ne.set(te.length>re?E.create().update(te).digest():te);for(let ie=0;ie<ne.length;ie++)ne[ie]^=54;this.iHash.update(ne),this.oHash=E.create();for(let ie=0;ie<ne.length;ie++)ne[ie]^=106;this.oHash.update(ne),ne.fill(0)}update(E){return assert.exists(this),this.iHash.update(E),this}digestInto(E){assert.exists(this),assert.bytes(E,this.outputLen),this.finished=!0,this.iHash.digestInto(E),this.oHash.update(E),this.oHash.digestInto(E),this.destroy()}digest(){const E=new Uint8Array(this.oHash.outputLen);return this.digestInto(E),E}_cloneInto(E){E||(E=Object.create(Object.getPrototypeOf(this),{}));const{oHash:ee,iHash:te,finished:re,destroyed:ne,blockLen:ie,outputLen:se}=this;return E=E,E.finished=re,E.destroyed=ne,E.blockLen=ie,E.outputLen=se,E.oHash=ee._cloneInto(E.oHash),E.iHash=te._cloneInto(E.iHash),E}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const hmac=(J,E,ee)=>new HMAC(J,E).update(ee).digest();hmac.create=(J,E)=>new HMAC(J,E);function extract(J,E,ee){return assert.hash(J),ee===void 0&&(ee=new Uint8Array(J.outputLen)),hmac(J,toBytes(ee),toBytes(E))}const HKDF_COUNTER=new Uint8Array([0]),EMPTY_BUFFER=new Uint8Array;function expand(J,E,ee,te=32){if(assert.hash(J),assert.number(te),te>255*J.outputLen)throw new Error("Length should be <= 255*HashLen");const re=Math.ceil(te/J.outputLen);ee===void 0&&(ee=EMPTY_BUFFER);const ne=new Uint8Array(re*J.outputLen),ie=hmac.create(J,E),se=ie._cloneInto(),oe=new Uint8Array(ie.outputLen);for(let ae=0;ae<re;ae++)HKDF_COUNTER[0]=ae+1,se.update(ae===0?EMPTY_BUFFER:oe).update(ee).update(HKDF_COUNTER).digestInto(oe),ne.set(oe,J.outputLen*ae),ie._cloneInto(se);return ie.destroy(),se.destroy(),oe.fill(0),HKDF_COUNTER.fill(0),ne.slice(0,te)}const hkdf=(J,E,ee,te,re)=>expand(J,extract(J,E,ee),te,re);function setBigUint64(J,E,ee,te){if(typeof J.setBigUint64=="function")return J.setBigUint64(E,ee,te);const re=BigInt(32),ne=BigInt(4294967295),ie=Number(ee>>re&ne),se=Number(ee&ne),oe=te?4:0,ae=te?0:4;J.setUint32(E+oe,ie,te),J.setUint32(E+ae,se,te)}class SHA2 extends Hash{constructor(E,ee,te,re){super(),this.blockLen=E,this.outputLen=ee,this.padOffset=te,this.isLE=re,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(E),this.view=createView(this.buffer)}update(E){assert.exists(this);const{view:ee,buffer:te,blockLen:re}=this;E=toBytes(E);const ne=E.length;for(let ie=0;ie<ne;){const se=Math.min(re-this.pos,ne-ie);if(se===re){const oe=createView(E);for(;re<=ne-ie;ie+=re)this.process(oe,ie);continue}te.set(E.subarray(ie,ie+se),this.pos),this.pos+=se,ie+=se,this.pos===re&&(this.process(ee,0),this.pos=0)}return this.length+=E.length,this.roundClean(),this}digestInto(E){assert.exists(this),assert.output(E,this),this.finished=!0;const{buffer:ee,view:te,blockLen:re,isLE:ne}=this;let{pos:ie}=this;ee[ie++]=128,this.buffer.subarray(ie).fill(0),this.padOffset>re-ie&&(this.process(te,0),ie=0);for(let le=ie;le<re;le++)ee[le]=0;setBigUint64(te,re-8,BigInt(this.length*8),ne),this.process(te,0);const se=createView(E),oe=this.outputLen;if(oe%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const ae=oe/4,ce=this.get();if(ae>ce.length)throw new Error("_sha2: outputLen bigger than state");for(let le=0;le<ae;le++)se.setUint32(4*le,ce[le],ne)}digest(){const{buffer:E,outputLen:ee}=this;this.digestInto(E);const te=E.slice(0,ee);return this.destroy(),te}_cloneInto(E){E||(E=new this.constructor),E.set(...this.get());const{blockLen:ee,buffer:te,length:re,finished:ne,destroyed:ie,pos:se}=this;return E.length=re,E.pos=se,E.finished=ne,E.destroyed=ie,re%ee&&E.buffer.set(te),E}}const Chi=(J,E,ee)=>J&E^~J&ee,Maj=(J,E,ee)=>J&E^J&ee^E&ee,SHA256_K=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),IV=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W=new Uint32Array(64);class SHA256 extends SHA2{constructor(){super(64,32,8,!1),this.A=IV[0]|0,this.B=IV[1]|0,this.C=IV[2]|0,this.D=IV[3]|0,this.E=IV[4]|0,this.F=IV[5]|0,this.G=IV[6]|0,this.H=IV[7]|0}get(){const{A:E,B:ee,C:te,D:re,E:ne,F:ie,G:se,H:oe}=this;return[E,ee,te,re,ne,ie,se,oe]}set(E,ee,te,re,ne,ie,se,oe){this.A=E|0,this.B=ee|0,this.C=te|0,this.D=re|0,this.E=ne|0,this.F=ie|0,this.G=se|0,this.H=oe|0}process(E,ee){for(let le=0;le<16;le++,ee+=4)SHA256_W[le]=E.getUint32(ee,!1);for(let le=16;le<64;le++){const he=SHA256_W[le-15],de=SHA256_W[le-2],ue=rotr(he,7)^rotr(he,18)^he>>>3,pe=rotr(de,17)^rotr(de,19)^de>>>10;SHA256_W[le]=pe+SHA256_W[le-7]+ue+SHA256_W[le-16]|0}let{A:te,B:re,C:ne,D:ie,E:se,F:oe,G:ae,H:ce}=this;for(let le=0;le<64;le++){const he=rotr(se,6)^rotr(se,11)^rotr(se,25),de=ce+he+Chi(se,oe,ae)+SHA256_K[le]+SHA256_W[le]|0,ue=(rotr(te,2)^rotr(te,13)^rotr(te,22))+Maj(te,re,ne)|0;ce=ae,ae=oe,oe=se,se=ie+de|0,ie=ne,ne=re,re=te,te=de+ue|0}te=te+this.A|0,re=re+this.B|0,ne=ne+this.C|0,ie=ie+this.D|0,se=se+this.E|0,oe=oe+this.F|0,ae=ae+this.G|0,ce=ce+this.H|0,this.set(te,re,ne,ie,se,oe,ae,ce)}roundClean(){SHA256_W.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class SHA224 extends SHA256{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const sha256=wrapConstructor(()=>new SHA256);wrapConstructor(()=>new SHA224);var chacha20poly1305={},chacha={};Object.defineProperty(chacha,"__esModule",{value:!0});var binary_1=binary,wipe_1=wipe$1,ROUNDS=20;function core(J,E,ee){for(var te=1634760805,re=857760878,ne=2036477234,ie=1797285236,se=ee[3]<<24|ee[2]<<16|ee[1]<<8|ee[0],oe=ee[7]<<24|ee[6]<<16|ee[5]<<8|ee[4],ae=ee[11]<<24|ee[10]<<16|ee[9]<<8|ee[8],ce=ee[15]<<24|ee[14]<<16|ee[13]<<8|ee[12],le=ee[19]<<24|ee[18]<<16|ee[17]<<8|ee[16],he=ee[23]<<24|ee[22]<<16|ee[21]<<8|ee[20],de=ee[27]<<24|ee[26]<<16|ee[25]<<8|ee[24],ue=ee[31]<<24|ee[30]<<16|ee[29]<<8|ee[28],pe=E[3]<<24|E[2]<<16|E[1]<<8|E[0],ye=E[7]<<24|E[6]<<16|E[5]<<8|E[4],me=E[11]<<24|E[10]<<16|E[9]<<8|E[8],be=E[15]<<24|E[14]<<16|E[13]<<8|E[12],_e=te,we=re,$e=ne,ve=ie,fe=se,Ee=oe,ke=ae,Ne=ce,xe=le,Ue=he,Ke=de,Te=ue,Ce=pe,Ve=ye,Re=me,Le=be,De=0;De<ROUNDS;De+=2)_e=_e+fe|0,Ce^=_e,Ce=Ce>>>32-16|Ce<<16,xe=xe+Ce|0,fe^=xe,fe=fe>>>32-12|fe<<12,we=we+Ee|0,Ve^=we,Ve=Ve>>>32-16|Ve<<16,Ue=Ue+Ve|0,Ee^=Ue,Ee=Ee>>>32-12|Ee<<12,$e=$e+ke|0,Re^=$e,Re=Re>>>32-16|Re<<16,Ke=Ke+Re|0,ke^=Ke,ke=ke>>>32-12|ke<<12,ve=ve+Ne|0,Le^=ve,Le=Le>>>32-16|Le<<16,Te=Te+Le|0,Ne^=Te,Ne=Ne>>>32-12|Ne<<12,$e=$e+ke|0,Re^=$e,Re=Re>>>32-8|Re<<8,Ke=Ke+Re|0,ke^=Ke,ke=ke>>>32-7|ke<<7,ve=ve+Ne|0,Le^=ve,Le=Le>>>32-8|Le<<8,Te=Te+Le|0,Ne^=Te,Ne=Ne>>>32-7|Ne<<7,we=we+Ee|0,Ve^=we,Ve=Ve>>>32-8|Ve<<8,Ue=Ue+Ve|0,Ee^=Ue,Ee=Ee>>>32-7|Ee<<7,_e=_e+fe|0,Ce^=_e,Ce=Ce>>>32-8|Ce<<8,xe=xe+Ce|0,fe^=xe,fe=fe>>>32-7|fe<<7,_e=_e+Ee|0,Le^=_e,Le=Le>>>32-16|Le<<16,Ke=Ke+Le|0,Ee^=Ke,Ee=Ee>>>32-12|Ee<<12,we=we+ke|0,Ce^=we,Ce=Ce>>>32-16|Ce<<16,Te=Te+Ce|0,ke^=Te,ke=ke>>>32-12|ke<<12,$e=$e+Ne|0,Ve^=$e,Ve=Ve>>>32-16|Ve<<16,xe=xe+Ve|0,Ne^=xe,Ne=Ne>>>32-12|Ne<<12,ve=ve+fe|0,Re^=ve,Re=Re>>>32-16|Re<<16,Ue=Ue+Re|0,fe^=Ue,fe=fe>>>32-12|fe<<12,$e=$e+Ne|0,Ve^=$e,Ve=Ve>>>32-8|Ve<<8,xe=xe+Ve|0,Ne^=xe,Ne=Ne>>>32-7|Ne<<7,ve=ve+fe|0,Re^=ve,Re=Re>>>32-8|Re<<8,Ue=Ue+Re|0,fe^=Ue,fe=fe>>>32-7|fe<<7,we=we+ke|0,Ce^=we,Ce=Ce>>>32-8|Ce<<8,Te=Te+Ce|0,ke^=Te,ke=ke>>>32-7|ke<<7,_e=_e+Ee|0,Le^=_e,Le=Le>>>32-8|Le<<8,Ke=Ke+Le|0,Ee^=Ke,Ee=Ee>>>32-7|Ee<<7;binary_1.writeUint32LE(_e+te|0,J,0),binary_1.writeUint32LE(we+re|0,J,4),binary_1.writeUint32LE($e+ne|0,J,8),binary_1.writeUint32LE(ve+ie|0,J,12),binary_1.writeUint32LE(fe+se|0,J,16),binary_1.writeUint32LE(Ee+oe|0,J,20),binary_1.writeUint32LE(ke+ae|0,J,24),binary_1.writeUint32LE(Ne+ce|0,J,28),binary_1.writeUint32LE(xe+le|0,J,32),binary_1.writeUint32LE(Ue+he|0,J,36),binary_1.writeUint32LE(Ke+de|0,J,40),binary_1.writeUint32LE(Te+ue|0,J,44),binary_1.writeUint32LE(Ce+pe|0,J,48),binary_1.writeUint32LE(Ve+ye|0,J,52),binary_1.writeUint32LE(Re+me|0,J,56),binary_1.writeUint32LE(Le+be|0,J,60)}function streamXOR(J,E,ee,te,re){if(re===void 0&&(re=0),J.length!==32)throw new Error("ChaCha: key size must be 32 bytes");if(te.length<ee.length)throw new Error("ChaCha: destination is shorter than source");var ne,ie;if(re===0){if(E.length!==8&&E.length!==12)throw new Error("ChaCha nonce must be 8 or 12 bytes");ne=new Uint8Array(16),ie=ne.length-E.length,ne.set(E,ie)}else{if(E.length!==16)throw new Error("ChaCha nonce with counter must be 16 bytes");ne=E,ie=re}for(var se=new Uint8Array(64),oe=0;oe<ee.length;oe+=64){core(se,ne,J);for(var ae=oe;ae<oe+64&&ae<ee.length;ae++)te[ae]=ee[ae]^se[ae-oe];incrementCounter(ne,0,ie)}return wipe_1.wipe(se),re===0&&wipe_1.wipe(ne),te}chacha.streamXOR=streamXOR;function stream(J,E,ee,te){return te===void 0&&(te=0),wipe_1.wipe(ee),streamXOR(J,E,ee,ee,te)}chacha.stream=stream;function incrementCounter(J,E,ee){for(var te=1;ee--;)te=te+(J[E]&255)|0,J[E]=te&255,te>>>=8,E++;if(te>0)throw new Error("ChaCha: counter overflow")}var poly1305={},constantTime={};Object.defineProperty(constantTime,"__esModule",{value:!0});function select(J,E,ee){return~(J-1)&E|J-1&ee}constantTime.select=select;function lessOrEqual(J,E){return(J|0)-(E|0)-1>>>31&1}constantTime.lessOrEqual=lessOrEqual;function compare(J,E){if(J.length!==E.length)return 0;for(var ee=0,te=0;te<J.length;te++)ee|=J[te]^E[te];return 1&ee-1>>>8}constantTime.compare=compare;function equal(J,E){return J.length===0||E.length===0?!1:compare(J,E)!==0}constantTime.equal=equal;(function(J){Object.defineProperty(J,"__esModule",{value:!0});var E=constantTime,ee=wipe$1;J.DIGEST_LENGTH=16;var te=function(){function ie(se){this.digestLength=J.DIGEST_LENGTH,this._buffer=new Uint8Array(16),this._r=new Uint16Array(10),this._h=new Uint16Array(10),this._pad=new Uint16Array(8),this._leftover=0,this._fin=0,this._finished=!1;var oe=se[0]|se[1]<<8;this._r[0]=oe&8191;var ae=se[2]|se[3]<<8;this._r[1]=(oe>>>13|ae<<3)&8191;var ce=se[4]|se[5]<<8;this._r[2]=(ae>>>10|ce<<6)&7939;var le=se[6]|se[7]<<8;this._r[3]=(ce>>>7|le<<9)&8191;var he=se[8]|se[9]<<8;this._r[4]=(le>>>4|he<<12)&255,this._r[5]=he>>>1&8190;var de=se[10]|se[11]<<8;this._r[6]=(he>>>14|de<<2)&8191;var ue=se[12]|se[13]<<8;this._r[7]=(de>>>11|ue<<5)&8065;var pe=se[14]|se[15]<<8;this._r[8]=(ue>>>8|pe<<8)&8191,this._r[9]=pe>>>5&127,this._pad[0]=se[16]|se[17]<<8,this._pad[1]=se[18]|se[19]<<8,this._pad[2]=se[20]|se[21]<<8,this._pad[3]=se[22]|se[23]<<8,this._pad[4]=se[24]|se[25]<<8,this._pad[5]=se[26]|se[27]<<8,this._pad[6]=se[28]|se[29]<<8,this._pad[7]=se[30]|se[31]<<8}return ie.prototype._blocks=function(se,oe,ae){for(var ce=this._fin?0:2048,le=this._h[0],he=this._h[1],de=this._h[2],ue=this._h[3],pe=this._h[4],ye=this._h[5],me=this._h[6],be=this._h[7],_e=this._h[8],we=this._h[9],$e=this._r[0],ve=this._r[1],fe=this._r[2],Ee=this._r[3],ke=this._r[4],Ne=this._r[5],xe=this._r[6],Ue=this._r[7],Ke=this._r[8],Te=this._r[9];ae>=16;){var Ce=se[oe+0]|se[oe+1]<<8;le+=Ce&8191;var Ve=se[oe+2]|se[oe+3]<<8;he+=(Ce>>>13|Ve<<3)&8191;var Re=se[oe+4]|se[oe+5]<<8;de+=(Ve>>>10|Re<<6)&8191;var Le=se[oe+6]|se[oe+7]<<8;ue+=(Re>>>7|Le<<9)&8191;var De=se[oe+8]|se[oe+9]<<8;pe+=(Le>>>4|De<<12)&8191,ye+=De>>>1&8191;var Be=se[oe+10]|se[oe+11]<<8;me+=(De>>>14|Be<<2)&8191;var Oe=se[oe+12]|se[oe+13]<<8;be+=(Be>>>11|Oe<<5)&8191;var Ge=se[oe+14]|se[oe+15]<<8;_e+=(Oe>>>8|Ge<<8)&8191,we+=Ge>>>5|ce;var Me=0,je=Me;je+=le*$e,je+=he*(5*Te),je+=de*(5*Ke),je+=ue*(5*Ue),je+=pe*(5*xe),Me=je>>>13,je&=8191,je+=ye*(5*Ne),je+=me*(5*ke),je+=be*(5*Ee),je+=_e*(5*fe),je+=we*(5*ve),Me+=je>>>13,je&=8191;var We=Me;We+=le*ve,We+=he*$e,We+=de*(5*Te),We+=ue*(5*Ke),We+=pe*(5*Ue),Me=We>>>13,We&=8191,We+=ye*(5*xe),We+=me*(5*Ne),We+=be*(5*ke),We+=_e*(5*Ee),We+=we*(5*fe),Me+=We>>>13,We&=8191;var ze=Me;ze+=le*fe,ze+=he*ve,ze+=de*$e,ze+=ue*(5*Te),ze+=pe*(5*Ke),Me=ze>>>13,ze&=8191,ze+=ye*(5*Ue),ze+=me*(5*xe),ze+=be*(5*Ne),ze+=_e*(5*ke),ze+=we*(5*Ee),Me+=ze>>>13,ze&=8191;var Ae=Me;Ae+=le*Ee,Ae+=he*fe,Ae+=de*ve,Ae+=ue*$e,Ae+=pe*(5*Te),Me=Ae>>>13,Ae&=8191,Ae+=ye*(5*Ke),Ae+=me*(5*Ue),Ae+=be*(5*xe),Ae+=_e*(5*Ne),Ae+=we*(5*ke),Me+=Ae>>>13,Ae&=8191;var Pe=Me;Pe+=le*ke,Pe+=he*Ee,Pe+=de*fe,Pe+=ue*ve,Pe+=pe*$e,Me=Pe>>>13,Pe&=8191,Pe+=ye*(5*Te),Pe+=me*(5*Ke),Pe+=be*(5*Ue),Pe+=_e*(5*xe),Pe+=we*(5*Ne),Me+=Pe>>>13,Pe&=8191;var Ie=Me;Ie+=le*Ne,Ie+=he*ke,Ie+=de*Ee,Ie+=ue*fe,Ie+=pe*ve,Me=Ie>>>13,Ie&=8191,Ie+=ye*$e,Ie+=me*(5*Te),Ie+=be*(5*Ke),Ie+=_e*(5*Ue),Ie+=we*(5*xe),Me+=Ie>>>13,Ie&=8191;var ge=Me;ge+=le*xe,ge+=he*Ne,ge+=de*ke,ge+=ue*Ee,ge+=pe*fe,Me=ge>>>13,ge&=8191,ge+=ye*ve,ge+=me*$e,ge+=be*(5*Te),ge+=_e*(5*Ke),ge+=we*(5*Ue),Me+=ge>>>13,ge&=8191;var Se=Me;Se+=le*Ue,Se+=he*xe,Se+=de*Ne,Se+=ue*ke,Se+=pe*Ee,Me=Se>>>13,Se&=8191,Se+=ye*fe,Se+=me*ve,Se+=be*$e,Se+=_e*(5*Te),Se+=we*(5*Ke),Me+=Se>>>13,Se&=8191;var Fe=Me;Fe+=le*Ke,Fe+=he*Ue,Fe+=de*xe,Fe+=ue*Ne,Fe+=pe*ke,Me=Fe>>>13,Fe&=8191,Fe+=ye*Ee,Fe+=me*fe,Fe+=be*ve,Fe+=_e*$e,Fe+=we*(5*Te),Me+=Fe>>>13,Fe&=8191;var He=Me;He+=le*Te,He+=he*Ke,He+=de*Ue,He+=ue*xe,He+=pe*Ne,Me=He>>>13,He&=8191,He+=ye*ke,He+=me*Ee,He+=be*fe,He+=_e*ve,He+=we*$e,Me+=He>>>13,He&=8191,Me=(Me<<2)+Me|0,Me=Me+je|0,je=Me&8191,Me=Me>>>13,We+=Me,le=je,he=We,de=ze,ue=Ae,pe=Pe,ye=Ie,me=ge,be=Se,_e=Fe,we=He,oe+=16,ae-=16}this._h[0]=le,this._h[1]=he,this._h[2]=de,this._h[3]=ue,this._h[4]=pe,this._h[5]=ye,this._h[6]=me,this._h[7]=be,this._h[8]=_e,this._h[9]=we},ie.prototype.finish=function(se,oe){oe===void 0&&(oe=0);var ae=new Uint16Array(10),ce,le,he,de;if(this._leftover){for(de=this._leftover,this._buffer[de++]=1;de<16;de++)this._buffer[de]=0;this._fin=1,this._blocks(this._buffer,0,16)}for(ce=this._h[1]>>>13,this._h[1]&=8191,de=2;de<10;de++)this._h[de]+=ce,ce=this._h[de]>>>13,this._h[de]&=8191;for(this._h[0]+=ce*5,ce=this._h[0]>>>13,this._h[0]&=8191,this._h[1]+=ce,ce=this._h[1]>>>13,this._h[1]&=8191,this._h[2]+=ce,ae[0]=this._h[0]+5,ce=ae[0]>>>13,ae[0]&=8191,de=1;de<10;de++)ae[de]=this._h[de]+ce,ce=ae[de]>>>13,ae[de]&=8191;for(ae[9]-=8192,le=(ce^1)-1,de=0;de<10;de++)ae[de]&=le;for(le=~le,de=0;de<10;de++)this._h[de]=this._h[de]&le|ae[de];for(this._h[0]=(this._h[0]|this._h[1]<<13)&65535,this._h[1]=(this._h[1]>>>3|this._h[2]<<10)&65535,this._h[2]=(this._h[2]>>>6|this._h[3]<<7)&65535,this._h[3]=(this._h[3]>>>9|this._h[4]<<4)&65535,this._h[4]=(this._h[4]>>>12|this._h[5]<<1|this._h[6]<<14)&65535,this._h[5]=(this._h[6]>>>2|this._h[7]<<11)&65535,this._h[6]=(this._h[7]>>>5|this._h[8]<<8)&65535,this._h[7]=(this._h[8]>>>8|this._h[9]<<5)&65535,he=this._h[0]+this._pad[0],this._h[0]=he&65535,de=1;de<8;de++)he=(this._h[de]+this._pad[de]|0)+(he>>>16)|0,this._h[de]=he&65535;return se[oe+0]=this._h[0]>>>0,se[oe+1]=this._h[0]>>>8,se[oe+2]=this._h[1]>>>0,se[oe+3]=this._h[1]>>>8,se[oe+4]=this._h[2]>>>0,se[oe+5]=this._h[2]>>>8,se[oe+6]=this._h[3]>>>0,se[oe+7]=this._h[3]>>>8,se[oe+8]=this._h[4]>>>0,se[oe+9]=this._h[4]>>>8,se[oe+10]=this._h[5]>>>0,se[oe+11]=this._h[5]>>>8,se[oe+12]=this._h[6]>>>0,se[oe+13]=this._h[6]>>>8,se[oe+14]=this._h[7]>>>0,se[oe+15]=this._h[7]>>>8,this._finished=!0,this},ie.prototype.update=function(se){var oe=0,ae=se.length,ce;if(this._leftover){ce=16-this._leftover,ce>ae&&(ce=ae);for(var le=0;le<ce;le++)this._buffer[this._leftover+le]=se[oe+le];if(ae-=ce,oe+=ce,this._leftover+=ce,this._leftover<16)return this;this._blocks(this._buffer,0,16),this._leftover=0}if(ae>=16&&(ce=ae-ae%16,this._blocks(se,oe,ce),oe+=ce,ae-=ce),ae){for(var le=0;le<ae;le++)this._buffer[this._leftover+le]=se[oe+le];this._leftover+=ae}return this},ie.prototype.digest=function(){if(this._finished)throw new Error("Poly1305 was finished");var se=new Uint8Array(16);return this.finish(se),se},ie.prototype.clean=function(){return ee.wipe(this._buffer),ee.wipe(this._r),ee.wipe(this._h),ee.wipe(this._pad),this._leftover=0,this._fin=0,this._finished=!0,this},ie}();J.Poly1305=te;function re(ie,se){var oe=new te(ie);oe.update(se);var ae=oe.digest();return oe.clean(),ae}J.oneTimeAuth=re;function ne(ie,se){return ie.length!==J.DIGEST_LENGTH||se.length!==J.DIGEST_LENGTH?!1:E.equal(ie,se)}J.equal=ne})(poly1305);(function(J){Object.defineProperty(J,"__esModule",{value:!0});var E=chacha,ee=poly1305,te=wipe$1,re=binary,ne=constantTime;J.KEY_LENGTH=32,J.NONCE_LENGTH=12,J.TAG_LENGTH=16;var ie=new Uint8Array(16),se=function(){function oe(ae){if(this.nonceLength=J.NONCE_LENGTH,this.tagLength=J.TAG_LENGTH,ae.length!==J.KEY_LENGTH)throw new Error("ChaCha20Poly1305 needs 32-byte key");this._key=new Uint8Array(ae)}return oe.prototype.seal=function(ae,ce,le,he){if(ae.length>16)throw new Error("ChaCha20Poly1305: incorrect nonce length");var de=new Uint8Array(16);de.set(ae,de.length-ae.length);var ue=new Uint8Array(32);E.stream(this._key,de,ue,4);var pe=ce.length+this.tagLength,ye;if(he){if(he.length!==pe)throw new Error("ChaCha20Poly1305: incorrect destination length");ye=he}else ye=new Uint8Array(pe);return E.streamXOR(this._key,de,ce,ye,4),this._authenticate(ye.subarray(ye.length-this.tagLength,ye.length),ue,ye.subarray(0,ye.length-this.tagLength),le),te.wipe(de),ye},oe.prototype.open=function(ae,ce,le,he){if(ae.length>16)throw new Error("ChaCha20Poly1305: incorrect nonce length");if(ce.length<this.tagLength)return null;var de=new Uint8Array(16);de.set(ae,de.length-ae.length);var ue=new Uint8Array(32);E.stream(this._key,de,ue,4);var pe=new Uint8Array(this.tagLength);if(this._authenticate(pe,ue,ce.subarray(0,ce.length-this.tagLength),le),!ne.equal(pe,ce.subarray(ce.length-this.tagLength,ce.length)))return null;var ye=ce.length-this.tagLength,me;if(he){if(he.length!==ye)throw new Error("ChaCha20Poly1305: incorrect destination length");me=he}else me=new Uint8Array(ye);return E.streamXOR(this._key,de,ce.subarray(0,ce.length-this.tagLength),me,4),te.wipe(de),me},oe.prototype.clean=function(){return te.wipe(this._key),this},oe.prototype._authenticate=function(ae,ce,le,he){var de=new ee.Poly1305(ce);he&&(de.update(he),he.length%16>0&&de.update(ie.subarray(he.length%16))),de.update(le),le.length%16>0&&de.update(ie.subarray(le.length%16));var ue=new Uint8Array(8);he&&re.writeUint64LE(he.length,ue),de.update(ue),re.writeUint64LE(le.length,ue),de.update(ue);for(var pe=de.digest(),ye=0;ye<pe.length;ye++)ae[ye]=pe[ye];de.clean(),te.wipe(pe),te.wipe(ue)},oe}();J.ChaCha20Poly1305=se})(chacha20poly1305);var x25519={};(function(J){Object.defineProperty(J,"__esModule",{value:!0}),J.sharedKey=J.generateKeyPair=J.generateKeyPairFromSeed=J.scalarMultBase=J.scalarMult=J.SHARED_KEY_LENGTH=J.SECRET_KEY_LENGTH=J.PUBLIC_KEY_LENGTH=void 0;const E=random,ee=wipe$1;J.PUBLIC_KEY_LENGTH=32,J.SECRET_KEY_LENGTH=32,J.SHARED_KEY_LENGTH=32;function te(we){const $e=new Float64Array(16);if(we)for(let ve=0;ve<we.length;ve++)$e[ve]=we[ve];return $e}const re=new Uint8Array(32);re[0]=9;const ne=te([56129,1]);function ie(we){let $e=1;for(let ve=0;ve<16;ve++){let fe=we[ve]+$e+65535;$e=Math.floor(fe/65536),we[ve]=fe-$e*65536}we[0]+=$e-1+37*($e-1)}function se(we,$e,ve){const fe=~(ve-1);for(let Ee=0;Ee<16;Ee++){const ke=fe&(we[Ee]^$e[Ee]);we[Ee]^=ke,$e[Ee]^=ke}}function oe(we,$e){const ve=te(),fe=te();for(let Ee=0;Ee<16;Ee++)fe[Ee]=$e[Ee];ie(fe),ie(fe),ie(fe);for(let Ee=0;Ee<2;Ee++){ve[0]=fe[0]-65517;for(let Ne=1;Ne<15;Ne++)ve[Ne]=fe[Ne]-65535-(ve[Ne-1]>>16&1),ve[Ne-1]&=65535;ve[15]=fe[15]-32767-(ve[14]>>16&1);const ke=ve[15]>>16&1;ve[14]&=65535,se(fe,ve,1-ke)}for(let Ee=0;Ee<16;Ee++)we[2*Ee]=fe[Ee]&255,we[2*Ee+1]=fe[Ee]>>8}function ae(we,$e){for(let ve=0;ve<16;ve++)we[ve]=$e[2*ve]+($e[2*ve+1]<<8);we[15]&=32767}function ce(we,$e,ve){for(let fe=0;fe<16;fe++)we[fe]=$e[fe]+ve[fe]}function le(we,$e,ve){for(let fe=0;fe<16;fe++)we[fe]=$e[fe]-ve[fe]}function he(we,$e,ve){let fe,Ee,ke=0,Ne=0,xe=0,Ue=0,Ke=0,Te=0,Ce=0,Ve=0,Re=0,Le=0,De=0,Be=0,Oe=0,Ge=0,Me=0,je=0,We=0,ze=0,Ae=0,Pe=0,Ie=0,ge=0,Se=0,Fe=0,He=0,qe=0,Ye=0,rt=0,ot=0,pt=0,gt=0,it=ve[0],nt=ve[1],et=ve[2],tt=ve[3],Qe=ve[4],Xe=ve[5],Je=ve[6],Ze=ve[7],st=ve[8],at=ve[9],ct=ve[10],lt=ve[11],ut=ve[12],ht=ve[13],dt=ve[14],ft=ve[15];fe=$e[0],ke+=fe*it,Ne+=fe*nt,xe+=fe*et,Ue+=fe*tt,Ke+=fe*Qe,Te+=fe*Xe,Ce+=fe*Je,Ve+=fe*Ze,Re+=fe*st,Le+=fe*at,De+=fe*ct,Be+=fe*lt,Oe+=fe*ut,Ge+=fe*ht,Me+=fe*dt,je+=fe*ft,fe=$e[1],Ne+=fe*it,xe+=fe*nt,Ue+=fe*et,Ke+=fe*tt,Te+=fe*Qe,Ce+=fe*Xe,Ve+=fe*Je,Re+=fe*Ze,Le+=fe*st,De+=fe*at,Be+=fe*ct,Oe+=fe*lt,Ge+=fe*ut,Me+=fe*ht,je+=fe*dt,We+=fe*ft,fe=$e[2],xe+=fe*it,Ue+=fe*nt,Ke+=fe*et,Te+=fe*tt,Ce+=fe*Qe,Ve+=fe*Xe,Re+=fe*Je,Le+=fe*Ze,De+=fe*st,Be+=fe*at,Oe+=fe*ct,Ge+=fe*lt,Me+=fe*ut,je+=fe*ht,We+=fe*dt,ze+=fe*ft,fe=$e[3],Ue+=fe*it,Ke+=fe*nt,Te+=fe*et,Ce+=fe*tt,Ve+=fe*Qe,Re+=fe*Xe,Le+=fe*Je,De+=fe*Ze,Be+=fe*st,Oe+=fe*at,Ge+=fe*ct,Me+=fe*lt,je+=fe*ut,We+=fe*ht,ze+=fe*dt,Ae+=fe*ft,fe=$e[4],Ke+=fe*it,Te+=fe*nt,Ce+=fe*et,Ve+=fe*tt,Re+=fe*Qe,Le+=fe*Xe,De+=fe*Je,Be+=fe*Ze,Oe+=fe*st,Ge+=fe*at,Me+=fe*ct,je+=fe*lt,We+=fe*ut,ze+=fe*ht,Ae+=fe*dt,Pe+=fe*ft,fe=$e[5],Te+=fe*it,Ce+=fe*nt,Ve+=fe*et,Re+=fe*tt,Le+=fe*Qe,De+=fe*Xe,Be+=fe*Je,Oe+=fe*Ze,Ge+=fe*st,Me+=fe*at,je+=fe*ct,We+=fe*lt,ze+=fe*ut,Ae+=fe*ht,Pe+=fe*dt,Ie+=fe*ft,fe=$e[6],Ce+=fe*it,Ve+=fe*nt,Re+=fe*et,Le+=fe*tt,De+=fe*Qe,Be+=fe*Xe,Oe+=fe*Je,Ge+=fe*Ze,Me+=fe*st,je+=fe*at,We+=fe*ct,ze+=fe*lt,Ae+=fe*ut,Pe+=fe*ht,Ie+=fe*dt,ge+=fe*ft,fe=$e[7],Ve+=fe*it,Re+=fe*nt,Le+=fe*et,De+=fe*tt,Be+=fe*Qe,Oe+=fe*Xe,Ge+=fe*Je,Me+=fe*Ze,je+=fe*st,We+=fe*at,ze+=fe*ct,Ae+=fe*lt,Pe+=fe*ut,Ie+=fe*ht,ge+=fe*dt,Se+=fe*ft,fe=$e[8],Re+=fe*it,Le+=fe*nt,De+=fe*et,Be+=fe*tt,Oe+=fe*Qe,Ge+=fe*Xe,Me+=fe*Je,je+=fe*Ze,We+=fe*st,ze+=fe*at,Ae+=fe*ct,Pe+=fe*lt,Ie+=fe*ut,ge+=fe*ht,Se+=fe*dt,Fe+=fe*ft,fe=$e[9],Le+=fe*it,De+=fe*nt,Be+=fe*et,Oe+=fe*tt,Ge+=fe*Qe,Me+=fe*Xe,je+=fe*Je,We+=fe*Ze,ze+=fe*st,Ae+=fe*at,Pe+=fe*ct,Ie+=fe*lt,ge+=fe*ut,Se+=fe*ht,Fe+=fe*dt,He+=fe*ft,fe=$e[10],De+=fe*it,Be+=fe*nt,Oe+=fe*et,Ge+=fe*tt,Me+=fe*Qe,je+=fe*Xe,We+=fe*Je,ze+=fe*Ze,Ae+=fe*st,Pe+=fe*at,Ie+=fe*ct,ge+=fe*lt,Se+=fe*ut,Fe+=fe*ht,He+=fe*dt,qe+=fe*ft,fe=$e[11],Be+=fe*it,Oe+=fe*nt,Ge+=fe*et,Me+=fe*tt,je+=fe*Qe,We+=fe*Xe,ze+=fe*Je,Ae+=fe*Ze,Pe+=fe*st,Ie+=fe*at,ge+=fe*ct,Se+=fe*lt,Fe+=fe*ut,He+=fe*ht,qe+=fe*dt,Ye+=fe*ft,fe=$e[12],Oe+=fe*it,Ge+=fe*nt,Me+=fe*et,je+=fe*tt,We+=fe*Qe,ze+=fe*Xe,Ae+=fe*Je,Pe+=fe*Ze,Ie+=fe*st,ge+=fe*at,Se+=fe*ct,Fe+=fe*lt,He+=fe*ut,qe+=fe*ht,Ye+=fe*dt,rt+=fe*ft,fe=$e[13],Ge+=fe*it,Me+=fe*nt,je+=fe*et,We+=fe*tt,ze+=fe*Qe,Ae+=fe*Xe,Pe+=fe*Je,Ie+=fe*Ze,ge+=fe*st,Se+=fe*at,Fe+=fe*ct,He+=fe*lt,qe+=fe*ut,Ye+=fe*ht,rt+=fe*dt,ot+=fe*ft,fe=$e[14],Me+=fe*it,je+=fe*nt,We+=fe*et,ze+=fe*tt,Ae+=fe*Qe,Pe+=fe*Xe,Ie+=fe*Je,ge+=fe*Ze,Se+=fe*st,Fe+=fe*at,He+=fe*ct,qe+=fe*lt,Ye+=fe*ut,rt+=fe*ht,ot+=fe*dt,pt+=fe*ft,fe=$e[15],je+=fe*it,We+=fe*nt,ze+=fe*et,Ae+=fe*tt,Pe+=fe*Qe,Ie+=fe*Xe,ge+=fe*Je,Se+=fe*Ze,Fe+=fe*st,He+=fe*at,qe+=fe*ct,Ye+=fe*lt,rt+=fe*ut,ot+=fe*ht,pt+=fe*dt,gt+=fe*ft,ke+=38*We,Ne+=38*ze,xe+=38*Ae,Ue+=38*Pe,Ke+=38*Ie,Te+=38*ge,Ce+=38*Se,Ve+=38*Fe,Re+=38*He,Le+=38*qe,De+=38*Ye,Be+=38*rt,Oe+=38*ot,Ge+=38*pt,Me+=38*gt,Ee=1,fe=ke+Ee+65535,Ee=Math.floor(fe/65536),ke=fe-Ee*65536,fe=Ne+Ee+65535,Ee=Math.floor(fe/65536),Ne=fe-Ee*65536,fe=xe+Ee+65535,Ee=Math.floor(fe/65536),xe=fe-Ee*65536,fe=Ue+Ee+65535,Ee=Math.floor(fe/65536),Ue=fe-Ee*65536,fe=Ke+Ee+65535,Ee=Math.floor(fe/65536),Ke=fe-Ee*65536,fe=Te+Ee+65535,Ee=Math.floor(fe/65536),Te=fe-Ee*65536,fe=Ce+Ee+65535,Ee=Math.floor(fe/65536),Ce=fe-Ee*65536,fe=Ve+Ee+65535,Ee=Math.floor(fe/65536),Ve=fe-Ee*65536,fe=Re+Ee+65535,Ee=Math.floor(fe/65536),Re=fe-Ee*65536,fe=Le+Ee+65535,Ee=Math.floor(fe/65536),Le=fe-Ee*65536,fe=De+Ee+65535,Ee=Math.floor(fe/65536),De=fe-Ee*65536,fe=Be+Ee+65535,Ee=Math.floor(fe/65536),Be=fe-Ee*65536,fe=Oe+Ee+65535,Ee=Math.floor(fe/65536),Oe=fe-Ee*65536,fe=Ge+Ee+65535,Ee=Math.floor(fe/65536),Ge=fe-Ee*65536,fe=Me+Ee+65535,Ee=Math.floor(fe/65536),Me=fe-Ee*65536,fe=je+Ee+65535,Ee=Math.floor(fe/65536),je=fe-Ee*65536,ke+=Ee-1+37*(Ee-1),Ee=1,fe=ke+Ee+65535,Ee=Math.floor(fe/65536),ke=fe-Ee*65536,fe=Ne+Ee+65535,Ee=Math.floor(fe/65536),Ne=fe-Ee*65536,fe=xe+Ee+65535,Ee=Math.floor(fe/65536),xe=fe-Ee*65536,fe=Ue+Ee+65535,Ee=Math.floor(fe/65536),Ue=fe-Ee*65536,fe=Ke+Ee+65535,Ee=Math.floor(fe/65536),Ke=fe-Ee*65536,fe=Te+Ee+65535,Ee=Math.floor(fe/65536),Te=fe-Ee*65536,fe=Ce+Ee+65535,Ee=Math.floor(fe/65536),Ce=fe-Ee*65536,fe=Ve+Ee+65535,Ee=Math.floor(fe/65536),Ve=fe-Ee*65536,fe=Re+Ee+65535,Ee=Math.floor(fe/65536),Re=fe-Ee*65536,fe=Le+Ee+65535,Ee=Math.floor(fe/65536),Le=fe-Ee*65536,fe=De+Ee+65535,Ee=Math.floor(fe/65536),De=fe-Ee*65536,fe=Be+Ee+65535,Ee=Math.floor(fe/65536),Be=fe-Ee*65536,fe=Oe+Ee+65535,Ee=Math.floor(fe/65536),Oe=fe-Ee*65536,fe=Ge+Ee+65535,Ee=Math.floor(fe/65536),Ge=fe-Ee*65536,fe=Me+Ee+65535,Ee=Math.floor(fe/65536),Me=fe-Ee*65536,fe=je+Ee+65535,Ee=Math.floor(fe/65536),je=fe-Ee*65536,ke+=Ee-1+37*(Ee-1),we[0]=ke,we[1]=Ne,we[2]=xe,we[3]=Ue,we[4]=Ke,we[5]=Te,we[6]=Ce,we[7]=Ve,we[8]=Re,we[9]=Le,we[10]=De,we[11]=Be,we[12]=Oe,we[13]=Ge,we[14]=Me,we[15]=je}function de(we,$e){he(we,$e,$e)}function ue(we,$e){const ve=te();for(let fe=0;fe<16;fe++)ve[fe]=$e[fe];for(let fe=253;fe>=0;fe--)de(ve,ve),fe!==2&&fe!==4&&he(ve,ve,$e);for(let fe=0;fe<16;fe++)we[fe]=ve[fe]}function pe(we,$e){const ve=new Uint8Array(32),fe=new Float64Array(80),Ee=te(),ke=te(),Ne=te(),xe=te(),Ue=te(),Ke=te();for(let Re=0;Re<31;Re++)ve[Re]=we[Re];ve[31]=we[31]&127|64,ve[0]&=248,ae(fe,$e);for(let Re=0;Re<16;Re++)ke[Re]=fe[Re];Ee[0]=xe[0]=1;for(let Re=254;Re>=0;--Re){const Le=ve[Re>>>3]>>>(Re&7)&1;se(Ee,ke,Le),se(Ne,xe,Le),ce(Ue,Ee,Ne),le(Ee,Ee,Ne),ce(Ne,ke,xe),le(ke,ke,xe),de(xe,Ue),de(Ke,Ee),he(Ee,Ne,Ee),he(Ne,ke,Ue),ce(Ue,Ee,Ne),le(Ee,Ee,Ne),de(ke,Ee),le(Ne,xe,Ke),he(Ee,Ne,ne),ce(Ee,Ee,xe),he(Ne,Ne,Ee),he(Ee,xe,Ke),he(xe,ke,fe),de(ke,Ue),se(Ee,ke,Le),se(Ne,xe,Le)}for(let Re=0;Re<16;Re++)fe[Re+16]=Ee[Re],fe[Re+32]=Ne[Re],fe[Re+48]=ke[Re],fe[Re+64]=xe[Re];const Te=fe.subarray(32),Ce=fe.subarray(16);ue(Te,Te),he(Ce,Ce,Te);const Ve=new Uint8Array(32);return oe(Ve,Ce),Ve}J.scalarMult=pe;function ye(we){return pe(we,re)}J.scalarMultBase=ye;function me(we){if(we.length!==J.SECRET_KEY_LENGTH)throw new Error(`x25519: seed must be ${J.SECRET_KEY_LENGTH} bytes`);const $e=new Uint8Array(we);return{publicKey:ye($e),secretKey:$e}}J.generateKeyPairFromSeed=me;function be(we){const $e=(0,E.randomBytes)(32,we),ve=me($e);return(0,ee.wipe)($e),ve}J.generateKeyPair=be;function _e(we,$e,ve=!1){if(we.length!==J.PUBLIC_KEY_LENGTH)throw new Error("X25519: incorrect secret key length");if($e.length!==J.PUBLIC_KEY_LENGTH)throw new Error("X25519: incorrect public key length");const fe=pe(we,$e);if(ve){let Ee=0;for(let ke=0;ke<fe.length;ke++)Ee|=fe[ke];if(Ee===0)throw new Error("X25519: invalid shared key")}return fe}J.sharedKey=_e})(x25519);const pureJsCrypto={hashSHA256(J){return sha256(J)},getHKDF(J,E){const ee=hkdf(sha256,E,J,void 0,96),te=ee.subarray(0,32),re=ee.subarray(32,64),ne=ee.subarray(64,96);return[te,re,ne]},generateX25519KeyPair(){const J=x25519.generateKeyPair();return{publicKey:J.publicKey,privateKey:J.secretKey}},generateX25519KeyPairFromSeed(J){const E=x25519.generateKeyPairFromSeed(J);return{publicKey:E.publicKey,privateKey:E.secretKey}},generateX25519SharedKey(J,E){return x25519.sharedKey(J,E)},chaCha20Poly1305Encrypt(J,E,ee,te){return new chacha20poly1305.ChaCha20Poly1305(te).seal(E,J,ee)},chaCha20Poly1305Decrypt(J,E,ee,te,re){return new chacha20poly1305.ChaCha20Poly1305(te).open(E,J,ee,re)}},allocUnsafe$2=J=>globalThis.Buffer?globalThis.Buffer.allocUnsafe(J):new Uint8Array(J),uint16BEEncode=J=>{const E=allocUnsafe$2(2);return new DataView(E.buffer,E.byteOffset,E.byteLength).setUint16(0,J,!1),E};uint16BEEncode.bytes=2;const uint16BEDecode=J=>{if(J.length<2)throw RangeError("Could not decode int16BE");return J instanceof Uint8Array?new DataView(J.buffer,J.byteOffset,J.byteLength).getUint16(0,!1):J.getUint16(0)};uint16BEDecode.bytes=2;function encode0(J){return concat$3([J.ne,J.ciphertext],J.ne.length+J.ciphertext.length)}function encode1(J){return concat$3([J.ne,J.ns,J.ciphertext],J.ne.length+J.ns.length+J.ciphertext.length)}function encode2(J){return concat$3([J.ns,J.ciphertext],J.ns.length+J.ciphertext.length)}function decode0(J){if(J.length<32)throw new Error("Cannot decode stage 0 MessageBuffer: length less than 32 bytes.");return{ne:J.subarray(0,32),ciphertext:J.subarray(32,J.length),ns:new Uint8Array(0)}}function decode1(J){if(J.length<80)throw new Error("Cannot decode stage 1 MessageBuffer: length less than 80 bytes.");return{ne:J.subarray(0,32),ns:J.subarray(32,80),ciphertext:J.subarray(80,J.length)}}function decode2(J){if(J.length<48)throw new Error("Cannot decode stage 2 MessageBuffer: length less than 48 bytes.");return{ne:new Uint8Array(0),ns:J.subarray(0,48),ciphertext:J.subarray(48,J.length)}}function encryptStream(J,E){return async function*(ee){for await(const te of ee)for(let re=0;re<te.length;re+=NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG){let ne=re+NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;ne>te.length&&(ne=te.length);const ie=J.encrypt(te.subarray(re,ne),J.session);E?.encryptedPackets.increment(),yield uint16BEEncode(ie.byteLength),yield ie}}}function decryptStream(J,E){return async function*(ee){for await(const te of ee)for(let re=0;re<te.length;re+=NOISE_MSG_MAX_LENGTH_BYTES){let ne=re+NOISE_MSG_MAX_LENGTH_BYTES;if(ne>te.length&&(ne=te.length),ne-chacha20poly1305.TAG_LENGTH<re)throw new Error("Invalid chunk");const ie=te.subarray(re,ne),se=te.subarray(re,ne-chacha20poly1305.TAG_LENGTH),{plaintext:oe,valid:ae}=J.decrypt(ie,J.session,se);if(!ae)throw E?.decryptErrors.increment(),new Error("Failed to validate decrypted chunk");E?.decryptedPackets.increment(),yield oe}}}class UnexpectedPeerError extends Error{code;constructor(E="Unexpected Peer"){super(E),this.code=UnexpectedPeerError.code}static code="ERR_UNEXPECTED_PEER"}class InvalidCryptoExchangeError extends Error{code;constructor(E="Invalid crypto exchange"){super(E),this.code=InvalidCryptoExchangeError.code}static code="ERR_INVALID_CRYPTO_EXCHANGE"}var NoiseExtensions;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{if(re.lengthDelimited!==!1&&te.fork(),ee.webtransportCerthashes!=null)for(const ne of ee.webtransportCerthashes)te.uint32(10),te.bytes(ne);re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={webtransportCerthashes:[]},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.webtransportCerthashes.push(ee.bytes());break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage(ee,J.codec())})(NoiseExtensions||(NoiseExtensions={}));var NoiseHandshakePayload;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{re.lengthDelimited!==!1&&te.fork(),(re.writeDefaults===!0||ee.identityKey!=null&&ee.identityKey.byteLength>0)&&(te.uint32(10),te.bytes(ee.identityKey??new Uint8Array(0))),(re.writeDefaults===!0||ee.identitySig!=null&&ee.identitySig.byteLength>0)&&(te.uint32(18),te.bytes(ee.identitySig??new Uint8Array(0))),ee.extensions!=null&&(te.uint32(34),NoiseExtensions.codec().encode(ee.extensions,te,{writeDefaults:!1})),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={identityKey:new Uint8Array(0),identitySig:new Uint8Array(0)},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.identityKey=ee.bytes();break;case 2:re.identitySig=ee.bytes();break;case 4:re.extensions=NoiseExtensions.codec().decode(ee,ee.uint32());break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage(ee,J.codec())})(NoiseHandshakePayload||(NoiseHandshakePayload={}));async function getPayload(J,E,ee){const te=await signPayload(J,getHandshakePayload(E));if(J.publicKey==null)throw new Error("PublicKey was missing from local PeerId");return createHandshakePayload(J.publicKey,te,ee)}function createHandshakePayload(J,E,ee){return NoiseHandshakePayload.encode({identityKey:J,identitySig:E,extensions:ee??{webtransportCerthashes:[]}}).subarray()}async function signPayload(J,E){if(J.privateKey==null)throw new Error("PrivateKey was missing from PeerId");return(await unmarshalPrivateKey(J.privateKey)).sign(E)}async function getPeerIdFromPayload(J){return peerIdFromKeys(J.identityKey)}function decodePayload(J){return NoiseHandshakePayload.decode(J)}function getHandshakePayload(J){const E=fromString$4("noise-libp2p-static-key:");return concat$3([E,J],E.length+J.length)}async function verifySignedPayload(J,E,ee){const te=await peerIdFromKeys(E.identityKey);if(!te.equals(ee))throw new Error(`Payload identity key ${te.toString()} does not match expected remote peer ${ee.toString()}`);const re=getHandshakePayload(J);if(te.publicKey==null)throw new Error("PublicKey was missing from PeerId");if(E.identitySig==null)throw new Error("Signature was missing from message");if(!await unmarshalPublicKey(te.publicKey).verify(re,E.identitySig))throw new Error("Static key doesn't match to peer that signed payload!");return te}function isValidPublicKey(J){return!(!(J instanceof Uint8Array)||J.length!==32)}const log$c=logger("libp2p:noise");let keyLogger;DUMP_SESSION_KEYS?keyLogger=log$c:keyLogger=Object.assign(()=>{},{enabled:!1,trace:()=>{},error:()=>{}});function logLocalStaticKeys(J){keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${toString$4(J.publicKey,"hex")}`),keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${toString$4(J.privateKey,"hex")}`)}function logLocalEphemeralKeys(J){J?(keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${toString$4(J.publicKey,"hex")}`),keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${toString$4(J.privateKey,"hex")}`)):keyLogger("Missing local ephemeral keys.")}function logRemoteStaticKey(J){keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${toString$4(J,"hex")}`)}function logRemoteEphemeralKey(J){keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${toString$4(J,"hex")}`)}function logCipherState(J){J.cs1&&J.cs2?(keyLogger(`CIPHER_STATE_1 ${J.cs1.n.getUint64()} ${toString$4(J.cs1.k,"hex")}`),keyLogger(`CIPHER_STATE_2 ${J.cs2.n.getUint64()} ${toString$4(J.cs2.k,"hex")}`)):keyLogger("Missing cipher state.")}const MIN_NONCE=0,MAX_NONCE=4294967295,ERR_MAX_NONCE="Cipherstate has reached maximum n, a new handshake must be performed";class Nonce{n;bytes;view;constructor(E=MIN_NONCE){this.n=E,this.bytes=new Uint8Array(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,E,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>MAX_NONCE)throw new Error(ERR_MAX_NONCE)}}class AbstractHandshake{crypto;constructor(E){this.crypto=E}encryptWithAd(E,ee,te){const re=this.encrypt(E.k,E.n,ee,te);return E.n.increment(),re}decryptWithAd(E,ee,te,re){const{plaintext:ne,valid:ie}=this.decrypt(E.k,E.n,ee,te,re);return ie&&E.n.increment(),{plaintext:ne,valid:ie}}hasKey(E){return!this.isEmptyKey(E.k)}createEmptyKey(){return new Uint8Array(32)}isEmptyKey(E){const ee=this.createEmptyKey();return equals(ee,E)}encrypt(E,ee,te,re){return ee.assertValue(),this.crypto.chaCha20Poly1305Encrypt(re,ee.getBytes(),te,E)}encryptAndHash(E,ee){let te;return this.hasKey(E.cs)?te=this.encryptWithAd(E.cs,E.h,ee):te=ee,this.mixHash(E,te),te}decrypt(E,ee,te,re,ne){ee.assertValue();const ie=this.crypto.chaCha20Poly1305Decrypt(re,ee.getBytes(),te,E,ne);return ie?{plaintext:ie,valid:!0}:{plaintext:new Uint8Array(0),valid:!1}}decryptAndHash(E,ee){let te,re=!0;return this.hasKey(E.cs)?{plaintext:te,valid:re}=this.decryptWithAd(E.cs,E.h,ee):te=ee,this.mixHash(E,ee),{plaintext:te,valid:re}}dh(E,ee){try{const te=this.crypto.generateX25519SharedKey(E,ee);return te.length===32?te:te.subarray(0,32)}catch(te){const re=te;return log$c.error(re),new Uint8Array(32)}}mixHash(E,ee){E.h=this.getHash(E.h,ee)}getHash(E,ee){return this.crypto.hashSHA256(concat$3([E,ee],E.length+ee.length))}mixKey(E,ee){const[te,re]=this.crypto.getHKDF(E.ck,ee);E.cs=this.initializeKey(re),E.ck=te}initializeKey(E){return{k:E,n:new Nonce}}initializeSymmetric(E){const ee=fromString$4(E,"utf-8"),te=this.hashProtocolName(ee),re=te,ne=this.createEmptyKey();return{cs:this.initializeKey(ne),ck:re,h:te}}hashProtocolName(E){if(E.length<=32){const ee=new Uint8Array(32);return ee.set(E),ee}else return this.getHash(E,new Uint8Array(0))}split(E){const[ee,te]=this.crypto.getHKDF(E.ck,new Uint8Array(0)),re=this.initializeKey(ee),ne=this.initializeKey(te);return{cs1:re,cs2:ne}}writeMessageRegular(E,ee){const te=this.encryptWithAd(E,new Uint8Array(0),ee),re=this.createEmptyKey(),ne=new Uint8Array(0);return{ne:re,ns:ne,ciphertext:te}}readMessageRegular(E,ee){return this.decryptWithAd(E,new Uint8Array(0),ee.ciphertext)}}class XX extends AbstractHandshake{initializeInitiator(E,ee,te,re){const ne="Noise_XX_25519_ChaChaPoly_SHA256",ie=this.initializeSymmetric(ne);this.mixHash(ie,E);const se=new Uint8Array(32);return{ss:ie,s:ee,rs:te,psk:re,re:se}}initializeResponder(E,ee,te,re){const ne="Noise_XX_25519_ChaChaPoly_SHA256",ie=this.initializeSymmetric(ne);this.mixHash(ie,E);const se=new Uint8Array(32);return{ss:ie,s:ee,rs:te,psk:re,re:se}}writeMessageA(E,ee,te){const re=new Uint8Array(0);te!==void 0?E.e=te:E.e=this.crypto.generateX25519KeyPair();const ne=E.e.publicKey;this.mixHash(E.ss,ne);const ie=this.encryptAndHash(E.ss,ee);return{ne,ns:re,ciphertext:ie}}writeMessageB(E,ee){E.e=this.crypto.generateX25519KeyPair();const te=E.e.publicKey;this.mixHash(E.ss,te),this.mixKey(E.ss,this.dh(E.e.privateKey,E.re));const re=E.s.publicKey,ne=this.encryptAndHash(E.ss,re);this.mixKey(E.ss,this.dh(E.s.privateKey,E.re));const ie=this.encryptAndHash(E.ss,ee);return{ne:te,ns:ne,ciphertext:ie}}writeMessageC(E,ee){const te=E.s.publicKey,re=this.encryptAndHash(E.ss,te);this.mixKey(E.ss,this.dh(E.s.privateKey,E.re));const ne=this.encryptAndHash(E.ss,ee),ie={ne:this.createEmptyKey(),ns:re,ciphertext:ne},{cs1:se,cs2:oe}=this.split(E.ss);return{h:E.ss.h,messageBuffer:ie,cs1:se,cs2:oe}}readMessageA(E,ee){return isValidPublicKey(ee.ne)&&(E.re=ee.ne),this.mixHash(E.ss,E.re),this.decryptAndHash(E.ss,ee.ciphertext)}readMessageB(E,ee){if(isValidPublicKey(ee.ne)&&(E.re=ee.ne),this.mixHash(E.ss,E.re),!E.e)throw new Error("Handshake state `e` param is missing.");this.mixKey(E.ss,this.dh(E.e.privateKey,E.re));const{plaintext:te,valid:re}=this.decryptAndHash(E.ss,ee.ns);re&&isValidPublicKey(te)&&(E.rs=te),this.mixKey(E.ss,this.dh(E.e.privateKey,E.rs));const{plaintext:ne,valid:ie}=this.decryptAndHash(E.ss,ee.ciphertext);return{plaintext:ne,valid:re&&ie}}readMessageC(E,ee){const{plaintext:te,valid:re}=this.decryptAndHash(E.ss,ee.ns);if(re&&isValidPublicKey(te)&&(E.rs=te),!E.e)throw new Error("Handshake state `e` param is missing.");this.mixKey(E.ss,this.dh(E.e.privateKey,E.rs));const{plaintext:ne,valid:ie}=this.decryptAndHash(E.ss,ee.ciphertext),{cs1:se,cs2:oe}=this.split(E.ss);return{h:E.ss.h,plaintext:ne,valid:re&&ie,cs1:se,cs2:oe}}initSession(E,ee,te){const re=this.createEmptyKey(),ne=new Uint8Array(32);let ie;return E?ie=this.initializeInitiator(ee,te,ne,re):ie=this.initializeResponder(ee,te,ne,re),{hs:ie,i:E,mc:0}}sendMessage(E,ee,te){let re;if(E.mc===0)re=this.writeMessageA(E.hs,ee,te);else if(E.mc===1)re=this.writeMessageB(E.hs,ee);else if(E.mc===2){const{h:ne,messageBuffer:ie,cs1:se,cs2:oe}=this.writeMessageC(E.hs,ee);re=ie,E.h=ne,E.cs1=se,E.cs2=oe}else if(E.mc>2)if(E.i){if(!E.cs1)throw new Error("CS1 (cipher state) is not defined");re=this.writeMessageRegular(E.cs1,ee)}else{if(!E.cs2)throw new Error("CS2 (cipher state) is not defined");re=this.writeMessageRegular(E.cs2,ee)}else throw new Error("Session invalid.");return E.mc++,re}recvMessage(E,ee){let te=new Uint8Array(0),re=!1;if(E.mc===0)({plaintext:te,valid:re}=this.readMessageA(E.hs,ee));else if(E.mc===1)({plaintext:te,valid:re}=this.readMessageB(E.hs,ee));else if(E.mc===2){const{h:ne,plaintext:ie,valid:se,cs1:oe,cs2:ae}=this.readMessageC(E.hs,ee);te=ie,re=se,E.h=ne,E.cs1=oe,E.cs2=ae}return E.mc++,{plaintext:te,valid:re}}}class XXHandshake{isInitiator;session;remotePeer;remoteExtensions={webtransportCerthashes:[]};payload;connection;xx;staticKeypair;prologue;constructor(E,ee,te,re,ne,ie,se,oe){this.isInitiator=E,this.payload=ee,this.prologue=te,this.staticKeypair=ne,this.connection=ie,se&&(this.remotePeer=se),this.xx=oe??new XX(re),this.session=this.xx.initSession(this.isInitiator,this.prologue,this.staticKeypair)}async propose(){if(logLocalStaticKeys(this.session.hs.s),this.isInitiator){log$c.trace("Stage 0 - Initiator starting to send first message.");const E=this.xx.sendMessage(this.session,new Uint8Array(0));this.connection.writeLP(encode0(E)),log$c.trace("Stage 0 - Initiator finished sending first message."),logLocalEphemeralKeys(this.session.hs.e)}else{log$c.trace("Stage 0 - Responder waiting to receive first message...");const E=decode0((await this.connection.readLP()).subarray()),{valid:ee}=this.xx.recvMessage(this.session,E);if(!ee)throw new InvalidCryptoExchangeError("xx handshake stage 0 validation fail");log$c.trace("Stage 0 - Responder received first message."),logRemoteEphemeralKey(this.session.hs.re)}}async exchange(){if(this.isInitiator){log$c.trace("Stage 1 - Initiator waiting to receive first message from responder...");const E=decode1((await this.connection.readLP()).subarray()),{plaintext:ee,valid:te}=this.xx.recvMessage(this.session,E);if(!te)throw new InvalidCryptoExchangeError("xx handshake stage 1 validation fail");log$c.trace("Stage 1 - Initiator received the message."),logRemoteEphemeralKey(this.session.hs.re),logRemoteStaticKey(this.session.hs.rs),log$c.trace("Initiator going to check remote's signature...");try{const re=decodePayload(ee);this.remotePeer=this.remotePeer||await getPeerIdFromPayload(re),await verifySignedPayload(this.session.hs.rs,re,this.remotePeer),this.setRemoteNoiseExtension(re.extensions)}catch(re){const ne=re;throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${ne.message}`)}log$c.trace("All good with the signature!")}else{log$c.trace("Stage 1 - Responder sending out first message with signed payload and static key.");const E=this.xx.sendMessage(this.session,this.payload);this.connection.writeLP(encode1(E)),log$c.trace("Stage 1 - Responder sent the second handshake message with signed payload."),logLocalEphemeralKeys(this.session.hs.e)}}async finish(){if(this.isInitiator){log$c.trace("Stage 2 - Initiator sending third handshake message.");const E=this.xx.sendMessage(this.session,this.payload);this.connection.writeLP(encode2(E)),log$c.trace("Stage 2 - Initiator sent message with signed payload.")}else{log$c.trace("Stage 2 - Responder waiting for third handshake message...");const E=decode2((await this.connection.readLP()).subarray()),{plaintext:ee,valid:te}=this.xx.recvMessage(this.session,E);if(!te)throw new InvalidCryptoExchangeError("xx handshake stage 2 validation fail");log$c.trace("Stage 2 - Responder received the message, finished handshake.");try{const re=decodePayload(ee);this.remotePeer=this.remotePeer||await getPeerIdFromPayload(re),await verifySignedPayload(this.session.hs.rs,re,this.remotePeer),this.setRemoteNoiseExtension(re.extensions)}catch(re){const ne=re;throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${ne.message}`)}}logCipherState(this.session)}encrypt(E,ee){const te=this.getCS(ee);return this.xx.encryptWithAd(te,new Uint8Array(0),E)}decrypt(E,ee,te){const re=this.getCS(ee,!1);return this.xx.decryptWithAd(re,new Uint8Array(0),E,te)}getRemoteStaticKey(){return this.session.hs.rs}getCS(E,ee=!0){if(!E.cs1||!E.cs2)throw new InvalidCryptoExchangeError("Handshake not completed properly, cipher state does not exist.");return this.isInitiator?ee?E.cs1:E.cs2:ee?E.cs2:E.cs1}setRemoteNoiseExtension(E){E&&(this.remoteExtensions=E)}}function registerMetrics(J){return{xxHandshakeSuccesses:J.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:J.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:J.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:J.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:J.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}class Noise{protocol="/noise";crypto;prologue;staticKeys;extensions;metrics;constructor(E={}){const{staticNoiseKey:ee,extensions:te,crypto:re,prologueBytes:ne,metrics:ie}=E;this.crypto=re??pureJsCrypto,this.extensions=te,this.metrics=ie?registerMetrics(ie):void 0,ee?this.staticKeys=this.crypto.generateX25519KeyPairFromSeed(ee):this.staticKeys=this.crypto.generateX25519KeyPair(),this.prologue=ne??new Uint8Array(0)}async secureOutbound(E,ee,te){const re=pbStream(ee,{lengthEncoder:uint16BEEncode,lengthDecoder:uint16BEDecode,maxDataLength:NOISE_MSG_MAX_LENGTH_BYTES}),ne=await this.performHandshake({connection:re,isInitiator:!0,localPeer:E,remotePeer:te});return{conn:await this.createSecureConnection(re,ne),remoteExtensions:ne.remoteExtensions,remotePeer:ne.remotePeer}}async secureInbound(E,ee,te){const re=pbStream(ee,{lengthEncoder:uint16BEEncode,lengthDecoder:uint16BEDecode,maxDataLength:NOISE_MSG_MAX_LENGTH_BYTES}),ne=await this.performHandshake({connection:re,isInitiator:!1,localPeer:E,remotePeer:te});return{conn:await this.createSecureConnection(re,ne),remotePeer:ne.remotePeer,remoteExtensions:ne.remoteExtensions}}async performHandshake(E){const ee=await getPayload(E.localPeer,this.staticKeys.publicKey,this.extensions);return this.performXXHandshake(E,ee)}async performXXHandshake(E,ee){const{isInitiator:te,remotePeer:re,connection:ne}=E,ie=new XXHandshake(te,ee,this.prologue,this.crypto,this.staticKeys,ne,re);try{await ie.propose(),await ie.exchange(),await ie.finish(),this.metrics?.xxHandshakeSuccesses.increment()}catch(se){if(this.metrics?.xxHandshakeErrors.increment(),se instanceof Error)throw se.message=`Error occurred during XX handshake: ${se.message}`,se}return ie}async createSecureConnection(E,ee){const[te,re]=duplexPair(),ne=E.unwrap();return await pipe(te,encryptStream(ee,this.metrics),ne,ie=>decode$6(ie,{lengthDecoder:uint16BEDecode}),decryptStream(ee,this.metrics),te),re}}function noise(J={}){return()=>new Noise(J)}var src$3={exports:{}};function base$2(J){if(J.length>=255)throw new TypeError("Alphabet too long");for(var E=new Uint8Array(256),ee=0;ee<E.length;ee++)E[ee]=255;for(var te=0;te<J.length;te++){var re=J.charAt(te),ne=re.charCodeAt(0);if(E[ne]!==255)throw new TypeError(re+" is ambiguous");E[ne]=te}var ie=J.length,se=J.charAt(0),oe=Math.log(ie)/Math.log(256),ae=Math.log(256)/Math.log(ie);function ce(de){if(de instanceof Uint8Array||(ArrayBuffer.isView(de)?de=new Uint8Array(de.buffer,de.byteOffset,de.byteLength):Array.isArray(de)&&(de=Uint8Array.from(de))),!(de instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(de.length===0)return"";for(var ue=0,pe=0,ye=0,me=de.length;ye!==me&&de[ye]===0;)ye++,ue++;for(var be=(me-ye)*ae+1>>>0,_e=new Uint8Array(be);ye!==me;){for(var we=de[ye],$e=0,ve=be-1;(we!==0||$e<pe)&&ve!==-1;ve--,$e++)we+=256*_e[ve]>>>0,_e[ve]=we%ie>>>0,we=we/ie>>>0;if(we!==0)throw new Error("Non-zero carry");pe=$e,ye++}for(var fe=be-pe;fe!==be&&_e[fe]===0;)fe++;for(var Ee=se.repeat(ue);fe<be;++fe)Ee+=J.charAt(_e[fe]);return Ee}function le(de){if(typeof de!="string")throw new TypeError("Expected String");if(de.length===0)return new Uint8Array;var ue=0;if(de[ue]!==" "){for(var pe=0,ye=0;de[ue]===se;)pe++,ue++;for(var me=(de.length-ue)*oe+1>>>0,be=new Uint8Array(me);de[ue];){var _e=E[de.charCodeAt(ue)];if(_e===255)return;for(var we=0,$e=me-1;(_e!==0||we<ye)&&$e!==-1;$e--,we++)_e+=ie*be[$e]>>>0,be[$e]=_e%256>>>0,_e=_e/256>>>0;if(_e!==0)throw new Error("Non-zero carry");ye=we,ue++}if(de[ue]!==" "){for(var ve=me-ye;ve!==me&&be[ve]===0;)ve++;for(var fe=new Uint8Array(pe+(me-ve)),Ee=pe;ve!==me;)fe[Ee++]=be[ve++];return fe}}}function he(de){var ue=le(de);if(ue)return ue;throw new Error("Non-base"+ie+" character")}return{encode:ce,decodeUnsafe:le,decode:he}}var src$2=base$2;const textDecoder=new TextDecoder,decodeText$1=J=>textDecoder.decode(J),textEncoder=new TextEncoder,encodeText$2=J=>textEncoder.encode(J);function concat$2(J,E){const ee=new Uint8Array(E);let te=0;for(const re of J)ee.set(re,te),te+=re.length;return ee}var util={decodeText:decodeText$1,encodeText:encodeText$2,concat:concat$2};const{encodeText:encodeText$1}=util;let Base$1=class{constructor(J,E,ee,te){this.name=J,this.code=E,this.codeBuf=encodeText$1(this.code),this.alphabet=te,this.codec=ee(te)}encode(J){return this.codec.encode(J)}decode(J){for(const E of J)if(this.alphabet&&this.alphabet.indexOf(E)<0)throw new Error(`invalid character '${E}' in '${J}'`);return this.codec.decode(J)}};var base$1=Base$1;const decode$5=(J,E,ee)=>{const te={};for(let ae=0;ae<E.length;++ae)te[E[ae]]=ae;let re=J.length;for(;J[re-1]==="=";)--re;const ne=new Uint8Array(re*ee/8|0);let ie=0,se=0,oe=0;for(let ae=0;ae<re;++ae){const ce=te[J[ae]];if(ce===void 0)throw new SyntaxError("Invalid character "+J[ae]);se=se<<ee|ce,ie+=ee,ie>=8&&(ie-=8,ne[oe++]=255&se>>ie)}if(ie>=ee||255&se<<8-ie)throw new SyntaxError("Unexpected end of data");return ne},encode$6=(J,E,ee)=>{const te=E[E.length-1]==="=",re=(1<<ee)-1;let ne="",ie=0,se=0;for(let oe=0;oe<J.length;++oe)for(se=se<<8|J[oe],ie+=8;ie>ee;)ie-=ee,ne+=E[re&se>>ie];if(ie&&(ne+=E[re&se<<ee-ie]),te)for(;ne.length*ee&7;)ne+="=";return ne},rfc4648$2=J=>E=>({encode(ee){return encode$6(ee,E,J)},decode(ee){return decode$5(ee,E,J)}});var rfc4648_1={rfc4648:rfc4648$2};const baseX$1=src$2,Base=base$1,{rfc4648:rfc4648$1}=rfc4648_1,{decodeText,encodeText}=util,identity$1=()=>({encode:decodeText,decode:encodeText}),constants$1=[["identity","\0",identity$1,""],["base2","0",rfc4648$1(1),"01"],["base8","7",rfc4648$1(3),"01234567"],["base10","9",baseX$1,"0123456789"],["base16","f",rfc4648$1(4),"0123456789abcdef"],["base16upper","F",rfc4648$1(4),"0123456789ABCDEF"],["base32hex","v",rfc4648$1(5),"0123456789abcdefghijklmnopqrstuv"],["base32hexupper","V",rfc4648$1(5),"0123456789ABCDEFGHIJKLMNOPQRSTUV"],["base32hexpad","t",rfc4648$1(5),"0123456789abcdefghijklmnopqrstuv="],["base32hexpadupper","T",rfc4648$1(5),"0123456789ABCDEFGHIJKLMNOPQRSTUV="],["base32","b",rfc4648$1(5),"abcdefghijklmnopqrstuvwxyz234567"],["base32upper","B",rfc4648$1(5),"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"],["base32pad","c",rfc4648$1(5),"abcdefghijklmnopqrstuvwxyz234567="],["base32padupper","C",rfc4648$1(5),"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567="],["base32z","h",rfc4648$1(5),"ybndrfg8ejkmcpqxot1uwisza345h769"],["base36","k",baseX$1,"0123456789abcdefghijklmnopqrstuvwxyz"],["base36upper","K",baseX$1,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"],["base58btc","z",baseX$1,"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],["base58flickr","Z",baseX$1,"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],["base64","m",rfc4648$1(6),"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],["base64pad","M",rfc4648$1(6),"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="],["base64url","u",rfc4648$1(6),"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"],["base64urlpad","U",rfc4648$1(6),"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]],names$2=constants$1.reduce((J,E)=>(J[E[0]]=new Base(E[0],E[1],E[2],E[3]),J),{}),codes$1=constants$1.reduce((J,E)=>(J[E[1]]=names$2[E[0]],J),{});var constants_1={names:names$2,codes:codes$1};(function(J,E){const ee=constants_1,{encodeText:te,decodeText:re,concat:ne}=util;function ie(pe,ye){if(!ye)throw new Error("requires an encoded Uint8Array");const{name:me,codeBuf:be}=le(pe);return ce(me,ye),ne([be,ye],be.length+ye.length)}function se(pe,ye){const me=le(pe),be=te(me.encode(ye));return ne([me.codeBuf,be],me.codeBuf.length+be.length)}function oe(pe){pe instanceof Uint8Array&&(pe=re(pe));const ye=pe[0];return["f","F","v","V","t","T","b","B","c","C","h","k","K"].includes(ye)&&(pe=pe.toLowerCase()),le(pe[0]).decode(pe.substring(1))}function ae(pe){if(pe instanceof Uint8Array&&(pe=re(pe)),Object.prototype.toString.call(pe)!=="[object String]")return!1;try{return le(pe[0]).name}catch{return!1}}function ce(pe,ye){le(pe).decode(re(ye))}function le(pe){if(Object.prototype.hasOwnProperty.call(ee.names,pe))return ee.names[pe];if(Object.prototype.hasOwnProperty.call(ee.codes,pe))return ee.codes[pe];throw new Error(`Unsupported encoding: ${pe}`)}function he(pe){return pe instanceof Uint8Array&&(pe=re(pe)),le(pe[0])}E=J.exports=ie,E.encode=se,E.decode=oe,E.isEncoded=ae,E.encoding=le,E.encodingFromData=he;const de=Object.freeze(ee.names),ue=Object.freeze(ee.codes);E.names=de,E.codes=ue})(src$3,src$3.exports);var srcExports=src$3.exports,encode_1=encode$5,MSB$2=128,REST$2=127,MSBALL=~REST$2,INT=Math.pow(2,31);function encode$5(J,E,ee){E=E||[],ee=ee||0;for(var te=ee;J>=INT;)E[ee++]=J&255|MSB$2,J/=128;for(;J&MSBALL;)E[ee++]=J&255|MSB$2,J>>>=7;return E[ee]=J|0,encode$5.bytes=ee-te+1,E}var decode$4=read,MSB$1=128,REST$1=127;function read(J,te){var ee=0,te=te||0,re=0,ne=te,ie,se=J.length;do{if(ne>=se)throw read.bytes=0,new RangeError("Could not decode varint");ie=J[ne++],ee+=re<28?(ie&REST$1)<<re:(ie&REST$1)*Math.pow(2,re),re+=7}while(ie>=MSB$1);return read.bytes=ne-te,ee}var N1=Math.pow(2,7),N2=Math.pow(2,14),N3=Math.pow(2,21),N4=Math.pow(2,28),N5=Math.pow(2,35),N6=Math.pow(2,42),N7=Math.pow(2,49),N8=Math.pow(2,56),N9=Math.pow(2,63),length=function(J){return J<N1?1:J<N2?2:J<N3?3:J<N4?4:J<N5?5:J<N6?6:J<N7?7:J<N8?8:J<N9?9:10},varint$1={encode:encode_1,decode:decode$4,encodingLength:length};const names$1=Object.freeze({identity:0,sha1:17,"sha2-256":18,"sha2-512":19,"sha3-512":20,"sha3-384":21,"sha3-256":22,"sha3-224":23,"shake-128":24,"shake-256":25,"keccak-224":26,"keccak-256":27,"keccak-384":28,"keccak-512":29,blake3:30,"murmur3-128":34,"murmur3-32":35,"dbl-sha2-256":86,md4:212,md5:213,bmt:214,"sha2-256-trunc254-padded":4114,"ripemd-128":4178,"ripemd-160":4179,"ripemd-256":4180,"ripemd-320":4181,x11:4352,kangarootwelve:7425,"sm3-256":21325,"blake2b-8":45569,"blake2b-16":45570,"blake2b-24":45571,"blake2b-32":45572,"blake2b-40":45573,"blake2b-48":45574,"blake2b-56":45575,"blake2b-64":45576,"blake2b-72":45577,"blake2b-80":45578,"blake2b-88":45579,"blake2b-96":45580,"blake2b-104":45581,"blake2b-112":45582,"blake2b-120":45583,"blake2b-128":45584,"blake2b-136":45585,"blake2b-144":45586,"blake2b-152":45587,"blake2b-160":45588,"blake2b-168":45589,"blake2b-176":45590,"blake2b-184":45591,"blake2b-192":45592,"blake2b-200":45593,"blake2b-208":45594,"blake2b-216":45595,"blake2b-224":45596,"blake2b-232":45597,"blake2b-240":45598,"blake2b-248":45599,"blake2b-256":45600,"blake2b-264":45601,"blake2b-272":45602,"blake2b-280":45603,"blake2b-288":45604,"blake2b-296":45605,"blake2b-304":45606,"blake2b-312":45607,"blake2b-320":45608,"blake2b-328":45609,"blake2b-336":45610,"blake2b-344":45611,"blake2b-352":45612,"blake2b-360":45613,"blake2b-368":45614,"blake2b-376":45615,"blake2b-384":45616,"blake2b-392":45617,"blake2b-400":45618,"blake2b-408":45619,"blake2b-416":45620,"blake2b-424":45621,"blake2b-432":45622,"blake2b-440":45623,"blake2b-448":45624,"blake2b-456":45625,"blake2b-464":45626,"blake2b-472":45627,"blake2b-480":45628,"blake2b-488":45629,"blake2b-496":45630,"blake2b-504":45631,"blake2b-512":45632,"blake2s-8":45633,"blake2s-16":45634,"blake2s-24":45635,"blake2s-32":45636,"blake2s-40":45637,"blake2s-48":45638,"blake2s-56":45639,"blake2s-64":45640,"blake2s-72":45641,"blake2s-80":45642,"blake2s-88":45643,"blake2s-96":45644,"blake2s-104":45645,"blake2s-112":45646,"blake2s-120":45647,"blake2s-128":45648,"blake2s-136":45649,"blake2s-144":45650,"blake2s-152":45651,"blake2s-160":45652,"blake2s-168":45653,"blake2s-176":45654,"blake2s-184":45655,"blake2s-192":45656,"blake2s-200":45657,"blake2s-208":45658,"blake2s-216":45659,"blake2s-224":45660,"blake2s-232":45661,"blake2s-240":45662,"blake2s-248":45663,"blake2s-256":45664,"skein256-8":45825,"skein256-16":45826,"skein256-24":45827,"skein256-32":45828,"skein256-40":45829,"skein256-48":45830,"skein256-56":45831,"skein256-64":45832,"skein256-72":45833,"skein256-80":45834,"skein256-88":45835,"skein256-96":45836,"skein256-104":45837,"skein256-112":45838,"skein256-120":45839,"skein256-128":45840,"skein256-136":45841,"skein256-144":45842,"skein256-152":45843,"skein256-160":45844,"skein256-168":45845,"skein256-176":45846,"skein256-184":45847,"skein256-192":45848,"skein256-200":45849,"skein256-208":45850,"skein256-216":45851,"skein256-224":45852,"skein256-232":45853,"skein256-240":45854,"skein256-248":45855,"skein256-256":45856,"skein512-8":45857,"skein512-16":45858,"skein512-24":45859,"skein512-32":45860,"skein512-40":45861,"skein512-48":45862,"skein512-56":45863,"skein512-64":45864,"skein512-72":45865,"skein512-80":45866,"skein512-88":45867,"skein512-96":45868,"skein512-104":45869,"skein512-112":45870,"skein512-120":45871,"skein512-128":45872,"skein512-136":45873,"skein512-144":45874,"skein512-152":45875,"skein512-160":45876,"skein512-168":45877,"skein512-176":45878,"skein512-184":45879,"skein512-192":45880,"skein512-200":45881,"skein512-208":45882,"skein512-216":45883,"skein512-224":45884,"skein512-232":45885,"skein512-240":45886,"skein512-248":45887,"skein512-256":45888,"skein512-264":45889,"skein512-272":45890,"skein512-280":45891,"skein512-288":45892,"skein512-296":45893,"skein512-304":45894,"skein512-312":45895,"skein512-320":45896,"skein512-328":45897,"skein512-336":45898,"skein512-344":45899,"skein512-352":45900,"skein512-360":45901,"skein512-368":45902,"skein512-376":45903,"skein512-384":45904,"skein512-392":45905,"skein512-400":45906,"skein512-408":45907,"skein512-416":45908,"skein512-424":45909,"skein512-432":45910,"skein512-440":45911,"skein512-448":45912,"skein512-456":45913,"skein512-464":45914,"skein512-472":45915,"skein512-480":45916,"skein512-488":45917,"skein512-496":45918,"skein512-504":45919,"skein512-512":45920,"skein1024-8":45921,"skein1024-16":45922,"skein1024-24":45923,"skein1024-32":45924,"skein1024-40":45925,"skein1024-48":45926,"skein1024-56":45927,"skein1024-64":45928,"skein1024-72":45929,"skein1024-80":45930,"skein1024-88":45931,"skein1024-96":45932,"skein1024-104":45933,"skein1024-112":45934,"skein1024-120":45935,"skein1024-128":45936,"skein1024-136":45937,"skein1024-144":45938,"skein1024-152":45939,"skein1024-160":45940,"skein1024-168":45941,"skein1024-176":45942,"skein1024-184":45943,"skein1024-192":45944,"skein1024-200":45945,"skein1024-208":45946,"skein1024-216":45947,"skein1024-224":45948,"skein1024-232":45949,"skein1024-240":45950,"skein1024-248":45951,"skein1024-256":45952,"skein1024-264":45953,"skein1024-272":45954,"skein1024-280":45955,"skein1024-288":45956,"skein1024-296":45957,"skein1024-304":45958,"skein1024-312":45959,"skein1024-320":45960,"skein1024-328":45961,"skein1024-336":45962,"skein1024-344":45963,"skein1024-352":45964,"skein1024-360":45965,"skein1024-368":45966,"skein1024-376":45967,"skein1024-384":45968,"skein1024-392":45969,"skein1024-400":45970,"skein1024-408":45971,"skein1024-416":45972,"skein1024-424":45973,"skein1024-432":45974,"skein1024-440":45975,"skein1024-448":45976,"skein1024-456":45977,"skein1024-464":45978,"skein1024-472":45979,"skein1024-480":45980,"skein1024-488":45981,"skein1024-496":45982,"skein1024-504":45983,"skein1024-512":45984,"skein1024-520":45985,"skein1024-528":45986,"skein1024-536":45987,"skein1024-544":45988,"skein1024-552":45989,"skein1024-560":45990,"skein1024-568":45991,"skein1024-576":45992,"skein1024-584":45993,"skein1024-592":45994,"skein1024-600":45995,"skein1024-608":45996,"skein1024-616":45997,"skein1024-624":45998,"skein1024-632":45999,"skein1024-640":46e3,"skein1024-648":46001,"skein1024-656":46002,"skein1024-664":46003,"skein1024-672":46004,"skein1024-680":46005,"skein1024-688":46006,"skein1024-696":46007,"skein1024-704":46008,"skein1024-712":46009,"skein1024-720":46010,"skein1024-728":46011,"skein1024-736":46012,"skein1024-744":46013,"skein1024-752":46014,"skein1024-760":46015,"skein1024-768":46016,"skein1024-776":46017,"skein1024-784":46018,"skein1024-792":46019,"skein1024-800":46020,"skein1024-808":46021,"skein1024-816":46022,"skein1024-824":46023,"skein1024-832":46024,"skein1024-840":46025,"skein1024-848":46026,"skein1024-856":46027,"skein1024-864":46028,"skein1024-872":46029,"skein1024-880":46030,"skein1024-888":46031,"skein1024-896":46032,"skein1024-904":46033,"skein1024-912":46034,"skein1024-920":46035,"skein1024-928":46036,"skein1024-936":46037,"skein1024-944":46038,"skein1024-952":46039,"skein1024-960":46040,"skein1024-968":46041,"skein1024-976":46042,"skein1024-984":46043,"skein1024-992":46044,"skein1024-1000":46045,"skein1024-1008":46046,"skein1024-1016":46047,"skein1024-1024":46048,"poseidon-bls12_381-a2-fc1":46081,"poseidon-bls12_381-a2-fc1-sc":46082});var constants={names:names$1};function base(J,E){if(J.length>=255)throw new TypeError("Alphabet too long");for(var ee=new Uint8Array(256),te=0;te<ee.length;te++)ee[te]=255;for(var re=0;re<J.length;re++){var ne=J.charAt(re),ie=ne.charCodeAt(0);if(ee[ie]!==255)throw new TypeError(ne+" is ambiguous");ee[ie]=re}var se=J.length,oe=J.charAt(0),ae=Math.log(se)/Math.log(256),ce=Math.log(256)/Math.log(se);function le(ue){if(ue instanceof Uint8Array||(ArrayBuffer.isView(ue)?ue=new Uint8Array(ue.buffer,ue.byteOffset,ue.byteLength):Array.isArray(ue)&&(ue=Uint8Array.from(ue))),!(ue instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(ue.length===0)return"";for(var pe=0,ye=0,me=0,be=ue.length;me!==be&&ue[me]===0;)me++,pe++;for(var _e=(be-me)*ce+1>>>0,we=new Uint8Array(_e);me!==be;){for(var $e=ue[me],ve=0,fe=_e-1;($e!==0||ve<ye)&&fe!==-1;fe--,ve++)$e+=256*we[fe]>>>0,we[fe]=$e%se>>>0,$e=$e/se>>>0;if($e!==0)throw new Error("Non-zero carry");ye=ve,me++}for(var Ee=_e-ye;Ee!==_e&&we[Ee]===0;)Ee++;for(var ke=oe.repeat(pe);Ee<_e;++Ee)ke+=J.charAt(we[Ee]);return ke}function he(ue){if(typeof ue!="string")throw new TypeError("Expected String");if(ue.length===0)return new Uint8Array;var pe=0;if(ue[pe]!==" "){for(var ye=0,me=0;ue[pe]===oe;)ye++,pe++;for(var be=(ue.length-pe)*ae+1>>>0,_e=new Uint8Array(be);ue[pe];){var we=ee[ue.charCodeAt(pe)];if(we===255)return;for(var $e=0,ve=be-1;(we!==0||$e<me)&&ve!==-1;ve--,$e++)we+=se*_e[ve]>>>0,_e[ve]=we%256>>>0,we=we/256>>>0;if(we!==0)throw new Error("Non-zero carry");me=$e,pe++}if(ue[pe]!==" "){for(var fe=be-me;fe!==be&&_e[fe]===0;)fe++;for(var Ee=new Uint8Array(ye+(be-fe)),ke=ye;fe!==be;)Ee[ke++]=_e[fe++];return Ee}}}function de(ue){var pe=he(ue);if(pe)return pe;throw new Error(`Non-${E} character`)}return{encode:le,decodeUnsafe:he,decode:de}}var src$1=base,_brrp__multiformats_scope_baseX=src$1;const coerce=J=>{if(J instanceof Uint8Array&&J.constructor.name==="Uint8Array")return J;if(J instanceof ArrayBuffer)return new Uint8Array(J);if(ArrayBuffer.isView(J))return new Uint8Array(J.buffer,J.byteOffset,J.byteLength);throw new Error("Unknown type, must be binary type")},fromString$2=J=>new TextEncoder().encode(J),toString$2=J=>new TextDecoder().decode(J);let Encoder$1=class{constructor(J,E,ee){this.name=J,this.prefix=E,this.baseEncode=ee}encode(J){if(J instanceof Uint8Array)return`${this.prefix}${this.baseEncode(J)}`;throw Error("Unknown type, must be binary type")}},Decoder$1=class{constructor(J,E,ee){if(this.name=J,this.prefix=E,E.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=E.codePointAt(0),this.baseDecode=ee}decode(J){if(typeof J=="string"){if(J.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(J)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(J.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(J){return or(this,J)}};class ComposedDecoder{constructor(E){this.decoders=E}or(E){return or(this,E)}decode(E){const ee=E[0],te=this.decoders[ee];if(te)return te.decode(E);throw RangeError(`Unable to decode multibase string ${JSON.stringify(E)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const or=(J,E)=>new ComposedDecoder({...J.decoders||{[J.prefix]:J},...E.decoders||{[E.prefix]:E}});class Codec{constructor(E,ee,te,re){this.name=E,this.prefix=ee,this.baseEncode=te,this.baseDecode=re,this.encoder=new Encoder$1(E,ee,te),this.decoder=new Decoder$1(E,ee,re)}encode(E){return this.encoder.encode(E)}decode(E){return this.decoder.decode(E)}}const from=({name:J,prefix:E,encode:ee,decode:te})=>new Codec(J,E,ee,te),baseX=({prefix:J,name:E,alphabet:ee})=>{const{encode:te,decode:re}=_brrp__multiformats_scope_baseX(ee,E);return from({prefix:J,name:E,encode:te,decode:ne=>coerce(re(ne))})},decode$3=(J,E,ee,te)=>{const re={};for(let ce=0;ce<E.length;++ce)re[E[ce]]=ce;let ne=J.length;for(;J[ne-1]==="=";)--ne;const ie=new Uint8Array(ne*ee/8|0);let se=0,oe=0,ae=0;for(let ce=0;ce<ne;++ce){const le=re[J[ce]];if(le===void 0)throw new SyntaxError(`Non-${te} character`);oe=oe<<ee|le,se+=ee,se>=8&&(se-=8,ie[ae++]=255&oe>>se)}if(se>=ee||255&oe<<8-se)throw new SyntaxError("Unexpected end of data");return ie},encode$4=(J,E,ee)=>{const te=E[E.length-1]==="=",re=(1<<ee)-1;let ne="",ie=0,se=0;for(let oe=0;oe<J.length;++oe)for(se=se<<8|J[oe],ie+=8;ie>ee;)ie-=ee,ne+=E[re&se>>ie];if(ie&&(ne+=E[re&se<<ee-ie]),te)for(;ne.length*ee&7;)ne+="=";return ne},rfc4648=({name:J,prefix:E,bitsPerChar:ee,alphabet:te})=>from({prefix:E,name:J,encode(re){return encode$4(re,te,ee)},decode(re){return decode$3(re,te,ee,J)}}),identity=from({prefix:"\0",name:"identity",encode:J=>toString$2(J),decode:J=>fromString$2(J)}),identityBase=Object.freeze(Object.defineProperty({__proto__:null,identity},Symbol.toStringTag,{value:"Module"})),base2=rfc4648({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),base2$1=Object.freeze(Object.defineProperty({__proto__:null,base2},Symbol.toStringTag,{value:"Module"})),base8=rfc4648({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),base8$1=Object.freeze(Object.defineProperty({__proto__:null,base8},Symbol.toStringTag,{value:"Module"})),base10=baseX({prefix:"9",name:"base10",alphabet:"0123456789"}),base10$1=Object.freeze(Object.defineProperty({__proto__:null,base10},Symbol.toStringTag,{value:"Module"})),base16=rfc4648({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),base16upper=rfc4648({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),base16$1=Object.freeze(Object.defineProperty({__proto__:null,base16,base16upper},Symbol.toStringTag,{value:"Module"})),base32=rfc4648({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),base32upper=rfc4648({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),base32pad=rfc4648({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),base32padupper=rfc4648({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),base32hex=rfc4648({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),base32hexupper=rfc4648({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),base32hexpad=rfc4648({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),base32hexpadupper=rfc4648({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),base32z=rfc4648({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),base32$1=Object.freeze(Object.defineProperty({__proto__:null,base32,base32hex,base32hexpad,base32hexpadupper,base32hexupper,base32pad,base32padupper,base32upper,base32z},Symbol.toStringTag,{value:"Module"})),base36=baseX({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),base36upper=baseX({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),base36$1=Object.freeze(Object.defineProperty({__proto__:null,base36,base36upper},Symbol.toStringTag,{value:"Module"})),base58btc=baseX({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),base58flickr=baseX({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),base58=Object.freeze(Object.defineProperty({__proto__:null,base58btc,base58flickr},Symbol.toStringTag,{value:"Module"})),base64=rfc4648({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),base64pad=rfc4648({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),base64url=rfc4648({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),base64urlpad=rfc4648({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),base64$1=Object.freeze(Object.defineProperty({__proto__:null,base64,base64pad,base64url,base64urlpad},Symbol.toStringTag,{value:"Module"})),alphabet=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),alphabetBytesToChars=alphabet.reduce((J,E,ee)=>(J[ee]=E,J),[]),alphabetCharsToBytes=alphabet.reduce((J,E,ee)=>(J[E.codePointAt(0)]=ee,J),[]);function encode$3(J){return J.reduce((E,ee)=>(E+=alphabetBytesToChars[ee],E),"")}function decode$2(J){const E=[];for(const ee of J){const te=alphabetCharsToBytes[ee.codePointAt(0)];if(te===void 0)throw new Error(`Non-base256emoji character: ${ee}`);E.push(te)}return new Uint8Array(E)}const base256emoji=from({prefix:"🚀",name:"base256emoji",encode:encode$3,decode:decode$2}),base256emoji$1=Object.freeze(Object.defineProperty({__proto__:null,base256emoji},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const bases={...identityBase,...base2$1,...base8$1,...base10$1,...base16$1,...base32$1,...base36$1,...base58,...base64$1,...base256emoji$1};function asUint8Array(J){return globalThis.Buffer!=null?new Uint8Array(J.buffer,J.byteOffset,J.byteLength):J}function allocUnsafe$1(J=0){return globalThis.Buffer!=null&&globalThis.Buffer.allocUnsafe!=null?asUint8Array(globalThis.Buffer.allocUnsafe(J)):new Uint8Array(J)}function createCodec(J,E,ee,te){return{name:J,prefix:E,encoder:{name:J,prefix:E,encode:ee},decoder:{decode:te}}}const string=createCodec("utf8","u",J=>"u"+new TextDecoder("utf8").decode(J),J=>new TextEncoder().encode(J.substring(1))),ascii=createCodec("ascii","a",J=>{let E="a";for(let ee=0;ee<J.length;ee++)E+=String.fromCharCode(J[ee]);return E},J=>{J=J.substring(1);const E=allocUnsafe$1(J.length);for(let ee=0;ee<J.length;ee++)E[ee]=J.charCodeAt(ee);return E}),BASES={utf8:string,"utf-8":string,hex:bases.base16,latin1:ascii,ascii,binary:ascii,...bases};function toString(J,E="utf8"){const ee=BASES[E];if(!ee)throw new Error(`Unsupported encoding "${E}"`);return(E==="utf8"||E==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(J.buffer,J.byteOffset,J.byteLength).toString("utf8"):ee.encoder.encode(J).substring(1)}const toString$1=Object.freeze(Object.defineProperty({__proto__:null,toString},Symbol.toStringTag,{value:"Module"})),require$$3=getAugmentedNamespace(toString$1);function fromString(J,E="utf8"){const ee=BASES[E];if(!ee)throw new Error(`Unsupported encoding "${E}"`);return(E==="utf8"||E==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?asUint8Array(globalThis.Buffer.from(J,"utf-8")):ee.decoder.decode(`${ee.prefix}${J}`)}const fromString$1=Object.freeze(Object.defineProperty({__proto__:null,fromString},Symbol.toStringTag,{value:"Module"})),require$$4=getAugmentedNamespace(fromString$1);function concat(J,E){E||(E=J.reduce((re,ne)=>re+ne.length,0));const ee=allocUnsafe$1(E);let te=0;for(const re of J)ee.set(re,te),te+=re.length;return asUint8Array(ee)}const concat$1=Object.freeze(Object.defineProperty({__proto__:null,concat},Symbol.toStringTag,{value:"Module"})),require$$5=getAugmentedNamespace(concat$1),multibase=srcExports,varint=varint$1,{names}=constants,{toString:uint8ArrayToString}=require$$3,{fromString:uint8ArrayFromString}=require$$4,{concat:uint8ArrayConcat}=require$$5,codes={};for(const J in names){const E=J;codes[names[E]]=E}Object.freeze(codes);function toHexString(J){if(!(J instanceof Uint8Array))throw new Error("must be passed a Uint8Array");return uint8ArrayToString(J,"base16")}function fromHexString(J){return uint8ArrayFromString(J,"base16")}function toB58String(J){if(!(J instanceof Uint8Array))throw new Error("must be passed a Uint8Array");return uint8ArrayToString(multibase.encode("base58btc",J)).slice(1)}function fromB58String(J){const E=J instanceof Uint8Array?uint8ArrayToString(J):J;return multibase.decode("z"+E)}function decode$1(J){if(!(J instanceof Uint8Array))throw new Error("multihash must be a Uint8Array");if(J.length<2)throw new Error("multihash too short. must be > 2 bytes.");const E=varint.decode(J);if(!isValidCode(E))throw new Error(`multihash unknown function code: 0x${E.toString(16)}`);J=J.slice(varint.decode.bytes);const ee=varint.decode(J);if(ee<0)throw new Error(`multihash invalid length: ${ee}`);if(J=J.slice(varint.decode.bytes),J.length!==ee)throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(J,"base16")}`);return{code:E,name:codes[E],length:ee,digest:J}}function encode$2(J,E,ee){if(!J||E===void 0)throw new Error("multihash encode requires at least two args: digest, code");const te=coerceCode(E);if(!(J instanceof Uint8Array))throw new Error("digest should be a Uint8Array");if(ee==null&&(ee=J.length),ee&&J.length!==ee)throw new Error("digest length should be equal to specified length.");const re=varint.encode(te),ne=varint.encode(ee);return uint8ArrayConcat([re,ne,J],re.length+ne.length+J.length)}function coerceCode(J){let E=J;if(typeof J=="string"){if(names[J]===void 0)throw new Error(`Unrecognized hash function named: ${J}`);E=names[J]}if(typeof E!="number")throw new Error(`Hash function code should be a number. Got: ${E}`);if(codes[E]===void 0&&!isAppCode(E))throw new Error(`Unrecognized function code: ${E}`);return E}function isAppCode(J){return J>0&&J<16}function isValidCode(J){return!!(isAppCode(J)||codes[J])}function validate(J){decode$1(J)}function prefix(J){return validate(J),J.subarray(0,2)}var src={names,codes,toHexString,fromHexString,toB58String,fromB58String,decode:decode$1,encode:encode$2,coerceCode,isAppCode,validate,prefix,isValidCode};const log$b=logger("libp2p:webrtc:sdp"),mbdecoder=Object.values(bases$1).map(J=>J.decoder).reduce((J,E)=>J.or(E));function getLocalFingerprint(J){const E=J.getConfiguration().certificates?.at(0);if(E==null||E.getFingerprints==null){log$b.trace("fetching fingerprint from local SDP");const te=J.localDescription;return te==null?void 0:getFingerprintFromSdp(te.sdp)}if(log$b.trace("fetching fingerprint from local certificate"),E.getFingerprints().length===0)return;const ee=E.getFingerprints()[0].value;if(ee==null)throw invalidFingerprint("","no fingerprint on local certificate");return ee}const fingerprintRegex=/^a=fingerprint:(?:\w+-[0-9]+)\s(?<fingerprint>(:?[0-9a-fA-F]{2})+)$/m;function getFingerprintFromSdp(J){return J.match(fingerprintRegex)?.groups?.fingerprint}function ipv(J){for(const E of J.protoNames())if(E.startsWith("ip"))return E.toUpperCase();return log$b("Warning: multiaddr does not appear to contain IP4 or IP6, defaulting to IP6",J),"IP6"}function certhash(J){const E=J.stringTuples().filter(ee=>ee[0]===CERTHASH_CODE).map(ee=>ee[1])[0];if(E===void 0||E==="")throw inappropriateMultiaddr(`Couldn't find a certhash component of multiaddr: ${J.toString()}`);return E}function decodeCerthash(J){const E=mbdecoder.decode(J);return src.decode(E)}function ma2Fingerprint(J){const E=decodeCerthash(certhash(J)),ee=toSupportedHashFunction(E.name),te=E.digest.reduce((ne,ie)=>ne+ie.toString(16).padStart(2,"0"),""),re=te.match(/.{1,2}/g);if(re==null)throw invalidFingerprint(te,J.toString());return[`${ee.toUpperCase()} ${re.join(":").toUpperCase()}`,te]}function toSupportedHashFunction(J){switch(J){case"sha1":return"sha-1";case"sha2-256":return"sha-256";case"sha2-512":return"sha-512";default:throw unsupportedHashAlgorithm(J)}}function ma2sdp(J,E){const{host:ee,port:te}=J.toOptions(),re=ipv(J),[ne]=ma2Fingerprint(J);return`v=0
o=- 0 0 IN ${re} ${ee}
s=-
c=IN ${re} ${ee}
t=0 0
a=ice-lite
m=application ${te} UDP/DTLS/SCTP webrtc-datachannel
a=mid:0
a=setup:passive
a=ice-ufrag:${E}
a=ice-pwd:${E}
a=fingerprint:${ne}
a=sctp-port:5000
a=max-message-size:100000
a=candidate:1467250027 1 UDP 1467250027 ${ee} ${te} typ host\r
`}function fromMultiAddr(J,E){return{type:"answer",sdp:ma2sdp(J,E)}}function munge(J,E){if(J.sdp===void 0)throw invalidArgument("Can't munge a missing SDP");return J.sdp=J.sdp.replace(/\na=ice-ufrag:[^\n]*\n/,`
a=ice-ufrag:`+E+`
`).replace(/\na=ice-pwd:[^\n]*\n/,`
a=ice-pwd:`+E+`
`),J}const charset=Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),genUfrag=J=>[...Array(J)].map(()=>charset.at(Math.floor(Math.random()*charset.length))).join(""),log$a=logger("libp2p:webrtc:transport"),HANDSHAKE_TIMEOUT_MS=1e4,WEBRTC_CODE=getProtocol("webrtc-direct").code,CERTHASH_CODE=getProtocol("certhash").code;class WebRTCDirectTransport{metrics;components;constructor(E){this.components=E,E.metrics!=null&&(this.metrics={dialerEvents:E.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total",{label:"event",help:"Total count of WebRTC dial events by type"})})}async dial(E,ee){const te=await this._connect(E,ee);return log$a(`dialing address - ${E.toString()}`),te}createListener(E){throw unimplemented("WebRTCTransport.createListener")}filter(E){return E.filter(validMa)}[Symbol.toStringTag]="@libp2p/webrtc-direct";[symbol$2]=!0;async _connect(E,ee){const te=new AbortController,re=te.signal,ne=E.getPeerId();if(ne===null)throw inappropriateMultiaddr("we need to have the remote's PeerId");const ie=peerIdFromString(ne),se=decodeCerthash(certhash(E)),oe=await RTCPeerConnection.generateCertificate({name:"ECDSA",namedCurve:"P-256",hash:toSupportedHashFunction(se.name)}),ae=new RTCPeerConnection({certificates:[oe]}),ce=new Promise((Ee,ke)=>{const Ne=ae.createDataChannel("",{negotiated:!0,id:0}),xe=setTimeout(()=>{const Ue=`Data channel was never opened: state: ${Ne.readyState}`;log$a.error(Ue),this.metrics?.dialerEvents.increment({open_error:!0}),ke(dataChannelError("data",Ue))},HANDSHAKE_TIMEOUT_MS);Ne.onopen=Ue=>{clearTimeout(xe),Ee(Ne)},Ne.onerror=Ue=>{clearTimeout(xe);const Ke=`Error opening a data channel for handshaking: ${Ue.target?.toString()??"not specified"}`;log$a.error(Ke),this.metrics?.dialerEvents.increment({unknown_error:!0}),ke(dataChannelError("data",Ke))}}),le="libp2p+webrtc+v1/"+genUfrag(32),he=await ae.createOffer(),de=munge(he,le);await ae.setLocalDescription(de);const ue=fromMultiAddr(E,le);await ae.setRemoteDescription(ue);const pe=await ce,ye=this.components.peerId,me=this.generateNoisePrologue(ae,se.code,E),be=noise({prologueBytes:me})(),_e=new WebRTCStream({channel:pe,stat:{direction:"inbound",timeline:{open:1}}}),we={..._e,sink:_e.sink.bind(_e),source:async function*(){for await(const Ee of _e.source)for(const ke of Ee)yield ke}()},$e=new WebRTCMultiaddrConnection({peerConnection:ae,remoteAddr:E,timeline:{open:Date.now()},metrics:this.metrics?.dialerEvents}),ve=isFirefox?"iceconnectionstatechange":"connectionstatechange";ae.addEventListener(ve,()=>{switch(ae.connectionState){case"failed":case"disconnected":case"closed":$e.close().catch(Ee=>{log$a.error("error closing connection",Ee)}).finally(()=>{te.abort()});break}},{signal:re}),this.metrics?.dialerEvents.increment({peer_connection:!0});const fe=new DataChannelMuxerFactory(ae,this.metrics?.dialerEvents);return await be.secureInbound(ye,we,ie),ee.upgrader.upgradeOutbound($e,{skipProtection:!0,skipEncryption:!0,muxerFactory:fe})}generateNoisePrologue(E,ee,te){if(E.getConfiguration().certificates?.length===0)throw invalidArgument("no local certificate");const re=getLocalFingerprint(E);if(re==null)throw invalidArgument("no local fingerprint found");const ne=re.trim().toLowerCase().replaceAll(":",""),ie=fromString$4(ne,"hex"),se=src.encode(ie,ee),oe=mbdecoder.decode(certhash(te)),ae=fromString$4("libp2p-webrtc-noise:");return concat$3([ae,se,oe])}}function validMa(J){const E=J.protoCodes();return E.includes(WEBRTC_CODE)&&E.includes(CERTHASH_CODE)&&J.getPeerId()!=null&&!E.includes(getProtocol("p2p-circuit").code)}function webRTCDirect(){return J=>new WebRTCDirectTransport(J)}function webRTC(J){return E=>new WebRTCTransport(E,J??{})}const WebSocket$1=WebSocket;var dom={},eventIterator={};Object.defineProperty(eventIterator,"__esModule",{value:!0});class EventQueue{constructor(){this.pullQueue=[],this.pushQueue=[],this.eventHandlers={},this.isPaused=!1,this.isStopped=!1}push(E){if(this.isStopped)return;const ee={value:E,done:!1};if(this.pullQueue.length){const te=this.pullQueue.shift();te&&te.resolve(ee)}else this.pushQueue.push(Promise.resolve(ee)),this.highWaterMark!==void 0&&this.pushQueue.length>=this.highWaterMark&&!this.isPaused&&(this.isPaused=!0,this.eventHandlers.highWater?this.eventHandlers.highWater():console&&console.warn(`EventIterator queue reached ${this.pushQueue.length} items`))}stop(){if(!this.isStopped){this.isStopped=!0,this.remove();for(const E of this.pullQueue)E.resolve({value:void 0,done:!0});this.pullQueue.length=0}}fail(E){if(!this.isStopped)if(this.isStopped=!0,this.remove(),this.pullQueue.length){for(const ee of this.pullQueue)ee.reject(E);this.pullQueue.length=0}else{const ee=Promise.reject(E);ee.catch(()=>{}),this.pushQueue.push(ee)}}remove(){Promise.resolve().then(()=>{this.removeCallback&&this.removeCallback()})}[Symbol.asyncIterator](){return{next:E=>{const ee=this.pushQueue.shift();return ee?(this.lowWaterMark!==void 0&&this.pushQueue.length<=this.lowWaterMark&&this.isPaused&&(this.isPaused=!1,this.eventHandlers.lowWater&&this.eventHandlers.lowWater()),ee):this.isStopped?Promise.resolve({value:void 0,done:!0}):new Promise((te,re)=>{this.pullQueue.push({resolve:te,reject:re})})},return:()=>(this.isStopped=!0,this.pushQueue.length=0,this.remove(),Promise.resolve({value:void 0,done:!0}))}}}let EventIterator$1=class{constructor(J,{highWaterMark:E=100,lowWaterMark:ee=1}={}){const te=new EventQueue;te.highWaterMark=E,te.lowWaterMark=ee,te.removeCallback=J({push:re=>te.push(re),stop:()=>te.stop(),fail:re=>te.fail(re),on:(re,ne)=>{te.eventHandlers[re]=ne}})||(()=>{}),this[Symbol.asyncIterator]=()=>te[Symbol.asyncIterator](),Object.freeze(this)}};eventIterator.EventIterator=EventIterator$1;eventIterator.default=EventIterator$1;Object.defineProperty(dom,"__esModule",{value:!0});const event_iterator_1=eventIterator;var EventIterator=dom.EventIterator=event_iterator_1.EventIterator;function subscribe(J,E,ee){return new event_iterator_1.EventIterator(({push:te})=>(this.addEventListener(J,te,E),()=>this.removeEventListener(J,te,E)),ee)}dom.subscribe=subscribe;dom.default=event_iterator_1.EventIterator;function isArrayBuffer(J){return J instanceof ArrayBuffer||J?.constructor?.name==="ArrayBuffer"&&typeof J?.byteLength=="number"}const source=J=>{J.binaryType="arraybuffer";const E=async()=>{await new Promise((ne,ie)=>{if(te){ne();return}if(re!=null){ie(re);return}const se=ce=>{J.removeEventListener("open",oe),J.removeEventListener("error",ae),ce()},oe=()=>{se(ne)},ae=ce=>{se(()=>{ie(ce.error??new Error(`connect ECONNREFUSED ${J.url}`))})};J.addEventListener("open",oe),J.addEventListener("error",ae)})},ee=async function*(){const ne=new EventIterator(({push:ie,stop:se,fail:oe})=>{const ae=le=>{let he=null;typeof le.data=="string"&&(he=fromString$4(le.data)),isArrayBuffer(le.data)&&(he=new Uint8Array(le.data)),le.data instanceof Uint8Array&&(he=le.data),he!=null&&ie(he)},ce=le=>{oe(le.error??new Error("Socket error"))};return J.addEventListener("message",ae),J.addEventListener("error",ce),J.addEventListener("close",se),()=>{J.removeEventListener("message",ae),J.removeEventListener("error",ce),J.removeEventListener("close",se)}},{highWaterMark:1/0});await E();for await(const ie of ne)yield isArrayBuffer(ie)?new Uint8Array(ie):ie}();let te=J.readyState===1,re;return J.addEventListener("open",()=>{te=!0,re=null}),J.addEventListener("close",()=>{te=!1,re=null}),J.addEventListener("error",ne=>{te||(re=ne.error??new Error(`connect ECONNREFUSED ${J.url}`))}),Object.assign(ee,{connected:E})},ready=async J=>{if(J.readyState>=2)throw new Error("socket closed");J.readyState!==1&&await new Promise((E,ee)=>{function te(){J.removeEventListener("open",re),J.removeEventListener("error",ne)}function re(){te(),E()}function ne(ie){te(),ee(ie.error??new Error(`connect ECONNREFUSED ${J.url}`))}J.addEventListener("open",re),J.addEventListener("error",ne)})},sink=(J,E)=>(E=E??{},E.closeOnEnd=E.closeOnEnd!==!1,async ee=>{for await(const te of ee){try{await ready(J)}catch(re){if(re.message==="socket closed")break;throw re}J.send(te)}E.closeOnEnd!=null&&J.readyState<=1&&await new Promise((te,re)=>{J.addEventListener("close",ne=>{if(ne.wasClean||ne.code===1006)te();else{const ie=Object.assign(new Error("ws error"),{event:ne});re(ie)}}),setTimeout(()=>{J.close()})})}),duplex=(J,E)=>{E=E??{};const ee=source(J);let te=E.remoteAddress,re=E.remotePort;if(J.url!=null)try{const ne=new URL(J.url);te=ne.hostname,re=parseInt(ne.port,10)}catch{}if(te==null||re==null)throw new Error("Remote connection did not have address and/or port");return{sink:sink(J,E),source:ee,connected:async()=>{await ee.connected()},close:async()=>{(J.readyState===J.CONNECTING||J.readyState===J.OPEN)&&await new Promise(ne=>{J.addEventListener("close",()=>{ne()}),J.close()})},destroy:()=>{J.terminate!=null?J.terminate():J.close()},remoteAddress:te,remotePort:re,socket:J}},isReactNative$1=typeof navigator<"u"&&navigator.product==="ReactNative";function getDefaultBase(){return isReactNative$1?"http://localhost":self.location?self.location.protocol+"//"+self.location.host:""}const URL$1=self.URL,defaultBase$1=getDefaultBase();let URLWithLegacySupport$2=class{constructor(J="",E=defaultBase$1){this.super=new URL$1(J,E),this.path=this.pathname+this.search,this.auth=this.username&&this.password?this.username+":"+this.password:null,this.query=this.search&&this.search.startsWith("?")?this.search.slice(1):null}get hash(){return this.super.hash}get host(){return this.super.host}get hostname(){return this.super.hostname}get href(){return this.super.href}get origin(){return this.super.origin}get password(){return this.super.password}get pathname(){return this.super.pathname}get port(){return this.super.port}get protocol(){return this.super.protocol}get search(){return this.super.search}get searchParams(){return this.super.searchParams}get username(){return this.super.username}set hash(J){this.super.hash=J}set host(J){this.super.host=J}set hostname(J){this.super.hostname=J}set href(J){this.super.href=J}set password(J){this.super.password=J}set pathname(J){this.super.pathname=J}set port(J){this.super.port=J}set protocol(J){this.super.protocol=J}set search(J){this.super.search=J}set username(J){this.super.username=J}static createObjectURL(J){return URL$1.createObjectURL(J)}static revokeObjectURL(J){URL$1.revokeObjectURL(J)}toJSON(){return this.super.toJSON()}toString(){return this.super.toString()}format(){return this.toString()}};function format$2(J){if(typeof J=="string")return new URL$1(J).toString();if(!(J instanceof URL$1)){const E=J.username&&J.password?`${J.username}:${J.password}@`:"",ee=J.auth?J.auth+"@":"",te=J.port?":"+J.port:"",re=J.protocol?J.protocol+"//":"",ne=J.host||"",ie=J.hostname||"",se=J.search||(J.query?"?"+J.query:""),oe=J.hash||"",ae=J.pathname||"",ce=J.path||ae+se;return`${re}${E||ee}${ne||ie+te}${ce}${oe}`}}var urlBrowser={URLWithLegacySupport:URLWithLegacySupport$2,URLSearchParams:self.URLSearchParams,defaultBase:defaultBase$1,format:format$2};const{URLWithLegacySupport:URLWithLegacySupport$1,format:format$1}=urlBrowser;var relative$1=(J,E={},ee={},te)=>{let re=E.protocol?E.protocol.replace(":",""):"http";re=(ee[re]||te||re)+":";let ne;try{ne=new URLWithLegacySupport$1(J)}catch{ne={}}const ie=Object.assign({},E,{protocol:re||ne.protocol,host:E.host||ne.host});return new URLWithLegacySupport$1(J,format$1(ie)).toString()};const{URLWithLegacySupport,format,URLSearchParams,defaultBase}=urlBrowser,relative=relative$1;var isoUrl={URL:URLWithLegacySupport,URLSearchParams,format,relative,defaultBase};const map={http:"ws",https:"wss"},def="ws",wsurl=(J,E)=>isoUrl.relative(J,E,map,def);function connect(J,E){const ee=typeof window>"u"?"":window.location;E=E??{};const te=wsurl(J,ee.toString()),re=new WebSocket$1(te,E.websocket);return duplex(re,E)}const reduceValue=(J,E)=>E,tcpUri=(J,E,ee,te)=>{if(te!=null&&te.assumeHttp===!1)return`tcp://${J}:${E}`;let re="tcp",ne=`:${E}`;return ee[ee.length-1].protocol==="tcp"&&(re=E==="443"?"https":"http",ne=E==="443"||E==="80"?"":ne),`${re}://${J}${ne}`},Reducers={ip4:reduceValue,ip6:(J,E,ee,te)=>te.length===1&&te[0].protocol==="ip6"?E:`[${E}]`,tcp:(J,E,ee,te,re)=>te.some(ne=>["http","https","ws","wss"].includes(ne.protocol))?`${J}:${E}`:tcpUri(J,E,te,re),udp:(J,E)=>`udp://${J}:${E}`,dnsaddr:reduceValue,dns4:reduceValue,dns6:reduceValue,ipfs:(J,E)=>`${J}/ipfs/${E}`,p2p:(J,E)=>`${J}/p2p/${E}`,http:J=>`http://${J}`,https:J=>`https://${J}`,ws:J=>`ws://${J}`,wss:J=>`wss://${J}`,"p2p-websocket-star":J=>`${J}/p2p-websocket-star`,"p2p-webrtc-star":J=>`${J}/p2p-webrtc-star`,"p2p-webrtc-direct":J=>`${J}/p2p-webrtc-direct`};function multiaddrToUri(J,E){const ee=multiaddr(J),te=ee.toString().split("/").slice(1);return ee.tuples().map(re=>({protocol:te.shift()??"",content:re[1]!=null?te.shift()??"":""})).reduce((re,ne,ie,se)=>{const oe=Reducers[ne.protocol];if(oe==null)throw new Error(`Unsupported protocol ${ne.protocol}`);return oe(re,ne.content,ie,se,E)},"")}function isElectron$1(){return!!(typeof window<"u"&&typeof window.process=="object"&&window.process.type==="renderer"||typeof process<"u"&&typeof process.versions=="object"&&process.versions.electron||typeof navigator=="object"&&typeof navigator.userAgent=="string"&&navigator.userAgent.indexOf("Electron")>=0)}var isElectron_1=isElectron$1;const detectElectron=getDefaultExportFromCjs(isElectron_1),isEnvWithDom=typeof window=="object"&&typeof document=="object"&&document.nodeType===9,isElectron=detectElectron(),isBrowser=isEnvWithDom&&!isElectron,isElectronMain=isElectron&&!isEnvWithDom,isElectronRenderer=isElectron&&isEnvWithDom,isNode=typeof globalThis.process<"u"&&typeof globalThis.process.release<"u"&&globalThis.process.release.name==="node"&&!isElectron,isWebWorker=typeof importScripts=="function"&&typeof self<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope;typeof globalThis.process<"u"&&typeof globalThis.process.env<"u"&&globalThis.process.env["NODE"+(()=>"_")()+"ENV"];const isReactNative=typeof navigator<"u"&&navigator.product==="ReactNative";function createListener$1(){throw new Error("WebSocket Servers can not be created in the browser!")}const CODE_P2P=421,CODE_CIRCUIT=290,CLOSE_TIMEOUT=2e3,log$9=logger("libp2p:websockets:socket");function socketToMaConn(J,E,ee){ee=ee??{};const te={async sink(re){ee?.signal!=null&&(re=abortableSource$1(re,ee.signal));try{await J.sink(re)}catch(ne){ne.type!=="aborted"&&log$9.error(ne)}},source:ee.signal!=null?abortableSource$1(J.source,ee.signal):J.source,remoteAddr:E,timeline:{open:Date.now()},async close(){const re=Date.now();try{await pTimeout(J.close(),{milliseconds:CLOSE_TIMEOUT})}catch{const{host:ne,port:ie}=te.remoteAddr.toOptions();log$9("timeout closing stream to %s:%s after %dms, destroying it manually",ne,ie,Date.now()-re),J.destroy()}finally{te.timeline.close=Date.now()}}};return J.socket.addEventListener("close",()=>{te.timeline.close==null&&(te.timeline.close=Date.now())},{once:!0}),te}function all(J){return J.filter(E=>{if(E.protoCodes().includes(CODE_CIRCUIT))return!1;const ee=E.decapsulateCode(CODE_P2P);return WebSockets$1.matches(ee)||WebSocketsSecure.matches(ee)})}function wss(J){return J.filter(E=>{if(E.protoCodes().includes(CODE_CIRCUIT))return!1;const ee=E.decapsulateCode(CODE_P2P);return WebSocketsSecure.matches(ee)})}const log$8=logger("libp2p:websockets");class WebSockets{constructor(E){this.init=E}get[Symbol.toStringTag](){return"@libp2p/websockets"}get[symbol$2](){return!0}async dial(E,ee){log$8("dialing %s",E),ee=ee??{};const te=await this._connect(E,ee),re=socketToMaConn(te,E);log$8("new outbound connection %s",re.remoteAddr);const ne=await ee.upgrader.upgradeOutbound(re);return log$8("outbound connection %s upgraded",re.remoteAddr),ne}async _connect(E,ee){if(ee?.signal?.aborted===!0)throw new AbortError$5;const te=E.toOptions();log$8("dialing %s:%s",te.host,te.port);const re=pDefer(),ne=ae=>{log$8.error("connection error:",ae),re.reject(ae)},ie=connect(multiaddrToUri(E),this.init);if(ie.socket.on!=null?ie.socket.on("error",ne):ie.socket.onerror=ne,ee.signal==null)return await Promise.race([ie.connected(),re.promise]),log$8("connected %s",E),ie;let se;const oe=new Promise((ae,ce)=>{if(se=()=>{ce(new AbortError$5),ie.close().catch(le=>{log$8.error("error closing raw socket",le)})},ee?.signal?.aborted===!0){se();return}ee?.signal?.addEventListener("abort",se)});try{await Promise.race([oe,re.promise,ie.connected()])}finally{se!=null&&ee?.signal?.removeEventListener("abort",se)}return log$8("connected %s",E),ie}createListener(E){return createListener$1({...this.init,...E})}filter(E){return E=Array.isArray(E)?E:[E],this.init?.filter!=null?this.init?.filter(E):isBrowser||isWebWorker?wss(E):all(E)}}function webSockets(J={}){return()=>new WebSockets(J)}function allocUnsafe(J){return new Uint8Array(J)}var MessageTypes;(function(J){J[J.NEW_STREAM=0]="NEW_STREAM",J[J.MESSAGE_RECEIVER=1]="MESSAGE_RECEIVER",J[J.MESSAGE_INITIATOR=2]="MESSAGE_INITIATOR",J[J.CLOSE_RECEIVER=3]="CLOSE_RECEIVER",J[J.CLOSE_INITIATOR=4]="CLOSE_INITIATOR",J[J.RESET_RECEIVER=5]="RESET_RECEIVER",J[J.RESET_INITIATOR=6]="RESET_INITIATOR"})(MessageTypes||(MessageTypes={}));const MessageTypeNames=Object.freeze({0:"NEW_STREAM",1:"MESSAGE_RECEIVER",2:"MESSAGE_INITIATOR",3:"CLOSE_RECEIVER",4:"CLOSE_INITIATOR",5:"RESET_RECEIVER",6:"RESET_INITIATOR"}),InitiatorMessageTypes=Object.freeze({NEW_STREAM:MessageTypes.NEW_STREAM,MESSAGE:MessageTypes.MESSAGE_INITIATOR,CLOSE:MessageTypes.CLOSE_INITIATOR,RESET:MessageTypes.RESET_INITIATOR}),ReceiverMessageTypes=Object.freeze({MESSAGE:MessageTypes.MESSAGE_RECEIVER,CLOSE:MessageTypes.CLOSE_RECEIVER,RESET:MessageTypes.RESET_RECEIVER});function isAsyncIterable(J){return J[Symbol.asyncIterator]!=null}const DEFAULT_BATCH_SIZE=1024*1024,DEFAULT_SERIALIZE=(J,E)=>{E.append(J)};function batchedBytes(J,E){return isAsyncIterable(J)?async function*(){let ee=new Uint8ArrayList,te=!1,re=pDefer(),ne=Number(E?.size??DEFAULT_BATCH_SIZE);if((isNaN(ne)||ne===0||ne<0)&&(ne=DEFAULT_BATCH_SIZE),ne!==Math.round(ne))throw new Error("Batch size must be an integer");const ie=E?.yieldAfter??0,se=E?.serialize??DEFAULT_SERIALIZE;for(Promise.resolve().then(async()=>{try{let oe;for await(const ae of J){if(se(ae,ee),ee.byteLength>=ne){clearTimeout(oe),re.resolve();continue}oe=setTimeout(()=>{re.resolve()},ie)}clearTimeout(oe),re.resolve()}catch(oe){re.reject(oe)}finally{te=!0}});!te;)if(await re.promise,re=pDefer(),ee.byteLength>0){const oe=ee;ee=new Uint8ArrayList,yield oe.subarray()}}():function*(){const ee=new Uint8ArrayList;let te=Number(E?.size??DEFAULT_BATCH_SIZE);if((isNaN(te)||te===0||te<0)&&(te=DEFAULT_BATCH_SIZE),te!==Math.round(te))throw new Error("Batch size must be an integer");const re=E?.serialize??DEFAULT_SERIALIZE;for(const ne of J)re(ne,ee),ee.byteLength>=te&&(yield ee.subarray(0,te),ee.consume(te));ee.byteLength>0&&(yield ee.subarray())}()}const POOL_SIZE=10*1024;class Encoder{constructor(){this._pool=allocUnsafe(POOL_SIZE),this._poolOffset=0}write(E,ee){const te=this._pool;let re=this._poolOffset;varint$3.encode(E.id<<3|E.type,te,re),re+=varint$3.encode.bytes??0,(E.type===MessageTypes.NEW_STREAM||E.type===MessageTypes.MESSAGE_INITIATOR||E.type===MessageTypes.MESSAGE_RECEIVER)&&E.data!=null?varint$3.encode(E.data.length,te,re):varint$3.encode(0,te,re),re+=varint$3.encode.bytes??0;const ne=te.subarray(this._poolOffset,re);POOL_SIZE-re<100?(this._pool=allocUnsafe(POOL_SIZE),this._poolOffset=0):this._poolOffset=re,ee.append(ne),(E.type===MessageTypes.NEW_STREAM||E.type===MessageTypes.MESSAGE_INITIATOR||E.type===MessageTypes.MESSAGE_RECEIVER)&&E.data!=null&&ee.append(E.data)}}const encoder$1=new Encoder;async function*encode$1(J,E=0){if(E==null||E===0){for await(const ee of J){const te=new Uint8ArrayList;for(const re of ee)encoder$1.write(re,te);yield te.subarray()}return}yield*batchedBytes(J,{size:E,serialize:(ee,te)=>{for(const re of ee)encoder$1.write(re,te)}})}const MAX_MSG_SIZE=1<<20,MAX_MSG_QUEUE_SIZE=4<<20;class Decoder{constructor(E=MAX_MSG_SIZE,ee=MAX_MSG_QUEUE_SIZE){this._buffer=new Uint8ArrayList,this._headerInfo=null,this._maxMessageSize=E,this._maxUnprocessedMessageQueueSize=ee}write(E){if(E==null||E.length===0)return[];if(this._buffer.append(E),this._buffer.byteLength>this._maxUnprocessedMessageQueueSize)throw Object.assign(new Error("unprocessed message queue size too large!"),{code:"ERR_MSG_QUEUE_TOO_BIG"});const ee=[];for(;this._buffer.length!==0;){if(this._headerInfo==null)try{this._headerInfo=this._decodeHeader(this._buffer)}catch(oe){if(oe.code==="ERR_MSG_TOO_BIG")throw oe;break}const{id:te,type:re,length:ne,offset:ie}=this._headerInfo;if(this._buffer.length-ie<ne)break;const se={id:te,type:re};(re===MessageTypes.NEW_STREAM||re===MessageTypes.MESSAGE_INITIATOR||re===MessageTypes.MESSAGE_RECEIVER)&&(se.data=this._buffer.sublist(ie,ie+ne)),ee.push(se),this._buffer.consume(ie+ne),this._headerInfo=null}return ee}_decodeHeader(E){const{value:ee,offset:te}=readVarInt(E),{value:re,offset:ne}=readVarInt(E,te),ie=ee&7;if(MessageTypeNames[ie]==null)throw new Error(`Invalid type received: ${ie}`);if(re>this._maxMessageSize)throw Object.assign(new Error("message size too large!"),{code:"ERR_MSG_TOO_BIG"});return{id:ee>>3,type:ie,offset:te+ne,length:re}}}const MSB=128,REST=127;function readVarInt(J,E=0){let ee=0,te=0,re=E,ne;const ie=J.length;do{if(re>=ie||te>49)throw E=0,new RangeError("Could not decode varint");ne=J.get(re++),ee+=te<28?(ne&REST)<<te:(ne&REST)*Math.pow(2,te),te+=7}while(ne>=MSB);return E=re-E,{value:ee,offset:E}}const log$7=logger("libp2p:mplex:stream"),ERR_STREAM_RESET="ERR_STREAM_RESET",ERR_STREAM_ABORT="ERR_STREAM_ABORT",ERR_SINK_ENDED="ERR_SINK_ENDED",ERR_DOUBLE_SINK="ERR_DOUBLE_SINK";function createStream(J){const{id:E,name:ee,send:te,onEnd:re,type:ne="initiator",maxMsgSize:ie=MAX_MSG_SIZE}=J,se=new AbortController,oe=new AbortController,ae=new AbortController,ce=ne==="initiator"?InitiatorMessageTypes:ReceiverMessageTypes,le=ne==="initiator"?`i${E}`:`r${E}`,he=`${ee??E}`;let de=!1,ue=!1,pe=!1,ye;const me={open:Date.now()},be=ve=>{de||(de=!0,log$7.trace("%s stream %s source end - err: %o",ne,he,ve),ve!=null&&ye==null&&(ye=ve),ue&&($e.stat.timeline.close=Date.now(),re?.(ye)))},_e=ve=>{ue||(ue=!0,log$7.trace("%s stream %s sink end - err: %o",ne,he,ve),ve!=null&&ye==null&&(ye=ve),de&&(me.close=Date.now(),re?.(ye)))},we=pushable({onEnd:be}),$e={close:()=>{log$7.trace("%s stream %s close",ne,he),$e.closeRead(),$e.closeWrite()},closeRead:()=>{log$7.trace("%s stream %s closeRead",ne,he),!de&&we.end()},closeWrite:()=>{if(log$7.trace("%s stream %s closeWrite",ne,he),!ue){ae.abort();try{te({id:E,type:ce.CLOSE})}catch(ve){log$7.trace("%s stream %s error sending close",ne,ee,ve)}_e()}},abort:ve=>{log$7.trace("%s stream %s abort",ne,he,ve),we.end(ve),se.abort(),_e(ve)},reset:()=>{const ve=new CodeError("stream reset",ERR_STREAM_RESET);oe.abort(),we.end(ve),_e(ve)},sink:async ve=>{if(pe)throw new CodeError("sink already called on stream",ERR_DOUBLE_SINK);if(pe=!0,ue)throw new CodeError("stream closed for writing",ERR_SINK_ENDED);const fe=anySignal([se.signal,oe.signal,ae.signal]);try{ve=abortableSource$1(ve,fe),ne==="initiator"&&te({id:E,type:InitiatorMessageTypes.NEW_STREAM,data:new Uint8ArrayList(fromString$4(he))});for await(let Ee of ve)for(;Ee.length>0;){if(Ee.length<=ie){te({id:E,type:ce.MESSAGE,data:Ee instanceof Uint8Array?new Uint8ArrayList(Ee):Ee});break}Ee=Ee instanceof Uint8Array?new Uint8ArrayList(Ee):Ee,te({id:E,type:ce.MESSAGE,data:Ee.sublist(0,ie)}),Ee.consume(ie)}}catch(Ee){if(Ee.type==="aborted"&&Ee.message==="The operation was aborted"){if(ae.signal.aborted)return;oe.signal.aborted&&(Ee.message="stream reset",Ee.code=ERR_STREAM_RESET),se.signal.aborted&&(Ee.message="stream aborted",Ee.code=ERR_STREAM_ABORT)}if(Ee.code===ERR_STREAM_RESET)log$7.trace("%s stream %s reset",ne,ee);else{log$7.trace("%s stream %s error",ne,ee,Ee);try{te({id:E,type:ce.RESET})}catch(ke){log$7.trace("%s stream %s error sending reset",ne,ee,ke)}}we.end(Ee),_e(Ee);return}finally{fe.clear()}try{te({id:E,type:ce.CLOSE})}catch(Ee){log$7.trace("%s stream %s error sending close",ne,ee,Ee)}_e()},source:we,sourcePush:ve=>{we.push(ve)},sourceReadableLength(){return we.readableLength},stat:{direction:ne==="initiator"?"outbound":"inbound",timeline:me},metadata:{},id:le};return $e}const log$6=logger("libp2p:mplex"),MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION=1024,MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION=1024,MAX_STREAM_BUFFER_SIZE=1024*1024*4,DISCONNECT_THRESHOLD=5;function printMessage(J){const E={...J,type:`${MessageTypeNames[J.type]} (${J.type})`};return J.type===MessageTypes.NEW_STREAM&&(E.data=toString$4(J.data instanceof Uint8Array?J.data:J.data.subarray())),(J.type===MessageTypes.MESSAGE_INITIATOR||J.type===MessageTypes.MESSAGE_RECEIVER)&&(E.data=toString$4(J.data instanceof Uint8Array?J.data:J.data.subarray(),"base16")),E}class MplexStreamMuxer{constructor(E){this.protocol="/mplex/6.7.0",E=E??{},this._streamId=0,this._streams={initiators:new Map,receivers:new Map},this._init=E,this.sink=this._createSink();const ee=this._createSource();this._source=ee,this.source=ee,this.closeController=new AbortController,this.rateLimiter=new rateLimiterFlexible.RateLimiterMemory({points:E.disconnectThreshold??DISCONNECT_THRESHOLD,duration:1})}get streams(){const E=[];for(const ee of this._streams.initiators.values())E.push(ee);for(const ee of this._streams.receivers.values())E.push(ee);return E}newStream(E){if(this.closeController.signal.aborted)throw new Error("Muxer already closed");const ee=this._streamId++;E=E==null?ee.toString():E.toString();const te=this._streams.initiators;return this._newStream({id:ee,name:E,type:"initiator",registry:te})}close(E){this.closeController.signal.aborted||(E!=null?this.streams.forEach(ee=>{ee.abort(E)}):this.streams.forEach(ee=>{ee.close()}),this.closeController.abort())}_newReceiverStream(E){const{id:ee,name:te}=E,re=this._streams.receivers;return this._newStream({id:ee,name:te,type:"receiver",registry:re})}_newStream(E){const{id:ee,name:te,type:re,registry:ne}=E;if(log$6("new %s stream %s",re,ee),re==="initiator"&&this._streams.initiators.size===(this._init.maxOutboundStreams??MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION))throw new CodeError("Too many outbound streams open","ERR_TOO_MANY_OUTBOUND_STREAMS");if(ne.has(ee))throw new Error(`${re} stream ${ee} already exists!`);const ie=createStream({id:ee,name:te,send:se=>{log$6.enabled&&log$6.trace("%s stream %s send",re,ee,printMessage(se)),this._source.push(se)},type:re,onEnd:()=>{log$6("%s stream with id %s and protocol %s ended",re,ee,ie.stat.protocol),ne.delete(ee),this._init.onStreamEnd!=null&&this._init.onStreamEnd(ie)},maxMsgSize:this._init.maxMsgSize});return ne.set(ee,ie),ie}_createSink(){return async E=>{const ee=anySignal([this.closeController.signal,this._init.signal]);try{E=abortableSource$1(E,ee);const te=new Decoder(this._init.maxMsgSize,this._init.maxUnprocessedMessageQueueSize);for await(const re of E)for(const ne of te.write(re))await this._handleIncoming(ne);this._source.end()}catch(te){log$6("error in sink",te),this._source.end(te)}finally{ee.clear()}}}_createSource(){const E=pushableV({objectMode:!0,onEnd:ee=>{this.close(ee)}});return Object.assign(encode$1(E,this._init.minSendBytes),{push:E.push,end:E.end,return:E.return})}async _handleIncoming(E){const{id:ee,type:te}=E;if(log$6.enabled&&log$6.trace("incoming message",printMessage(E)),E.type===MessageTypes.NEW_STREAM){if(this._streams.receivers.size===(this._init.maxInboundStreams??MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION)){log$6("too many inbound streams open"),this._source.push({id:ee,type:MessageTypes.RESET_RECEIVER});try{await this.rateLimiter.consume("new-stream",1)}catch{log$6("rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection"),this._source.end(new Error("Too many open streams"));return}return}const ie=this._newReceiverStream({id:ee,name:toString$4(E.data instanceof Uint8Array?E.data:E.data.subarray())});this._init.onIncomingStream!=null&&this._init.onIncomingStream(ie);return}const re=((te&1)===1?this._streams.initiators:this._streams.receivers).get(ee);if(re==null){log$6("missing stream %s for message type %s",ee,MessageTypeNames[te]);return}const ne=this._init.maxStreamBufferSize??MAX_STREAM_BUFFER_SIZE;switch(te){case MessageTypes.MESSAGE_INITIATOR:case MessageTypes.MESSAGE_RECEIVER:if(re.sourceReadableLength()>ne){this._source.push({id:E.id,type:te===MessageTypes.MESSAGE_INITIATOR?MessageTypes.RESET_RECEIVER:MessageTypes.RESET_INITIATOR});const ie=new CodeError("Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers","ERR_STREAM_INPUT_BUFFER_FULL");re.abort(ie);return}re.sourcePush(E.data);break;case MessageTypes.CLOSE_INITIATOR:case MessageTypes.CLOSE_RECEIVER:re.closeRead();break;case MessageTypes.RESET_INITIATOR:case MessageTypes.RESET_RECEIVER:re.reset();break;default:log$6("unknown message type %s",te)}}}class Mplex{constructor(E={}){this.protocol="/mplex/6.7.0",this._init=E}createStreamMuxer(E={}){return new MplexStreamMuxer({...E,...this._init})}}function mplex(J={}){return()=>new Mplex(J)}const CIRCUIT_PROTO_CODE=290,RELAY_RENDEZVOUS_NS="/libp2p/relay",DEFAULT_RESERVATION_CONCURRENCY=1,RELAY_TAG="circuit-relay-relay";BigInt(1<<17);const RELAY_V2_HOP_CODEC="/libp2p/circuit/relay/0.2.0/hop",RELAY_V2_STOP_CODEC="/libp2p/circuit/relay/0.2.0/stop";logger("libp2p:circuit-relay:utils");async function namespaceToCid(J){const E=new TextEncoder().encode(J),ee=await sha256$2.digest(E);return CID.createV0(ee)}function getExpirationMilliseconds(J){const E=J*BigInt(1e3);return Number(E-BigInt(new Date().getTime()))}var HopMessage;(function(J){(function(te){te.RESERVE="RESERVE",te.CONNECT="CONNECT",te.STATUS="STATUS"})(J.Type||(J.Type={}));let E;(function(te){te[te.RESERVE=0]="RESERVE",te[te.CONNECT=1]="CONNECT",te[te.STATUS=2]="STATUS"})(E||(E={})),function(te){te.codec=()=>enumeration(E)}(J.Type||(J.Type={}));let ee;J.codec=()=>(ee==null&&(ee=message((te,re,ne={})=>{ne.lengthDelimited!==!1&&re.fork(),te.type!=null&&(re.uint32(8),J.Type.codec().encode(te.type,re)),te.peer!=null&&(re.uint32(18),Peer.codec().encode(te.peer,re)),te.reservation!=null&&(re.uint32(26),Reservation.codec().encode(te.reservation,re)),te.limit!=null&&(re.uint32(34),Limit.codec().encode(te.limit,re)),te.status!=null&&(re.uint32(40),Status.codec().encode(te.status,re)),ne.lengthDelimited!==!1&&re.ldelim()},(te,re)=>{const ne={},ie=re==null?te.len:te.pos+re;for(;te.pos<ie;){const se=te.uint32();switch(se>>>3){case 1:ne.type=J.Type.codec().decode(te);break;case 2:ne.peer=Peer.codec().decode(te,te.uint32());break;case 3:ne.reservation=Reservation.codec().decode(te,te.uint32());break;case 4:ne.limit=Limit.codec().decode(te,te.uint32());break;case 5:ne.status=Status.codec().decode(te);break;default:te.skipType(se&7);break}}return ne})),ee),J.encode=te=>encodeMessage(te,J.codec()),J.decode=te=>decodeMessage(te,J.codec())})(HopMessage||(HopMessage={}));var StopMessage;(function(J){(function(te){te.CONNECT="CONNECT",te.STATUS="STATUS"})(J.Type||(J.Type={}));let E;(function(te){te[te.CONNECT=0]="CONNECT",te[te.STATUS=1]="STATUS"})(E||(E={})),function(te){te.codec=()=>enumeration(E)}(J.Type||(J.Type={}));let ee;J.codec=()=>(ee==null&&(ee=message((te,re,ne={})=>{ne.lengthDelimited!==!1&&re.fork(),te.type!=null&&(re.uint32(8),J.Type.codec().encode(te.type,re)),te.peer!=null&&(re.uint32(18),Peer.codec().encode(te.peer,re)),te.limit!=null&&(re.uint32(26),Limit.codec().encode(te.limit,re)),te.status!=null&&(re.uint32(32),Status.codec().encode(te.status,re)),ne.lengthDelimited!==!1&&re.ldelim()},(te,re)=>{const ne={},ie=re==null?te.len:te.pos+re;for(;te.pos<ie;){const se=te.uint32();switch(se>>>3){case 1:ne.type=J.Type.codec().decode(te);break;case 2:ne.peer=Peer.codec().decode(te,te.uint32());break;case 3:ne.limit=Limit.codec().decode(te,te.uint32());break;case 4:ne.status=Status.codec().decode(te);break;default:te.skipType(se&7);break}}return ne})),ee),J.encode=te=>encodeMessage(te,J.codec()),J.decode=te=>decodeMessage(te,J.codec())})(StopMessage||(StopMessage={}));var Peer;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{if(re.lengthDelimited!==!1&&te.fork(),ee.id!=null&&ee.id.byteLength>0&&(te.uint32(10),te.bytes(ee.id)),ee.addrs!=null)for(const ne of ee.addrs)te.uint32(18),te.bytes(ne);re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={id:new Uint8Array(0),addrs:[]},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.id=ee.bytes();break;case 2:re.addrs.push(ee.bytes());break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage(ee,J.codec())})(Peer||(Peer={}));var Reservation;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{if(re.lengthDelimited!==!1&&te.fork(),ee.expire!=null&&ee.expire!==0n&&(te.uint32(8),te.uint64(ee.expire)),ee.addrs!=null)for(const ne of ee.addrs)te.uint32(18),te.bytes(ne);ee.voucher!=null&&(te.uint32(26),te.bytes(ee.voucher)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={expire:0n,addrs:[]},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.expire=ee.uint64();break;case 2:re.addrs.push(ee.bytes());break;case 3:re.voucher=ee.bytes();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage(ee,J.codec())})(Reservation||(Reservation={}));var Limit;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{re.lengthDelimited!==!1&&te.fork(),ee.duration!=null&&(te.uint32(8),te.uint32(ee.duration)),ee.data!=null&&(te.uint32(16),te.uint64(ee.data)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.duration=ee.uint32();break;case 2:re.data=ee.uint64();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage(ee,J.codec())})(Limit||(Limit={}));var Status;(function(J){J.UNUSED="UNUSED",J.OK="OK",J.RESERVATION_REFUSED="RESERVATION_REFUSED",J.RESOURCE_LIMIT_EXCEEDED="RESOURCE_LIMIT_EXCEEDED",J.PERMISSION_DENIED="PERMISSION_DENIED",J.CONNECTION_FAILED="CONNECTION_FAILED",J.NO_RESERVATION="NO_RESERVATION",J.MALFORMED_MESSAGE="MALFORMED_MESSAGE",J.UNEXPECTED_MESSAGE="UNEXPECTED_MESSAGE"})(Status||(Status={}));var __StatusValues;(function(J){J[J.UNUSED=0]="UNUSED",J[J.OK=100]="OK",J[J.RESERVATION_REFUSED=200]="RESERVATION_REFUSED",J[J.RESOURCE_LIMIT_EXCEEDED=201]="RESOURCE_LIMIT_EXCEEDED",J[J.PERMISSION_DENIED=202]="PERMISSION_DENIED",J[J.CONNECTION_FAILED=203]="CONNECTION_FAILED",J[J.NO_RESERVATION=204]="NO_RESERVATION",J[J.MALFORMED_MESSAGE=400]="MALFORMED_MESSAGE",J[J.UNEXPECTED_MESSAGE=401]="UNEXPECTED_MESSAGE"})(__StatusValues||(__StatusValues={}));(function(J){J.codec=()=>enumeration(__StatusValues)})(Status||(Status={}));var ReservationVoucher;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{re.lengthDelimited!==!1&&te.fork(),ee.relay!=null&&ee.relay.byteLength>0&&(te.uint32(10),te.bytes(ee.relay)),ee.peer!=null&&ee.peer.byteLength>0&&(te.uint32(18),te.bytes(ee.peer)),ee.expiration!=null&&ee.expiration!==0n&&(te.uint32(24),te.uint64(ee.expiration)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={relay:new Uint8Array(0),peer:new Uint8Array(0),expiration:0n},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.relay=ee.bytes();break;case 2:re.peer=ee.bytes();break;case 3:re.expiration=ee.uint64();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage(ee,J.codec())})(ReservationVoucher||(ReservationVoucher={}));var retry={};function RetryOperation(J,E){typeof E=="boolean"&&(E={forever:E}),this._originalTimeouts=JSON.parse(JSON.stringify(J)),this._timeouts=J,this._options=E||{},this._maxRetryTime=E&&E.maxRetryTime||1/0,this._fn=null,this._errors=[],this._attempts=1,this._operationTimeout=null,this._operationTimeoutCb=null,this._timeout=null,this._operationStart=null,this._timer=null,this._options.forever&&(this._cachedTimeouts=this._timeouts.slice(0))}var retry_operation=RetryOperation;RetryOperation.prototype.reset=function(){this._attempts=1,this._timeouts=this._originalTimeouts.slice(0)};RetryOperation.prototype.stop=function(){this._timeout&&clearTimeout(this._timeout),this._timer&&clearTimeout(this._timer),this._timeouts=[],this._cachedTimeouts=null};RetryOperation.prototype.retry=function(J){if(this._timeout&&clearTimeout(this._timeout),!J)return!1;var E=new Date().getTime();if(J&&E-this._operationStart>=this._maxRetryTime)return this._errors.push(J),this._errors.unshift(new Error("RetryOperation timeout occurred")),!1;this._errors.push(J);var ee=this._timeouts.shift();if(ee===void 0)if(this._cachedTimeouts)this._errors.splice(0,this._errors.length-1),ee=this._cachedTimeouts.slice(-1);else return!1;var te=this;return this._timer=setTimeout(function(){te._attempts++,te._operationTimeoutCb&&(te._timeout=setTimeout(function(){te._operationTimeoutCb(te._attempts)},te._operationTimeout),te._options.unref&&te._timeout.unref()),te._fn(te._attempts)},ee),this._options.unref&&this._timer.unref(),!0};RetryOperation.prototype.attempt=function(J,E){this._fn=J,E&&(E.timeout&&(this._operationTimeout=E.timeout),E.cb&&(this._operationTimeoutCb=E.cb));var ee=this;this._operationTimeoutCb&&(this._timeout=setTimeout(function(){ee._operationTimeoutCb()},ee._operationTimeout)),this._operationStart=new Date().getTime(),this._fn(this._attempts)};RetryOperation.prototype.try=function(J){console.log("Using RetryOperation.try() is deprecated"),this.attempt(J)};RetryOperation.prototype.start=function(J){console.log("Using RetryOperation.start() is deprecated"),this.attempt(J)};RetryOperation.prototype.start=RetryOperation.prototype.try;RetryOperation.prototype.errors=function(){return this._errors};RetryOperation.prototype.attempts=function(){return this._attempts};RetryOperation.prototype.mainError=function(){if(this._errors.length===0)return null;for(var J={},E=null,ee=0,te=0;te<this._errors.length;te++){var re=this._errors[te],ne=re.message,ie=(J[ne]||0)+1;J[ne]=ie,ie>=ee&&(E=re,ee=ie)}return E};(function(J){var E=retry_operation;J.operation=function(ee){var te=J.timeouts(ee);return new E(te,{forever:ee&&(ee.forever||ee.retries===1/0),unref:ee&&ee.unref,maxRetryTime:ee&&ee.maxRetryTime})},J.timeouts=function(ee){if(ee instanceof Array)return[].concat(ee);var te={retries:10,factor:2,minTimeout:1*1e3,maxTimeout:1/0,randomize:!1};for(var re in ee)te[re]=ee[re];if(te.minTimeout>te.maxTimeout)throw new Error("minTimeout is greater than maxTimeout");for(var ne=[],ie=0;ie<te.retries;ie++)ne.push(this.createTimeout(ie,te));return ee&&ee.forever&&!ne.length&&ne.push(this.createTimeout(ie,te)),ne.sort(function(se,oe){return se-oe}),ne},J.createTimeout=function(ee,te){var re=te.randomize?Math.random()+1:1,ne=Math.round(re*Math.max(te.minTimeout,1)*Math.pow(te.factor,ee));return ne=Math.min(ne,te.maxTimeout),ne},J.wrap=function(ee,te,re){if(te instanceof Array&&(re=te,te=null),!re){re=[];for(var ne in ee)typeof ee[ne]=="function"&&re.push(ne)}for(var ie=0;ie<re.length;ie++){var se=re[ie],oe=ee[se];ee[se]=function(ae){var ce=J.operation(te),le=Array.prototype.slice.call(arguments,1),he=le.pop();le.push(function(de){ce.retry(de)||(de&&(arguments[0]=ce.mainError()),he.apply(this,arguments))}),ce.attempt(function(){ae.apply(ee,le)})}.bind(ee,oe),ee[se].options=te}}})(retry);logger("libp2p:circuit-relay:advert-service");logger("libp2p:circuit-relay:server");const log$5=logger("libp2p:stream:converter");function streamToMaConnection(J,E={}){const{stream:ee,remoteAddr:te}=J,{sink:re,source:ne}=ee,ie=async function*(){for await(const ae of ne)ae instanceof Uint8Array?yield ae:yield*ae}(),se={async sink(ae){E.signal!=null&&(ae=abortableSource$1(ae,E.signal));try{await re(ae),await oe()}catch(ce){ce.type!=="aborted"&&log$5(ce)}},source:E.signal!=null?abortableSource$1(ie,E.signal):ie,remoteAddr:te,timeline:{open:Date.now(),close:void 0},async close(){await re(async function*(){yield new Uint8Array(0)}()),await oe()}};async function oe(){se.timeline.close==null&&(se.timeline.close=Date.now()),await Promise.resolve()}return se}var __classPrivateFieldGet$2=globalThis&&globalThis.__classPrivateFieldGet||function(J,E,ee,te){if(ee==="a"&&!te)throw new TypeError("Private accessor was defined without a getter");if(typeof E=="function"?J!==E||!te:!E.has(J))throw new TypeError("Cannot read private member from an object whose class did not declare it");return ee==="m"?te:ee==="a"?te.call(J):te?te.value:E.get(J)},_CircuitRelayTransportListener_instances,_CircuitRelayTransportListener_removeRelayPeer;const log$4=logger("libp2p:circuit-relay:transport:listener");class CircuitRelayTransportListener extends EventEmitter$3{constructor(E){super(),_CircuitRelayTransportListener_instances.add(this),this.connectionManager=E.connectionManager,this.relayStore=E.relayStore,this.listeningAddrs=new PeerMap,this.relayStore.addEventListener("relay:removed",ee=>{__classPrivateFieldGet$2(this,_CircuitRelayTransportListener_instances,"m",_CircuitRelayTransportListener_removeRelayPeer).call(this,ee.detail)})}async listen(E){log$4("listen on %s",E);const ee=E.getPeerId();let te;if(ee!=null){const ne=peerIdFromString(ee),ie=this.connectionManager.getConnectionsMap().get(ne)??[];ie.length>0&&(te=ie[0])}if(te==null){const ne=E.toString().split("/p2p-circuit").find(se=>se!==""),ie=multiaddr(ne);te=await this.connectionManager.openConnection(ie)}if(!this.relayStore.hasReservation(te.remotePeer)){await this.relayStore.addRelay(te.remotePeer,"configured");return}const re=this.relayStore.getReservation(te.remotePeer);if(re==null)throw new CodeError("Did not have reservation after making reservation","ERR_NO_RESERVATION");if(this.listeningAddrs.has(te.remotePeer)){log$4("already listening on relay %p",te.remotePeer);return}this.listeningAddrs.set(te.remotePeer,re.addrs.map(ne=>multiaddr(ne).encapsulate("/p2p-circuit"))),this.safeDispatchEvent("listening",{})}getAddrs(){return[...this.listeningAddrs.values()].flat()}async close(){}}_CircuitRelayTransportListener_instances=new WeakSet,_CircuitRelayTransportListener_removeRelayPeer=function J(E){const ee=this.listeningAddrs.has(E);this.listeningAddrs.delete(E),ee&&this.safeDispatchEvent("close",{})};function createListener(J){return new CircuitRelayTransportListener(J)}var __classPrivateFieldGet$1=globalThis&&globalThis.__classPrivateFieldGet||function(J,E,ee,te){if(ee==="a"&&!te)throw new TypeError("Private accessor was defined without a getter");if(typeof E=="function"?J!==E||!te:!E.has(J))throw new TypeError("Cannot read private member from an object whose class did not declare it");return ee==="m"?te:ee==="a"?te.call(J):te?te.value:E.get(J)},_ReservationStore_instances,_ReservationStore_createReservation,_ReservationStore_removeRelay;const log$3=logger("libp2p:circuit-relay:transport:reservation-store"),REFRESH_WINDOW=60*1e3*10,REFRESH_TIMEOUT=60*1e3*5,REFRESH_TIMEOUT_MIN=30*1e3;class ReservationStore extends EventEmitter$3{constructor(E,ee){super(),_ReservationStore_instances.add(this),this.peerId=E.peerId,this.connectionManager=E.connectionManager,this.transportManager=E.transportManager,this.peerStore=E.peerStore,this.events=E.events,this.reservations=new PeerMap,this.maxDiscoveredRelays=ee?.discoverRelays??0,this.started=!1,this.reserveQueue=new PQueue({concurrency:ee?.reservationConcurrency??DEFAULT_RESERVATION_CONCURRENCY}),this.events.addEventListener("peer:disconnect",te=>{__classPrivateFieldGet$1(this,_ReservationStore_instances,"m",_ReservationStore_removeRelay).call(this,te.detail)})}isStarted(){return this.started}async start(){this.started=!0}async stop(){this.reservations.forEach(({timeout:E})=>{clearTimeout(E)}),this.reservations.clear(),this.started=!0}async addRelay(E,ee){if(this.peerId.equals(E)){log$3("not trying to use self as relay");return}log$3("add relay %p",E),await this.reserveQueue.add(async()=>{try{const te=this.reservations.get(E);if(te!=null){if(getExpirationMilliseconds(te.reservation.expire)>REFRESH_WINDOW){log$3("already have reservation on relay peer %p and it expires in more than 10 minutes",E);return}clearTimeout(te.timeout),this.reservations.delete(E)}if(ee==="discovered"&&[...this.reservations.values()].reduce((ae,ce)=>(ce.type==="discovered"&&ae++,ae),0)>=this.maxDiscoveredRelays){log$3("already have enough discovered relays");return}const re=await this.connectionManager.openConnection(E);if(re.remoteAddr.protoNames().includes("p2p-circuit")){log$3("not creating reservation over relayed connection");return}const ne=await __classPrivateFieldGet$1(this,_ReservationStore_instances,"m",_ReservationStore_createReservation).call(this,re);log$3("created reservation on relay peer %p",E);const ie=getExpirationMilliseconds(ne.expire),se=Math.min(Math.max(ie-REFRESH_TIMEOUT,REFRESH_TIMEOUT_MIN),Math.pow(2,31)-1),oe=setTimeout(()=>{this.addRelay(E,ee).catch(ae=>{log$3.error("could not refresh reservation to relay %p",E,ae)})},se);this.reservations.set(E,{timeout:oe,reservation:ne,type:ee}),await this.peerStore.merge(E,{tags:{[RELAY_TAG]:{value:1,ttl:ie}}}),await this.transportManager.listen([multiaddr(`/p2p/${E.toString()}/p2p-circuit`)])}catch(te){log$3.error("could not reserve slot on %p",E,te),this.reservations.delete(E)}})}hasReservation(E){return this.reservations.has(E)}getReservation(E){return this.reservations.get(E)?.reservation}}_ReservationStore_instances=new WeakSet,_ReservationStore_createReservation=async function J(E){log$3("requesting reservation from %s",E.remotePeer);const ee=await E.newStream(RELAY_V2_HOP_CODEC),te=pbStream(ee).pb(HopMessage);te.write({type:HopMessage.Type.RESERVE});let re;try{re=await te.read()}catch(ie){throw log$3.error("error parsing reserve message response from %p because",E.remotePeer,ie),ie}finally{ee.close()}if(re.status===Status.OK&&re.reservation!=null)return re.reservation;const ne=`reservation failed with status ${re.status??"undefined"}`;throw log$3.error(ne),new Error(ne)},_ReservationStore_removeRelay=function J(E){const ee=this.reservations.get(E);ee!=null&&(log$3("connection to relay %p closed, removing reservation from local store",E),clearTimeout(ee.timeout),this.reservations.delete(E),this.safeDispatchEvent("relay:removed",{detail:E}),this.reservations.size<this.maxDiscoveredRelays&&(log$3("not enough relays %d/%d",this.reservations.size,this.maxDiscoveredRelays),this.safeDispatchEvent("relay:not-enough-relays",{})))};const noop=()=>{};class TopologyImpl{constructor(E){this.min=E.min??0,this.max=E.max??1/0,this.peers=new Set,this.onConnect=E.onConnect??noop,this.onDisconnect=E.onDisconnect??noop}get[Symbol.toStringTag](){return topologySymbol.toString()}get[topologySymbol](){return!0}async setRegistrar(E){this.registrar=E}disconnect(E){this.onDisconnect(E)}}function createTopology(J){return new TopologyImpl(J)}const log$2=logger("libp2p:circuit-relay:discover-relays");class RelayDiscovery extends EventEmitter$3{constructor(E){super(),this.started=!1,this.peerId=E.peerId,this.peerStore=E.peerStore,this.contentRouting=E.contentRouting,this.registrar=E.registrar}isStarted(){return this.started}async start(){this.topologyId=await this.registrar.register(RELAY_V2_HOP_CODEC,createTopology({onConnect:E=>{this.safeDispatchEvent("relay:discover",{detail:E})}})),this.discover().catch(E=>{log$2.error("error listening on relays",E)}),this.started=!0}stop(){this.topologyId!=null&&this.registrar.unregister(this.topologyId),this.started=!1}async discover(){log$2("searching peer store for relays");const E=(await this.peerStore.all()).filter(({protocols:ee})=>ee.includes(RELAY_V2_HOP_CODEC)).sort(()=>Math.random()-.5);for(const ee of E)log$2("found relay peer %p in content peer store",ee.id),this.safeDispatchEvent("relay:discover",{detail:ee.id});log$2("found %d relay peers in peer store",E.length);try{log$2("searching content routing for relays");const ee=await namespaceToCid(RELAY_RENDEZVOUS_NS);let te=0;for await(const re of this.contentRouting.findProviders(ee))if(re.multiaddrs.length>0&&!re.id.equals(this.peerId)){const ne=re.id;te++,await this.peerStore.merge(ne,{multiaddrs:re.multiaddrs}),log$2("found relay peer %p in content routing",ne),this.safeDispatchEvent("relay:discover",{detail:ne})}log$2("found %d relay peers in content routing",te)}catch(ee){log$2.error("failed when finding relays on the network",ee)}}}const log$1=logger("libp2p:circuit-relay:transport"),isValidStop=J=>{if(J.peer==null)return!1;try{J.peer.addrs.forEach(multiaddr)}catch{return!1}return!0};class CircuitRelayTransport{constructor(E,ee){this.registrar=E.registrar,this.peerStore=E.peerStore,this.connectionManager=E.connectionManager,this.peerId=E.peerId,this.upgrader=E.upgrader,this.addressManager=E.addressManager,this.connectionGater=E.connectionGater,ee.discoverRelays!=null&&ee.discoverRelays>0&&(this.discovery=new RelayDiscovery(E),this.discovery.addEventListener("relay:discover",te=>{this.reservationStore.addRelay(te.detail,"discovered").catch(re=>{log$1.error("could not add discovered relay %p",te.detail,re)})})),this.reservationStore=new ReservationStore(E,ee),this.reservationStore.addEventListener("relay:not-enough-relays",()=>{this.discovery?.discover().catch(te=>{log$1.error("could not discover relays",te)})}),this.started=!1}isStarted(){return this.started}async start(){await this.reservationStore.start(),await this.discovery?.start(),await this.registrar.handle(RELAY_V2_STOP_CODEC,E=>{this.onStop(E).catch(ee=>{log$1.error(ee)})}),this.started=!0}async stop(){this.discovery?.stop(),await this.reservationStore.stop(),await this.registrar.unhandle(RELAY_V2_STOP_CODEC),this.started=!1}get[symbol$2](){return!0}get[Symbol.toStringTag](){return"libp2p/circuit-relay-v2"}async dial(E,ee={}){if(E.protoCodes().filter(he=>he===CIRCUIT_PROTO_CODE).length!==1){const he="Invalid circuit relay address";throw log$1.error(he,E),new CodeError(he,codes$6.ERR_RELAYED_DIAL)}const te=E.toString().split("/p2p-circuit"),re=multiaddr(te[0]),ne=multiaddr(te[te.length-1]),ie=re.getPeerId(),se=ne.getPeerId();if(ie==null||se==null){const he=`Circuit relay dial to ${E.toString()} failed as address did not have peer ids`;throw log$1.error(he),new CodeError(he,codes$6.ERR_RELAYED_DIAL)}const oe=peerIdFromString(ie),ae=peerIdFromString(se);let ce=!1,le=this.connectionManager.getConnections(oe)[0];le==null&&(await this.peerStore.merge(oe,{multiaddrs:[re]}),le=await this.connectionManager.openConnection(oe,ee),ce=!0);try{const he=await le.newStream([RELAY_V2_HOP_CODEC]);return await this.connectV2({stream:he,connection:le,destinationPeer:ae,destinationAddr:ne,relayAddr:re,ma:E,disconnectOnFailure:ce})}catch(he){throw log$1.error(`Circuit relay dial to destination ${ae.toString()} via relay ${oe.toString()} failed`,he),ce&&await le.close(),he}}async connectV2({stream:E,connection:ee,destinationPeer:te,destinationAddr:re,relayAddr:ne,ma:ie,disconnectOnFailure:se}){try{const oe=pbStream(E),ae=oe.pb(HopMessage);ae.write({type:HopMessage.Type.CONNECT,peer:{id:te.toBytes(),addrs:[multiaddr(re).bytes]}});const ce=await ae.read();if(ce.status!==Status.OK)throw new CodeError(`failed to connect via relay with status ${ce?.status?.toString()??"undefined"}`,codes$6.ERR_HOP_REQUEST_FAILED);const le=streamToMaConnection({stream:oe.unwrap(),remoteAddr:ie,localAddr:ne.encapsulate(`/p2p-circuit/p2p/${this.peerId.toString()}`)});return log$1("new outbound connection %s",le.remoteAddr),await this.upgrader.upgradeOutbound(le)}catch(oe){throw log$1.error(`Circuit relay dial to destination ${te.toString()} via relay ${ee.remotePeer.toString()} failed`,oe),se&&await ee.close(),oe}}createListener(E){return createListener({connectionManager:this.connectionManager,relayStore:this.reservationStore})}filter(E){return E=Array.isArray(E)?E:[E],E.filter(ee=>Circuit.matches(ee))}async onStop({connection:E,stream:ee}){const te=pbStream(ee),re=await te.readPB(StopMessage);if(log$1("received circuit v2 stop protocol request from %s",E.remotePeer),re?.type===void 0)return;const ne=te.pb(StopMessage);if(log$1("new circuit relay v2 stop stream from %s",E.remotePeer),re.type!==StopMessage.Type.CONNECT){log$1.error("invalid stop connect request via peer %s",E.remotePeer),ne.write({type:StopMessage.Type.STATUS,status:Status.UNEXPECTED_MESSAGE});return}if(!isValidStop(re)){log$1.error("invalid stop connect request via peer %s",E.remotePeer),ne.write({type:StopMessage.Type.STATUS,status:Status.MALFORMED_MESSAGE});return}const ie=peerIdFromBytes(re.peer.id);if(await this.connectionGater.denyInboundRelayedConnection?.(E.remotePeer,ie)===!0){ne.write({type:StopMessage.Type.STATUS,status:Status.PERMISSION_DENIED});return}ne.write({type:StopMessage.Type.STATUS,status:Status.OK});const se=E.remoteAddr.encapsulate(`/p2p-circuit/p2p/${ie.toString()}`),oe=this.addressManager.getAddresses()[0],ae=streamToMaConnection({stream:te.unwrap(),remoteAddr:se,localAddr:oe});log$1("new inbound connection %s",ae.remoteAddr),await this.upgrader.upgradeInbound(ae),log$1("%s connection %s upgraded","inbound",ae.remoteAddr)}}function circuitRelayTransport(J={}){return E=>new CircuitRelayTransport(E,J)}var Identify;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{if(re.lengthDelimited!==!1&&te.fork(),ee.protocolVersion!=null&&(te.uint32(42),te.string(ee.protocolVersion)),ee.agentVersion!=null&&(te.uint32(50),te.string(ee.agentVersion)),ee.publicKey!=null&&(te.uint32(10),te.bytes(ee.publicKey)),ee.listenAddrs!=null)for(const ne of ee.listenAddrs)te.uint32(18),te.bytes(ne);if(ee.observedAddr!=null&&(te.uint32(34),te.bytes(ee.observedAddr)),ee.protocols!=null)for(const ne of ee.protocols)te.uint32(26),te.string(ne);ee.signedPeerRecord!=null&&(te.uint32(66),te.bytes(ee.signedPeerRecord)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={listenAddrs:[],protocols:[]},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 5:re.protocolVersion=ee.string();break;case 6:re.agentVersion=ee.string();break;case 1:re.publicKey=ee.bytes();break;case 2:re.listenAddrs.push(ee.bytes());break;case 4:re.observedAddr=ee.bytes();break;case 3:re.protocols.push(ee.string());break;case 8:re.signedPeerRecord=ee.bytes();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage(ee,J.codec())})(Identify||(Identify={}));const version$1="0.45.0",AGENT_VERSION=`js-libp2p/${version$1}`,IDENTIFY_PROTOCOL_VERSION="0.1.0",MULTICODEC_IDENTIFY_PROTOCOL_NAME="id",MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME="id/push",MULTICODEC_IDENTIFY_PROTOCOL_VERSION="1.0.0",MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION="1.0.0";var __classPrivateFieldGet=globalThis&&globalThis.__classPrivateFieldGet||function(J,E,ee,te){if(ee==="a"&&!te)throw new TypeError("Private accessor was defined without a getter");if(typeof E=="function"?J!==E||!te:!E.has(J))throw new TypeError("Cannot read private member from an object whose class did not declare it");return ee==="m"?te:ee==="a"?te.call(J):te?te.value:E.get(J)},_DefaultIdentifyService_instances,_DefaultIdentifyService_consumeIdentifyMessage;const log=logger("libp2p:identify"),MAX_IDENTIFY_MESSAGE_SIZE=1024*8,defaultValues={protocolPrefix:"ipfs",agentVersion:AGENT_VERSION,timeout:6e4,maxInboundStreams:1,maxOutboundStreams:1,maxPushIncomingStreams:1,maxPushOutgoingStreams:1,maxObservedAddresses:10,maxIdentifyMessageSize:8192};class DefaultIdentifyService{constructor(E,ee){_DefaultIdentifyService_instances.add(this),this.started=!1,this.peerId=E.peerId,this.peerStore=E.peerStore,this.registrar=E.registrar,this.addressManager=E.addressManager,this.connectionManager=E.connectionManager,this.events=E.events,this.identifyProtocolStr=`/${ee.protocolPrefix??defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`,this.identifyPushProtocolStr=`/${ee.protocolPrefix??defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`,this.timeout=ee.timeout??defaultValues.timeout,this.maxInboundStreams=ee.maxInboundStreams??defaultValues.maxInboundStreams,this.maxOutboundStreams=ee.maxOutboundStreams??defaultValues.maxOutboundStreams,this.maxPushIncomingStreams=ee.maxPushIncomingStreams??defaultValues.maxPushIncomingStreams,this.maxPushOutgoingStreams=ee.maxPushOutgoingStreams??defaultValues.maxPushOutgoingStreams,this.maxIdentifyMessageSize=ee.maxIdentifyMessageSize??defaultValues.maxIdentifyMessageSize,this.maxObservedAddresses=ee.maxObservedAddresses??defaultValues.maxObservedAddresses,this.host={protocolVersion:`${ee.protocolPrefix??defaultValues.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,agentVersion:ee.agentVersion??defaultValues.agentVersion},E.events.addEventListener("connection:open",te=>{const re=te.detail;this.identify(re).catch(ne=>{log.error("error during identify trigged by connection:open",ne)})}),E.events.addEventListener("self:peer:update",te=>{this.push().catch(re=>{log.error(re)})}),this.host.agentVersion===AGENT_VERSION&&(isNode||isElectronMain?this.host.agentVersion+=` UserAgent=${globalThis.process.version}`:(isBrowser||isWebWorker||isElectronRenderer||isReactNative)&&(this.host.agentVersion+=` UserAgent=${globalThis.navigator.userAgent}`))}isStarted(){return this.started}async start(){this.started||(await this.peerStore.merge(this.peerId,{metadata:{AgentVersion:fromString$4(this.host.agentVersion),ProtocolVersion:fromString$4(this.host.protocolVersion)}}),await this.registrar.handle(this.identifyProtocolStr,E=>{this._handleIdentify(E).catch(ee=>{log.error(ee)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams}),await this.registrar.handle(this.identifyPushProtocolStr,E=>{this._handlePush(E).catch(ee=>{log.error(ee)})},{maxInboundStreams:this.maxPushIncomingStreams,maxOutboundStreams:this.maxPushOutgoingStreams}),this.started=!0)}async stop(){await this.registrar.unhandle(this.identifyProtocolStr),await this.registrar.unhandle(this.identifyPushProtocolStr),this.started=!1}async pushToConnections(E){const ee=this.addressManager.getAddresses().map(ce=>ce.decapsulateCode(getProtocol("p2p").code)),te=new PeerRecord({peerId:this.peerId,multiaddrs:ee}),re=await RecordEnvelope.seal(te,this.peerId),ne=this.registrar.getProtocols(),ie=await this.peerStore.get(this.peerId),se=toString$4(ie.metadata.get("AgentVersion")??fromString$4(this.host.agentVersion)),oe=toString$4(ie.metadata.get("ProtocolVersion")??fromString$4(this.host.protocolVersion)),ae=E.map(async ce=>{let le;const he=AbortSignal.timeout(this.timeout);try{setMaxListeners?.(1/0,he)}catch{}try{le=await ce.newStream([this.identifyPushProtocolStr],{signal:he}),await abortableDuplex(le,he).sink(pipe([Identify.encode({listenAddrs:ee.map(de=>de.bytes),signedPeerRecord:re.marshal(),protocols:ne,agentVersion:se,protocolVersion:oe})],de=>encode$8(de)))}catch(de){log.error("could not push identify update to peer",de)}finally{le?.close()}});await Promise.all(ae)}async push(){if(!this.isStarted())return;const E=[];await Promise.all(this.connectionManager.getConnections().map(async ee=>{try{if(!(await this.peerStore.get(ee.remotePeer)).protocols.includes(this.identifyPushProtocolStr))return;E.push(ee)}catch(te){if(te.code!==codes$6.ERR_NOT_FOUND)throw te}})),await this.pushToConnections(E)}async _identify(E,ee={}){let te;const re=anySignal([AbortSignal.timeout(this.timeout),ee?.signal]);try{setMaxListeners?.(1/0,re)}catch{}try{te=await E.newStream([this.identifyProtocolStr],{signal:re});const ne=abortableDuplex(te,re),ie=await pipe([],ne,se=>decode$6(se,{maxDataLength:this.maxIdentifyMessageSize??MAX_IDENTIFY_MESSAGE_SIZE}),async se=>await first(se));if(ie==null)throw new CodeError("No data could be retrieved",codes$6.ERR_CONNECTION_ENDED);try{return Identify.decode(ie)}catch(se){throw new CodeError(String(se),codes$6.ERR_INVALID_MESSAGE)}}finally{te?.close(),re.clear()}}async identify(E,ee={}){const te=await this._identify(E,ee),{publicKey:re,protocols:ne,observedAddr:ie}=te;if(re==null)throw new CodeError("public key was missing from identify message",codes$6.ERR_MISSING_PUBLIC_KEY);const se=await peerIdFromKeys(re);if(!E.remotePeer.equals(se))throw new CodeError("identified peer does not match the expected peer",codes$6.ERR_INVALID_PEER);if(this.peerId.equals(se))throw new CodeError("identified peer is our own peer id?",codes$6.ERR_INVALID_PEER);const oe=getCleanMultiaddr(ie);log("identify completed for peer %p and protocols %o",se,ne),log("our observed address is %s",oe),oe!=null&&this.addressManager.getObservedAddrs().length<(this.maxObservedAddresses??1/0)&&(log("storing our observed address %s",oe?.toString()),this.addressManager.addObservedAddr(oe));const ae=await __classPrivateFieldGet(this,_DefaultIdentifyService_instances,"m",_DefaultIdentifyService_consumeIdentifyMessage).call(this,E.remotePeer,te),ce={peerId:se,protocolVersion:te.protocolVersion,agentVersion:te.agentVersion,publicKey:te.publicKey,listenAddrs:te.listenAddrs.map(le=>multiaddr(le)),observedAddr:te.observedAddr==null?void 0:multiaddr(te.observedAddr),protocols:te.protocols,signedPeerRecord:ae};this.events.safeDispatchEvent("peer:identify",{detail:ce})}async _handleIdentify(E){const{connection:ee,stream:te}=E,re=AbortSignal.timeout(this.timeout);try{setMaxListeners?.(1/0,re)}catch{}try{const ne=this.peerId.publicKey??new Uint8Array(0),ie=await this.peerStore.get(this.peerId),se=this.addressManager.getAddresses().map(he=>he.decapsulateCode(getProtocol("p2p").code));let oe=ie.peerRecordEnvelope;if(se.length>0&&oe==null){const he=new PeerRecord({peerId:this.peerId,multiaddrs:se});oe=(await RecordEnvelope.seal(he,this.peerId)).marshal().subarray()}const ae=Identify.encode({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:ne,listenAddrs:se.map(he=>he.bytes),signedPeerRecord:oe,observedAddr:ee.remoteAddr.bytes,protocols:ie.protocols}),ce=abortableDuplex(te,re),le=pipe([ae],he=>encode$8(he));await ce.sink(le)}catch(ne){log.error("could not respond to identify request",ne)}finally{te.close()}}async _handlePush(E){const{connection:ee,stream:te}=E;try{if(this.peerId.equals(ee.remotePeer))throw new Error("received push from ourselves?");const re=abortableDuplex(te,AbortSignal.timeout(this.timeout)),ne=await pbStream(re,{maxDataLength:this.maxIdentifyMessageSize??MAX_IDENTIFY_MESSAGE_SIZE}).readPB(Identify);await __classPrivateFieldGet(this,_DefaultIdentifyService_instances,"m",_DefaultIdentifyService_consumeIdentifyMessage).call(this,ee.remotePeer,ne)}catch(re){log.error("received invalid message",re);return}finally{te.close()}log("handled push from %p",ee.remotePeer)}}_DefaultIdentifyService_instances=new WeakSet,_DefaultIdentifyService_consumeIdentifyMessage=async function J(E,ee){if(ee==null)throw new Error("Message was null or undefined");if(log("received identify from %p",E),ee.signedPeerRecord==null)return;const te=await RecordEnvelope.openAndCertify(ee.signedPeerRecord,PeerRecord.DOMAIN),re=PeerRecord.createFromProtobuf(te.payload);if(!re.peerId.equals(te.peerId))throw new Error("signing key does not match PeerId in the PeerRecord");if(!E.equals(re.peerId))throw new Error("signing key does not match remote PeerId");let ne;try{ne=await this.peerStore.get(re.peerId)}catch(se){if(se.code!=="ERR_NOT_FOUND")throw se}log("received signedPeerRecord in push from %p",E);let ie=new Map;if(ne?.peerRecordEnvelope!=null){const se=await RecordEnvelope.createFromProtobuf(ne.peerRecordEnvelope),oe=PeerRecord.createFromProtobuf(se.payload);oe.seqNumber>=re.seqNumber&&log("sequence number was lower or equal to existing sequence number - stored: %d received: %d",oe.seqNumber,re.seqNumber),ie=ne.metadata}return ee.agentVersion!=null&&ie.set("AgentVersion",fromString$4(ee.agentVersion)),ee.protocolVersion!=null&&ie.set("ProtocolVersion",fromString$4(ee.protocolVersion)),await this.peerStore.patch(re.peerId,{peerRecordEnvelope:ee.signedPeerRecord,protocols:ee.protocols,addresses:re.multiaddrs.map(se=>({isCertified:!0,multiaddr:se})),metadata:ie}),log("consumed signedPeerRecord sent in push from %p",E),{seq:re.seqNumber,addresses:re.multiaddrs}};function getCleanMultiaddr(J){if(J!=null&&J.length>0)try{return multiaddr(J)}catch{}}function identifyService(J={}){return E=>new DefaultIdentifyService(E,J)}const PROTO="/ipdm/1.0.0";class P2PTransport{#e;#t=pushable();#r;#n;constructor(E,ee){this.#e=E,this.#r=ee?.connectingAddress,E.addEventListener("connection:open",te=>{console.log("connection:open",te.detail)}),E.addEventListener("connection:close",te=>{console.log("connection:close",te.detail)})}#s(){const E=this;let ee=!1,te=!1;return{async next(){const re=await E.#i();if(!ee)return ee=!0,{done:!1,value:new MessageEvent("open",{data:{readyState:1}})};if(te)return{done:!0,value:null};const ne=await re.source.next();return ne.done?(te=!0,{done:!1,value:new MessageEvent("error",{data:{readyState:2}})}):{done:!1,value:new MessageEvent("message",{data:new TextDecoder().decode(ne.value.subarray())})}},async return(){return{done:!0,value:new MessageEvent("error",{data:{readyState:2}})}},async throw(){return{done:!0,value:new MessageEvent("error",{data:{readyState:2}})}},[Symbol.asyncIterator](){return this}}}listen(E){return this.#s()[Symbol.asyncIterator]()}async closeListener(){this.#n?.close(),await this.#e.unhandle(PROTO)}async#i(){if(this.#n)return this.#n;if(this.#r){const E=this.#r,ee=multiaddr(E),te=await(await this.#e.dial(ee)).newStream([PROTO]);this.#n=te,pipe(this.#t,te)}else this.#n=await new Promise(E=>{this.#e.handle(PROTO,({stream:ee,connection:te})=>{pipe(this.#t,ee),E(ee)})});return this.#n}async send(E,ee){return await this.#i(),this.#t.push(new TextEncoder().encode(E)),{ok:!0,status:200,statusText:"OK"}}async closeSender(){this.#n?.close(),this.#t.end()}}class P2PTransportCreator{#e;#t;constructor(E){this.#e=E}static async createPrivateLibp2pNode(E){const ee=await createLibp2p({addresses:{listen:["/webrtc"]},transports:[webRTC(),webRTCDirect(),webSockets({filter:all}),circuitRelayTransport({discoverRelays:1})],connectionEncryption:[noise()],streamMuxers:[mplex(),yamux()],peerDiscovery:E?.bootstrapAddrs?.length?[bootstrap({list:E.bootstrapAddrs,timeout:1e3,tagName:"bootstrap",tagValue:50,tagTTL:12e4})]:[],connectionGater:{denyDialMultiaddr:()=>!1},services:{identify:identifyService()}}),te=E.relayAddr;return te?new Promise(re=>{ee.addEventListener("self:peer:update",ne=>{for(const ie of ee.getMultiaddrs()){const se=ie.toString();se.includes(te)&&se.includes("webrtc")&&re({node:ee,connectingAddr:se})}}),ee.dial(multiaddr(te))}):{node:ee}}static async createPublicLibp2pNode(E){const{tcp:ee}=await __vitePreload(()=>import("./index-340f92ae-1632b5eb.js"),[]),te=await createLibp2p({addresses:{listen:["/ip4/0.0.0.0/tcp/0","/ip4/0.0.0.0/tcp/0/ws","/ip4/0.0.0.0/udp/0/webrtc-direct","/ip4/0.0.0.0/udp/0/webrtc"]},transports:[ee(),webSockets({filter:all}),webRTCDirect()],connectionEncryption:[noise()],streamMuxers:[mplex(),yamux()],peerDiscovery:E?.bootstrapAddrs?.length?[bootstrap({list:E.bootstrapAddrs,timeout:1e3,tagName:"bootstrap",tagValue:50,tagTTL:12e4})]:[],connectionGater:{denyDialMultiaddr:()=>!1},services:{identify:identifyService()}});return await te.start(),te}async createSenderTransport(E){return this.#t||(this.#t=new P2PTransport(this.#e,E)),new P2PSenderTransport(this.#t)}async createReceiverTransport(E){return this.#t||(this.#t=new P2PTransport(this.#e,E)),new P2PReceiverTransport(this.#t)}}class P2PReceiverTransport{#e;constructor(E){this.#e=E}listen(E){return this.#e.listen(E)}async close(){this.#e.closeListener()}}class P2PSenderTransport{#e;constructor(E){this.#e=E}async send(E,ee){return this.#e.send(E,ee)}async close(){this.#e.closeSender()}}const encoder=new TextEncoder,decoder=new TextDecoder,encodeBase64=J=>{let E=J;typeof E=="string"&&(E=encoder.encode(E));const ee=32768,te=[];for(let re=0;re<E.length;re+=ee)te.push(String.fromCharCode.apply(null,E.subarray(re,re+ee)));return btoa(te.join(""))},encode=J=>encodeBase64(J).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),decodeBase64=J=>{const E=atob(J),ee=new Uint8Array(E.length);for(let te=0;te<E.length;te++)ee[te]=E.charCodeAt(te);return ee},decode=J=>{let E=J;E instanceof Uint8Array&&(E=decoder.decode(E)),E=E.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return decodeBase64(E)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}};class JOSEError extends Error{static get code(){return"ERR_JOSE_GENERIC"}constructor(E){var ee;super(E),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,(ee=Error.captureStackTrace)===null||ee===void 0||ee.call(Error,this,this.constructor)}}class JWTClaimValidationFailed extends JOSEError{static get code(){return"ERR_JWT_CLAIM_VALIDATION_FAILED"}constructor(E,ee="unspecified",te="unspecified"){super(E),this.code="ERR_JWT_CLAIM_VALIDATION_FAILED",this.claim=ee,this.reason=te}}class JWTExpired extends JOSEError{static get code(){return"ERR_JWT_EXPIRED"}constructor(E,ee="unspecified",te="unspecified"){super(E),this.code="ERR_JWT_EXPIRED",this.claim=ee,this.reason=te}}class JWTInvalid extends JOSEError{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}static get code(){return"ERR_JWT_INVALID"}}function isObjectLike(J){return typeof J=="object"&&J!==null}function isObject(J){if(!isObjectLike(J)||Object.prototype.toString.call(J)!=="[object Object]")return!1;if(Object.getPrototypeOf(J)===null)return!0;let E=J;for(;Object.getPrototypeOf(E)!==null;)E=Object.getPrototypeOf(E);return Object.getPrototypeOf(J)===E}const epoch=J=>Math.floor(J.getTime()/1e3),minute=60,hour=minute*60,day=hour*24,week=day*7,year=day*365.25,REGEX=/^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i,secs=J=>{const E=REGEX.exec(J);if(!E)throw new TypeError("Invalid time period format");const ee=parseFloat(E[1]);switch(E[2].toLowerCase()){case"sec":case"secs":case"second":case"seconds":case"s":return Math.round(ee);case"minute":case"minutes":case"min":case"mins":case"m":return Math.round(ee*minute);case"hour":case"hours":case"hr":case"hrs":case"h":return Math.round(ee*hour);case"day":case"days":case"d":return Math.round(ee*day);case"week":case"weeks":case"w":return Math.round(ee*week);default:return Math.round(ee*year)}},normalizeTyp=J=>J.toLowerCase().replace(/^application\//,""),checkAudiencePresence=(J,E)=>typeof J=="string"?E.includes(J):Array.isArray(J)?E.some(Set.prototype.has.bind(new Set(J))):!1,jwtPayload=(J,E,ee={})=>{const{typ:te}=ee;if(te&&(typeof J.typ!="string"||normalizeTyp(J.typ)!==normalizeTyp(te)))throw new JWTClaimValidationFailed('unexpected "typ" JWT header value',"typ","check_failed");let re;try{re=JSON.parse(decoder.decode(E))}catch{}if(!isObject(re))throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");const{requiredClaims:ne=[],issuer:ie,subject:se,audience:oe,maxTokenAge:ae}=ee;ae!==void 0&&ne.push("iat"),oe!==void 0&&ne.push("aud"),se!==void 0&&ne.push("sub"),ie!==void 0&&ne.push("iss");for(const de of new Set(ne.reverse()))if(!(de in re))throw new JWTClaimValidationFailed(`missing required "${de}" claim`,de,"missing");if(ie&&!(Array.isArray(ie)?ie:[ie]).includes(re.iss))throw new JWTClaimValidationFailed('unexpected "iss" claim value',"iss","check_failed");if(se&&re.sub!==se)throw new JWTClaimValidationFailed('unexpected "sub" claim value',"sub","check_failed");if(oe&&!checkAudiencePresence(re.aud,typeof oe=="string"?[oe]:oe))throw new JWTClaimValidationFailed('unexpected "aud" claim value',"aud","check_failed");let ce;switch(typeof ee.clockTolerance){case"string":ce=secs(ee.clockTolerance);break;case"number":ce=ee.clockTolerance;break;case"undefined":ce=0;break;default:throw new TypeError("Invalid clockTolerance option type")}const{currentDate:le}=ee,he=epoch(le||new Date);if((re.iat!==void 0||ae)&&typeof re.iat!="number")throw new JWTClaimValidationFailed('"iat" claim must be a number',"iat","invalid");if(re.nbf!==void 0){if(typeof re.nbf!="number")throw new JWTClaimValidationFailed('"nbf" claim must be a number',"nbf","invalid");if(re.nbf>he+ce)throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed',"nbf","check_failed")}if(re.exp!==void 0){if(typeof re.exp!="number")throw new JWTClaimValidationFailed('"exp" claim must be a number',"exp","invalid");if(re.exp<=he-ce)throw new JWTExpired('"exp" claim timestamp check failed',"exp","check_failed")}if(ae){const de=he-re.iat,ue=typeof ae=="number"?ae:secs(ae);if(de-ce>ue)throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)',"iat","check_failed");if(de<0-ce)throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)',"iat","check_failed")}return re};class ProduceJWT{constructor(E){if(!isObject(E))throw new TypeError("JWT Claims Set MUST be an object");this._payload=E}setIssuer(E){return this._payload={...this._payload,iss:E},this}setSubject(E){return this._payload={...this._payload,sub:E},this}setAudience(E){return this._payload={...this._payload,aud:E},this}setJti(E){return this._payload={...this._payload,jti:E},this}setNotBefore(E){return typeof E=="number"?this._payload={...this._payload,nbf:E}:this._payload={...this._payload,nbf:epoch(new Date)+secs(E)},this}setExpirationTime(E){return typeof E=="number"?this._payload={...this._payload,exp:E}:this._payload={...this._payload,exp:epoch(new Date)+secs(E)},this}setIssuedAt(E){return typeof E>"u"?this._payload={...this._payload,iat:epoch(new Date)}:this._payload={...this._payload,iat:E},this}}class UnsecuredJWT extends ProduceJWT{encode(){const E=encode(JSON.stringify({alg:"none"})),ee=encode(JSON.stringify(this._payload));return`${E}.${ee}.`}static decode(E,ee){if(typeof E!="string")throw new JWTInvalid("Unsecured JWT must be a string");const{0:te,1:re,2:ne,length:ie}=E.split(".");if(ie!==3||ne!=="")throw new JWTInvalid("Invalid Unsecured JWT");let se;try{if(se=JSON.parse(decoder.decode(decode(te))),se.alg!=="none")throw new Error}catch{throw new JWTInvalid("Invalid Unsecured JWT")}return{payload:jwtPayload(se,decode(re),ee),header:se}}}const EDWARDS_DID_PREFIX=new Uint8Array([237,1]),BASE58_DID_PREFIX="did:key:z";function keyBytesFromDid(J,E){if(!J.startsWith(BASE58_DID_PREFIX))throw new Error("Please use a base58-encoded DID formatted `did:key:z...`");const ee=J.slice(BASE58_DID_PREFIX.length),te=fromString$6(ee,"base58btc");if(!hasPrefix(te,E))throw new Error(`Expected prefix: ${E}`);return te.slice(E.length)}function didFromKeyBytes(J,E){const ee=concat$4([E,J]),te=toString$6(ee,"base58btc");return BASE58_DID_PREFIX+te}const hasPrefix=(J,E)=>equals$3(E,J.subarray(0,E.byteLength));class DecentralizedIdentity{#e;#t;constructor(E={},ee=EDWARDS_DID_PREFIX){this.#e=ee,this.#t=E}encode(E){return didFromKeyBytes(E,this.#e)}decode(E){return keyBytesFromDid(E,this.#e)}encodeInvite(E){const{iss:ee,claims:te}=E;return new UnsecuredJWT({...this.#t,...te}).setIssuer(this.encode(ee)).encode()}decodeInvite(E){const ee=UnsecuredJWT.decode(E);if(!ee.payload.iss)throw new Error("invalid invite");console.log("invite payload",ee);const te=this.decode(ee.payload.iss),re=ee.payload,ne={};return re?.addr&&(ne.addr=re.addr),{iss:te,claims:ne}}}var SessionEventType=(J=>(J.channel_error="channel_error",J.channel_open="channel_open",J.open_error="open_error",J.message="message",J.handshake="handshake",J))(SessionEventType||{});class EncryptedSession{constructor(E,ee=new SseTransport,te=new FetchSenderTransport,re=new Base64EnvelopeEncoding,ne=new InternalFormatJson,ie=!0){this.cryptoContext=E,this.receiver=ee,this.sender=te,this.wireFormat=re,this.format=ne,this.enableCache=ie}sessionId;toSessionId;async disconnect(){await this.receiver.close()}async*waitForJoin(){if(!(this.cryptoContext instanceof InitiatorCryptoContext)||!this.cryptoContext.handshakeChannelId)throw new Error("Must be the initiating party to accept joins");const E=encodeUrlParam(this.cryptoContext.handshakeChannelId);for await(const ee of this.receiver.listen(E))if(ee.type==="open")yield this.#t(ee);else if(ee.type==="error")yield this.#r(ee);else try{const te=this.wireFormat.decodeHandshakeEnvelope(ee.data),{plaintext:re,toSessionId:ne,sessionId:ie}=await this.cryptoContext.handleJoin(te);this.sessionId=encodeUrlParam(ie),this.toSessionId=encodeUrlParam(ne),yield this.#e("handshake",re);return}catch(te){console.warn(ee,te)}}async join(E,ee){if(!(this.cryptoContext instanceof JoinerCryptoContext))throw new Error("Must be the joining party to join");const{envelope:te,toChannelId:re,sessionId:ne,toSessionId:ie}=await this.cryptoContext.initSender(E,ee),se=this.wireFormat.encodeHandshakeEnvelope(te);this.sessionId=encodeUrlParam(ne),this.toSessionId=encodeUrlParam(ie),await this.sender.send(se,encodeUrlParam(re))}#e(E,ee){return{type:E,detail:ee}}#t(E){return this.#e("channel_open",{readyState:E.target?.readyState??E.data?.readyState})}#r(E){return this.#e("channel_error",{readyState:E.target?.readyState??E.data?.readyState})}async*listen(){if(!this.sessionId)throw this.notInitializedError();for await(const E of this.receiver.listen(this.sessionId))if(E.type==="open")yield this.#t(E);else if(E.type==="error")yield this.#r(E);else try{const ee=this.wireFormat.decodeEnvelope(E.data),te=await this.cryptoContext.open(ee.payload,ee.header);yield this.#e("message",te)}catch(ee){console.warn(E,ee),yield this.#e("open_error",{})}}#n=0;async senderSend(E){const ee=this.#n++;return{...await this.sender.send(E,this.toSessionId),requestId:ee}}async send(E){if(!this.toSessionId)throw this.notInitializedError();const ee=await this.cryptoContext.seal(E),te=this.wireFormat.encodeEnvelope(ee);return this.senderSend(te)}notInitializedError(){return new Error("Not initialized")}}class EncryptedSessionCreator{constructor(E=new HttpTransportCreator,ee=new DecentralizedIdentity){this.transportCreator=E,this.identity=ee}async createInitiatorSession(E,ee){return new EncryptedSession(E,await this.transportCreator.createReceiverTransport(ee),await this.transportCreator.createSenderTransport(ee))}async createJoinerSession(E,ee){return new EncryptedSession(E,await this.transportCreator.createReceiverTransport(ee),await this.transportCreator.createSenderTransport(ee))}async#e(){const E=new InitiatorCryptoContext,{serializedPublicKey:ee}=await E.init(),te=this.identity.encodeInvite({iss:new Uint8Array(ee)});return{initiator:E,invite:te}}async waitForJoin(E){const{initiator:ee,invite:te}=await this.#e(),re=await this.createInitiatorSession(ee);return{invite:te,joinPromise:new Promise(async(ne,ie)=>{let se;for await(const oe of re.waitForJoin()){if(oe.type==="handshake"){se=oe.detail;break}E&&E(oe)}return ne({joinMessage:se,session:this.#r(re)})})}}async joinWithInvite(E,ee){const te=new JoinerCryptoContext,re=this.identity.decodeInvite(E),ne=await this.createJoinerSession(te,re.claims?.addr?{connectingAddress:re.claims.addr}:void 0);return await ne.join(re.iss,ee),this.#r(ne)}#t(E){return!(!("sessionId"in E)||!("toSessionId"in E))}#r(E){if(!this.#t(E))throw new Error("bad session");return E}}class EncryptedSessionWithReplay extends EncryptedSession{#e=new Map;async senderSend(E){const ee=await super.senderSend(E);return this.#e.set(ee.requestId,E),ee}clearCache(E){for(const ee of E)this.#e.delete(ee)}async resendFromCache(E){if(!this.toSessionId)throw this.notInitializedError();for(const ee of E){const te=this.#e.get(ee);te&&await this.sender.send(te,this.toSessionId)}}}class EncryptedSessionWithReplayCreator extends EncryptedSessionCreator{async createInitiatorSession(E,ee){return new EncryptedSessionWithReplay(E,await this.transportCreator.createReceiverTransport(ee),await this.transportCreator.createSenderTransport(ee))}async createJoinerSession(E,ee){return new EncryptedSessionWithReplay(E,await this.transportCreator.createReceiverTransport(ee),await this.transportCreator.createSenderTransport(ee))}}class ChatContext{constructor(E,ee,te=new InternalFormatJson){this.eventTarget=E,this.sessionCreator=ee,this.format=te}session;#e;#t=0;#r=0;#n=0;#s=0;#i=!0;static createEncryptedChatContext({baseApiUrl:E}={}){let ee;E&&(ee={baseSendApiUrl:`${E}/api/send?channelId=`,baseRecieveApiUrl:`${E}/api/sse?channelId=`});const te=new EventTarget;return new DurableChatContext(te,new EncryptedSessionWithReplayCreator(new HttpTransportCreator(ee)))}static async createP2PEncryptedChatContext({relayAddr:E}){const ee=new EventTarget,{node:te,connectingAddr:re}=await P2PTransportCreator.createPrivateLibp2pNode({relayAddr:E}),ne=new P2PTransportCreator(te),ie=new DecentralizedIdentity({addr:re});return new DurableChatContext(ee,new EncryptedSessionWithReplayCreator(ne,ie))}emit(E,ee){this.eventTarget.dispatchEvent(new ChatEvent(E,{detail:ee}))}on(E,ee){ChatEvent.addTypedListener(this.eventTarget,E,ee)}async joinWithInvite(E){if(this.session)return;const ee={type:MessageType.meta,name:this.#e||"👽",id:0,lastSeenId:0};this.session=await this.sessionCreator.joinWithInvite(E,this.format.encode(ee)),this.#u(),this.emit(ChatEventType.initiated,{})}async createInviteAndWait(){const{invite:E,joinPromise:ee}=await this.sessionCreator.waitForJoin(ne=>this.#c(ne));this.emit(ChatEventType.invite,{invite:E});const{session:te,joinMessage:re}=await ee;this.session=te,this.#u(),await this.#l(re),this.emit(ChatEventType.initiated,{}),await this.#o(MessageType.meta,{name:this.#e||"🤡"})}#c(E){switch(E.type){case SessionEventType.channel_error:this.emit(ChatEventType.channel_error,E.detail);break;case SessionEventType.channel_open:this.emit(ChatEventType.channel_open,E.detail);break}}async setUsername(E){this.#e=E,this.session&&await this.#o(MessageType.meta,{name:E})}async send(E){this.session&&await this.#o(MessageType.message,E)}async ping(){return await this.sendAck()}async sendAck(){await this.#o(MessageType.ack,{})}async disconnect(){this.session&&(await this.#o(MessageType.disconnect,{}),await this.#a(!0))}async#a(E){this.session&&(await this.session.disconnect(),this.emit(ChatEventType.disconnected,{local:E}),this.session=void 0)}async sessionSend(E){return await this.session.send(this.format.encode(E))}async#o(E,ee){if(this.session){const te=++this.#t,re={...ee,type:E,id:te,lastSeenId:this.#n};this.emit(ChatEventType.queued,re);try{await this.sessionSend(re),this.#r=Date.now(),this.emit(ChatEventType.sent,re),setTimeout(()=>this.#h(),31e3)}catch{this.emit(ChatEventType.failed,re)}}}#h(){const E=Date.now()-3e4;!this.#i&&this.#r<E&&this.sendAck()}decodePlaintext(E){const ee=this.format.decode(E);if(!this.#d(ee))throw new Error("bad message");return ee}#d(E){return!(!("id"in E)||!("type"in E)||!("lastSeenId"in E))}async#l(E){const ee=this.decodePlaintext(E);ee.id>this.#n&&(this.#n=ee.id),this.#s=Date.now(),this.#i&&(this.#i=!1,this.emit(ChatEventType.active,{})),this.emit(ChatEventType.message,ee),ee.type===MessageType.disconnect&&await this.#a(!1),setTimeout(()=>this.#f(),61e3)}#f(){if(!this.session)return;const E=Date.now()-6e4;!this.#i&&this.#s<E&&(this.#i=!0,this.emit(ChatEventType.idle,{}))}async*sessionListen(){for await(const E of this.session.listen())yield E}async#u(){if(!this.session)throw new Error("Session hasn't been initiated.");for await(const E of this.sessionListen())switch(E.type){case SessionEventType.message:await this.#l(E.detail);break}}}class DurableChatContext extends ChatContext{#e=0;#t=0;#r=0;#n=!1;#s=0;#i=new Map;async sessionSend(E){const ee=await this.session.send(this.format.encode(E));return this.#i.set(E.id,ee.requestId),this.#e=E.id,ee}async*sessionListen(){let E=0,ee=!1;this.#n=!1,this.#s=this.#r;for await(const te of this.session.listen()){switch(te.type){case SessionEventType.message:{const re=this.decodePlaintext(te.detail);E=0,this.#r=re.lastSeenId,await this.#c(),this.#n&&this.#r>=this.#s&&(this.#n=!1);break}case SessionEventType.open_error:this.#s=this.#r,E++,this.#n||await this.sendAck(),E===9&&this.emit(ChatEventType.dead_session,{openErrors:E}),this.#n=!0;break;case SessionEventType.channel_error:this.emit(ChatEventType.channel_error,te.detail),ee=!0;break;case SessionEventType.channel_open:this.emit(ChatEventType.channel_open,te.detail),ee&&(ee=!1,await this.sendAck());break}yield te}}async#c(){this.#r>this.#t&&this.#a(this.#r),!this.#n&&this.#r<this.#e&&await this.#o()}#a(E){const ee=[];for(const[te,re]of this.#i)te<=E&&(ee.push(re),this.#i.delete(te));this.session.clearCache(ee),this.#t=E}async#o(){const E=[...this.#i.values()];await this.session.resendFromCache(E)}}const RELAY_REGEX=/;?r=([^;]+)/;function getInvite(J){const E=J?.slice(1).replace(RELAY_REGEX,"");return console.log("get invite",E),E}function getRelayAddr(J){const E=J?.match(RELAY_REGEX);if(console.log("get relay",E),E&&E.length>1)return E[1]}const IS_BROWSER=typeof window<"u",AppState=G(void 0);var ConnectionStatus=(J=>(J.disconnected="disconnected",J.connecting="connecting",J.connected="connected",J))(ConnectionStatus||{}),ChatStatus=(J=>(J[J.uninitialized=0]="uninitialized",J[J.active=1]="active",J[J.idle=2]="idle",J[J.disconnected=3]="disconnected",J[J.error=4]="error",J))(ChatStatus||{});async function createAppState(){const E=getInvite(location.hash)?void 0:getRelayAddr(location.hash)??"/ip4/127.0.0.1/tcp/59351/ws";console.log("relayAddr",E);const ee=await ChatContext.createP2PEncryptedChatContext({relayAddr:E}),te=u(IS_BROWSER&&localStorage?.getItem("username")||"");IS_BROWSER&&b(()=>te.value&&localStorage.setItem("username",te.value)),b(()=>te.value&&ee.setUsername(te.value));const re=u(""),ne=u("disconnected"),ie=u(0),se=u(""),oe=w$1(()=>ie.value!==0);return ee.on(ChatEventType.invite,ae=>{console.log("invite",ae),re.value=`${location.origin}/#${ae.detail.invite}`}),ee.on(ChatEventType.channel_open,()=>{console.log("open"),ne.value="connected"}),ee.on(ChatEventType.channel_error,ae=>{switch(console.log("error",ae),ae.detail.readyState){case EventSource.OPEN:ne.value="connected";break;case EventSource.CLOSED:ne.value="disconnected";break;case EventSource.CONNECTING:default:ne.value="connecting";break}}),ee.on(ChatEventType.initiated,()=>{ie.value=1}),ee.on(ChatEventType.disconnected,()=>{ie.value=3,ne.value="disconnected"}),ee.on(ChatEventType.message,ae=>{switch(ie.value=1,ae.detail.type){case MessageType.meta:ae.detail.name&&(se.value=ae.detail.name,location.hash="");break}}),{username:te,partnerUsername:se,chatStatus:ie,connectionStatus:ne,chatReady:oe,joinLink:re,chatContext:ee}}const addMessageFn=J=>E=>{const ee=E.lastSeenId;let te=J.value;ee!==void 0&&!E.self&&(te=te.map(re=>{const ne=re.id;return re.self&&ne!==void 0&&ee>ne?{...re,seen:!0}:re})),E.msg?J.value=[...te,E]:J.value=te};function setupMessageListeners(J,E,ee){const te=addMessageFn(E),re=u(0);J.on(ChatEventType.message,ne=>{ne.detail.type===MessageType.message?te({...ne.detail,uid:`i:${ne.detail.id}`,seen:!0,time:Date.now(),self:!1}):ne.detail.type===MessageType.disconnect?te({...ne.detail,uid:`i:${ne.detail.id}`,msg:`${ee.value} has left the chat`,system:!0,seen:!0,self:!1,time:Date.now()}):ne.detail.lastSeenId&&te({...ne.detail,uid:`i:${ne.detail.id}`})}),J.on(ChatEventType.queued,ne=>{ne.detail.type===MessageType.message&&te({...ne.detail,uid:`o:${ne.detail.id}`,seen:!1,self:!0})}),J.on(ChatEventType.disconnected,ne=>{ne.detail.local&&te({uid:`s:${re.value++}`,msg:"You left the chat",system:!0,self:!0,time:Date.now()})}),J.on(ChatEventType.dead_session,()=>{te({uid:`s:${re.value++}`,msg:"The session may have died! Refresh to start a new one.",system:!0,self:!0,time:Date.now()})}),J.on(ChatEventType.idle,()=>{te({uid:`s:${re.value++}`,msg:`${ee.value} may have gone offline. Refresh to start a new session.`,system:!0,self:!0,time:Date.now()})}),J.on(ChatEventType.sent,ne=>{console.log("sent",ne)}),J.on(ChatEventType.failed,ne=>{console.log("failed",ne)})}var browser={},canPromise$1=function(){return typeof Promise=="function"&&Promise.prototype&&Promise.prototype.then},qrcode={},utils$1={};let toSJISFunction;const CODEWORDS_COUNT=[0,26,44,70,100,134,172,196,242,292,346,404,466,532,581,655,733,815,901,991,1085,1156,1258,1364,1474,1588,1706,1828,1921,2051,2185,2323,2465,2611,2761,2876,3034,3196,3362,3532,3706];utils$1.getSymbolSize=function J(E){if(!E)throw new Error('"version" cannot be null or undefined');if(E<1||E>40)throw new Error('"version" should be in range from 1 to 40');return E*4+17};utils$1.getSymbolTotalCodewords=function J(E){return CODEWORDS_COUNT[E]};utils$1.getBCHDigit=function(J){let E=0;for(;J!==0;)E++,J>>>=1;return E};utils$1.setToSJISFunction=function J(E){if(typeof E!="function")throw new Error('"toSJISFunc" is not a valid function.');toSJISFunction=E};utils$1.isKanjiModeEnabled=function(){return typeof toSJISFunction<"u"};utils$1.toSJIS=function J(E){return toSJISFunction(E)};var errorCorrectionLevel={};(function(J){J.L={bit:1},J.M={bit:0},J.Q={bit:3},J.H={bit:2};function E(ee){if(typeof ee!="string")throw new Error("Param is not a string");switch(ee.toLowerCase()){case"l":case"low":return J.L;case"m":case"medium":return J.M;case"q":case"quartile":return J.Q;case"h":case"high":return J.H;default:throw new Error("Unknown EC Level: "+ee)}}J.isValid=function(te){return te&&typeof te.bit<"u"&&te.bit>=0&&te.bit<4},J.from=function(te,re){if(J.isValid(te))return te;try{return E(te)}catch{return re}}})(errorCorrectionLevel);function BitBuffer$1(){this.buffer=[],this.length=0}BitBuffer$1.prototype={get:function(J){const E=Math.floor(J/8);return(this.buffer[E]>>>7-J%8&1)===1},put:function(J,E){for(let ee=0;ee<E;ee++)this.putBit((J>>>E-ee-1&1)===1)},getLengthInBits:function(){return this.length},putBit:function(J){const E=Math.floor(this.length/8);this.buffer.length<=E&&this.buffer.push(0),J&&(this.buffer[E]|=128>>>this.length%8),this.length++}};var bitBuffer=BitBuffer$1;function BitMatrix$1(J){if(!J||J<1)throw new Error("BitMatrix size must be defined and greater than 0");this.size=J,this.data=new Uint8Array(J*J),this.reservedBit=new Uint8Array(J*J)}BitMatrix$1.prototype.set=function(J,E,ee,te){const re=J*this.size+E;this.data[re]=ee,te&&(this.reservedBit[re]=!0)};BitMatrix$1.prototype.get=function(J,E){return this.data[J*this.size+E]};BitMatrix$1.prototype.xor=function(J,E,ee){this.data[J*this.size+E]^=ee};BitMatrix$1.prototype.isReserved=function(J,E){return this.reservedBit[J*this.size+E]};var bitMatrix=BitMatrix$1,alignmentPattern={};(function(J){const E=utils$1.getSymbolSize;J.getRowColCoords=function(te){if(te===1)return[];const re=Math.floor(te/7)+2,ne=E(te),ie=ne===145?26:Math.ceil((ne-13)/(2*re-2))*2,se=[ne-7];for(let oe=1;oe<re-1;oe++)se[oe]=se[oe-1]-ie;return se.push(6),se.reverse()},J.getPositions=function(te){const re=[],ne=J.getRowColCoords(te),ie=ne.length;for(let se=0;se<ie;se++)for(let oe=0;oe<ie;oe++)se===0&&oe===0||se===0&&oe===ie-1||se===ie-1&&oe===0||re.push([ne[se],ne[oe]]);return re}})(alignmentPattern);var finderPattern={};const getSymbolSize=utils$1.getSymbolSize,FINDER_PATTERN_SIZE=7;finderPattern.getPositions=function J(E){const ee=getSymbolSize(E);return[[0,0],[ee-FINDER_PATTERN_SIZE,0],[0,ee-FINDER_PATTERN_SIZE]]};var maskPattern={};(function(J){J.Patterns={PATTERN000:0,PATTERN001:1,PATTERN010:2,PATTERN011:3,PATTERN100:4,PATTERN101:5,PATTERN110:6,PATTERN111:7};const E={N1:3,N2:3,N3:40,N4:10};J.isValid=function(re){return re!=null&&re!==""&&!isNaN(re)&&re>=0&&re<=7},J.from=function(re){return J.isValid(re)?parseInt(re,10):void 0},J.getPenaltyN1=function(re){const ne=re.size;let ie=0,se=0,oe=0,ae=null,ce=null;for(let le=0;le<ne;le++){se=oe=0,ae=ce=null;for(let he=0;he<ne;he++){let de=re.get(le,he);de===ae?se++:(se>=5&&(ie+=E.N1+(se-5)),ae=de,se=1),de=re.get(he,le),de===ce?oe++:(oe>=5&&(ie+=E.N1+(oe-5)),ce=de,oe=1)}se>=5&&(ie+=E.N1+(se-5)),oe>=5&&(ie+=E.N1+(oe-5))}return ie},J.getPenaltyN2=function(re){const ne=re.size;let ie=0;for(let se=0;se<ne-1;se++)for(let oe=0;oe<ne-1;oe++){const ae=re.get(se,oe)+re.get(se,oe+1)+re.get(se+1,oe)+re.get(se+1,oe+1);(ae===4||ae===0)&&ie++}return ie*E.N2},J.getPenaltyN3=function(re){const ne=re.size;let ie=0,se=0,oe=0;for(let ae=0;ae<ne;ae++){se=oe=0;for(let ce=0;ce<ne;ce++)se=se<<1&2047|re.get(ae,ce),ce>=10&&(se===1488||se===93)&&ie++,oe=oe<<1&2047|re.get(ce,ae),ce>=10&&(oe===1488||oe===93)&&ie++}return ie*E.N3},J.getPenaltyN4=function(re){let ne=0;const ie=re.data.length;for(let oe=0;oe<ie;oe++)ne+=re.data[oe];return Math.abs(Math.ceil(ne*100/ie/5)-10)*E.N4};function ee(te,re,ne){switch(te){case J.Patterns.PATTERN000:return(re+ne)%2===0;case J.Patterns.PATTERN001:return re%2===0;case J.Patterns.PATTERN010:return ne%3===0;case J.Patterns.PATTERN011:return(re+ne)%3===0;case J.Patterns.PATTERN100:return(Math.floor(re/2)+Math.floor(ne/3))%2===0;case J.Patterns.PATTERN101:return re*ne%2+re*ne%3===0;case J.Patterns.PATTERN110:return(re*ne%2+re*ne%3)%2===0;case J.Patterns.PATTERN111:return(re*ne%3+(re+ne)%2)%2===0;default:throw new Error("bad maskPattern:"+te)}}J.applyMask=function(re,ne){const ie=ne.size;for(let se=0;se<ie;se++)for(let oe=0;oe<ie;oe++)ne.isReserved(oe,se)||ne.xor(oe,se,ee(re,oe,se))},J.getBestMask=function(re,ne){const ie=Object.keys(J.Patterns).length;let se=0,oe=1/0;for(let ae=0;ae<ie;ae++){ne(ae),J.applyMask(ae,re);const ce=J.getPenaltyN1(re)+J.getPenaltyN2(re)+J.getPenaltyN3(re)+J.getPenaltyN4(re);J.applyMask(ae,re),ce<oe&&(oe=ce,se=ae)}return se}})(maskPattern);var errorCorrectionCode={};const ECLevel$1=errorCorrectionLevel,EC_BLOCKS_TABLE=[1,1,1,1,1,1,1,1,1,1,2,2,1,2,2,4,1,2,4,4,2,4,4,4,2,4,6,5,2,4,6,6,2,5,8,8,4,5,8,8,4,5,8,11,4,8,10,11,4,9,12,16,4,9,16,16,6,10,12,18,6,10,17,16,6,11,16,19,6,13,18,21,7,14,21,25,8,16,20,25,8,17,23,25,9,17,23,34,9,18,25,30,10,20,27,32,12,21,29,35,12,23,34,37,12,25,34,40,13,26,35,42,14,28,38,45,15,29,40,48,16,31,43,51,17,33,45,54,18,35,48,57,19,37,51,60,19,38,53,63,20,40,56,66,21,43,59,70,22,45,62,74,24,47,65,77,25,49,68,81],EC_CODEWORDS_TABLE=[7,10,13,17,10,16,22,28,15,26,36,44,20,36,52,64,26,48,72,88,36,64,96,112,40,72,108,130,48,88,132,156,60,110,160,192,72,130,192,224,80,150,224,264,96,176,260,308,104,198,288,352,120,216,320,384,132,240,360,432,144,280,408,480,168,308,448,532,180,338,504,588,196,364,546,650,224,416,600,700,224,442,644,750,252,476,690,816,270,504,750,900,300,560,810,960,312,588,870,1050,336,644,952,1110,360,700,1020,1200,390,728,1050,1260,420,784,1140,1350,450,812,1200,1440,480,868,1290,1530,510,924,1350,1620,540,980,1440,1710,570,1036,1530,1800,570,1064,1590,1890,600,1120,1680,1980,630,1204,1770,2100,660,1260,1860,2220,720,1316,1950,2310,750,1372,2040,2430];errorCorrectionCode.getBlocksCount=function J(E,ee){switch(ee){case ECLevel$1.L:return EC_BLOCKS_TABLE[(E-1)*4+0];case ECLevel$1.M:return EC_BLOCKS_TABLE[(E-1)*4+1];case ECLevel$1.Q:return EC_BLOCKS_TABLE[(E-1)*4+2];case ECLevel$1.H:return EC_BLOCKS_TABLE[(E-1)*4+3];default:return}};errorCorrectionCode.getTotalCodewordsCount=function J(E,ee){switch(ee){case ECLevel$1.L:return EC_CODEWORDS_TABLE[(E-1)*4+0];case ECLevel$1.M:return EC_CODEWORDS_TABLE[(E-1)*4+1];case ECLevel$1.Q:return EC_CODEWORDS_TABLE[(E-1)*4+2];case ECLevel$1.H:return EC_CODEWORDS_TABLE[(E-1)*4+3];default:return}};var polynomial={},galoisField={};const EXP_TABLE=new Uint8Array(512),LOG_TABLE=new Uint8Array(256);(function J(){let E=1;for(let ee=0;ee<255;ee++)EXP_TABLE[ee]=E,LOG_TABLE[E]=ee,E<<=1,E&256&&(E^=285);for(let ee=255;ee<512;ee++)EXP_TABLE[ee]=EXP_TABLE[ee-255]})();galoisField.log=function J(E){if(E<1)throw new Error("log("+E+")");return LOG_TABLE[E]};galoisField.exp=function J(E){return EXP_TABLE[E]};galoisField.mul=function J(E,ee){return E===0||ee===0?0:EXP_TABLE[LOG_TABLE[E]+LOG_TABLE[ee]]};(function(J){const E=galoisField;J.mul=function(te,re){const ne=new Uint8Array(te.length+re.length-1);for(let ie=0;ie<te.length;ie++)for(let se=0;se<re.length;se++)ne[ie+se]^=E.mul(te[ie],re[se]);return ne},J.mod=function(te,re){let ne=new Uint8Array(te);for(;ne.length-re.length>=0;){const ie=ne[0];for(let oe=0;oe<re.length;oe++)ne[oe]^=E.mul(re[oe],ie);let se=0;for(;se<ne.length&&ne[se]===0;)se++;ne=ne.slice(se)}return ne},J.generateECPolynomial=function(te){let re=new Uint8Array([1]);for(let ne=0;ne<te;ne++)re=J.mul(re,new Uint8Array([1,E.exp(ne)]));return re}})(polynomial);const Polynomial=polynomial;function ReedSolomonEncoder$1(J){this.genPoly=void 0,this.degree=J,this.degree&&this.initialize(this.degree)}ReedSolomonEncoder$1.prototype.initialize=function J(E){this.degree=E,this.genPoly=Polynomial.generateECPolynomial(this.degree)};ReedSolomonEncoder$1.prototype.encode=function J(E){if(!this.genPoly)throw new Error("Encoder not initialized");const ee=new Uint8Array(E.length+this.degree);ee.set(E);const te=Polynomial.mod(ee,this.genPoly),re=this.degree-te.length;if(re>0){const ne=new Uint8Array(this.degree);return ne.set(te,re),ne}return te};var reedSolomonEncoder=ReedSolomonEncoder$1,version={},mode={},versionCheck={};versionCheck.isValid=function J(E){return!isNaN(E)&&E>=1&&E<=40};var regex={};const numeric="[0-9]+",alphanumeric="[A-Z $%*+\\-./:]+";let kanji="(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";kanji=kanji.replace(/u/g,"\\u");const byte="(?:(?![A-Z0-9 $%*+\\-./:]|"+kanji+`)(?:.|[\r
]))+`;regex.KANJI=new RegExp(kanji,"g");regex.BYTE_KANJI=new RegExp("[^A-Z0-9 $%*+\\-./:]+","g");regex.BYTE=new RegExp(byte,"g");regex.NUMERIC=new RegExp(numeric,"g");regex.ALPHANUMERIC=new RegExp(alphanumeric,"g");const TEST_KANJI=new RegExp("^"+kanji+"$"),TEST_NUMERIC=new RegExp("^"+numeric+"$"),TEST_ALPHANUMERIC=new RegExp("^[A-Z0-9 $%*+\\-./:]+$");regex.testKanji=function J(E){return TEST_KANJI.test(E)};regex.testNumeric=function J(E){return TEST_NUMERIC.test(E)};regex.testAlphanumeric=function J(E){return TEST_ALPHANUMERIC.test(E)};(function(J){const E=versionCheck,ee=regex;J.NUMERIC={id:"Numeric",bit:1,ccBits:[10,12,14]},J.ALPHANUMERIC={id:"Alphanumeric",bit:2,ccBits:[9,11,13]},J.BYTE={id:"Byte",bit:4,ccBits:[8,16,16]},J.KANJI={id:"Kanji",bit:8,ccBits:[8,10,12]},J.MIXED={bit:-1},J.getCharCountIndicator=function(ne,ie){if(!ne.ccBits)throw new Error("Invalid mode: "+ne);if(!E.isValid(ie))throw new Error("Invalid version: "+ie);return ie>=1&&ie<10?ne.ccBits[0]:ie<27?ne.ccBits[1]:ne.ccBits[2]},J.getBestModeForData=function(ne){return ee.testNumeric(ne)?J.NUMERIC:ee.testAlphanumeric(ne)?J.ALPHANUMERIC:ee.testKanji(ne)?J.KANJI:J.BYTE},J.toString=function(ne){if(ne&&ne.id)return ne.id;throw new Error("Invalid mode")},J.isValid=function(ne){return ne&&ne.bit&&ne.ccBits};function te(re){if(typeof re!="string")throw new Error("Param is not a string");switch(re.toLowerCase()){case"numeric":return J.NUMERIC;case"alphanumeric":return J.ALPHANUMERIC;case"kanji":return J.KANJI;case"byte":return J.BYTE;default:throw new Error("Unknown mode: "+re)}}J.from=function(ne,ie){if(J.isValid(ne))return ne;try{return te(ne)}catch{return ie}}})(mode);(function(J){const E=utils$1,ee=errorCorrectionCode,te=errorCorrectionLevel,re=mode,ne=versionCheck,ie=7973,se=E.getBCHDigit(ie);function oe(he,de,ue){for(let pe=1;pe<=40;pe++)if(de<=J.getCapacity(pe,ue,he))return pe}function ae(he,de){return re.getCharCountIndicator(he,de)+4}function ce(he,de){let ue=0;return he.forEach(function(pe){const ye=ae(pe.mode,de);ue+=ye+pe.getBitsLength()}),ue}function le(he,de){for(let ue=1;ue<=40;ue++)if(ce(he,ue)<=J.getCapacity(ue,de,re.MIXED))return ue}J.from=function(de,ue){return ne.isValid(de)?parseInt(de,10):ue},J.getCapacity=function(de,ue,pe){if(!ne.isValid(de))throw new Error("Invalid QR Code version");typeof pe>"u"&&(pe=re.BYTE);const ye=E.getSymbolTotalCodewords(de),me=ee.getTotalCodewordsCount(de,ue),be=(ye-me)*8;if(pe===re.MIXED)return be;const _e=be-ae(pe,de);switch(pe){case re.NUMERIC:return Math.floor(_e/10*3);case re.ALPHANUMERIC:return Math.floor(_e/11*2);case re.KANJI:return Math.floor(_e/13);case re.BYTE:default:return Math.floor(_e/8)}},J.getBestVersionForData=function(de,ue){let pe;const ye=te.from(ue,te.M);if(Array.isArray(de)){if(de.length>1)return le(de,ye);if(de.length===0)return 1;pe=de[0]}else pe=de;return oe(pe.mode,pe.getLength(),ye)},J.getEncodedBits=function(de){if(!ne.isValid(de)||de<7)throw new Error("Invalid QR Code version");let ue=de<<12;for(;E.getBCHDigit(ue)-se>=0;)ue^=ie<<E.getBCHDigit(ue)-se;return de<<12|ue}})(version);var formatInfo={};const Utils$3=utils$1,G15=1335,G15_MASK=21522,G15_BCH=Utils$3.getBCHDigit(G15);formatInfo.getEncodedBits=function J(E,ee){const te=E.bit<<3|ee;let re=te<<10;for(;Utils$3.getBCHDigit(re)-G15_BCH>=0;)re^=G15<<Utils$3.getBCHDigit(re)-G15_BCH;return(te<<10|re)^G15_MASK};var segments={};const Mode$4=mode;function NumericData(J){this.mode=Mode$4.NUMERIC,this.data=J.toString()}NumericData.getBitsLength=function J(E){return 10*Math.floor(E/3)+(E%3?E%3*3+1:0)};NumericData.prototype.getLength=function J(){return this.data.length};NumericData.prototype.getBitsLength=function J(){return NumericData.getBitsLength(this.data.length)};NumericData.prototype.write=function J(E){let ee,te,re;for(ee=0;ee+3<=this.data.length;ee+=3)te=this.data.substr(ee,3),re=parseInt(te,10),E.put(re,10);const ne=this.data.length-ee;ne>0&&(te=this.data.substr(ee),re=parseInt(te,10),E.put(re,ne*3+1))};var numericData=NumericData;const Mode$3=mode,ALPHA_NUM_CHARS=["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"," ","$","%","*","+","-",".","/",":"];function AlphanumericData(J){this.mode=Mode$3.ALPHANUMERIC,this.data=J}AlphanumericData.getBitsLength=function J(E){return 11*Math.floor(E/2)+6*(E%2)};AlphanumericData.prototype.getLength=function J(){return this.data.length};AlphanumericData.prototype.getBitsLength=function J(){return AlphanumericData.getBitsLength(this.data.length)};AlphanumericData.prototype.write=function J(E){let ee;for(ee=0;ee+2<=this.data.length;ee+=2){let te=ALPHA_NUM_CHARS.indexOf(this.data[ee])*45;te+=ALPHA_NUM_CHARS.indexOf(this.data[ee+1]),E.put(te,11)}this.data.length%2&&E.put(ALPHA_NUM_CHARS.indexOf(this.data[ee]),6)};var alphanumericData=AlphanumericData,encodeUtf8$1=function J(E){for(var ee=[],te=E.length,re=0;re<te;re++){var ne=E.charCodeAt(re);if(ne>=55296&&ne<=56319&&te>re+1){var ie=E.charCodeAt(re+1);ie>=56320&&ie<=57343&&(ne=(ne-55296)*1024+ie-56320+65536,re+=1)}if(ne<128){ee.push(ne);continue}if(ne<2048){ee.push(ne>>6|192),ee.push(ne&63|128);continue}if(ne<55296||ne>=57344&&ne<65536){ee.push(ne>>12|224),ee.push(ne>>6&63|128),ee.push(ne&63|128);continue}if(ne>=65536&&ne<=1114111){ee.push(ne>>18|240),ee.push(ne>>12&63|128),ee.push(ne>>6&63|128),ee.push(ne&63|128);continue}ee.push(239,191,189)}return new Uint8Array(ee).buffer};const encodeUtf8=encodeUtf8$1,Mode$2=mode;function ByteData(J){this.mode=Mode$2.BYTE,typeof J=="string"&&(J=encodeUtf8(J)),this.data=new Uint8Array(J)}ByteData.getBitsLength=function J(E){return E*8};ByteData.prototype.getLength=function J(){return this.data.length};ByteData.prototype.getBitsLength=function J(){return ByteData.getBitsLength(this.data.length)};ByteData.prototype.write=function(J){for(let E=0,ee=this.data.length;E<ee;E++)J.put(this.data[E],8)};var byteData=ByteData;const Mode$1=mode,Utils$2=utils$1;function KanjiData(J){this.mode=Mode$1.KANJI,this.data=J}KanjiData.getBitsLength=function J(E){return E*13};KanjiData.prototype.getLength=function J(){return this.data.length};KanjiData.prototype.getBitsLength=function J(){return KanjiData.getBitsLength(this.data.length)};KanjiData.prototype.write=function(J){let E;for(E=0;E<this.data.length;E++){let ee=Utils$2.toSJIS(this.data[E]);if(ee>=33088&&ee<=40956)ee-=33088;else if(ee>=57408&&ee<=60351)ee-=49472;else throw new Error("Invalid SJIS character: "+this.data[E]+`
Make sure your charset is UTF-8`);ee=(ee>>>8&255)*192+(ee&255),J.put(ee,13)}};var kanjiData=KanjiData,dijkstra={exports:{}};(function(J){var E={single_source_shortest_paths:function(ee,te,re){var ne={},ie={};ie[te]=0;var se=E.PriorityQueue.make();se.push(te,0);for(var oe,ae,ce,le,he,de,ue,pe,ye;!se.empty();){oe=se.pop(),ae=oe.value,le=oe.cost,he=ee[ae]||{};for(ce in he)he.hasOwnProperty(ce)&&(de=he[ce],ue=le+de,pe=ie[ce],ye=typeof ie[ce]>"u",(ye||pe>ue)&&(ie[ce]=ue,se.push(ce,ue),ne[ce]=ae))}if(typeof re<"u"&&typeof ie[re]>"u"){var me=["Could not find a path from ",te," to ",re,"."].join("");throw new Error(me)}return ne},extract_shortest_path_from_predecessor_list:function(ee,te){for(var re=[],ne=te;ne;)re.push(ne),ee[ne],ne=ee[ne];return re.reverse(),re},find_path:function(ee,te,re){var ne=E.single_source_shortest_paths(ee,te,re);return E.extract_shortest_path_from_predecessor_list(ne,re)},PriorityQueue:{make:function(ee){var te=E.PriorityQueue,re={},ne;ee=ee||{};for(ne in te)te.hasOwnProperty(ne)&&(re[ne]=te[ne]);return re.queue=[],re.sorter=ee.sorter||te.default_sorter,re},default_sorter:function(ee,te){return ee.cost-te.cost},push:function(ee,te){var re={value:ee,cost:te};this.queue.push(re),this.queue.sort(this.sorter)},pop:function(){return this.queue.shift()},empty:function(){return this.queue.length===0}}};J.exports=E})(dijkstra);var dijkstraExports=dijkstra.exports;(function(J){const E=mode,ee=numericData,te=alphanumericData,re=byteData,ne=kanjiData,ie=regex,se=utils$1,oe=dijkstraExports;function ae(me){return unescape(encodeURIComponent(me)).length}function ce(me,be,_e){const we=[];let $e;for(;($e=me.exec(_e))!==null;)we.push({data:$e[0],index:$e.index,mode:be,length:$e[0].length});return we}function le(me){const be=ce(ie.NUMERIC,E.NUMERIC,me),_e=ce(ie.ALPHANUMERIC,E.ALPHANUMERIC,me);let we,$e;return se.isKanjiModeEnabled()?(we=ce(ie.BYTE,E.BYTE,me),$e=ce(ie.KANJI,E.KANJI,me)):(we=ce(ie.BYTE_KANJI,E.BYTE,me),$e=[]),be.concat(_e,we,$e).sort(function(fe,Ee){return fe.index-Ee.index}).map(function(fe){return{data:fe.data,mode:fe.mode,length:fe.length}})}function he(me,be){switch(be){case E.NUMERIC:return ee.getBitsLength(me);case E.ALPHANUMERIC:return te.getBitsLength(me);case E.KANJI:return ne.getBitsLength(me);case E.BYTE:return re.getBitsLength(me)}}function de(me){return me.reduce(function(be,_e){const we=be.length-1>=0?be[be.length-1]:null;return we&&we.mode===_e.mode?(be[be.length-1].data+=_e.data,be):(be.push(_e),be)},[])}function ue(me){const be=[];for(let _e=0;_e<me.length;_e++){const we=me[_e];switch(we.mode){case E.NUMERIC:be.push([we,{data:we.data,mode:E.ALPHANUMERIC,length:we.length},{data:we.data,mode:E.BYTE,length:we.length}]);break;case E.ALPHANUMERIC:be.push([we,{data:we.data,mode:E.BYTE,length:we.length}]);break;case E.KANJI:be.push([we,{data:we.data,mode:E.BYTE,length:ae(we.data)}]);break;case E.BYTE:be.push([{data:we.data,mode:E.BYTE,length:ae(we.data)}])}}return be}function pe(me,be){const _e={},we={start:{}};let $e=["start"];for(let ve=0;ve<me.length;ve++){const fe=me[ve],Ee=[];for(let ke=0;ke<fe.length;ke++){const Ne=fe[ke],xe=""+ve+ke;Ee.push(xe),_e[xe]={node:Ne,lastCount:0},we[xe]={};for(let Ue=0;Ue<$e.length;Ue++){const Ke=$e[Ue];_e[Ke]&&_e[Ke].node.mode===Ne.mode?(we[Ke][xe]=he(_e[Ke].lastCount+Ne.length,Ne.mode)-he(_e[Ke].lastCount,Ne.mode),_e[Ke].lastCount+=Ne.length):(_e[Ke]&&(_e[Ke].lastCount=Ne.length),we[Ke][xe]=he(Ne.length,Ne.mode)+4+E.getCharCountIndicator(Ne.mode,be))}}$e=Ee}for(let ve=0;ve<$e.length;ve++)we[$e[ve]].end=0;return{map:we,table:_e}}function ye(me,be){let _e;const we=E.getBestModeForData(me);if(_e=E.from(be,we),_e!==E.BYTE&&_e.bit<we.bit)throw new Error('"'+me+'" cannot be encoded with mode '+E.toString(_e)+`.
 Suggested mode is: `+E.toString(we));switch(_e===E.KANJI&&!se.isKanjiModeEnabled()&&(_e=E.BYTE),_e){case E.NUMERIC:return new ee(me);case E.ALPHANUMERIC:return new te(me);case E.KANJI:return new ne(me);case E.BYTE:return new re(me)}}J.fromArray=function(be){return be.reduce(function(_e,we){return typeof we=="string"?_e.push(ye(we,null)):we.data&&_e.push(ye(we.data,we.mode)),_e},[])},J.fromString=function(be,_e){const we=le(be,se.isKanjiModeEnabled()),$e=ue(we),ve=pe($e,_e),fe=oe.find_path(ve.map,"start","end"),Ee=[];for(let ke=1;ke<fe.length-1;ke++)Ee.push(ve.table[fe[ke]].node);return J.fromArray(de(Ee))},J.rawSplit=function(be){return J.fromArray(le(be,se.isKanjiModeEnabled()))}})(segments);const Utils$1=utils$1,ECLevel=errorCorrectionLevel,BitBuffer=bitBuffer,BitMatrix=bitMatrix,AlignmentPattern=alignmentPattern,FinderPattern=finderPattern,MaskPattern=maskPattern,ECCode=errorCorrectionCode,ReedSolomonEncoder=reedSolomonEncoder,Version=version,FormatInfo=formatInfo,Mode=mode,Segments=segments;function setupFinderPattern(J,E){const ee=J.size,te=FinderPattern.getPositions(E);for(let re=0;re<te.length;re++){const ne=te[re][0],ie=te[re][1];for(let se=-1;se<=7;se++)if(!(ne+se<=-1||ee<=ne+se))for(let oe=-1;oe<=7;oe++)ie+oe<=-1||ee<=ie+oe||(se>=0&&se<=6&&(oe===0||oe===6)||oe>=0&&oe<=6&&(se===0||se===6)||se>=2&&se<=4&&oe>=2&&oe<=4?J.set(ne+se,ie+oe,!0,!0):J.set(ne+se,ie+oe,!1,!0))}}function setupTimingPattern(J){const E=J.size;for(let ee=8;ee<E-8;ee++){const te=ee%2===0;J.set(ee,6,te,!0),J.set(6,ee,te,!0)}}function setupAlignmentPattern(J,E){const ee=AlignmentPattern.getPositions(E);for(let te=0;te<ee.length;te++){const re=ee[te][0],ne=ee[te][1];for(let ie=-2;ie<=2;ie++)for(let se=-2;se<=2;se++)ie===-2||ie===2||se===-2||se===2||ie===0&&se===0?J.set(re+ie,ne+se,!0,!0):J.set(re+ie,ne+se,!1,!0)}}function setupVersionInfo(J,E){const ee=J.size,te=Version.getEncodedBits(E);let re,ne,ie;for(let se=0;se<18;se++)re=Math.floor(se/3),ne=se%3+ee-8-3,ie=(te>>se&1)===1,J.set(re,ne,ie,!0),J.set(ne,re,ie,!0)}function setupFormatInfo(J,E,ee){const te=J.size,re=FormatInfo.getEncodedBits(E,ee);let ne,ie;for(ne=0;ne<15;ne++)ie=(re>>ne&1)===1,ne<6?J.set(ne,8,ie,!0):ne<8?J.set(ne+1,8,ie,!0):J.set(te-15+ne,8,ie,!0),ne<8?J.set(8,te-ne-1,ie,!0):ne<9?J.set(8,15-ne-1+1,ie,!0):J.set(8,15-ne-1,ie,!0);J.set(te-8,8,1,!0)}function setupData(J,E){const ee=J.size;let te=-1,re=ee-1,ne=7,ie=0;for(let se=ee-1;se>0;se-=2)for(se===6&&se--;;){for(let oe=0;oe<2;oe++)if(!J.isReserved(re,se-oe)){let ae=!1;ie<E.length&&(ae=(E[ie]>>>ne&1)===1),J.set(re,se-oe,ae),ne--,ne===-1&&(ie++,ne=7)}if(re+=te,re<0||ee<=re){re-=te,te=-te;break}}}function createData(J,E,ee){const te=new BitBuffer;ee.forEach(function(oe){te.put(oe.mode.bit,4),te.put(oe.getLength(),Mode.getCharCountIndicator(oe.mode,J)),oe.write(te)});const re=Utils$1.getSymbolTotalCodewords(J),ne=ECCode.getTotalCodewordsCount(J,E),ie=(re-ne)*8;for(te.getLengthInBits()+4<=ie&&te.put(0,4);te.getLengthInBits()%8!==0;)te.putBit(0);const se=(ie-te.getLengthInBits())/8;for(let oe=0;oe<se;oe++)te.put(oe%2?17:236,8);return createCodewords(te,J,E)}function createCodewords(J,E,ee){const te=Utils$1.getSymbolTotalCodewords(E),re=ECCode.getTotalCodewordsCount(E,ee),ne=te-re,ie=ECCode.getBlocksCount(E,ee),se=te%ie,oe=ie-se,ae=Math.floor(te/ie),ce=Math.floor(ne/ie),le=ce+1,he=ae-ce,de=new ReedSolomonEncoder(he);let ue=0;const pe=new Array(ie),ye=new Array(ie);let me=0;const be=new Uint8Array(J.buffer);for(let fe=0;fe<ie;fe++){const Ee=fe<oe?ce:le;pe[fe]=be.slice(ue,ue+Ee),ye[fe]=de.encode(pe[fe]),ue+=Ee,me=Math.max(me,Ee)}const _e=new Uint8Array(te);let we=0,$e,ve;for($e=0;$e<me;$e++)for(ve=0;ve<ie;ve++)$e<pe[ve].length&&(_e[we++]=pe[ve][$e]);for($e=0;$e<he;$e++)for(ve=0;ve<ie;ve++)_e[we++]=ye[ve][$e];return _e}function createSymbol(J,E,ee,te){let re;if(Array.isArray(J))re=Segments.fromArray(J);else if(typeof J=="string"){let ae=E;if(!ae){const ce=Segments.rawSplit(J);ae=Version.getBestVersionForData(ce,ee)}re=Segments.fromString(J,ae||40)}else throw new Error("Invalid data");const ne=Version.getBestVersionForData(re,ee);if(!ne)throw new Error("The amount of data is too big to be stored in a QR Code");if(!E)E=ne;else if(E<ne)throw new Error(`
The chosen QR Code version cannot contain this amount of data.
Minimum version required to store current data is: `+ne+`.
`);const ie=createData(E,ee,re),se=Utils$1.getSymbolSize(E),oe=new BitMatrix(se);return setupFinderPattern(oe,E),setupTimingPattern(oe),setupAlignmentPattern(oe,E),setupFormatInfo(oe,ee,0),E>=7&&setupVersionInfo(oe,E),setupData(oe,ie),isNaN(te)&&(te=MaskPattern.getBestMask(oe,setupFormatInfo.bind(null,oe,ee))),MaskPattern.applyMask(te,oe),setupFormatInfo(oe,ee,te),{modules:oe,version:E,errorCorrectionLevel:ee,maskPattern:te,segments:re}}qrcode.create=function J(E,ee){if(typeof E>"u"||E==="")throw new Error("No input text");let te=ECLevel.M,re,ne;return typeof ee<"u"&&(te=ECLevel.from(ee.errorCorrectionLevel,ECLevel.M),re=Version.from(ee.version),ne=MaskPattern.from(ee.maskPattern),ee.toSJISFunc&&Utils$1.setToSJISFunction(ee.toSJISFunc)),createSymbol(E,re,te,ne)};var canvas={},utils={};(function(J){function E(ee){if(typeof ee=="number"&&(ee=ee.toString()),typeof ee!="string")throw new Error("Color should be defined as hex string");let te=ee.slice().replace("#","").split("");if(te.length<3||te.length===5||te.length>8)throw new Error("Invalid hex color: "+ee);(te.length===3||te.length===4)&&(te=Array.prototype.concat.apply([],te.map(function(ne){return[ne,ne]}))),te.length===6&&te.push("F","F");const re=parseInt(te.join(""),16);return{r:re>>24&255,g:re>>16&255,b:re>>8&255,a:re&255,hex:"#"+te.slice(0,6).join("")}}J.getOptions=function(te){te||(te={}),te.color||(te.color={});const re=typeof te.margin>"u"||te.margin===null||te.margin<0?4:te.margin,ne=te.width&&te.width>=21?te.width:void 0,ie=te.scale||4;return{width:ne,scale:ne?4:ie,margin:re,color:{dark:E(te.color.dark||"#000000ff"),light:E(te.color.light||"#ffffffff")},type:te.type,rendererOpts:te.rendererOpts||{}}},J.getScale=function(te,re){return re.width&&re.width>=te+re.margin*2?re.width/(te+re.margin*2):re.scale},J.getImageWidth=function(te,re){const ne=J.getScale(te,re);return Math.floor((te+re.margin*2)*ne)},J.qrToImageData=function(te,re,ne){const ie=re.modules.size,se=re.modules.data,oe=J.getScale(ie,ne),ae=Math.floor((ie+ne.margin*2)*oe),ce=ne.margin*oe,le=[ne.color.light,ne.color.dark];for(let he=0;he<ae;he++)for(let de=0;de<ae;de++){let ue=(he*ae+de)*4,pe=ne.color.light;if(he>=ce&&de>=ce&&he<ae-ce&&de<ae-ce){const ye=Math.floor((he-ce)/oe),me=Math.floor((de-ce)/oe);pe=le[se[ye*ie+me]?1:0]}te[ue++]=pe.r,te[ue++]=pe.g,te[ue++]=pe.b,te[ue]=pe.a}}})(utils);(function(J){const E=utils;function ee(re,ne,ie){re.clearRect(0,0,ne.width,ne.height),ne.style||(ne.style={}),ne.height=ie,ne.width=ie,ne.style.height=ie+"px",ne.style.width=ie+"px"}function te(){try{return document.createElement("canvas")}catch{throw new Error("You need to specify a canvas element")}}J.render=function(ne,ie,se){let oe=se,ae=ie;typeof oe>"u"&&(!ie||!ie.getContext)&&(oe=ie,ie=void 0),ie||(ae=te()),oe=E.getOptions(oe);const ce=E.getImageWidth(ne.modules.size,oe),le=ae.getContext("2d"),he=le.createImageData(ce,ce);return E.qrToImageData(he.data,ne,oe),ee(le,ae,ce),le.putImageData(he,0,0),ae},J.renderToDataURL=function(ne,ie,se){let oe=se;typeof oe>"u"&&(!ie||!ie.getContext)&&(oe=ie,ie=void 0),oe||(oe={});const ae=J.render(ne,ie,oe),ce=oe.type||"image/png",le=oe.rendererOpts||{};return ae.toDataURL(ce,le.quality)}})(canvas);var svgTag={};const Utils=utils;function getColorAttrib(J,E){const ee=J.a/255,te=E+'="'+J.hex+'"';return ee<1?te+" "+E+'-opacity="'+ee.toFixed(2).slice(1)+'"':te}function svgCmd(J,E,ee){let te=J+E;return typeof ee<"u"&&(te+=" "+ee),te}function qrToPath(J,E,ee){let te="",re=0,ne=!1,ie=0;for(let se=0;se<J.length;se++){const oe=Math.floor(se%E),ae=Math.floor(se/E);!oe&&!ne&&(ne=!0),J[se]?(ie++,se>0&&oe>0&&J[se-1]||(te+=ne?svgCmd("M",oe+ee,.5+ae+ee):svgCmd("m",re,0),re=0,ne=!1),oe+1<E&&J[se+1]||(te+=svgCmd("h",ie),ie=0)):re++}return te}svgTag.render=function J(E,ee,te){const re=Utils.getOptions(ee),ne=E.modules.size,ie=E.modules.data,se=ne+re.margin*2,oe=re.color.light.a?"<path "+getColorAttrib(re.color.light,"fill")+' d="M0 0h'+se+"v"+se+'H0z"/>':"",ae="<path "+getColorAttrib(re.color.dark,"stroke")+' d="'+qrToPath(ie,ne,re.margin)+'"/>',ce='viewBox="0 0 '+se+" "+se+'"',he='<svg xmlns="http://www.w3.org/2000/svg" '+(re.width?'width="'+re.width+'" height="'+re.width+'" ':"")+ce+' shape-rendering="crispEdges">'+oe+ae+`</svg>
`;return typeof te=="function"&&te(null,he),he};const canPromise=canPromise$1,QRCode=qrcode,CanvasRenderer=canvas,SvgRenderer=svgTag;function renderCanvas(J,E,ee,te,re){const ne=[].slice.call(arguments,1),ie=ne.length,se=typeof ne[ie-1]=="function";if(!se&&!canPromise())throw new Error("Callback required as last argument");if(se){if(ie<2)throw new Error("Too few arguments provided");ie===2?(re=ee,ee=E,E=te=void 0):ie===3&&(E.getContext&&typeof re>"u"?(re=te,te=void 0):(re=te,te=ee,ee=E,E=void 0))}else{if(ie<1)throw new Error("Too few arguments provided");return ie===1?(ee=E,E=te=void 0):ie===2&&!E.getContext&&(te=ee,ee=E,E=void 0),new Promise(function(oe,ae){try{const ce=QRCode.create(ee,te);oe(J(ce,E,te))}catch(ce){ae(ce)}})}try{const oe=QRCode.create(ee,te);re(null,J(oe,E,te))}catch(oe){re(oe)}}browser.create=QRCode.create;browser.toCanvas=renderCanvas.bind(null,CanvasRenderer.render);browser.toDataURL=renderCanvas.bind(null,CanvasRenderer.renderToDataURL);browser.toString=renderCanvas.bind(null,function(J,E,ee){return SvgRenderer.render(J,ee)});function ShareLink(){const{joinLink:J}=q$1(AppState),E=useSignal(!1),ee="share"in navigator,te=useSignal("");b(()=>{J.value&&browser.toDataURL(J.value,{width:194}).then(ne=>te.value=ne)});const re=T$1(()=>{ee&&navigator.share({title:"5EDM",text:"DM me discretely on 5EDM",url:J.value}).then(()=>E.value=!0).catch(ne=>console.log("Error sharing",ne))},[J.value,ee,E]);return o$1("div",{className:"self-center max-w-xs flex flex-col align-items-center",children:[o$1("h3",{className:"font-bold text-lg mb-2",children:"Share this link to DM discretely"}),o$1("div",{className:"space-2 pb-0",children:o$1("div",{className:"form-control",children:o$1("label",{className:"input-group input-group-sm",children:[o$1("input",{type:"text",placeholder:"initializing...",className:"input input-bordered focus:outline-none input-sm w-full",value:J.value,onClick:ne=>ne.currentTarget.select(),readOnly:!0}),ee?o$1("button",{className:"opacity:2 btn btn-sm btn-circle self-center",onClick:re,children:o$1("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24","stroke-width":"1.5",stroke:"currentColor",className:"w-6 h-6",children:o$1("path",{"stroke-linecap":"round","stroke-linejoin":"round",d:"M9 8.25H7.5a2.25 2.25 0 00-2.25 2.25v9a2.25 2.25 0 002.25 2.25h9a2.25 2.25 0 002.25-2.25v-9a2.25 2.25 0 00-2.25-2.25H15m0-3l-3-3m0 0l-3 3m3-3V15"})})}):o$1("button",{className:"btn btn-sm",onClick:()=>{E.value=!0,navigator.clipboard.writeText(J.value)},children:E.value?o$1("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24","stroke-width":"1.5",stroke:"currentColor",className:"w-5 h-5",children:o$1("path",{"stroke-linecap":"round","stroke-linejoin":"round",d:"M11.35 3.836c-.065.21-.1.433-.1.664 0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75 2.25 2.25 0 00-.1-.664m-5.8 0A2.251 2.251 0 0113.5 2.25H15c1.012 0 1.867.668 2.15 1.586m-5.8 0c-.376.023-.75.05-1.124.08C9.095 4.01 8.25 4.973 8.25 6.108V8.25m8.9-4.414c.376.023.75.05 1.124.08 1.131.094 1.976 1.057 1.976 2.192V16.5A2.25 2.25 0 0118 18.75h-2.25m-7.5-10.5H4.875c-.621 0-1.125.504-1.125 1.125v11.25c0 .621.504 1.125 1.125 1.125h9.75c.621 0 1.125-.504 1.125-1.125V18.75m-7.5-10.5h6.375c.621 0 1.125.504 1.125 1.125v9.375m-8.25-3l1.5 1.5 3-3.75"})}):o$1("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24","stroke-width":"1.5",stroke:"currentColor",className:"w-5 h-5",children:o$1("path",{"stroke-linecap":"round","stroke-linejoin":"round",d:"M8.25 7.5V6.108c0-1.135.845-2.098 1.976-2.192.373-.03.748-.057 1.123-.08M15.75 18H18a2.25 2.25 0 002.25-2.25V6.108c0-1.135-.845-2.098-1.976-2.192a48.424 48.424 0 00-1.123-.08M15.75 18.75v-1.875a3.375 3.375 0 00-3.375-3.375h-1.5a1.125 1.125 0 01-1.125-1.125v-1.5A3.375 3.375 0 006.375 7.5H5.25m11.9-3.664A2.251 2.251 0 0015 2.25h-1.5a2.251 2.251 0 00-2.15 1.586m5.8 0c.065.21.1.433.1.664v.75h-6V4.5c0-.231.035-.454.1-.664M6.75 7.5H4.875c-.621 0-1.125.504-1.125 1.125v12c0 .621.504 1.125 1.125 1.125h9.75c.621 0 1.125-.504 1.125-1.125V16.5a9 9 0 00-9-9z"})})})]})})}),o$1("div",{className:"divider",children:"OR"}),o$1("div",{className:"self-center rounded-lg overflow-hidden",children:te.value?o$1("img",{src:te.value}):o$1("div",{className:"animate-pulse dark:bg-base-100 bg-slate-200 w-48 h-48"})})]})}function UpdateUsernameDialog(J){const{username:E,chatReady:ee}=q$1(AppState),[te,re]=h$1(J.user),ne=T$1(se=>{se&&!E.value&&(se.checked=!0)},[E.value]),ie=w$1(()=>ee.value?"Update your username":"Pick a username");return o$1(k$1,{children:[o$1("input",{ref:ne,type:"checkbox",id:"username-modal",className:"modal-toggle"}),o$1("div",{className:"modal modal-middle",children:o$1("div",{className:"modal-box",children:[o$1("h3",{className:"font-bold text-lg",children:ie}),o$1("p",{className:"py-4",children:o$1("input",{title:"Username",autoComplete:"off",type:"text",className:"input placeholder:text-gray-600 focus:placeholder:text-gray-500 w-full input-bordered focus:outline-none focus:ring focus:border-gray-500",value:te,onInput:se=>re(se.currentTarget.value)})}),o$1("div",{className:"modal-action",children:o$1("label",{htmlFor:"username-modal",className:"btn btn-secondary disabled:opacity-50",disabled:te.length===0,onClick:se=>{te?J.setUser(te):(se.preventDefault(),se.stopPropagation())},children:"Done"})})]})})]})}function Header({chatContext:J}){const{partnerUsername:E,username:ee,connectionStatus:te,chatReady:re,chatStatus:ne}=q$1(AppState),ie=w$1(()=>{switch(te.value){case ConnectionStatus.connecting:return"badge-warning";case ConnectionStatus.connected:return"badge-success";case ConnectionStatus.disconnected:default:return"badge-error"}}),se=w$1(()=>ne.value===ChatStatus.disconnected),oe=T$1(()=>{se.value||J.disconnect();const ae=document.activeElement;ae instanceof HTMLElement&&ae?.blur()},[se.value,J]);return o$1("div",{className:"sticky top-0 grid grid-cols-3 gap-3 w-full z-10 bg-base-200 p-3",children:[o$1("div",{className:"basis-1/3",children:o$1("label",{className:"btn btn-sm btn-circle",htmlFor:"about-modal",children:"?"})}),re.value?E.value?o$1("div",{className:"dropdown justify-self-center max-w-full flex-nowrap",children:[o$1("label",{tabIndex:0,className:"btn btn-sm normal-case max-w-full flex-nowrap inline-flex",children:[o$1("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24","stroke-width":"1.5",stroke:"currentColor",width:"16",height:"16",className:"mr-1",children:o$1("path",{"stroke-linecap":"round","stroke-linejoin":"round",d:"M16.5 10.5V6.75a4.5 4.5 0 10-9 0v3.75m-.75 11.25h10.5a2.25 2.25 0 002.25-2.25v-6.75a2.25 2.25 0 00-2.25-2.25H6.75a2.25 2.25 0 00-2.25 2.25v6.75a2.25 2.25 0 002.25 2.25z"})}),o$1("span",{className:"truncate",children:E})]}),o$1("ul",{tabIndex:0,className:"dropdown-content menu p-2 shadow bg-base-100 rounded-box w-52",children:o$1("li",{children:o$1("a",{onClick:oe,disabled:se.value,className:"disabled:opacity-50",children:"Disconnect"})})})]}):o$1("div",{className:"inline-flex items-center btn btn-sm normal-case justify-self-center max-w-full flex-nowrap",children:o$1("svg",{className:"animate-spin h-5 w-5 text-white",xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",children:[o$1("circle",{className:"opacity-25",cx:"12",cy:"12",r:"10",stroke:"currentColor","stroke-width":"4"}),o$1("path",{className:"opacity-75",fill:"currentColor",d:"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"})]})}):o$1("div",{}),o$1("div",{className:"indicator justify-self-end max-w-full",children:[o$1("span",{className:`indicator-item indicator-end badge badge-xs ${ie.value}`}),o$1("label",{className:"inline-flex items-center btn btn-sm normal-case max-w-full truncate flex-nowrap",htmlFor:"username-modal",children:[o$1("span",{className:"truncate mr-1",children:ee}),o$1("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24","stroke-width":"1.5",stroke:"currentColor",className:"w-5 h-5",children:o$1("path",{"stroke-linecap":"round","stroke-linejoin":"round",d:"M4.5 12a7.5 7.5 0 0015 0m-15 0a7.5 7.5 0 1115 0m-15 0H3m16.5 0H21m-1.5 0H12m-8.457 3.077l1.41-.513m14.095-5.13l1.41-.513M5.106 17.785l1.15-.964m11.49-9.642l1.149-.964M7.501 19.795l.75-1.3m7.5-12.99l.75-1.3m-6.063 16.658l.26-1.477m2.605-14.772l.26-1.477m0 17.726l-.26-1.477M10.698 4.614l-.26-1.477M16.5 19.794l-.75-1.299M7.5 4.205L12 12m6.894 5.785l-1.149-.964M6.256 7.178l-1.15-.964m15.352 8.864l-1.41-.513M4.954 9.435l-1.41-.514M12.002 12l-3.75 6.495"})})]})]})]})}const EMOJI_REGEX=/^(\p{Extended_Pictographic}|\p{Emoji_Presentation})+$/u,expandables={"~=[,,_,,]:3":{img:"/expand/nyan-cat.gif",ltr:!0},"/nyan":{img:"/expand/nyan-cat.gif",ltr:!0},"/ryu":{img:"/expand/ryu.gif",ltr:!1},"/ken":{img:"/expand/ken.gif",ltr:!0}};function expandMessage(J,E){if(J in expandables){const ee=expandables[J];if(typeof ee=="string")J=ee;else{const te=ee.ltr&&E||!ee.ltr&&!E?"-scale-x-100":"";return o$1("img",{src:ee.img,className:`${te} max-h-32`})}}return typeof J=="string"&&EMOJI_REGEX.test(J)?o$1(EmojiMessage,{msg:J}):E?SelfBubble(J):PartnerBubble(J)}function MessageBox(J){if(J.system)return SystemMessage(J);const E=expandMessage(J.msg,!!J.self);return J.self?o$1(SelfMessage,{message:J,children:E}):o$1(OtherMessage,{message:J,children:E})}function SelfBubble(J){return o$1("div",{className:"relative sm:max-w-xl max-w-[80%] px-4 py-2 text-white bg-info rounded-lg rounded-br-none",children:o$1("span",{className:"block",children:J})})}function PartnerBubble(J){return o$1("div",{className:"relative sm:max-w-xl max-w-[80%] px-4 py-2 dark:text-white fg-base-content dark:bg-gray-700 bg-base-200 rounded-lg rounded-bl-none",children:o$1("span",{className:"block",children:J})})}function SystemMessage({msg:J,uid:E}){return o$1("li",{id:E,"data-author":"self",className:"flex justify-center my-4 text-gray-400 italic text-center",children:J})}function SelfMessage({message:J,children:E}){const ee=J.seen?"":"opacity-90";return o$1("li",{id:J.uid,"data-author":"self",className:`${ee} peer flex justify-end peer-change-self:mt-4`,children:E})}function OtherMessage({message:J,children:E}){return o$1("li",{id:J.uid,"data-author":"other",className:"peer flex justify-start peer-change-other:mt-4",children:E})}function EmojiMessage({msg:J}){const ee=[...J].length<=6?"text-6xl py-5":"";return o$1("div",{className:`relative px-4 py-2 ${ee}`,children:o$1("span",{className:"block",children:J})})}function StateWrapper(){const J=useSignal(void 0);p$2(()=>{(async()=>{const te=await createAppState();J.value=te})()},[]);const E=w$1(()=>typeof J.value<"u");return console.log("render?",E.value,J.value),E.value?o$1(ChatWrapper,{appState:J.value}):null}function ChatWrapper({appState:J}){return o$1(AppState.Provider,{value:J,children:o$1(Chat,{})})}function Chat(){const{username:J,chatContext:E,connectionStatus:ee}=q$1(AppState),te=re=>{J.value=re};return b(()=>{const re=getInvite(location.hash);re?E.joinWithInvite(re):(ee.value=ConnectionStatus.connecting,E.createInviteAndWait())}),o$1("div",{className:"flex flex-col h-full dark:bg-base-300 overflow-hidden",tabIndex:99,children:[o$1(Header,{chatContext:E}),o$1(ChatHistory,{}),o$1(SendField,{}),o$1(UpdateUsernameDialog,{user:J.value,setUser:te})]})}function ChatHistory(){const{chatReady:J,chatContext:E,partnerUsername:ee}=q$1(AppState),te=useSignal([]),re=_$2(null);p$2(()=>{setupMessageListeners(E,te,ee)},[]),p$2(()=>{re.current?.scrollIntoView(!1)},[te.value.length]);const ne=w$1(()=>te.value.filter(ie=>!!ie.msg));return o$1("div",{className:"grow relative w-full p-4 overflow-y-auto",children:J.value?o$1("ul",{children:[ne.value.map(ie=>o$1(MessageBox,{...ie},ie.uid)),o$1("div",{ref:re})]}):o$1("div",{className:"grow w-full h-full flex place-content-center",children:o$1(ShareLink,{})})})}function SendField(){const{chatStatus:J,chatContext:E}=q$1(AppState),ee=useSignal(""),te=_$2(null),re=w$1(()=>J.value===ChatStatus.uninitialized||J.value===ChatStatus.disconnected),ne=T$1(ie=>{if(ie.preventDefault(),ie.stopImmediatePropagation(),!re.value){if(ee.value==="/bye")E.disconnect();else{const se={msg:ee.value};E.send(se)}ee.value=""}},[ee.value,re.value,E]);return o$1("div",{className:"sticky pwa:pb-10 bottom-0 bg-base-200 self-end items-center justify-between w-full p-3",children:o$1("form",{className:"flex",onSubmit:ne,children:o$1("div",{className:"input inline-flex w-full",children:[o$1("input",{type:"text",placeholder:"Message",value:ee.value,onInput:ie=>ee.value=ie.currentTarget.value,className:"transition input input-ghost focus:fg-content placeholder:text-gray-600 focus:placeholder:text-gray-500 focus:outline-none grow pl-0 disabled:bg-transparent disabled:border-0",autoComplete:"off",ref:te,disabled:re.value,required:!0}),o$1("button",{type:"submit",disabled:re.value,children:o$1("svg",{className:"w-5 h-5 transition hover:text-gray-400 text-gray-500 origin-center transform rotate-90 ml-3",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor",children:o$1("path",{d:"M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z"})})})]})})})}function App(){return o$1(Layout,{children:[o$1(StateWrapper,{}),o$1(AboutDialog,{})]})}const index="";D$1(o$1(App,{}),document.body);export{AbortError$5 as A,CodeError as C,EventEmitter$3 as E,TCP$1 as T,CustomEvent$1 as a,commonjsGlobal as c,getDefaultExportFromCjs as g,logger as l,multiaddr as m,net as n,symbol$2 as s};
