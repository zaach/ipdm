(function(){const E=document.createElement("link").relList;if(E&&E.supports&&E.supports("modulepreload"))return;for(const re of document.querySelectorAll('link[rel="modulepreload"]'))te(re);new MutationObserver(re=>{for(const ne of re)if(ne.type==="childList")for(const ie of ne.addedNodes)ie.tagName==="LINK"&&ie.rel==="modulepreload"&&te(ie)}).observe(document,{childList:!0,subtree:!0});function ee(re){const ne={};return re.integrity&&(ne.integrity=re.integrity),re.referrerPolicy&&(ne.referrerPolicy=re.referrerPolicy),re.crossOrigin==="use-credentials"?ne.credentials="include":re.crossOrigin==="anonymous"?ne.credentials="omit":ne.credentials="same-origin",ne}function te(re){if(re.ep)return;re.ep=!0;const ne=ee(re);fetch(re.href,ne)}})();var n$1,l$3,u$2,t$2,o$3,r$2,f$2,e$2,c$2={},s$5=[],a$2=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i,v$3=Array.isArray;function h$2(J,E){for(var ee in E)J[ee]=E[ee];return J}function p$3(J){var E=J.parentNode;E&&E.removeChild(J)}function y$2(J,E,ee){var te,re,ne,ie={};for(ne in E)ne=="key"?te=E[ne]:ne=="ref"?re=E[ne]:ie[ne]=E[ne];if(arguments.length>2&&(ie.children=arguments.length>3?n$1.call(arguments,2):ee),typeof J=="function"&&J.defaultProps!=null)for(ne in J.defaultProps)ie[ne]===void 0&&(ie[ne]=J.defaultProps[ne]);return d$4(J,ie,te,re,null)}function d$4(J,E,ee,te,re){var ne={type:J,props:E,key:ee,ref:te,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:re??++u$2};return re==null&&l$3.vnode!=null&&l$3.vnode(ne),ne}function k$1(J){return J.children}function b$2(J,E){this.props=J,this.context=E}function g$2(J,E){if(E==null)return J.__?g$2(J.__,J.__.__k.indexOf(J)+1):null;for(var ee;E<J.__k.length;E++)if((ee=J.__k[E])!=null&&ee.__e!=null)return ee.__e;return typeof J.type=="function"?g$2(J):null}function m$2(J){var E,ee;if((J=J.__)!=null&&J.__c!=null){for(J.__e=J.__c.base=null,E=0;E<J.__k.length;E++)if((ee=J.__k[E])!=null&&ee.__e!=null){J.__e=J.__c.base=ee.__e;break}return m$2(J)}}function w$4(J){(!J.__d&&(J.__d=!0)&&t$2.push(J)&&!x.__r++||o$3!==l$3.debounceRendering)&&((o$3=l$3.debounceRendering)||r$2)(x)}function x(){var J,E,ee,te,re,ne,ie,se;for(t$2.sort(f$2);J=t$2.shift();)J.__d&&(E=t$2.length,te=void 0,re=void 0,ie=(ne=(ee=J).__v).__e,(se=ee.__P)&&(te=[],(re=h$2({},ne)).__v=ne.__v+1,L$1(se,ne,re,ee.__n,se.ownerSVGElement!==void 0,ne.__h!=null?[ie]:null,te,ie??g$2(ne),ne.__h),M$1(te,ne),ne.__e!=ie&&m$2(ne)),t$2.length>E&&t$2.sort(f$2));x.__r=0}function P$2(J,E,ee,te,re,ne,ie,se,oe,ce){var ae,le,ue,he,pe,de,fe,me=te&&te.__k||s$5,_e=me.length;for(ee.__k=[],ae=0;ae<E.length;ae++)if((he=ee.__k[ae]=(he=E[ae])==null||typeof he=="boolean"||typeof he=="function"?null:typeof he=="string"||typeof he=="number"||typeof he=="bigint"?d$4(null,he,null,null,he):v$3(he)?d$4(k$1,{children:he},null,null,null):he.__b>0?d$4(he.type,he.props,he.key,he.ref?he.ref:null,he.__v):he)!=null){if(he.__=ee,he.__b=ee.__b+1,(ue=me[ae])===null||ue&&he.key==ue.key&&he.type===ue.type)me[ae]=void 0;else for(le=0;le<_e;le++){if((ue=me[le])&&he.key==ue.key&&he.type===ue.type){me[le]=void 0;break}ue=null}L$1(J,he,ue=ue||c$2,re,ne,ie,se,oe,ce),pe=he.__e,(le=he.ref)&&ue.ref!=le&&(fe||(fe=[]),ue.ref&&fe.push(ue.ref,null,he),fe.push(le,he.__c||pe,he)),pe!=null?(de==null&&(de=pe),typeof he.type=="function"&&he.__k===ue.__k?he.__d=oe=C$1(he,oe,J):oe=$$1(J,he,ue,me,pe,oe),typeof ee.type=="function"&&(ee.__d=oe)):oe&&ue.__e==oe&&oe.parentNode!=J&&(oe=g$2(ue))}for(ee.__e=de,ae=_e;ae--;)me[ae]!=null&&(typeof ee.type=="function"&&me[ae].__e!=null&&me[ae].__e==ee.__d&&(ee.__d=A(te).nextSibling),q$2(me[ae],me[ae]));if(fe)for(ae=0;ae<fe.length;ae++)O(fe[ae],fe[++ae],fe[++ae])}function C$1(J,E,ee){for(var te,re=J.__k,ne=0;re&&ne<re.length;ne++)(te=re[ne])&&(te.__=J,E=typeof te.type=="function"?C$1(te,E,ee):$$1(ee,te,te,re,te.__e,E));return E}function S$1(J,E){return E=E||[],J==null||typeof J=="boolean"||(v$3(J)?J.some(function(ee){S$1(ee,E)}):E.push(J)),E}function $$1(J,E,ee,te,re,ne){var ie,se,oe;if(E.__d!==void 0)ie=E.__d,E.__d=void 0;else if(ee==null||re!=ne||re.parentNode==null)e:if(ne==null||ne.parentNode!==J)J.appendChild(re),ie=null;else{for(se=ne,oe=0;(se=se.nextSibling)&&oe<te.length;oe+=1)if(se==re)break e;J.insertBefore(re,ne),ie=ne}return ie!==void 0?ie:re.nextSibling}function A(J){var E,ee,te;if(J.type==null||typeof J.type=="string")return J.__e;if(J.__k){for(E=J.__k.length-1;E>=0;E--)if((ee=J.__k[E])&&(te=A(ee)))return te}return null}function H$1(J,E,ee,te,re){var ne;for(ne in ee)ne==="children"||ne==="key"||ne in E||T$2(J,ne,null,ee[ne],te);for(ne in E)re&&typeof E[ne]!="function"||ne==="children"||ne==="key"||ne==="value"||ne==="checked"||ee[ne]===E[ne]||T$2(J,ne,E[ne],ee[ne],te)}function I$1(J,E,ee){E[0]==="-"?J.setProperty(E,ee??""):J[E]=ee==null?"":typeof ee!="number"||a$2.test(E)?ee:ee+"px"}function T$2(J,E,ee,te,re){var ne;e:if(E==="style")if(typeof ee=="string")J.style.cssText=ee;else{if(typeof te=="string"&&(J.style.cssText=te=""),te)for(E in te)ee&&E in ee||I$1(J.style,E,"");if(ee)for(E in ee)te&&ee[E]===te[E]||I$1(J.style,E,ee[E])}else if(E[0]==="o"&&E[1]==="n")ne=E!==(E=E.replace(/Capture$/,"")),E=E.toLowerCase()in J?E.toLowerCase().slice(2):E.slice(2),J.l||(J.l={}),J.l[E+ne]=ee,ee?te||J.addEventListener(E,ne?z$2:j$2,ne):J.removeEventListener(E,ne?z$2:j$2,ne);else if(E!=="dangerouslySetInnerHTML"){if(re)E=E.replace(/xlink(H|:h)/,"h").replace(/sName$/,"s");else if(E!=="width"&&E!=="height"&&E!=="href"&&E!=="list"&&E!=="form"&&E!=="tabIndex"&&E!=="download"&&E!=="rowSpan"&&E!=="colSpan"&&E in J)try{J[E]=ee??"";break e}catch{}typeof ee=="function"||(ee==null||ee===!1&&E[4]!=="-"?J.removeAttribute(E):J.setAttribute(E,ee))}}function j$2(J){return this.l[J.type+!1](l$3.event?l$3.event(J):J)}function z$2(J){return this.l[J.type+!0](l$3.event?l$3.event(J):J)}function L$1(J,E,ee,te,re,ne,ie,se,oe){var ce,ae,le,ue,he,pe,de,fe,me,_e,be,Ee,ve,we,ge,Se=E.type;if(E.constructor!==void 0)return null;ee.__h!=null&&(oe=ee.__h,se=E.__e=ee.__e,E.__h=null,ne=[se]),(ce=l$3.__b)&&ce(E);try{e:if(typeof Se=="function"){if(fe=E.props,me=(ce=Se.contextType)&&te[ce.__c],_e=ce?me?me.props.value:ce.__:te,ee.__c?de=(ae=E.__c=ee.__c).__=ae.__E:("prototype"in Se&&Se.prototype.render?E.__c=ae=new Se(fe,_e):(E.__c=ae=new b$2(fe,_e),ae.constructor=Se,ae.render=B$2),me&&me.sub(ae),ae.props=fe,ae.state||(ae.state={}),ae.context=_e,ae.__n=te,le=ae.__d=!0,ae.__h=[],ae._sb=[]),ae.__s==null&&(ae.__s=ae.state),Se.getDerivedStateFromProps!=null&&(ae.__s==ae.state&&(ae.__s=h$2({},ae.__s)),h$2(ae.__s,Se.getDerivedStateFromProps(fe,ae.__s))),ue=ae.props,he=ae.state,ae.__v=E,le)Se.getDerivedStateFromProps==null&&ae.componentWillMount!=null&&ae.componentWillMount(),ae.componentDidMount!=null&&ae.__h.push(ae.componentDidMount);else{if(Se.getDerivedStateFromProps==null&&fe!==ue&&ae.componentWillReceiveProps!=null&&ae.componentWillReceiveProps(fe,_e),!ae.__e&&ae.shouldComponentUpdate!=null&&ae.shouldComponentUpdate(fe,ae.__s,_e)===!1||E.__v===ee.__v){for(E.__v!==ee.__v&&(ae.props=fe,ae.state=ae.__s,ae.__d=!1),ae.__e=!1,E.__e=ee.__e,E.__k=ee.__k,E.__k.forEach(function($e){$e&&($e.__=E)}),be=0;be<ae._sb.length;be++)ae.__h.push(ae._sb[be]);ae._sb=[],ae.__h.length&&ie.push(ae);break e}ae.componentWillUpdate!=null&&ae.componentWillUpdate(fe,ae.__s,_e),ae.componentDidUpdate!=null&&ae.__h.push(function(){ae.componentDidUpdate(ue,he,pe)})}if(ae.context=_e,ae.props=fe,ae.__P=J,Ee=l$3.__r,ve=0,"prototype"in Se&&Se.prototype.render){for(ae.state=ae.__s,ae.__d=!1,Ee&&Ee(E),ce=ae.render(ae.props,ae.state,ae.context),we=0;we<ae._sb.length;we++)ae.__h.push(ae._sb[we]);ae._sb=[]}else do ae.__d=!1,Ee&&Ee(E),ce=ae.render(ae.props,ae.state,ae.context),ae.state=ae.__s;while(ae.__d&&++ve<25);ae.state=ae.__s,ae.getChildContext!=null&&(te=h$2(h$2({},te),ae.getChildContext())),le||ae.getSnapshotBeforeUpdate==null||(pe=ae.getSnapshotBeforeUpdate(ue,he)),P$2(J,v$3(ge=ce!=null&&ce.type===k$1&&ce.key==null?ce.props.children:ce)?ge:[ge],E,ee,te,re,ne,ie,se,oe),ae.base=E.__e,E.__h=null,ae.__h.length&&ie.push(ae),de&&(ae.__E=ae.__=null),ae.__e=!1}else ne==null&&E.__v===ee.__v?(E.__k=ee.__k,E.__e=ee.__e):E.__e=N(ee.__e,E,ee,te,re,ne,ie,oe);(ce=l$3.diffed)&&ce(E)}catch($e){E.__v=null,(oe||ne!=null)&&(E.__e=se,E.__h=!!oe,ne[ne.indexOf(se)]=null),l$3.__e($e,E,ee)}}function M$1(J,E){l$3.__c&&l$3.__c(E,J),J.some(function(ee){try{J=ee.__h,ee.__h=[],J.some(function(te){te.call(ee)})}catch(te){l$3.__e(te,ee.__v)}})}function N(J,E,ee,te,re,ne,ie,se){var oe,ce,ae,le=ee.props,ue=E.props,he=E.type,pe=0;if(he==="svg"&&(re=!0),ne!=null){for(;pe<ne.length;pe++)if((oe=ne[pe])&&"setAttribute"in oe==!!he&&(he?oe.localName===he:oe.nodeType===3)){J=oe,ne[pe]=null;break}}if(J==null){if(he===null)return document.createTextNode(ue);J=re?document.createElementNS("http://www.w3.org/2000/svg",he):document.createElement(he,ue.is&&ue),ne=null,se=!1}if(he===null)le===ue||se&&J.data===ue||(J.data=ue);else{if(ne=ne&&n$1.call(J.childNodes),ce=(le=ee.props||c$2).dangerouslySetInnerHTML,ae=ue.dangerouslySetInnerHTML,!se){if(ne!=null)for(le={},pe=0;pe<J.attributes.length;pe++)le[J.attributes[pe].name]=J.attributes[pe].value;(ae||ce)&&(ae&&(ce&&ae.__html==ce.__html||ae.__html===J.innerHTML)||(J.innerHTML=ae&&ae.__html||""))}if(H$1(J,ue,le,re,se),ae)E.__k=[];else if(P$2(J,v$3(pe=E.props.children)?pe:[pe],E,ee,te,re&&he!=="foreignObject",ne,ie,ne?ne[0]:ee.__k&&g$2(ee,0),se),ne!=null)for(pe=ne.length;pe--;)ne[pe]!=null&&p$3(ne[pe]);se||("value"in ue&&(pe=ue.value)!==void 0&&(pe!==J.value||he==="progress"&&!pe||he==="option"&&pe!==le.value)&&T$2(J,"value",pe,le.value,!1),"checked"in ue&&(pe=ue.checked)!==void 0&&pe!==J.checked&&T$2(J,"checked",pe,le.checked,!1))}return J}function O(J,E,ee){try{typeof J=="function"?J(E):J.current=E}catch(te){l$3.__e(te,ee)}}function q$2(J,E,ee){var te,re;if(l$3.unmount&&l$3.unmount(J),(te=J.ref)&&(te.current&&te.current!==J.__e||O(te,null,E)),(te=J.__c)!=null){if(te.componentWillUnmount)try{te.componentWillUnmount()}catch(ne){l$3.__e(ne,E)}te.base=te.__P=null,J.__c=void 0}if(te=J.__k)for(re=0;re<te.length;re++)te[re]&&q$2(te[re],E,ee||typeof J.type!="function");ee||J.__e==null||p$3(J.__e),J.__=J.__e=J.__d=void 0}function B$2(J,E,ee){return this.constructor(J,ee)}function D$1(J,E,ee){var te,re,ne;l$3.__&&l$3.__(J,E),re=(te=typeof ee=="function")?null:ee&&ee.__k||E.__k,ne=[],L$1(E,J=(!te&&ee||E).__k=y$2(k$1,null,[J]),re||c$2,c$2,E.ownerSVGElement!==void 0,!te&&ee?[ee]:re?null:E.firstChild?n$1.call(E.childNodes):null,ne,!te&&ee?ee:re?re.__e:E.firstChild,te),M$1(ne,J)}function G(J,E){var ee={__c:E="__cC"+e$2++,__:J,Consumer:function(te,re){return te.children(re)},Provider:function(te){var re,ne;return this.getChildContext||(re=[],(ne={})[E]=this,this.getChildContext=function(){return ne},this.shouldComponentUpdate=function(ie){this.props.value!==ie.value&&re.some(function(se){se.__e=!0,w$4(se)})},this.sub=function(ie){re.push(ie);var se=ie.componentWillUnmount;ie.componentWillUnmount=function(){re.splice(re.indexOf(ie),1),se&&se.call(ie)}}),te.children}};return ee.Provider.__=ee.Consumer.contextType=ee}n$1=s$5.slice,l$3={__e:function(J,E,ee,te){for(var re,ne,ie;E=E.__;)if((re=E.__c)&&!re.__)try{if((ne=re.constructor)&&ne.getDerivedStateFromError!=null&&(re.setState(ne.getDerivedStateFromError(J)),ie=re.__d),re.componentDidCatch!=null&&(re.componentDidCatch(J,te||{}),ie=re.__d),ie)return re.__E=re}catch(se){J=se}throw J}},u$2=0,b$2.prototype.setState=function(J,E){var ee;ee=this.__s!=null&&this.__s!==this.state?this.__s:this.__s=h$2({},this.state),typeof J=="function"&&(J=J(h$2({},ee),this.props)),J&&h$2(ee,J),J!=null&&this.__v&&(E&&this._sb.push(E),w$4(this))},b$2.prototype.forceUpdate=function(J){this.__v&&(this.__e=!0,J&&this.__h.push(J),w$4(this))},b$2.prototype.render=k$1,t$2=[],r$2=typeof Promise=="function"?Promise.prototype.then.bind(Promise.resolve()):setTimeout,f$2=function(J,E){return J.__v.__b-E.__v.__b},x.__r=0,e$2=0;var t$1,r$1,u$1,i$1,o$2=0,f$1=[],c$1=[],e$1=l$3.__b,a$1=l$3.__r,v$2=l$3.diffed,l$2=l$3.__c,m$1=l$3.unmount;function d$3(J,E){l$3.__h&&l$3.__h(r$1,J,o$2||E),o$2=0;var ee=r$1.__H||(r$1.__H={__:[],__h:[]});return J>=ee.__.length&&ee.__.push({__V:c$1}),ee.__[J]}function h$1(J){return o$2=1,s$4(B$1,J)}function s$4(J,E,ee){var te=d$3(t$1++,2);if(te.t=J,!te.__c&&(te.__=[ee?ee(E):B$1(void 0,E),function(se){var oe=te.__N?te.__N[0]:te.__[0],ce=te.t(oe,se);oe!==ce&&(te.__N=[ce,te.__[1]],te.__c.setState({}))}],te.__c=r$1,!r$1.u)){var re=function(se,oe,ce){if(!te.__c.__H)return!0;var ae=te.__c.__H.__.filter(function(ue){return ue.__c});if(ae.every(function(ue){return!ue.__N}))return!ne||ne.call(this,se,oe,ce);var le=!1;return ae.forEach(function(ue){if(ue.__N){var he=ue.__[0];ue.__=ue.__N,ue.__N=void 0,he!==ue.__[0]&&(le=!0)}}),!(!le&&te.__c.props===se)&&(!ne||ne.call(this,se,oe,ce))};r$1.u=!0;var ne=r$1.shouldComponentUpdate,ie=r$1.componentWillUpdate;r$1.componentWillUpdate=function(se,oe,ce){if(this.__e){var ae=ne;ne=void 0,re(se,oe,ce),ne=ae}ie&&ie.call(this,se,oe,ce)},r$1.shouldComponentUpdate=re}return te.__N||te.__}function p$2(J,E){var ee=d$3(t$1++,3);!l$3.__s&&z$1(ee.__H,E)&&(ee.__=J,ee.i=E,r$1.__H.__h.push(ee))}function _$2(J){return o$2=5,F(function(){return{current:J}},[])}function F(J,E){var ee=d$3(t$1++,7);return z$1(ee.__H,E)?(ee.__V=J(),ee.i=E,ee.__h=J,ee.__V):ee.__}function T$1(J,E){return o$2=8,F(function(){return J},E)}function q$1(J){var E=r$1.context[J.__c],ee=d$3(t$1++,9);return ee.c=J,E?(ee.__==null&&(ee.__=!0,E.sub(r$1)),E.props.value):J.__}function b$1(){for(var J;J=f$1.shift();)if(J.__P&&J.__H)try{J.__H.__h.forEach(k),J.__H.__h.forEach(w$3),J.__H.__h=[]}catch(E){J.__H.__h=[],l$3.__e(E,J.__v)}}l$3.__b=function(J){r$1=null,e$1&&e$1(J)},l$3.__r=function(J){a$1&&a$1(J),t$1=0;var E=(r$1=J.__c).__H;E&&(u$1===r$1?(E.__h=[],r$1.__h=[],E.__.forEach(function(ee){ee.__N&&(ee.__=ee.__N),ee.__V=c$1,ee.__N=ee.i=void 0})):(E.__h.forEach(k),E.__h.forEach(w$3),E.__h=[])),u$1=r$1},l$3.diffed=function(J){v$2&&v$2(J);var E=J.__c;E&&E.__H&&(E.__H.__h.length&&(f$1.push(E)!==1&&i$1===l$3.requestAnimationFrame||((i$1=l$3.requestAnimationFrame)||j$1)(b$1)),E.__H.__.forEach(function(ee){ee.i&&(ee.__H=ee.i),ee.__V!==c$1&&(ee.__=ee.__V),ee.i=void 0,ee.__V=c$1})),u$1=r$1=null},l$3.__c=function(J,E){E.some(function(ee){try{ee.__h.forEach(k),ee.__h=ee.__h.filter(function(te){return!te.__||w$3(te)})}catch(te){E.some(function(re){re.__h&&(re.__h=[])}),E=[],l$3.__e(te,ee.__v)}}),l$2&&l$2(J,E)},l$3.unmount=function(J){m$1&&m$1(J);var E,ee=J.__c;ee&&ee.__H&&(ee.__H.__.forEach(function(te){try{k(te)}catch(re){E=re}}),ee.__H=void 0,E&&l$3.__e(E,ee.__v))};var g$1=typeof requestAnimationFrame=="function";function j$1(J){var E,ee=function(){clearTimeout(te),g$1&&cancelAnimationFrame(E),setTimeout(J)},te=setTimeout(ee,100);g$1&&(E=requestAnimationFrame(ee))}function k(J){var E=r$1,ee=J.__c;typeof ee=="function"&&(J.__c=void 0,ee()),r$1=E}function w$3(J){var E=r$1;J.__c=J.__(),r$1=E}function z$1(J,E){return!J||J.length!==E.length||E.some(function(ee,te){return ee!==J[te]})}function B$1(J,E){return typeof E=="function"?E(J):E}function S(J,E){for(var ee in E)J[ee]=E[ee];return J}function C(J,E){for(var ee in J)if(ee!=="__source"&&!(ee in E))return!0;for(var te in E)if(te!=="__source"&&J[te]!==E[te])return!0;return!1}function w$2(J){this.props=J}(w$2.prototype=new b$2).isPureReactComponent=!0,w$2.prototype.shouldComponentUpdate=function(J,E){return C(this.props,J)||C(this.state,E)};var R=l$3.__b;l$3.__b=function(J){J.type&&J.type.__f&&J.ref&&(J.props.ref=J.ref,J.ref=null),R&&R(J)};var T=l$3.__e;l$3.__e=function(J,E,ee,te){if(J.then){for(var re,ne=E;ne=ne.__;)if((re=ne.__c)&&re.__c)return E.__e==null&&(E.__e=ee.__e,E.__k=ee.__k),re.__c(J,E)}T(J,E,ee,te)};var I=l$3.unmount;function L(J,E,ee){return J&&(J.__c&&J.__c.__H&&(J.__c.__H.__.forEach(function(te){typeof te.__c=="function"&&te.__c()}),J.__c.__H=null),(J=S({},J)).__c!=null&&(J.__c.__P===ee&&(J.__c.__P=E),J.__c=null),J.__k=J.__k&&J.__k.map(function(te){return L(te,E,ee)})),J}function P$1(J,E,ee){return J&&(J.__v=null,J.__k=J.__k&&J.__k.map(function(te){return P$1(te,E,ee)}),J.__c&&J.__c.__P===E&&(J.__e&&ee.insertBefore(J.__e,J.__d),J.__c.__e=!0,J.__c.__P=ee)),J}function U(){this.__u=0,this.t=null,this.__b=null}function D(J){var E=J.__.__c;return E&&E.__a&&E.__a(J)}function M(){this.u=null,this.o=null}l$3.unmount=function(J){var E=J.__c;E&&E.__R&&E.__R(),E&&J.__h===!0&&(J.type=null),I&&I(J)},(U.prototype=new b$2).__c=function(J,E){var ee=E.__c,te=this;te.t==null&&(te.t=[]),te.t.push(ee);var re=D(te.__v),ne=!1,ie=function(){ne||(ne=!0,ee.__R=null,re?re(se):se())};ee.__R=ie;var se=function(){if(!--te.__u){if(te.state.__a){var ce=te.state.__a;te.__v.__k[0]=P$1(ce,ce.__c.__P,ce.__c.__O)}var ae;for(te.setState({__a:te.__b=null});ae=te.t.pop();)ae.forceUpdate()}},oe=E.__h===!0;te.__u++||oe||te.setState({__a:te.__b=te.__v.__k[0]}),J.then(ie,ie)},U.prototype.componentWillUnmount=function(){this.t=[]},U.prototype.render=function(J,E){if(this.__b){if(this.__v.__k){var ee=document.createElement("div"),te=this.__v.__k[0].__c;this.__v.__k[0]=L(this.__b,ee,te.__O=te.__P)}this.__b=null}var re=E.__a&&y$2(k$1,null,J.fallback);return re&&(re.__h=null),[y$2(k$1,null,E.__a?null:J.children),re]};var V$1=function(J,E,ee){if(++ee[1]===ee[0]&&J.o.delete(E),J.props.revealOrder&&(J.props.revealOrder[0]!=="t"||!J.o.size))for(ee=J.u;ee;){for(;ee.length>3;)ee.pop()();if(ee[1]<ee[0])break;J.u=ee=ee[2]}};function W(J){return this.getChildContext=function(){return J.context},J.children}function j(J){var E=this,ee=J.i;E.componentWillUnmount=function(){D$1(null,E.l),E.l=null,E.i=null},E.i&&E.i!==ee&&E.componentWillUnmount(),J.__v?(E.l||(E.i=ee,E.l={nodeType:1,parentNode:ee,childNodes:[],appendChild:function(te){this.childNodes.push(te),E.i.appendChild(te)},insertBefore:function(te,re){this.childNodes.push(te),E.i.appendChild(te)},removeChild:function(te){this.childNodes.splice(this.childNodes.indexOf(te)>>>1,1),E.i.removeChild(te)}}),D$1(y$2(W,{context:E.context},J.__v),E.l)):E.l&&E.componentWillUnmount()}function z(J,E){var ee=y$2(j,{__v:J,i:E});return ee.containerInfo=E,ee}(M.prototype=new b$2).__a=function(J){var E=this,ee=D(E.__v),te=E.o.get(J);return te[0]++,function(re){var ne=function(){E.props.revealOrder?(te.push(re),V$1(E,J,te)):re()};ee?ee(ne):ne()}},M.prototype.render=function(J){this.u=null,this.o=new Map;var E=S$1(J.children);J.revealOrder&&J.revealOrder[0]==="b"&&E.reverse();for(var ee=E.length;ee--;)this.o.set(E[ee],this.u=[1,0,this.u]);return J.children},M.prototype.componentDidUpdate=M.prototype.componentDidMount=function(){var J=this;this.o.forEach(function(E,ee){V$1(J,ee,E)})};var B=typeof Symbol<"u"&&Symbol.for&&Symbol.for("react.element")||60103,H=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,Z=/^on(Ani|Tra|Tou|BeforeInp|Compo)/,Y=/[A-Z0-9]/g,$=typeof document<"u",q=function(J){return(typeof Symbol<"u"&&typeof Symbol()=="symbol"?/fil|che|rad/:/fil|che|ra/).test(J)};b$2.prototype.isReactComponent={},["componentWillMount","componentWillReceiveProps","componentWillUpdate"].forEach(function(J){Object.defineProperty(b$2.prototype,J,{configurable:!0,get:function(){return this["UNSAFE_"+J]},set:function(E){Object.defineProperty(this,J,{configurable:!0,writable:!0,value:E})}})});var K$1=l$3.event;function Q(){}function X(){return this.cancelBubble}function nn(){return this.defaultPrevented}l$3.event=function(J){K$1&&(J=K$1(J));var E=J.currentTarget,ee=J.type;return ee!=="input"&&ee!=="change"||!E.h||Promise.resolve().then(function(){return function(te,re){re.value!=null&&Promise.resolve().then(function(){return re.value=re.v}),te==="change"&&re.checked!=null&&Promise.resolve().then(function(){return re.checked=re.v})}(ee,E)}),J.persist=Q,J.isPropagationStopped=X,J.isDefaultPrevented=nn,J.nativeEvent=J};var en={enumerable:!1,configurable:!0,get:function(){return this.class}},rn=l$3.vnode;l$3.vnode=function(J){typeof J.type=="string"&&function(E){var ee=E.props,te=E.type,re={};for(var ne in ee){var ie=ee[ne];if(!(ne==="value"&&"defaultValue"in ee&&ie==null||$&&ne==="children"&&te==="noscript"||ne==="class"||ne==="className")){var se=ne.toLowerCase();ne==="defaultValue"&&"value"in ee&&ee.value==null?ne="value":ne==="download"&&ie===!0?ie="":se==="ondoubleclick"?ne="ondblclick":se!=="onchange"||te!=="input"&&te!=="textarea"||q(ee.type)?se==="onfocus"?ne="onfocusin":se==="onblur"?ne="onfocusout":Z.test(ne)?ne=se:te.indexOf("-")===-1&&H.test(ne)?ne=ne.replace(Y,"-$&").toLowerCase():ie===null&&(ie=void 0):se=ne="oninput",se==="oninput"&&re[ne=se]&&(ne="oninputCapture"),re[ne]=ie}}te=="select"&&re.multiple&&Array.isArray(re.value)&&(re.value=S$1(ee.children).forEach(function(oe){oe.props.selected=re.value.indexOf(oe.props.value)!=-1})),te=="select"&&re.defaultValue!=null&&(re.value=S$1(ee.children).forEach(function(oe){oe.props.selected=re.multiple?re.defaultValue.indexOf(oe.props.value)!=-1:re.defaultValue==oe.props.value})),ee.class&&!ee.className?(re.class=ee.class,Object.defineProperty(re,"className",en)):(ee.className&&!ee.class||ee.class&&ee.className)&&(re.class=re.className=ee.className),E.props=re}(J),J.$$typeof=B,rn&&rn(J)};var un=l$3.__r;l$3.__r=function(J){un&&un(J),J.__c};var on=l$3.diffed;l$3.diffed=function(J){on&&on(J);var E=J.type,ee=J.props,te=J.__e,re=te&&te.h;te==null||E!=="input"&&E!=="textarea"&&E!=="select"||re===!1||(re||ee.oninput||ee.onchange||ee.onChange)&&(ee.value!=null?(te.h=!0,te.v=ee.value):ee.checked!=null?(te.h=!0,te.v=ee.checked):te.h=!1),te!=null&&J.type==="textarea"&&"value"in ee&&ee.value!==te.value&&(te.value=ee.value==null?"":ee.value)};var _$1=0;function o$1(J,E,ee,te,re,ne){var ie,se,oe={};for(se in E)se=="ref"?ie=E[se]:oe[se]=E[se];var ce={type:J,props:oe,key:ee,ref:ie,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:--_$1,__source:re,__self:ne};if(typeof J=="function"&&(ie=J.defaultProps))for(se in ie)oe[se]===void 0&&(oe[se]=ie[se]);return l$3.vnode&&l$3.vnode(ce),ce}const Head=({children:J})=>{const E=document.head;return z(o$1(k$1,{children:J}),E)},Layout=({children:J})=>o$1(k$1,{children:[o$1(Head,{children:[o$1("meta",{name:"apple-mobile-web-app-capable",content:"yes"}),o$1("link",{rel:"manifest",href:"/manifest.json"}),o$1("link",{rel:"icon",type:"image/png",href:"/favicon.png"})]}),o$1("main",{className:"h-full",children:J})]});function Link({href:J,children:E}){return o$1("a",{href:J,className:"font-semibold inline-flex items-center gap-1",children:E})}function AboutDialog(){return o$1(k$1,{children:[o$1("input",{type:"checkbox",id:"about-modal",className:"modal-toggle"}),o$1("label",{htmlFor:"about-modal",className:"modal cursor-pointer",children:o$1("label",{className:"modal-box relative",htmlFor:"",children:[o$1("div",{className:"relative h-12 flex place-content-center mb-4",children:o$1("img",{src:"/ipdm-logo.png",className:"md:w-12 md:h-12"})}),o$1("div",{className:"alert p-1 pl-2",children:o$1("div",{children:[o$1("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",className:"stroke-current flex-shrink-0 w-6 h-6",children:o$1("path",{"stroke-linecap":"round","stroke-linejoin":"round","stroke-width":"2",d:"M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"})}),o$1("span",{className:"text-xs py-1",children:["This app is demo-tier! Use"," ",o$1(Link,{href:"https://signal.org/",children:"Signal"})," if you need the real deal."]})]})}),o$1("div",{className:"mt-4 text-sm",children:[o$1("p",{className:"text-center",children:"This is a work-in-progress decentralized secure messaging platform. For more information visit the source repository."}),o$1("p",{className:"text-center mt-4 inline-flex items-center gap-2 w-full justify-center",children:o$1(Link,{href:"https://github.com/zaach/ipdm",children:["Source"," ",o$1("svg",{id:"i-github",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 64 64",width:"16",height:"16",className:"inline-block",children:o$1("path",{"stroke-width":"0",fill:"currentColor",d:"M32 0 C14 0 0 14 0 32 0 53 19 62 22 62 24 62 24 61 24 60 L24 55 C17 57 14 53 13 50 13 50 13 49 11 47 10 46 6 44 10 44 13 44 15 48 15 48 18 52 22 51 24 50 24 48 26 46 26 46 18 45 12 42 12 31 12 27 13 24 15 22 15 22 13 18 15 13 15 13 20 13 24 17 27 15 37 15 40 17 44 13 49 13 49 13 51 20 49 22 49 22 51 24 52 27 52 31 52 42 45 45 38 46 39 47 40 49 40 52 L40 60 C40 61 40 62 42 62 45 62 64 53 64 32 64 14 50 0 32 0 Z"})})]})})]}),o$1("div",{className:"modal-action justify-center",children:o$1("label",{htmlFor:"about-modal",className:"btn btn-wide",children:"okay"})})]})})]})}function i(){throw new Error("Cycle detected")}function t(){if(n>1)n--;else{for(var J,E=!1;r!==void 0;){var ee=r;for(r=void 0,s$3++;ee!==void 0;){var te=ee.o;if(ee.o=void 0,ee.f&=-3,!(8&ee.f)&&d$2(ee))try{ee.c()}catch(re){E||(J=re,E=!0)}ee=te}}if(s$3=0,n--,E)throw J}}var o=void 0,r=void 0,n=0,s$3=0,f=0;function v$1(J){if(o!==void 0){var E=J.n;if(E===void 0||E.t!==o)return o.s=E={i:0,S:J,p:void 0,n:o.s,t:o,e:void 0,x:void 0,r:E},J.n=E,32&o.f&&J.S(E),E;if(E.i===-1)return E.i=0,E.p!==void 0&&(E.p.n=E.n,E.n!==void 0&&(E.n.p=E.p),E.p=void 0,E.n=o.s,o.s.p=E,o.s=E),E}}function e(J){this.v=J,this.i=0,this.n=void 0,this.t=void 0}e.prototype.h=function(){return!0};e.prototype.S=function(J){this.t!==J&&J.e===void 0&&(J.x=this.t,this.t!==void 0&&(this.t.e=J),this.t=J)};e.prototype.U=function(J){var E=J.e,ee=J.x;E!==void 0&&(E.x=ee,J.e=void 0),ee!==void 0&&(ee.e=E,J.x=void 0),J===this.t&&(this.t=ee)};e.prototype.subscribe=function(J){var E=this;return b(function(){var ee=E.value,te=32&this.f;this.f&=-33;try{J(ee)}finally{this.f|=te}})};e.prototype.valueOf=function(){return this.value};e.prototype.toString=function(){return this.value+""};e.prototype.peek=function(){return this.v};Object.defineProperty(e.prototype,"value",{get:function(){var J=v$1(this);return J!==void 0&&(J.i=this.i),this.v},set:function(J){if(J!==this.v){s$3>100&&i(),this.v=J,this.i++,f++,n++;try{for(var E=this.t;E!==void 0;E=E.x)E.t.N()}finally{t()}}}});function u(J){return new e(J)}function d$2(J){for(var E=J.s;E!==void 0;E=E.n)if(E.S.i!==E.i||!E.S.h()||E.S.i!==E.i)return!0;return!1}function c(J){for(var E=J.s;E!==void 0;E=E.n){var ee=E.S.n;ee!==void 0&&(E.r=ee),E.S.n=E,E.i=-1}}function a(J){for(var E=J.s,ee=void 0;E!==void 0;){var te=E.n;E.i===-1?(E.S.U(E),E.n=void 0):(ee!==void 0&&(ee.p=E),E.p=void 0,E.n=ee,ee=E),E.S.n=E.r,E.r!==void 0&&(E.r=void 0),E=te}J.s=ee}function l$1(J){e.call(this,void 0),this.x=J,this.s=void 0,this.g=f-1,this.f=4}(l$1.prototype=new e).h=function(){if(this.f&=-3,1&this.f)return!1;if((36&this.f)==32||(this.f&=-5,this.g===f))return!0;if(this.g=f,this.f|=1,this.i>0&&!d$2(this))return this.f&=-2,!0;var J=o;try{c(this),o=this;var E=this.x();(16&this.f||this.v!==E||this.i===0)&&(this.v=E,this.f&=-17,this.i++)}catch(ee){this.v=ee,this.f|=16,this.i++}return o=J,a(this),this.f&=-2,!0};l$1.prototype.S=function(J){if(this.t===void 0){this.f|=36;for(var E=this.s;E!==void 0;E=E.n)E.S.S(E)}e.prototype.S.call(this,J)};l$1.prototype.U=function(J){if(e.prototype.U.call(this,J),this.t===void 0){this.f&=-33;for(var E=this.s;E!==void 0;E=E.n)E.S.U(E)}};l$1.prototype.N=function(){if(!(2&this.f)){this.f|=6;for(var J=this.t;J!==void 0;J=J.x)J.t.N()}};l$1.prototype.peek=function(){if(this.h()||i(),16&this.f)throw this.v;return this.v};Object.defineProperty(l$1.prototype,"value",{get:function(){1&this.f&&i();var J=v$1(this);if(this.h(),J!==void 0&&(J.i=this.i),16&this.f)throw this.v;return this.v}});function w$1(J){return new l$1(J)}function y$1(J){var E=J.u;if(J.u=void 0,typeof E=="function"){n++;var ee=o;o=void 0;try{E()}catch(te){throw J.f&=-2,J.f|=8,_(J),te}finally{o=ee,t()}}}function _(J){for(var E=J.s;E!==void 0;E=E.n)E.S.U(E);J.x=void 0,J.s=void 0,y$1(J)}function g(J){if(o!==this)throw new Error("Out-of-order effect");a(this),o=J,this.f&=-2,8&this.f&&_(this),t()}function p$1(J){this.x=J,this.u=void 0,this.s=void 0,this.o=void 0,this.f=32}p$1.prototype.c=function(){var J=this.S();try{!(8&this.f)&&this.x!==void 0&&(this.u=this.x())}finally{J()}};p$1.prototype.S=function(){1&this.f&&i(),this.f|=1,this.f&=-9,y$1(this),c(this),n++;var J=o;return o=this,g.bind(this,J)};p$1.prototype.N=function(){2&this.f||(this.f|=2,this.o=r,r=this)};p$1.prototype.d=function(){this.f|=8,1&this.f||_(this)};function b(J){var E=new p$1(J);return E.c(),E.d.bind(E)}var v;function s$2(J,E){l$3[J]=E.bind(null,l$3[J]||function(){})}function l(J){v&&v(),v=J&&J.S()}function p(J){var E=this,ee=J.data,te=useSignal(ee);te.value=ee;var re=F(function(){for(var ne=E.__v;ne=ne.__;)if(ne.__c){ne.__c.__$f|=4;break}return E.__$u.c=function(){E.base.data=re.peek()},w$1(function(){var ie=te.value.value;return ie===0?0:ie===!0?"":ie||""})},[]);return re.value}p.displayName="_st";Object.defineProperties(e.prototype,{constructor:{configurable:!0},type:{configurable:!0,value:p},props:{configurable:!0,get:function(){return{data:this}}},__b:{configurable:!0,value:1}});s$2("__b",function(J,E){if(typeof E.type=="string"){var ee,te=E.props;for(var re in te)if(re!=="children"){var ne=te[re];ne instanceof e&&(ee||(E.__np=ee={}),ee[re]=ne,te[re]=ne.peek())}}J(E)});s$2("__r",function(J,E){l();var ee,te=E.__c;te&&(te.__$f&=-2,(ee=te.__$u)===void 0&&(te.__$u=ee=function(re){var ne;return b(function(){ne=this}),ne.c=function(){te.__$f|=1,te.setState({})},ne}())),l(ee),J(E)});s$2("__e",function(J,E,ee,te){l(),J(E,ee,te)});s$2("diffed",function(J,E){l();var ee;if(typeof E.type=="string"&&(ee=E.__e)){var te=E.__np,re=E.props;if(te){var ne=ee.U;if(ne)for(var ie in ne){var se=ne[ie];se!==void 0&&!(ie in te)&&(se.d(),ne[ie]=void 0)}else ee.U=ne={};for(var oe in te){var ce=ne[oe],ae=te[oe];ce===void 0?(ce=d$1(ee,oe,ae,re),ne[oe]=ce):ce.o(ae,re)}}}J(E)});function d$1(J,E,ee,te){var re=E in J&&J.ownerSVGElement===void 0,ne=u(ee);return{o:function(ie,se){ne.value=ie,te=se},d:b(function(){var ie=ne.value.value;te[E]!==ie&&(te[E]=ie,re?J[E]=ie:ie?J.setAttribute(E,ie):J.removeAttribute(E))})}}s$2("unmount",function(J,E){if(typeof E.type=="string"){var ee=E.__e;if(ee){var te=ee.U;if(te){ee.U=void 0;for(var re in te){var ne=te[re];ne&&ne.d()}}}}else{var ie=E.__c;if(ie){var se=ie.__$u;se&&(ie.__$u=void 0,se.d())}}J(E)});s$2("__h",function(J,E,ee,te){te<3&&(E.__$f|=2),J(E,ee,te)});b$2.prototype.shouldComponentUpdate=function(J,E){var ee=this.__$u;if(!(ee&&ee.s!==void 0||4&this.__$f)||3&this.__$f)return!0;for(var te in E)return!0;for(var re in J)if(re!=="__source"&&J[re]!==this.props[re])return!0;for(var ne in this.props)if(!(ne in J))return!0;return!1};function useSignal(J){return F(function(){return u(J)},[])}const scriptRel="modulepreload",assetsURL=function(J){return"/"+J},seen={},__vitePreload=function(E,ee,te){if(!ee||ee.length===0)return E();const re=document.getElementsByTagName("link");return Promise.all(ee.map(ne=>{if(ne=assetsURL(ne),ne in seen)return;seen[ne]=!0;const ie=ne.endsWith(".css"),se=ie?'[rel="stylesheet"]':"";if(!!te)for(let ae=re.length-1;ae>=0;ae--){const le=re[ae];if(le.href===ne&&(!ie||le.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${ne}"]${se}`))return;const ce=document.createElement("link");if(ce.rel=ie?"stylesheet":scriptRel,ie||(ce.as="script",ce.crossOrigin=""),ce.href=ne,document.head.appendChild(ce),ie)return new Promise((ae,le)=>{ce.addEventListener("load",ae),ce.addEventListener("error",()=>le(new Error(`Unable to preload CSS for ${ne}`)))})})).then(()=>E())};var commonjsGlobal=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function getDefaultExportFromCjs(J){return J&&J.__esModule&&Object.prototype.hasOwnProperty.call(J,"default")?J.default:J}function getAugmentedNamespace(J){if(J.__esModule)return J;var E=J.default;if(typeof E=="function"){var ee=function te(){if(this instanceof te){var re=[null];re.push.apply(re,arguments);var ne=Function.bind.apply(E,re);return new ne}return E.apply(this,arguments)};ee.prototype=E.prototype}else ee={};return Object.defineProperty(ee,"__esModule",{value:!0}),Object.keys(J).forEach(function(te){var re=Object.getOwnPropertyDescriptor(J,te);Object.defineProperty(ee,te,re.get?re:{enumerable:!0,get:function(){return J[te]}})}),ee}var base64$8={},__extends=commonjsGlobal&&commonjsGlobal.__extends||function(){var J=function(E,ee){return J=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(te,re){te.__proto__=re}||function(te,re){for(var ne in re)re.hasOwnProperty(ne)&&(te[ne]=re[ne])},J(E,ee)};return function(E,ee){J(E,ee);function te(){this.constructor=E}E.prototype=ee===null?Object.create(ee):(te.prototype=ee.prototype,new te)}}();Object.defineProperty(base64$8,"__esModule",{value:!0});var INVALID_BYTE=256,Coder=function(){function J(E){E===void 0&&(E="="),this._paddingCharacter=E}return J.prototype.encodedLength=function(E){return this._paddingCharacter?(E+2)/3*4|0:(E*8+5)/6|0},J.prototype.encode=function(E){for(var ee="",te=0;te<E.length-2;te+=3){var re=E[te]<<16|E[te+1]<<8|E[te+2];ee+=this._encodeByte(re>>>3*6&63),ee+=this._encodeByte(re>>>2*6&63),ee+=this._encodeByte(re>>>1*6&63),ee+=this._encodeByte(re>>>0*6&63)}var ne=E.length-te;if(ne>0){var re=E[te]<<16|(ne===2?E[te+1]<<8:0);ee+=this._encodeByte(re>>>3*6&63),ee+=this._encodeByte(re>>>2*6&63),ne===2?ee+=this._encodeByte(re>>>1*6&63):ee+=this._paddingCharacter||"",ee+=this._paddingCharacter||""}return ee},J.prototype.maxDecodedLength=function(E){return this._paddingCharacter?E/4*3|0:(E*6+7)/8|0},J.prototype.decodedLength=function(E){return this.maxDecodedLength(E.length-this._getPaddingLength(E))},J.prototype.decode=function(E){if(E.length===0)return new Uint8Array(0);for(var ee=this._getPaddingLength(E),te=E.length-ee,re=new Uint8Array(this.maxDecodedLength(te)),ne=0,ie=0,se=0,oe=0,ce=0,ae=0,le=0;ie<te-4;ie+=4)oe=this._decodeChar(E.charCodeAt(ie+0)),ce=this._decodeChar(E.charCodeAt(ie+1)),ae=this._decodeChar(E.charCodeAt(ie+2)),le=this._decodeChar(E.charCodeAt(ie+3)),re[ne++]=oe<<2|ce>>>4,re[ne++]=ce<<4|ae>>>2,re[ne++]=ae<<6|le,se|=oe&INVALID_BYTE,se|=ce&INVALID_BYTE,se|=ae&INVALID_BYTE,se|=le&INVALID_BYTE;if(ie<te-1&&(oe=this._decodeChar(E.charCodeAt(ie)),ce=this._decodeChar(E.charCodeAt(ie+1)),re[ne++]=oe<<2|ce>>>4,se|=oe&INVALID_BYTE,se|=ce&INVALID_BYTE),ie<te-2&&(ae=this._decodeChar(E.charCodeAt(ie+2)),re[ne++]=ce<<4|ae>>>2,se|=ae&INVALID_BYTE),ie<te-3&&(le=this._decodeChar(E.charCodeAt(ie+3)),re[ne++]=ae<<6|le,se|=le&INVALID_BYTE),se!==0)throw new Error("Base64Coder: incorrect characters for decoding");return re},J.prototype._encodeByte=function(E){var ee=E;return ee+=65,ee+=25-E>>>8&0-65-26+97,ee+=51-E>>>8&26-97-52+48,ee+=61-E>>>8&52-48-62+43,ee+=62-E>>>8&62-43-63+47,String.fromCharCode(ee)},J.prototype._decodeChar=function(E){var ee=INVALID_BYTE;return ee+=(42-E&E-44)>>>8&-INVALID_BYTE+E-43+62,ee+=(46-E&E-48)>>>8&-INVALID_BYTE+E-47+63,ee+=(47-E&E-58)>>>8&-INVALID_BYTE+E-48+52,ee+=(64-E&E-91)>>>8&-INVALID_BYTE+E-65+0,ee+=(96-E&E-123)>>>8&-INVALID_BYTE+E-97+26,ee},J.prototype._getPaddingLength=function(E){var ee=0;if(this._paddingCharacter){for(var te=E.length-1;te>=0&&E[te]===this._paddingCharacter;te--)ee++;if(E.length<4||ee>2)throw new Error("Base64Coder: incorrect padding")}return ee},J}();base64$8.Coder=Coder;var stdCoder=new Coder;function encode$k(J){return stdCoder.encode(J)}base64$8.encode=encode$k;function decode$l(J){return stdCoder.decode(J)}base64$8.decode=decode$l;var URLSafeCoder=function(J){__extends(E,J);function E(){return J!==null&&J.apply(this,arguments)||this}return E.prototype._encodeByte=function(ee){var te=ee;return te+=65,te+=25-ee>>>8&0-65-26+97,te+=51-ee>>>8&26-97-52+48,te+=61-ee>>>8&52-48-62+45,te+=62-ee>>>8&62-45-63+95,String.fromCharCode(te)},E.prototype._decodeChar=function(ee){var te=INVALID_BYTE;return te+=(44-ee&ee-46)>>>8&-INVALID_BYTE+ee-45+62,te+=(94-ee&ee-96)>>>8&-INVALID_BYTE+ee-95+63,te+=(47-ee&ee-58)>>>8&-INVALID_BYTE+ee-48+52,te+=(64-ee&ee-91)>>>8&-INVALID_BYTE+ee-65+0,te+=(96-ee&ee-123)>>>8&-INVALID_BYTE+ee-97+26,te},E}(Coder);base64$8.URLSafeCoder=URLSafeCoder;var urlSafeCoder=new URLSafeCoder;function encodeURLSafe(J){return urlSafeCoder.encode(J)}base64$8.encodeURLSafe=encodeURLSafe;function decodeURLSafe(J){return urlSafeCoder.decode(J)}base64$8.decodeURLSafe=decodeURLSafe;base64$8.encodedLength=function(J){return stdCoder.encodedLength(J)};base64$8.maxDecodedLength=function(J){return stdCoder.maxDecodedLength(J)};base64$8.decodedLength=function(J){return stdCoder.decodedLength(J)};class Base64EnvelopeEncoding{INTER_SPLIT=":";INTRA_SPLIT=".";encodeHandshakeEnvelope(E){const ee=E.header.map(re=>base64$8.encode(new Uint8Array(re))),te=E.payload.map(re=>base64$8.encode(new Uint8Array(re)));return[ee.join(this.INTER_SPLIT),te.join(this.INTER_SPLIT)].join(this.INTRA_SPLIT)}decodeHandshakeEnvelope(E){const[ee,te]=E.split(this.INTRA_SPLIT),re=ee.split(this.INTER_SPLIT),ne=te.split(this.INTER_SPLIT),ie=[base64$8.decode(re[0]),base64$8.decode(re[1])],se=[base64$8.decode(ne[0]),base64$8.decode(ne[1])];return{header:ie,payload:se}}encodeEnvelope(E){const ee=base64$8.encode(new Uint8Array(E.header)),te=base64$8.encode(new Uint8Array(E.payload));return[ee,te].join(this.INTRA_SPLIT)}decodeEnvelope(E){const[ee,te]=E.split(this.INTRA_SPLIT),re=base64$8.decode(ee),ne=base64$8.decode(te);return{header:re,payload:ne}}}class InternalFormatJson{encode(E){const ee=JSON.stringify(E);return new TextEncoder().encode(ee)}decode(E){return JSON.parse(new TextDecoder().decode(E))}}var ChatEventType=(J=>(J.channel_open="channel_open",J.channel_error="channel_error",J.invite="invite",J.initiated="initiated",J.message="message",J.queued="queued",J.sent="sent",J.failed="failed",J.idle="idle",J.active="active",J.disconnected="disconnected",J.dead_session="dead_session",J))(ChatEventType||{});class ChatEvent extends CustomEvent{constructor(E,ee){super(E,ee)}static addTypedListener(E,ee,te){E.addEventListener(ee,re=>{eventTypeGuard(re,ee,ChatEvent)&&te(re)})}}function eventTypeGuard(J,E,ee){return J instanceof ee&&J.type===E}var MessageType$1=(J=>(J[J.message=0]="message",J[J.ack=1]="ack",J[J.disconnect=2]="disconnect",J[J.meta=3]="meta",J))(MessageType$1||{});class HpkeError extends Error{constructor(E){let ee;E instanceof Error?ee=E.message:typeof E=="string"?ee=E:ee="",super(ee),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor),this.name=this.constructor.name,this.message===""?this.message=this.name:this.message=this.name+": "+this.message}}class InvalidParamError extends HpkeError{}class ValidationError extends HpkeError{}class SerializeError extends HpkeError{}class DeserializeError extends HpkeError{}class EncapError extends HpkeError{}class DecapError extends HpkeError{}class ExportError extends HpkeError{}class SealError extends HpkeError{}class OpenError extends HpkeError{}class MessageLimitReachedError extends HpkeError{}class DeriveKeyPairError extends HpkeError{}class NotSupportedError extends HpkeError{}var Mode$5;(function(J){J[J.Base=0]="Base",J[J.Psk=1]="Psk",J[J.Auth=2]="Auth",J[J.AuthPsk=3]="AuthPsk"})(Mode$5||(Mode$5={}));var Kem$1;(function(J){J[J.DhkemP256HkdfSha256=16]="DhkemP256HkdfSha256",J[J.DhkemP384HkdfSha384=17]="DhkemP384HkdfSha384",J[J.DhkemP521HkdfSha512=18]="DhkemP521HkdfSha512",J[J.DhkemX25519HkdfSha256=32]="DhkemX25519HkdfSha256",J[J.DhkemX448HkdfSha512=33]="DhkemX448HkdfSha512"})(Kem$1||(Kem$1={}));var Kdf$1;(function(J){J[J.HkdfSha256=1]="HkdfSha256",J[J.HkdfSha384=2]="HkdfSha384",J[J.HkdfSha512=3]="HkdfSha512"})(Kdf$1||(Kdf$1={}));var Aead$1;(function(J){J[J.Aes128Gcm=1]="Aes128Gcm",J[J.Aes256Gcm=2]="Aes256Gcm",J[J.Chacha20Poly1305=3]="Chacha20Poly1305",J[J.ExportOnly=65535]="ExportOnly"})(Aead$1||(Aead$1={}));const dntGlobals={},dntGlobalThis=createMergeProxy(globalThis,dntGlobals);function createMergeProxy(J,E){return new Proxy(J,{get(ee,te,re){return te in E?E[te]:J[te]},set(ee,te,re){return te in E&&delete E[te],J[te]=re,!0},deleteProperty(ee,te){let re=!1;return te in E&&(delete E[te],re=!0),te in J&&(delete J[te],re=!0),re},ownKeys(ee){const te=Reflect.ownKeys(J),re=Reflect.ownKeys(E),ne=new Set(re);return[...te.filter(ie=>!ne.has(ie)),...re]},defineProperty(ee,te,re){return te in E&&delete E[te],Reflect.defineProperty(J,te,re),!0},getOwnPropertyDescriptor(ee,te){return te in E?Reflect.getOwnPropertyDescriptor(E,te):Reflect.getOwnPropertyDescriptor(J,te)},has(ee,te){return te in E||te in J}})}const isBrowser$1=()=>typeof dntGlobalThis<"u",isCloudflareWorkers=()=>typeof caches<"u",isCryptoKeyPair=J=>typeof J=="object"&&J!==null&&typeof J.privateKey=="object"&&typeof J.publicKey=="object";function i2Osp(J,E){if(E<=0)throw new Error("i2Osp: too small size");if(J>=256**E)throw new Error("i2Osp: too large integer");const ee=new Uint8Array(E);for(let te=0;te<E&&J;te++)ee[E-(te+1)]=J%256,J=J>>8;return ee}function xor$1(J,E){if(J.byteLength!==E.byteLength)throw new Error("xor: different length inputs");const ee=new Uint8Array(J.byteLength);for(let te=0;te<J.byteLength;te++)ee[te]=J[te]^E[te];return ee}function concat$6(J,E){const ee=new Uint8Array(J.length+E.length);return ee.set(J,0),ee.set(E,J.length),ee}function concat3(J,E,ee){const te=new Uint8Array(J.length+E.length+ee.length);return te.set(J,0),te.set(E,J.length),te.set(ee,J.length+E.length),te}class WebCrypto{constructor(E){Object.defineProperty(this,"_api",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._api=E}}async function loadCrypto(){if((isBrowser$1()||isCloudflareWorkers())&&globalThis.crypto!==void 0)return globalThis.crypto;try{const{webcrypto:J}=await Promise.resolve().then(()=>nodeCrypto);return J}catch{throw new NotSupportedError("Web Cryptograph API not supported")}}async function loadSubtleCrypto(){if((isBrowser$1()||isCloudflareWorkers())&&globalThis.crypto!==void 0)return globalThis.crypto.subtle;try{const{webcrypto:J}=await Promise.resolve().then(()=>nodeCrypto);return J.subtle}catch{throw new NotSupportedError("Web Cryptograph API not supported")}}const KEM_USAGES=["deriveBits"],AEAD_USAGES=["encrypt","decrypt"],INPUT_LENGTH_LIMIT=128,MINIMUM_PSK_LENGTH=32,EMPTY=new Uint8Array(0),HPKE_VERSION=new Uint8Array([72,80,75,69,45,118,49]),SUITE_ID_HEADER_HPKE=new Uint8Array([72,80,75,69,0,0,0,0,0,0]),SUITE_ID_HEADER_KEM=new Uint8Array([75,69,77,0,0]),LABEL_DKP_PRK=new Uint8Array([100,107,112,95,112,114,107]),LABEL_EAE_PRK=new Uint8Array([101,97,101,95,112,114,107]),LABEL_INFO_HASH=new Uint8Array([105,110,102,111,95,104,97,115,104]),LABEL_PSK_ID_HASH=new Uint8Array([112,115,107,95,105,100,95,104,97,115,104]),LABEL_SECRET=new Uint8Array([115,101,99,114,101,116]),LABEL_SHARED_SECRET=new Uint8Array([115,104,97,114,101,100,95,115,101,99,114,101,116]),LABEL_KEY=new Uint8Array([107,101,121]),LABEL_BASE_NONCE=new Uint8Array([98,97,115,101,95,110,111,110,99,101]),LABEL_EXP=new Uint8Array([101,120,112]),LABEL_SEC=new Uint8Array([115,101,99]),LABEL_CANDIDATE=new Uint8Array([99,97,110,100,105,100,97,116,101]),LABEL_SK=new Uint8Array([115,107]),ORDER_P_256=new Uint8Array([255,255,255,255,0,0,0,0,255,255,255,255,255,255,255,255,188,230,250,173,167,23,158,132,243,185,202,194,252,99,37,81]),ORDER_P_384=new Uint8Array([255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,199,99,77,129,244,55,45,223,88,26,13,178,72,176,167,122,236,236,25,106,204,197,41,115]),ORDER_P_521=new Uint8Array([1,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,250,81,134,135,131,191,47,150,107,127,204,1,72,247,9,165,208,59,181,201,184,137,156,71,174,187,111,183,30,145,56,100,9]);class ExporterContext extends WebCrypto{constructor(E,ee,te){super(E),Object.defineProperty(this,"exporterSecret",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_kdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._kdf=ee,this.exporterSecret=te}async seal(E,ee){return await this._emitError1()}async open(E,ee){return await this._emitError1()}async setupBidirectional(E,ee){return await this._emitError2()}async export(E,ee){if(E.byteLength>INPUT_LENGTH_LIMIT)throw new InvalidParamError("Too long exporter context");try{return await this._kdf.labeledExpand(this.exporterSecret,LABEL_SEC,new Uint8Array(E),ee)}catch(te){throw new ExportError(te)}}_emitError1(){return new Promise((E,ee)=>{ee(new NotSupportedError("Not available on export-only mode"))})}_emitError2(){return new Promise((E,ee)=>{ee(new NotSupportedError("Not available on export-only mode"))})}}class RecipientExporterContext extends ExporterContext{}class SenderExporterContext extends ExporterContext{constructor(E,ee,te,re){super(E,ee,te),Object.defineProperty(this,"enc",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.enc=re}}class AesGcmKey{constructor(E,ee){Object.defineProperty(this,"_rawKey",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_key",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_api",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._rawKey=E,this._api=ee}async seal(E,ee,te){this._key===void 0&&(this._key=await this.importKey(this._rawKey),new Uint8Array(this._rawKey).fill(0));const re={name:"AES-GCM",iv:E,additionalData:te};return await this._api.encrypt(re,this._key,ee)}async open(E,ee,te){this._key===void 0&&(this._key=await this.importKey(this._rawKey),new Uint8Array(this._rawKey).fill(0));const re={name:"AES-GCM",iv:E,additionalData:te};return await this._api.decrypt(re,this._key,ee)}async importKey(E){return await this._api.importKey("raw",E,{name:"AES-GCM"},!0,AEAD_USAGES)}}function writeUint32LE$1(J,E=new Uint8Array(4),ee=0){return E[ee+0]=J>>>0,E[ee+1]=J>>>8,E[ee+2]=J>>>16,E[ee+3]=J>>>24,E}function writeUint64LE$1(J,E=new Uint8Array(8),ee=0){return writeUint32LE$1(J>>>0,E,ee),writeUint32LE$1(J/4294967296>>>0,E,ee+4),E}function wipe$2(J){for(let E=0;E<J.length;E++)J[E]=0;return J}const ROUNDS$1=20;function core$1(J,E,ee){const te=ee[3]<<24|ee[2]<<16|ee[1]<<8|ee[0],re=ee[7]<<24|ee[6]<<16|ee[5]<<8|ee[4],ne=ee[11]<<24|ee[10]<<16|ee[9]<<8|ee[8],ie=ee[15]<<24|ee[14]<<16|ee[13]<<8|ee[12],se=ee[19]<<24|ee[18]<<16|ee[17]<<8|ee[16],oe=ee[23]<<24|ee[22]<<16|ee[21]<<8|ee[20],ce=ee[27]<<24|ee[26]<<16|ee[25]<<8|ee[24],ae=ee[31]<<24|ee[30]<<16|ee[29]<<8|ee[28],le=E[3]<<24|E[2]<<16|E[1]<<8|E[0],ue=E[7]<<24|E[6]<<16|E[5]<<8|E[4],he=E[11]<<24|E[10]<<16|E[9]<<8|E[8],pe=E[15]<<24|E[14]<<16|E[13]<<8|E[12];let de=1634760805,fe=857760878,me=2036477234,_e=1797285236,be=te,Ee=re,ve=ne,we=ie,ge=se,Se=oe,$e=ce,Pe=ae,Me=le,xe=ue,Fe=he,ke=pe;for(let Te=0;Te<ROUNDS$1;Te+=2)de=de+be|0,Me^=de,Me=Me>>>32-16|Me<<16,ge=ge+Me|0,be^=ge,be=be>>>32-12|be<<12,fe=fe+Ee|0,xe^=fe,xe=xe>>>32-16|xe<<16,Se=Se+xe|0,Ee^=Se,Ee=Ee>>>32-12|Ee<<12,me=me+ve|0,Fe^=me,Fe=Fe>>>32-16|Fe<<16,$e=$e+Fe|0,ve^=$e,ve=ve>>>32-12|ve<<12,_e=_e+we|0,ke^=_e,ke=ke>>>32-16|ke<<16,Pe=Pe+ke|0,we^=Pe,we=we>>>32-12|we<<12,me=me+ve|0,Fe^=me,Fe=Fe>>>32-8|Fe<<8,$e=$e+Fe|0,ve^=$e,ve=ve>>>32-7|ve<<7,_e=_e+we|0,ke^=_e,ke=ke>>>32-8|ke<<8,Pe=Pe+ke|0,we^=Pe,we=we>>>32-7|we<<7,fe=fe+Ee|0,xe^=fe,xe=xe>>>32-8|xe<<8,Se=Se+xe|0,Ee^=Se,Ee=Ee>>>32-7|Ee<<7,de=de+be|0,Me^=de,Me=Me>>>32-8|Me<<8,ge=ge+Me|0,be^=ge,be=be>>>32-7|be<<7,de=de+Ee|0,ke^=de,ke=ke>>>32-16|ke<<16,$e=$e+ke|0,Ee^=$e,Ee=Ee>>>32-12|Ee<<12,fe=fe+ve|0,Me^=fe,Me=Me>>>32-16|Me<<16,Pe=Pe+Me|0,ve^=Pe,ve=ve>>>32-12|ve<<12,me=me+we|0,xe^=me,xe=xe>>>32-16|xe<<16,ge=ge+xe|0,we^=ge,we=we>>>32-12|we<<12,_e=_e+be|0,Fe^=_e,Fe=Fe>>>32-16|Fe<<16,Se=Se+Fe|0,be^=Se,be=be>>>32-12|be<<12,me=me+we|0,xe^=me,xe=xe>>>32-8|xe<<8,ge=ge+xe|0,we^=ge,we=we>>>32-7|we<<7,_e=_e+be|0,Fe^=_e,Fe=Fe>>>32-8|Fe<<8,Se=Se+Fe|0,be^=Se,be=be>>>32-7|be<<7,fe=fe+ve|0,Me^=fe,Me=Me>>>32-8|Me<<8,Pe=Pe+Me|0,ve^=Pe,ve=ve>>>32-7|ve<<7,de=de+Ee|0,ke^=de,ke=ke>>>32-8|ke<<8,$e=$e+ke|0,Ee^=$e,Ee=Ee>>>32-7|Ee<<7;writeUint32LE$1(de+1634760805|0,J,0),writeUint32LE$1(fe+857760878|0,J,4),writeUint32LE$1(me+2036477234|0,J,8),writeUint32LE$1(_e+1797285236|0,J,12),writeUint32LE$1(be+te|0,J,16),writeUint32LE$1(Ee+re|0,J,20),writeUint32LE$1(ve+ne|0,J,24),writeUint32LE$1(we+ie|0,J,28),writeUint32LE$1(ge+se|0,J,32),writeUint32LE$1(Se+oe|0,J,36),writeUint32LE$1($e+ce|0,J,40),writeUint32LE$1(Pe+ae|0,J,44),writeUint32LE$1(Me+le|0,J,48),writeUint32LE$1(xe+ue|0,J,52),writeUint32LE$1(Fe+he|0,J,56),writeUint32LE$1(ke+pe|0,J,60)}function streamXOR$1(J,E,ee,te,re=0){if(J.length!==32)throw new Error("ChaCha: key size must be 32 bytes");if(te.length<ee.length)throw new Error("ChaCha: destination is shorter than source");let ne,ie;if(re===0){if(E.length!==8&&E.length!==12)throw new Error("ChaCha nonce must be 8 or 12 bytes");ne=new Uint8Array(16),ie=ne.length-E.length,ne.set(E,ie)}else{if(E.length!==16)throw new Error("ChaCha nonce with counter must be 16 bytes");ne=E,ie=re}const se=new Uint8Array(64);for(let oe=0;oe<ee.length;oe+=64){core$1(se,ne,J);for(let ce=oe;ce<oe+64&&ce<ee.length;ce++)te[ce]=ee[ce]^se[ce-oe];incrementCounter$1(ne,0,ie)}return wipe$2(se),re===0&&wipe$2(ne),te}function stream$1(J,E,ee,te=0){return wipe$2(ee),streamXOR$1(J,E,ee,ee,te)}function incrementCounter$1(J,E,ee){let te=1;for(;ee--;)te=te+(J[E]&255)|0,J[E]=te&255,te>>>=8,E++;if(te>0)throw new Error("ChaCha: counter overflow")}function compare$3(J,E){if(J.length!==E.length)return 0;let ee=0;for(let te=0;te<J.length;te++)ee|=J[te]^E[te];return 1&ee-1>>>8}function equal$1(J,E){return J.length===0||E.length===0?!1:compare$3(J,E)!==0}const DIGEST_LENGTH=16;class Poly1305{constructor(E){Object.defineProperty(this,"digestLength",{enumerable:!0,configurable:!0,writable:!0,value:DIGEST_LENGTH}),Object.defineProperty(this,"_buffer",{enumerable:!0,configurable:!0,writable:!0,value:new Uint8Array(16)}),Object.defineProperty(this,"_r",{enumerable:!0,configurable:!0,writable:!0,value:new Uint16Array(10)}),Object.defineProperty(this,"_h",{enumerable:!0,configurable:!0,writable:!0,value:new Uint16Array(10)}),Object.defineProperty(this,"_pad",{enumerable:!0,configurable:!0,writable:!0,value:new Uint16Array(8)}),Object.defineProperty(this,"_leftover",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_fin",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_finished",{enumerable:!0,configurable:!0,writable:!0,value:!1});let ee=E[0]|E[1]<<8;this._r[0]=ee&8191;let te=E[2]|E[3]<<8;this._r[1]=(ee>>>13|te<<3)&8191;let re=E[4]|E[5]<<8;this._r[2]=(te>>>10|re<<6)&7939;let ne=E[6]|E[7]<<8;this._r[3]=(re>>>7|ne<<9)&8191;let ie=E[8]|E[9]<<8;this._r[4]=(ne>>>4|ie<<12)&255,this._r[5]=ie>>>1&8190;let se=E[10]|E[11]<<8;this._r[6]=(ie>>>14|se<<2)&8191;let oe=E[12]|E[13]<<8;this._r[7]=(se>>>11|oe<<5)&8065;let ce=E[14]|E[15]<<8;this._r[8]=(oe>>>8|ce<<8)&8191,this._r[9]=ce>>>5&127,this._pad[0]=E[16]|E[17]<<8,this._pad[1]=E[18]|E[19]<<8,this._pad[2]=E[20]|E[21]<<8,this._pad[3]=E[22]|E[23]<<8,this._pad[4]=E[24]|E[25]<<8,this._pad[5]=E[26]|E[27]<<8,this._pad[6]=E[28]|E[29]<<8,this._pad[7]=E[30]|E[31]<<8}_blocks(E,ee,te){let re=this._fin?0:2048,ne=this._h[0],ie=this._h[1],se=this._h[2],oe=this._h[3],ce=this._h[4],ae=this._h[5],le=this._h[6],ue=this._h[7],he=this._h[8],pe=this._h[9],de=this._r[0],fe=this._r[1],me=this._r[2],_e=this._r[3],be=this._r[4],Ee=this._r[5],ve=this._r[6],we=this._r[7],ge=this._r[8],Se=this._r[9];for(;te>=16;){let $e=E[ee+0]|E[ee+1]<<8;ne+=$e&8191;let Pe=E[ee+2]|E[ee+3]<<8;ie+=($e>>>13|Pe<<3)&8191;let Me=E[ee+4]|E[ee+5]<<8;se+=(Pe>>>10|Me<<6)&8191;let xe=E[ee+6]|E[ee+7]<<8;oe+=(Me>>>7|xe<<9)&8191;let Fe=E[ee+8]|E[ee+9]<<8;ce+=(xe>>>4|Fe<<12)&8191,ae+=Fe>>>1&8191;let ke=E[ee+10]|E[ee+11]<<8;le+=(Fe>>>14|ke<<2)&8191;let Te=E[ee+12]|E[ee+13]<<8;ue+=(ke>>>11|Te<<5)&8191;let Ve=E[ee+14]|E[ee+15]<<8;he+=(Te>>>8|Ve<<8)&8191,pe+=Ve>>>5|re;let Ce=0,Ne=Ce;Ne+=ne*de,Ne+=ie*(5*Se),Ne+=se*(5*ge),Ne+=oe*(5*we),Ne+=ce*(5*ve),Ce=Ne>>>13,Ne&=8191,Ne+=ae*(5*Ee),Ne+=le*(5*be),Ne+=ue*(5*_e),Ne+=he*(5*me),Ne+=pe*(5*fe),Ce+=Ne>>>13,Ne&=8191;let Oe=Ce;Oe+=ne*fe,Oe+=ie*de,Oe+=se*(5*Se),Oe+=oe*(5*ge),Oe+=ce*(5*we),Ce=Oe>>>13,Oe&=8191,Oe+=ae*(5*ve),Oe+=le*(5*Ee),Oe+=ue*(5*be),Oe+=he*(5*_e),Oe+=pe*(5*me),Ce+=Oe>>>13,Oe&=8191;let Le=Ce;Le+=ne*me,Le+=ie*fe,Le+=se*de,Le+=oe*(5*Se),Le+=ce*(5*ge),Ce=Le>>>13,Le&=8191,Le+=ae*(5*we),Le+=le*(5*ve),Le+=ue*(5*Ee),Le+=he*(5*be),Le+=pe*(5*_e),Ce+=Le>>>13,Le&=8191;let Be=Ce;Be+=ne*_e,Be+=ie*me,Be+=se*fe,Be+=oe*de,Be+=ce*(5*Se),Ce=Be>>>13,Be&=8191,Be+=ae*(5*ge),Be+=le*(5*we),Be+=ue*(5*ve),Be+=he*(5*Ee),Be+=pe*(5*be),Ce+=Be>>>13,Be&=8191;let ze=Ce;ze+=ne*be,ze+=ie*_e,ze+=se*me,ze+=oe*fe,ze+=ce*de,Ce=ze>>>13,ze&=8191,ze+=ae*(5*Se),ze+=le*(5*ge),ze+=ue*(5*we),ze+=he*(5*ve),ze+=pe*(5*Ee),Ce+=ze>>>13,ze&=8191;let Ue=Ce;Ue+=ne*Ee,Ue+=ie*be,Ue+=se*_e,Ue+=oe*me,Ue+=ce*fe,Ce=Ue>>>13,Ue&=8191,Ue+=ae*de,Ue+=le*(5*Se),Ue+=ue*(5*ge),Ue+=he*(5*we),Ue+=pe*(5*ve),Ce+=Ue>>>13,Ue&=8191;let Ge=Ce;Ge+=ne*ve,Ge+=ie*Ee,Ge+=se*be,Ge+=oe*_e,Ge+=ce*me,Ce=Ge>>>13,Ge&=8191,Ge+=ae*fe,Ge+=le*de,Ge+=ue*(5*Se),Ge+=he*(5*ge),Ge+=pe*(5*we),Ce+=Ge>>>13,Ge&=8191;let je=Ce;je+=ne*we,je+=ie*ve,je+=se*Ee,je+=oe*be,je+=ce*_e,Ce=je>>>13,je&=8191,je+=ae*me,je+=le*fe,je+=ue*de,je+=he*(5*Se),je+=pe*(5*ge),Ce+=je>>>13,je&=8191;let We=Ce;We+=ne*ge,We+=ie*we,We+=se*ve,We+=oe*Ee,We+=ce*be,Ce=We>>>13,We&=8191,We+=ae*_e,We+=le*me,We+=ue*fe,We+=he*de,We+=pe*(5*Se),Ce+=We>>>13,We&=8191;let Ae=Ce;Ae+=ne*Se,Ae+=ie*ge,Ae+=se*we,Ae+=oe*ve,Ae+=ce*Ee,Ce=Ae>>>13,Ae&=8191,Ae+=ae*be,Ae+=le*_e,Ae+=ue*me,Ae+=he*fe,Ae+=pe*de,Ce+=Ae>>>13,Ae&=8191,Ce=(Ce<<2)+Ce|0,Ce=Ce+Ne|0,Ne=Ce&8191,Ce=Ce>>>13,Oe+=Ce,ne=Ne,ie=Oe,se=Le,oe=Be,ce=ze,ae=Ue,le=Ge,ue=je,he=We,pe=Ae,ee+=16,te-=16}this._h[0]=ne,this._h[1]=ie,this._h[2]=se,this._h[3]=oe,this._h[4]=ce,this._h[5]=ae,this._h[6]=le,this._h[7]=ue,this._h[8]=he,this._h[9]=pe}finish(E,ee=0){const te=new Uint16Array(10);let re,ne,ie,se;if(this._leftover){for(se=this._leftover,this._buffer[se++]=1;se<16;se++)this._buffer[se]=0;this._fin=1,this._blocks(this._buffer,0,16)}for(re=this._h[1]>>>13,this._h[1]&=8191,se=2;se<10;se++)this._h[se]+=re,re=this._h[se]>>>13,this._h[se]&=8191;for(this._h[0]+=re*5,re=this._h[0]>>>13,this._h[0]&=8191,this._h[1]+=re,re=this._h[1]>>>13,this._h[1]&=8191,this._h[2]+=re,te[0]=this._h[0]+5,re=te[0]>>>13,te[0]&=8191,se=1;se<10;se++)te[se]=this._h[se]+re,re=te[se]>>>13,te[se]&=8191;for(te[9]-=8192,ne=(re^1)-1,se=0;se<10;se++)te[se]&=ne;for(ne=~ne,se=0;se<10;se++)this._h[se]=this._h[se]&ne|te[se];for(this._h[0]=(this._h[0]|this._h[1]<<13)&65535,this._h[1]=(this._h[1]>>>3|this._h[2]<<10)&65535,this._h[2]=(this._h[2]>>>6|this._h[3]<<7)&65535,this._h[3]=(this._h[3]>>>9|this._h[4]<<4)&65535,this._h[4]=(this._h[4]>>>12|this._h[5]<<1|this._h[6]<<14)&65535,this._h[5]=(this._h[6]>>>2|this._h[7]<<11)&65535,this._h[6]=(this._h[7]>>>5|this._h[8]<<8)&65535,this._h[7]=(this._h[8]>>>8|this._h[9]<<5)&65535,ie=this._h[0]+this._pad[0],this._h[0]=ie&65535,se=1;se<8;se++)ie=(this._h[se]+this._pad[se]|0)+(ie>>>16)|0,this._h[se]=ie&65535;return E[ee+0]=this._h[0]>>>0,E[ee+1]=this._h[0]>>>8,E[ee+2]=this._h[1]>>>0,E[ee+3]=this._h[1]>>>8,E[ee+4]=this._h[2]>>>0,E[ee+5]=this._h[2]>>>8,E[ee+6]=this._h[3]>>>0,E[ee+7]=this._h[3]>>>8,E[ee+8]=this._h[4]>>>0,E[ee+9]=this._h[4]>>>8,E[ee+10]=this._h[5]>>>0,E[ee+11]=this._h[5]>>>8,E[ee+12]=this._h[6]>>>0,E[ee+13]=this._h[6]>>>8,E[ee+14]=this._h[7]>>>0,E[ee+15]=this._h[7]>>>8,this._finished=!0,this}update(E){let ee=0,te=E.length,re;if(this._leftover){re=16-this._leftover,re>te&&(re=te);for(let ne=0;ne<re;ne++)this._buffer[this._leftover+ne]=E[ee+ne];if(te-=re,ee+=re,this._leftover+=re,this._leftover<16)return this;this._blocks(this._buffer,0,16),this._leftover=0}if(te>=16&&(re=te-te%16,this._blocks(E,ee,re),ee+=re,te-=re),te){for(let ne=0;ne<te;ne++)this._buffer[this._leftover+ne]=E[ee+ne];this._leftover+=te}return this}digest(){if(this._finished)throw new Error("Poly1305 was finished");let E=new Uint8Array(16);return this.finish(E),E}clean(){return wipe$2(this._buffer),wipe$2(this._r),wipe$2(this._h),wipe$2(this._pad),this._leftover=0,this._fin=0,this._finished=!0,this}}const KEY_LENGTH=32,NONCE_LENGTH=12,TAG_LENGTH=16,ZEROS=new Uint8Array(16);class ChaCha20Poly1305{constructor(E){if(Object.defineProperty(this,"nonceLength",{enumerable:!0,configurable:!0,writable:!0,value:NONCE_LENGTH}),Object.defineProperty(this,"tagLength",{enumerable:!0,configurable:!0,writable:!0,value:TAG_LENGTH}),Object.defineProperty(this,"_key",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),E.length!==KEY_LENGTH)throw new Error("ChaCha20Poly1305 needs 32-byte key");this._key=new Uint8Array(E)}seal(E,ee,te,re){if(E.length>16)throw new Error("ChaCha20Poly1305: incorrect nonce length");const ne=new Uint8Array(16);ne.set(E,ne.length-E.length);const ie=new Uint8Array(32);stream$1(this._key,ne,ie,4);const se=ee.length+this.tagLength;let oe;if(re){if(re.length!==se)throw new Error("ChaCha20Poly1305: incorrect destination length");oe=re}else oe=new Uint8Array(se);return streamXOR$1(this._key,ne,ee,oe,4),this._authenticate(oe.subarray(oe.length-this.tagLength,oe.length),ie,oe.subarray(0,oe.length-this.tagLength),te),wipe$2(ne),oe}open(E,ee,te,re){if(E.length>16)throw new Error("ChaCha20Poly1305: incorrect nonce length");if(ee.length<this.tagLength)return null;const ne=new Uint8Array(16);ne.set(E,ne.length-E.length);const ie=new Uint8Array(32);stream$1(this._key,ne,ie,4);const se=new Uint8Array(this.tagLength);if(this._authenticate(se,ie,ee.subarray(0,ee.length-this.tagLength),te),!equal$1(se,ee.subarray(ee.length-this.tagLength,ee.length)))return null;const oe=ee.length-this.tagLength;let ce;if(re){if(re.length!==oe)throw new Error("ChaCha20Poly1305: incorrect destination length");ce=re}else ce=new Uint8Array(oe);return streamXOR$1(this._key,ne,ee.subarray(0,ee.length-this.tagLength),ce,4),wipe$2(ne),ce}clean(){return wipe$2(this._key),this}_authenticate(E,ee,te,re){const ne=new Poly1305(ee);re&&(ne.update(re),re.length%16>0&&ne.update(ZEROS.subarray(re.length%16))),ne.update(te),te.length%16>0&&ne.update(ZEROS.subarray(te.length%16));const ie=new Uint8Array(8);re&&writeUint64LE$1(re.length,ie),ne.update(ie),writeUint64LE$1(te.length,ie),ne.update(ie);const se=ne.digest();for(let oe=0;oe<se.length;oe++)E[oe]=se[oe];ne.clean(),wipe$2(se),wipe$2(ie)}}class Chacha20Poly1305Key{constructor(E){Object.defineProperty(this,"_key",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._key=new ChaCha20Poly1305(new Uint8Array(E))}async seal(E,ee,te){return await this._seal(E,ee,te)}async open(E,ee,te){return await this._open(E,ee,te)}_seal(E,ee,te){return new Promise(re=>{const ne=this._key.seal(new Uint8Array(E),new Uint8Array(ee),new Uint8Array(te));re(ne.buffer)})}_open(E,ee,te){return new Promise((re,ne)=>{const ie=this._key.open(new Uint8Array(E),new Uint8Array(ee),new Uint8Array(te));ie instanceof Uint8Array?re(ie.buffer):ne(new Error("failed to open."))})}}class EncryptionContext extends ExporterContext{constructor(E,ee,te){if(super(E,ee,te.exporterSecret),Object.defineProperty(this,"_aead",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nK",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nN",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nT",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_f",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_r",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),te.key===void 0||te.baseNonce===void 0||te.seq===void 0)throw new Error("Required parameters are missing");switch(this._aead=te.aead,this._aead){case Aead$1.Aes128Gcm:this._nK=16,this._nN=12,this._nT=16;break;case Aead$1.Aes256Gcm:this._nK=32,this._nN=12,this._nT=16;break;case Aead$1.Chacha20Poly1305:this._nK=32,this._nN=12,this._nT=16;break;default:this._nK=0,this._nN=0,this._nT=0;break}const re=createAeadKey(this._aead,te.key,this._api);this._f={key:re,baseNonce:te.baseNonce,seq:te.seq},this._r={key:re,baseNonce:EMPTY,seq:0}}computeNonce(E){const ee=i2Osp(E.seq,E.baseNonce.byteLength);return xor$1(E.baseNonce,ee)}incrementSeq(E){if(E.seq>Number.MAX_SAFE_INTEGER)throw new MessageLimitReachedError("Message limit reached");E.seq+=1}async setupBidirectional(E,ee){try{this._r.baseNonce=new Uint8Array(await this.export(ee,this._nN));const te=await this.export(E,this._nK);this._r.key=createAeadKey(this._aead,te,this._api),this._r.seq=0}catch(te){throw this._r.baseNonce=EMPTY,te}}}function createAeadKey(J,E,ee){switch(J){case Aead$1.Aes128Gcm:return new AesGcmKey(E,ee);case Aead$1.Aes256Gcm:return new AesGcmKey(E,ee);case Aead$1.Chacha20Poly1305:return new Chacha20Poly1305Key(E);default:throw new Error("Invalid or unsupported AEAD id")}}const BYTES$1=32;let SHA256$1=class{constructor(){Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:BYTES$1}),Object.defineProperty(this,"_buf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_bufIdx",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_count",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_K",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_H",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_finalized",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._buf=new Uint8Array(64),this._K=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),this.init()}init(){return this._H=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),this._bufIdx=0,this._count=new Uint32Array(2),this._buf.fill(0),this._finalized=!1,this}update(J){if(J===null)throw new TypeError("msg must be a string or Uint8Array.");for(let ee=0,te=J.length;ee<te;ee++)this._buf[this._bufIdx++]=J[ee],this._bufIdx===64&&(this._transform(),this._bufIdx=0);const E=this._count;return(E[0]+=J.length<<3)<J.length<<3&&E[1]++,E[1]+=J.length>>>29,this}digest(){if(this._finalized)throw new Error("digest has already been called.");this._finalized=!0;const J=this._buf;let E=this._bufIdx;for(J[E++]=128;E!==56;)E===64&&(this._transform(),E=0),J[E++]=0;const ee=this._count;J[56]=ee[1]>>>24&255,J[57]=ee[1]>>>16&255,J[58]=ee[1]>>>8&255,J[59]=ee[1]>>>0&255,J[60]=ee[0]>>>24&255,J[61]=ee[0]>>>16&255,J[62]=ee[0]>>>8&255,J[63]=ee[0]>>>0&255,this._transform();const te=new Uint8Array(BYTES$1);for(let re=0;re<8;re++)te[(re<<2)+0]=this._H[re]>>>24&255,te[(re<<2)+1]=this._H[re]>>>16&255,te[(re<<2)+2]=this._H[re]>>>8&255,te[(re<<2)+3]=this._H[re]>>>0&255;return this.init(),te}_transform(){const J=this._H;let E=J[0],ee=J[1],te=J[2],re=J[3],ne=J[4],ie=J[5],se=J[6],oe=J[7];const ce=new Uint32Array(16);let ae;for(ae=0;ae<16;ae++)ce[ae]=this._buf[(ae<<2)+3]|this._buf[(ae<<2)+2]<<8|this._buf[(ae<<2)+1]<<16|this._buf[ae<<2]<<24;for(ae=0;ae<64;ae++){let le;if(ae<16)le=ce[ae];else{let ue=ce[ae+1&15],he=ce[ae+14&15];le=ce[ae&15]=(ue>>>7^ue>>>18^ue>>>3^ue<<25^ue<<14)+(he>>>17^he>>>19^he>>>10^he<<15^he<<13)+ce[ae&15]+ce[ae+9&15]|0}le=le+oe+(ne>>>6^ne>>>11^ne>>>25^ne<<26^ne<<21^ne<<7)+(se^ne&(ie^se))+this._K[ae]|0,oe=se,se=ie,ie=ne,ne=re+le,re=te,te=ee,ee=E,E=le+(ee&te^re&(ee^te))+(ee>>>2^ee>>>13^ee>>>22^ee<<30^ee<<19^ee<<10)|0}J[0]=J[0]+E|0,J[1]=J[1]+ee|0,J[2]=J[2]+te|0,J[3]=J[3]+re|0,J[4]=J[4]+ne|0,J[5]=J[5]+ie|0,J[6]=J[6]+se|0,J[7]=J[7]+oe|0}};const BYTES=64;class SHA512{constructor(){Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:BYTES}),Object.defineProperty(this,"_buffer",{enumerable:!0,configurable:!0,writable:!0,value:new Uint8Array(128)}),Object.defineProperty(this,"_bufferIndex",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_count",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_K",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_H",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_finalized",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._K=new Uint32Array([1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591]),this.init()}init(){return this._H=new Uint32Array([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),this._bufferIndex=0,this._count=new Uint32Array(2),this._buffer.fill(0),this._finalized=!1,this}update(E){if(E===null)throw new TypeError("msg must be a string or Uint8Array.");for(let te=0;te<E.length;te++)this._buffer[this._bufferIndex++]=E[te],this._bufferIndex===128&&(this.transform(),this._bufferIndex=0);let ee=this._count;return(ee[0]+=E.length<<3)<E.length<<3&&ee[1]++,ee[1]+=E.length>>>29,this}digest(){if(this._finalized)throw new Error("digest has already been called.");this._finalized=!0;var E=this._buffer,ee=this._bufferIndex;for(E[ee++]=128;ee!==112;)ee===128&&(this.transform(),ee=0),E[ee++]=0;let te=this._count;E[112]=E[113]=E[114]=E[115]=E[116]=E[117]=E[118]=E[119]=0,E[120]=te[1]>>>24&255,E[121]=te[1]>>>16&255,E[122]=te[1]>>>8&255,E[123]=te[1]>>>0&255,E[124]=te[0]>>>24&255,E[125]=te[0]>>>16&255,E[126]=te[0]>>>8&255,E[127]=te[0]>>>0&255,this.transform();let re,ne=new Uint8Array(64);for(re=0;re<16;re++)ne[(re<<2)+0]=this._H[re]>>>24&255,ne[(re<<2)+1]=this._H[re]>>>16&255,ne[(re<<2)+2]=this._H[re]>>>8&255,ne[(re<<2)+3]=this._H[re]&255;return this.init(),ne}transform(){let E=this._H,ee=E[0],te=E[1],re=E[2],ne=E[3],ie=E[4],se=E[5],oe=E[6],ce=E[7],ae=E[8],le=E[9],ue=E[10],he=E[11],pe=E[12],de=E[13],fe=E[14],me=E[15],_e=ee,be=te,Ee=re,ve=ne,we=ie,ge=se,Se=oe,$e=ce,Pe=ae,Me=le,xe=ue,Fe=he,ke=pe,Te=de,Ve=fe,Ce=me,Ne,Oe=new Uint32Array(160);for(Ne=0;Ne<32;Ne++)Oe[Ne]=this._buffer[(Ne<<2)+3]|this._buffer[(Ne<<2)+2]<<8|this._buffer[(Ne<<2)+1]<<16|this._buffer[Ne<<2]<<24;let Le,Be,ze,Ue,Ge,je,We,Ae,De,Ie,ye,Re,Ke,He;for(Ne=16;Ne<80;Ne++)Be=Oe[(Ne-15)*2],Le=Oe[(Ne-15)*2+1],Ue=(Le<<31|Be>>>1)^(Le<<24|Be>>>8)^Be>>>7,ze=(Be<<31|Le>>>1)^(Be<<24|Le>>>8)^(Be<<25|Le>>>7),je=Oe[(Ne-2)*2],Ge=Oe[(Ne-2)*2+1],Ae=(Ge<<13|je>>>19)^(je<<3|Ge>>>29)^je>>>6,We=(je<<13|Ge>>>19)^(Ge<<3|je>>>29)^(je<<26|Ge>>>6),Re=Oe[(Ne-7)*2],ye=Oe[(Ne-7)*2+1],He=Oe[(Ne-16)*2],Ke=Oe[(Ne-16)*2+1],De=ze+ye,Ie=Ue+Re+(De>>>0<ze>>>0?1:0),De+=We,Ie+=Ae+(De>>>0<We>>>0?1:0),De+=Ke,Ie+=He+(De>>>0<Ke>>>0?1:0),Oe[Ne*2]=Ie,Oe[Ne*2+1]=De;let qe,Ye,rt,ot,ft,gt,it,nt,et,tt,Qe,Xe,Je,Ze;for(Ne=0;Ne<80;Ne++)Ye=Pe&xe^~Pe&ke,qe=Me&Fe^~Me&Te,ot=_e&Ee^_e&we^Ee&we,rt=be&ve^be&ge^ve&ge,gt=(be<<4|_e>>>28)^(_e<<30|be>>>2)^(_e<<25|be>>>7),ft=(_e<<4|be>>>28)^(be<<30|_e>>>2)^(be<<25|_e>>>7),nt=(Me<<18|Pe>>>14)^(Me<<14|Pe>>>18)^(Pe<<23|Me>>>9),it=(Pe<<18|Me>>>14)^(Pe<<14|Me>>>18)^(Me<<23|Pe>>>9),tt=this._K[Ne*2],et=this._K[Ne*2+1],Qe=Ce+it,Xe=Ve+nt+(Qe>>>0<Ce>>>0?1:0),Qe+=qe,Xe+=Ye+(Qe>>>0<qe>>>0?1:0),Qe+=et,Xe+=tt+(Qe>>>0<et>>>0?1:0),Qe=Qe+Oe[Ne*2+1],Xe+=Oe[Ne*2]+(Qe>>>0<Oe[Ne*2+1]>>>0?1:0),Je=ft+rt,Ze=gt+ot+(Je>>>0<ft>>>0?1:0),Ve=ke,Ce=Te,ke=xe,Te=Fe,xe=Pe,Fe=Me,Me=$e+Qe|0,Pe=Se+Xe+(Me>>>0<$e>>>0?1:0)|0,Se=we,$e=ge,we=Ee,ge=ve,Ee=_e,ve=be,be=Qe+Je|0,_e=Xe+Ze+(be>>>0<Qe>>>0?1:0)|0;te=E[1]=te+be|0,E[0]=ee+_e+(te>>>0<be>>>0?1:0)|0,ne=E[3]=ne+ve|0,E[2]=re+Ee+(ne>>>0<ve>>>0?1:0)|0,se=E[5]=se+ge|0,E[4]=ie+we+(se>>>0<ge>>>0?1:0)|0,ce=E[7]=ce+$e|0,E[6]=oe+Se+(ce>>>0<$e>>>0?1:0)|0,le=E[9]=le+Me|0,E[8]=ae+Pe+(le>>>0<Me>>>0?1:0)|0,he=E[11]=he+Fe|0,E[10]=ue+xe+(he>>>0<Fe>>>0?1:0)|0,de=E[13]=de+Te|0,E[12]=pe+ke+(de>>>0<Te>>>0?1:0)|0,me=E[15]=me+Ce|0,E[14]=fe+Ve+(me>>>0<Ce>>>0?1:0)|0}}const SHA256_REGEX=/^\s*sha-?256\s*$/i,SHA512_REGEX=/^\s*sha-?512\s*$/i;let HMAC$2=class{constructor(J,E){Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"B",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"iPad",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"oPad",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"iKeyPad",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"oKeyPad",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"hasher",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.hashSize=J.hashSize,this.hasher=J,this.B=this.hashSize<=32?64:128,this.iPad=54,this.oPad=92,E&&this.init(E)}init(J){J||(J=new Uint8Array(0));let E=new Uint8Array(J);if(E.length>this.B&&(this.hasher.init(),E=this.hasher.update(J).digest()),E.byteLength<this.B){const ee=new Uint8Array(this.B);ee.set(E,0),E=ee}this.iKeyPad=new Uint8Array(this.B),this.oKeyPad=new Uint8Array(this.B);for(let ee=0;ee<this.B;++ee)this.iKeyPad[ee]=this.iPad^E[ee],this.oKeyPad[ee]=this.oPad^E[ee];return E.fill(0),this.hasher.init(),this.hasher.update(this.iKeyPad),this}update(J=new Uint8Array(0)){return this.hasher.update(J),this}digest(){const J=this.hasher.digest();return this.hasher.init(),this.hasher.update(this.oKeyPad).update(J).digest()}};function hmac$4(J,E,ee){if(SHA256_REGEX.test(J))return new HMAC$2(new SHA256$1).init(E).update(ee).digest();if(SHA512_REGEX.test(J))return new HMAC$2(new SHA512).init(E).update(ee).digest();throw new TypeError(`Unsupported hash ${J}. Must be one of SHA(1|256|512).`)}class KdfContext extends WebCrypto{constructor(E,ee,te){switch(super(E),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"hashSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"suiteId",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"algHash",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nH",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.id=ee,this.suiteId=te,ee){case Kdf$1.HkdfSha256:this.hashSize=32,this.algHash={name:"HMAC",hash:"SHA-256",length:256};break;case Kdf$1.HkdfSha384:this.hashSize=48,this.algHash={name:"HMAC",hash:"SHA-384",length:384};break;default:this.hashSize=64,this.algHash={name:"HMAC",hash:"SHA-512",length:512};break}if(this.algHash.length===void 0)throw new Error("Unknown hash size.");this._nH=this.algHash.length/8}buildLabeledIkm(E,ee){const te=new Uint8Array(7+this.suiteId.byteLength+E.byteLength+ee.byteLength);return te.set(HPKE_VERSION,0),te.set(this.suiteId,7),te.set(E,7+this.suiteId.byteLength),te.set(ee,7+this.suiteId.byteLength+E.byteLength),te}buildLabeledInfo(E,ee,te){const re=new Uint8Array(9+this.suiteId.byteLength+E.byteLength+ee.byteLength);return re.set(new Uint8Array([0,te]),0),re.set(HPKE_VERSION,2),re.set(this.suiteId,9),re.set(E,9+this.suiteId.byteLength),re.set(ee,9+this.suiteId.byteLength+E.byteLength),re}async extract(E,ee){if(E.byteLength===0&&(E=new ArrayBuffer(this._nH)),E.byteLength!==this._nH)switch(this.algHash.hash){case"SHA-256":return hmac$4("sha256",new Uint8Array(E),new Uint8Array(ee));case"SHA-512":return hmac$4("sha512",new Uint8Array(E),new Uint8Array(ee));default:throw new NotSupportedError(`${this.algHash.hash} key length should be ${this._nH}.`)}const te=await this._api.importKey("raw",E,this.algHash,!1,["sign"]);return await this._api.sign("HMAC",te,ee)}async expand(E,ee,te){const re=await this._api.importKey("raw",E,this.algHash,!1,["sign"]),ne=new ArrayBuffer(te),ie=new Uint8Array(ne);let se=EMPTY;const oe=new Uint8Array(ee),ce=new Uint8Array(1);if(te>255*this._nH)throw new Error("Entropy limit reached");const ae=new Uint8Array(this._nH+oe.length+1);for(let le=1,ue=0;ue<ie.length;le++)ce[0]=le,ae.set(se,0),ae.set(oe,se.length),ae.set(ce,se.length+oe.length),se=new Uint8Array(await this._api.sign("HMAC",re,ae.slice(0,se.length+oe.length+1))),ie.length-ue>=se.length?(ie.set(se,ue),ue+=se.length):(ie.set(se.slice(0,ie.length-ue),ue),ue+=ie.length-ue);return ne}async extractAndExpand(E,ee,te,re){const ne=await this._api.importKey("raw",ee,"HKDF",!1,KEM_USAGES);return await this._api.deriveBits({name:"HKDF",hash:this.algHash.hash,salt:E,info:te},ne,re*8)}async labeledExtract(E,ee,te){return await this.extract(E,this.buildLabeledIkm(ee,te))}async labeledExpand(E,ee,te,re){return await this.expand(E,this.buildLabeledInfo(ee,te,re),re)}}class Bignum{constructor(E){Object.defineProperty(this,"_num",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._num=new Uint8Array(E)}val(){return this._num}reset(){this._num.fill(0)}set(E){if(E.length!==this._num.length)throw new Error("Bignum.set: invalid argument");this._num.set(E)}isZero(){for(let E=0;E<this._num.length;E++)if(this._num[E]!==0)return!1;return!0}lessThan(E){if(E.length!==this._num.length)throw new Error("Bignum.lessThan: invalid argument");for(let ee=0;ee<this._num.length;ee++){if(this._num[ee]<E[ee])return!0;if(this._num[ee]>E[ee])return!1}return!1}}const PKCS8_ALG_ID_P_256=new Uint8Array([48,65,2,1,0,48,19,6,7,42,134,72,206,61,2,1,6,8,42,134,72,206,61,3,1,7,4,39,48,37,2,1,1,4,32]),PKCS8_ALG_ID_P_384=new Uint8Array([48,78,2,1,0,48,16,6,7,42,134,72,206,61,2,1,6,5,43,129,4,0,34,4,55,48,53,2,1,1,4,48]),PKCS8_ALG_ID_P_521=new Uint8Array([48,96,2,1,0,48,16,6,7,42,134,72,206,61,2,1,6,5,43,129,4,0,35,4,73,48,71,2,1,1,4,66]);class Ec{constructor(E,ee,te){switch(Object.defineProperty(this,"_hkdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_api",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_alg",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nPk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nSk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nDh",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_order",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_bitmask",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_pkcs8AlgId",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._hkdf=ee,this._api=te,E){case Kem$1.DhkemP256HkdfSha256:this._alg={name:"ECDH",namedCurve:"P-256"},this._nPk=65,this._nSk=32,this._nDh=32,this._order=ORDER_P_256,this._bitmask=255,this._pkcs8AlgId=PKCS8_ALG_ID_P_256;break;case Kem$1.DhkemP384HkdfSha384:this._alg={name:"ECDH",namedCurve:"P-384"},this._nPk=97,this._nSk=48,this._nDh=48,this._order=ORDER_P_384,this._bitmask=255,this._pkcs8AlgId=PKCS8_ALG_ID_P_384;break;default:this._alg={name:"ECDH",namedCurve:"P-521"},this._nPk=133,this._nSk=66,this._nDh=66,this._order=ORDER_P_521,this._bitmask=1,this._pkcs8AlgId=PKCS8_ALG_ID_P_521;break}}async serializePublicKey(E){const ee=await this._api.exportKey("raw",E);if(ee.byteLength!==this._nPk)throw new Error("Invalid public key for the ciphersuite");return ee}async deserializePublicKey(E){if(E.byteLength!==this._nPk)throw new Error("Invalid public key for the ciphersuite");try{return await this._api.importKey("raw",E,this._alg,!0,[])}catch{throw new Error("Invalid public key for the ciphersuite")}}async importKey(E,ee,te){if(E!=="raw")throw new Error("Unsupported format");if(te&&ee.byteLength!==this._nPk)throw new Error("Invalid public key for the ciphersuite");if(!te&&ee.byteLength!==this._nSk)throw new Error("Invalid private key for the ciphersuite");try{if(te)return await this._api.importKey(E,ee,this._alg,!0,[]);const re=new Uint8Array(ee),ne=new Uint8Array(this._pkcs8AlgId.length+re.length);return ne.set(this._pkcs8AlgId,0),ne.set(re,this._pkcs8AlgId.length),await this._api.importKey("pkcs8",ne,this._alg,!0,KEM_USAGES)}catch{throw new Error("Invalid key for the ciphersuite")}}async derivePublicKey(E){const ee=await this._api.exportKey("jwk",E);return delete ee.d,delete ee.key_ops,await this._api.importKey("jwk",ee,this._alg,!0,[])}async generateKeyPair(){return await this._api.generateKey(this._alg,!0,KEM_USAGES)}async deriveKeyPair(E){const ee=await this._hkdf.labeledExtract(EMPTY,LABEL_DKP_PRK,new Uint8Array(E)),te=new Bignum(this._nSk);for(let ie=0;te.isZero()||!te.lessThan(this._order);ie++){if(ie>255)throw new Error("Faild to derive a key pair");const se=new Uint8Array(await this._hkdf.labeledExpand(ee,LABEL_CANDIDATE,i2Osp(ie,1),this._nSk));se[0]=se[0]&this._bitmask,te.set(se)}const re=new Uint8Array(this._pkcs8AlgId.length+te.val().length);re.set(this._pkcs8AlgId,0),re.set(te.val(),this._pkcs8AlgId.length);const ne=await this._api.importKey("pkcs8",re,this._alg,!0,KEM_USAGES);return te.reset(),{privateKey:ne,publicKey:await this.derivePublicKey(ne)}}async dh(E,ee){return await this._api.deriveBits({name:"ECDH",public:ee},E,this._nDh*8)}}const PUBLIC_KEY_LENGTH=32;function gf(J){const E=new Float64Array(16);if(J)for(let ee=0;ee<J.length;ee++)E[ee]=J[ee];return E}const _9=new Uint8Array(32);_9[0]=9;const _121665=gf([56129,1]);function car25519(J){let E=1;for(let ee=0;ee<16;ee++){const te=J[ee]+E+65535;E=Math.floor(te/65536),J[ee]=te-E*65536}J[0]+=E-1+37*(E-1)}function sel25519(J,E,ee){const te=~(ee-1);for(let re=0;re<16;re++){const ne=te&(J[re]^E[re]);J[re]^=ne,E[re]^=ne}}function pack25519(J,E){const ee=gf(),te=gf();for(let re=0;re<16;re++)te[re]=E[re];car25519(te),car25519(te),car25519(te);for(let re=0;re<2;re++){ee[0]=te[0]-65517;for(let ie=1;ie<15;ie++)ee[ie]=te[ie]-65535-(ee[ie-1]>>16&1),ee[ie-1]&=65535;ee[15]=te[15]-32767-(ee[14]>>16&1);const ne=ee[15]>>16&1;ee[14]&=65535,sel25519(te,ee,1-ne)}for(let re=0;re<16;re++)J[2*re]=te[re]&255,J[2*re+1]=te[re]>>8}function unpack25519(J,E){for(let ee=0;ee<16;ee++)J[ee]=E[2*ee]+(E[2*ee+1]<<8);J[15]&=32767}function add(J,E,ee){for(let te=0;te<16;te++)J[te]=E[te]+ee[te]}function sub(J,E,ee){for(let te=0;te<16;te++)J[te]=E[te]-ee[te]}function mul(J,E,ee){let te,re,ne=0,ie=0,se=0,oe=0,ce=0,ae=0,le=0,ue=0,he=0,pe=0,de=0,fe=0,me=0,_e=0,be=0,Ee=0,ve=0,we=0,ge=0,Se=0,$e=0,Pe=0,Me=0,xe=0,Fe=0,ke=0,Te=0,Ve=0,Ce=0,Ne=0,Oe=0;const Le=ee[0],Be=ee[1],ze=ee[2],Ue=ee[3],Ge=ee[4],je=ee[5],We=ee[6],Ae=ee[7],De=ee[8],Ie=ee[9],ye=ee[10],Re=ee[11],Ke=ee[12],He=ee[13],qe=ee[14],Ye=ee[15];te=E[0],ne+=te*Le,ie+=te*Be,se+=te*ze,oe+=te*Ue,ce+=te*Ge,ae+=te*je,le+=te*We,ue+=te*Ae,he+=te*De,pe+=te*Ie,de+=te*ye,fe+=te*Re,me+=te*Ke,_e+=te*He,be+=te*qe,Ee+=te*Ye,te=E[1],ie+=te*Le,se+=te*Be,oe+=te*ze,ce+=te*Ue,ae+=te*Ge,le+=te*je,ue+=te*We,he+=te*Ae,pe+=te*De,de+=te*Ie,fe+=te*ye,me+=te*Re,_e+=te*Ke,be+=te*He,Ee+=te*qe,ve+=te*Ye,te=E[2],se+=te*Le,oe+=te*Be,ce+=te*ze,ae+=te*Ue,le+=te*Ge,ue+=te*je,he+=te*We,pe+=te*Ae,de+=te*De,fe+=te*Ie,me+=te*ye,_e+=te*Re,be+=te*Ke,Ee+=te*He,ve+=te*qe,we+=te*Ye,te=E[3],oe+=te*Le,ce+=te*Be,ae+=te*ze,le+=te*Ue,ue+=te*Ge,he+=te*je,pe+=te*We,de+=te*Ae,fe+=te*De,me+=te*Ie,_e+=te*ye,be+=te*Re,Ee+=te*Ke,ve+=te*He,we+=te*qe,ge+=te*Ye,te=E[4],ce+=te*Le,ae+=te*Be,le+=te*ze,ue+=te*Ue,he+=te*Ge,pe+=te*je,de+=te*We,fe+=te*Ae,me+=te*De,_e+=te*Ie,be+=te*ye,Ee+=te*Re,ve+=te*Ke,we+=te*He,ge+=te*qe,Se+=te*Ye,te=E[5],ae+=te*Le,le+=te*Be,ue+=te*ze,he+=te*Ue,pe+=te*Ge,de+=te*je,fe+=te*We,me+=te*Ae,_e+=te*De,be+=te*Ie,Ee+=te*ye,ve+=te*Re,we+=te*Ke,ge+=te*He,Se+=te*qe,$e+=te*Ye,te=E[6],le+=te*Le,ue+=te*Be,he+=te*ze,pe+=te*Ue,de+=te*Ge,fe+=te*je,me+=te*We,_e+=te*Ae,be+=te*De,Ee+=te*Ie,ve+=te*ye,we+=te*Re,ge+=te*Ke,Se+=te*He,$e+=te*qe,Pe+=te*Ye,te=E[7],ue+=te*Le,he+=te*Be,pe+=te*ze,de+=te*Ue,fe+=te*Ge,me+=te*je,_e+=te*We,be+=te*Ae,Ee+=te*De,ve+=te*Ie,we+=te*ye,ge+=te*Re,Se+=te*Ke,$e+=te*He,Pe+=te*qe,Me+=te*Ye,te=E[8],he+=te*Le,pe+=te*Be,de+=te*ze,fe+=te*Ue,me+=te*Ge,_e+=te*je,be+=te*We,Ee+=te*Ae,ve+=te*De,we+=te*Ie,ge+=te*ye,Se+=te*Re,$e+=te*Ke,Pe+=te*He,Me+=te*qe,xe+=te*Ye,te=E[9],pe+=te*Le,de+=te*Be,fe+=te*ze,me+=te*Ue,_e+=te*Ge,be+=te*je,Ee+=te*We,ve+=te*Ae,we+=te*De,ge+=te*Ie,Se+=te*ye,$e+=te*Re,Pe+=te*Ke,Me+=te*He,xe+=te*qe,Fe+=te*Ye,te=E[10],de+=te*Le,fe+=te*Be,me+=te*ze,_e+=te*Ue,be+=te*Ge,Ee+=te*je,ve+=te*We,we+=te*Ae,ge+=te*De,Se+=te*Ie,$e+=te*ye,Pe+=te*Re,Me+=te*Ke,xe+=te*He,Fe+=te*qe,ke+=te*Ye,te=E[11],fe+=te*Le,me+=te*Be,_e+=te*ze,be+=te*Ue,Ee+=te*Ge,ve+=te*je,we+=te*We,ge+=te*Ae,Se+=te*De,$e+=te*Ie,Pe+=te*ye,Me+=te*Re,xe+=te*Ke,Fe+=te*He,ke+=te*qe,Te+=te*Ye,te=E[12],me+=te*Le,_e+=te*Be,be+=te*ze,Ee+=te*Ue,ve+=te*Ge,we+=te*je,ge+=te*We,Se+=te*Ae,$e+=te*De,Pe+=te*Ie,Me+=te*ye,xe+=te*Re,Fe+=te*Ke,ke+=te*He,Te+=te*qe,Ve+=te*Ye,te=E[13],_e+=te*Le,be+=te*Be,Ee+=te*ze,ve+=te*Ue,we+=te*Ge,ge+=te*je,Se+=te*We,$e+=te*Ae,Pe+=te*De,Me+=te*Ie,xe+=te*ye,Fe+=te*Re,ke+=te*Ke,Te+=te*He,Ve+=te*qe,Ce+=te*Ye,te=E[14],be+=te*Le,Ee+=te*Be,ve+=te*ze,we+=te*Ue,ge+=te*Ge,Se+=te*je,$e+=te*We,Pe+=te*Ae,Me+=te*De,xe+=te*Ie,Fe+=te*ye,ke+=te*Re,Te+=te*Ke,Ve+=te*He,Ce+=te*qe,Ne+=te*Ye,te=E[15],Ee+=te*Le,ve+=te*Be,we+=te*ze,ge+=te*Ue,Se+=te*Ge,$e+=te*je,Pe+=te*We,Me+=te*Ae,xe+=te*De,Fe+=te*Ie,ke+=te*ye,Te+=te*Re,Ve+=te*Ke,Ce+=te*He,Ne+=te*qe,Oe+=te*Ye,ne+=38*ve,ie+=38*we,se+=38*ge,oe+=38*Se,ce+=38*$e,ae+=38*Pe,le+=38*Me,ue+=38*xe,he+=38*Fe,pe+=38*ke,de+=38*Te,fe+=38*Ve,me+=38*Ce,_e+=38*Ne,be+=38*Oe,re=1,te=ne+re+65535,re=Math.floor(te/65536),ne=te-re*65536,te=ie+re+65535,re=Math.floor(te/65536),ie=te-re*65536,te=se+re+65535,re=Math.floor(te/65536),se=te-re*65536,te=oe+re+65535,re=Math.floor(te/65536),oe=te-re*65536,te=ce+re+65535,re=Math.floor(te/65536),ce=te-re*65536,te=ae+re+65535,re=Math.floor(te/65536),ae=te-re*65536,te=le+re+65535,re=Math.floor(te/65536),le=te-re*65536,te=ue+re+65535,re=Math.floor(te/65536),ue=te-re*65536,te=he+re+65535,re=Math.floor(te/65536),he=te-re*65536,te=pe+re+65535,re=Math.floor(te/65536),pe=te-re*65536,te=de+re+65535,re=Math.floor(te/65536),de=te-re*65536,te=fe+re+65535,re=Math.floor(te/65536),fe=te-re*65536,te=me+re+65535,re=Math.floor(te/65536),me=te-re*65536,te=_e+re+65535,re=Math.floor(te/65536),_e=te-re*65536,te=be+re+65535,re=Math.floor(te/65536),be=te-re*65536,te=Ee+re+65535,re=Math.floor(te/65536),Ee=te-re*65536,ne+=re-1+37*(re-1),re=1,te=ne+re+65535,re=Math.floor(te/65536),ne=te-re*65536,te=ie+re+65535,re=Math.floor(te/65536),ie=te-re*65536,te=se+re+65535,re=Math.floor(te/65536),se=te-re*65536,te=oe+re+65535,re=Math.floor(te/65536),oe=te-re*65536,te=ce+re+65535,re=Math.floor(te/65536),ce=te-re*65536,te=ae+re+65535,re=Math.floor(te/65536),ae=te-re*65536,te=le+re+65535,re=Math.floor(te/65536),le=te-re*65536,te=ue+re+65535,re=Math.floor(te/65536),ue=te-re*65536,te=he+re+65535,re=Math.floor(te/65536),he=te-re*65536,te=pe+re+65535,re=Math.floor(te/65536),pe=te-re*65536,te=de+re+65535,re=Math.floor(te/65536),de=te-re*65536,te=fe+re+65535,re=Math.floor(te/65536),fe=te-re*65536,te=me+re+65535,re=Math.floor(te/65536),me=te-re*65536,te=_e+re+65535,re=Math.floor(te/65536),_e=te-re*65536,te=be+re+65535,re=Math.floor(te/65536),be=te-re*65536,te=Ee+re+65535,re=Math.floor(te/65536),Ee=te-re*65536,ne+=re-1+37*(re-1),J[0]=ne,J[1]=ie,J[2]=se,J[3]=oe,J[4]=ce,J[5]=ae,J[6]=le,J[7]=ue,J[8]=he,J[9]=pe,J[10]=de,J[11]=fe,J[12]=me,J[13]=_e,J[14]=be,J[15]=Ee}function square(J,E){mul(J,E,E)}function inv25519(J,E){const ee=gf();for(let te=0;te<16;te++)ee[te]=E[te];for(let te=253;te>=0;te--)square(ee,ee),te!==2&&te!==4&&mul(ee,ee,E);for(let te=0;te<16;te++)J[te]=ee[te]}function scalarMult(J,E){const ee=new Uint8Array(32),te=new Float64Array(80),re=gf(),ne=gf(),ie=gf(),se=gf(),oe=gf(),ce=gf();for(let he=0;he<31;he++)ee[he]=J[he];ee[31]=J[31]&127|64,ee[0]&=248,unpack25519(te,E);for(let he=0;he<16;he++)ne[he]=te[he];re[0]=se[0]=1;for(let he=254;he>=0;--he){const pe=ee[he>>>3]>>>(he&7)&1;sel25519(re,ne,pe),sel25519(ie,se,pe),add(oe,re,ie),sub(re,re,ie),add(ie,ne,se),sub(ne,ne,se),square(se,oe),square(ce,re),mul(re,ie,re),mul(ie,ne,oe),add(oe,re,ie),sub(re,re,ie),square(ne,re),sub(ie,se,ce),mul(re,ie,_121665),add(re,re,se),mul(ie,ie,re),mul(re,se,ce),mul(se,ne,te),square(ne,oe),sel25519(re,ne,pe),sel25519(ie,se,pe)}for(let he=0;he<16;he++)te[he+16]=re[he],te[he+32]=ie[he],te[he+48]=ne[he],te[he+64]=se[he];const ae=te.subarray(32),le=te.subarray(16);inv25519(ae,ae),mul(le,le,ae);const ue=new Uint8Array(32);return pack25519(ue,le),ue}function scalarMultBase(J){return scalarMult(J,_9)}async function generateKeyPair$4(){const J=new Uint8Array(32);return(await loadCrypto()).getRandomValues(J),{publicKey:scalarMultBase(J),secretKey:J}}function sharedKey(J,E,ee=!1){if(J.length!==PUBLIC_KEY_LENGTH)throw new Error("X25519: incorrect secret key length");if(E.length!==PUBLIC_KEY_LENGTH)throw new Error("X25519: incorrect public key length");const te=scalarMult(J,E);if(ee){let re=0;for(let ne=0;ne<te.length;ne++)re|=te[ne];if(re===0)throw new Error("X25519: invalid shared key")}return te}class XCryptoKey{constructor(E,ee,te){Object.defineProperty(this,"key",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"type",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"extractable",{enumerable:!0,configurable:!0,writable:!0,value:!0}),Object.defineProperty(this,"algorithm",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"usages",{enumerable:!0,configurable:!0,writable:!0,value:KEM_USAGES}),this.key=ee,this.type=te,this.algorithm={name:E}}}const ALG_NAME$1="X25519";class X25519{constructor(E){Object.defineProperty(this,"_hkdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nPk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nSk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._hkdf=E,this._nPk=32,this._nSk=32}async serializePublicKey(E){return await this._serializePublicKey(E)}async deserializePublicKey(E){return await this._deserializePublicKey(E)}async importKey(E,ee,te){if(E!=="raw")throw new Error("Unsupported format");return await this._importKey(ee,te)}async derivePublicKey(E){return await this._derivePublicKey(E)}async generateKeyPair(){const E=await generateKeyPair$4();return{publicKey:new XCryptoKey(ALG_NAME$1,E.publicKey,"public"),privateKey:new XCryptoKey(ALG_NAME$1,E.secretKey,"private")}}async deriveKeyPair(E){const ee=await this._hkdf.labeledExtract(EMPTY,LABEL_DKP_PRK,new Uint8Array(E)),te=await this._hkdf.labeledExpand(ee,LABEL_SK,EMPTY,this._nSk),re=new XCryptoKey(ALG_NAME$1,new Uint8Array(te),"private");return{privateKey:re,publicKey:await this.derivePublicKey(re)}}async dh(E,ee){return await this._dh(E,ee)}_serializePublicKey(E){return new Promise(ee=>{ee(E.key.buffer)})}_deserializePublicKey(E){return new Promise((ee,te)=>{E.byteLength!==this._nPk?te(new Error("Invalid public key for the ciphersuite")):ee(new XCryptoKey(ALG_NAME$1,new Uint8Array(E),"public"))})}_importKey(E,ee){return new Promise((te,re)=>{ee&&E.byteLength!==this._nPk&&re(new Error("Invalid public key for the ciphersuite")),!ee&&E.byteLength!==this._nSk&&re(new Error("Invalid private key for the ciphersuite")),te(new XCryptoKey(ALG_NAME$1,new Uint8Array(E),ee?"public":"private"))})}_derivePublicKey(E){return new Promise(ee=>{ee(new XCryptoKey(ALG_NAME$1,scalarMultBase(E.key),"public"))})}_dh(E,ee){return new Promise((te,re)=>{try{te(sharedKey(E.key,ee.key,!0))}catch(ne){re(ne)}})}}let dbits$1;const canary=0xdeadbeefcafe,j_lm=(canary&16777215)==15715070;function BigInteger$3(J,E,ee){J!=null&&(typeof J=="number"?this.fromNumber(J,E,ee):E==null&&typeof J!="string"?this.fromString(J,256):this.fromString(J,E))}function nbi$1(){return new BigInteger$3(null)}function am1$1(J,E,ee,te,re,ne){for(;--ne>=0;){const ie=E*this[J++]+ee[te]+re;re=Math.floor(ie/67108864),ee[te++]=ie&67108863}return re}function am2$1(J,E,ee,te,re,ne){const ie=E&32767,se=E>>15;for(;--ne>=0;){let oe=this[J]&32767;const ce=this[J++]>>15,ae=se*oe+ce*ie;oe=ie*oe+((ae&32767)<<15)+ee[te]+(re&1073741823),re=(oe>>>30)+(ae>>>15)+se*ce+(re>>>30),ee[te++]=oe&1073741823}return re}function am3$1(J,E,ee,te,re,ne){const ie=E&16383,se=E>>14;for(;--ne>=0;){let oe=this[J]&16383;const ce=this[J++]>>14,ae=se*oe+ce*ie;oe=ie*oe+((ae&16383)<<14)+ee[te]+re,re=(oe>>28)+(ae>>14)+se*ce,ee[te++]=oe&268435455}return re}const inBrowser=typeof navigator<"u";inBrowser&&j_lm&&navigator.appName=="Microsoft Internet Explorer"?(BigInteger$3.prototype.am=am2$1,dbits$1=30):inBrowser&&j_lm&&navigator.appName!="Netscape"?(BigInteger$3.prototype.am=am1$1,dbits$1=26):(BigInteger$3.prototype.am=am3$1,dbits$1=28);BigInteger$3.prototype.DB=dbits$1;BigInteger$3.prototype.DM=(1<<dbits$1)-1;BigInteger$3.prototype.DV=1<<dbits$1;const BI_FP$1=52;BigInteger$3.prototype.FV=Math.pow(2,BI_FP$1);BigInteger$3.prototype.F1=BI_FP$1-dbits$1;BigInteger$3.prototype.F2=2*dbits$1-BI_FP$1;const BI_RM$1="0123456789abcdefghijklmnopqrstuvwxyz",BI_RC$1=new Array;let rr$1,vv$1;rr$1="0".charCodeAt(0);for(vv$1=0;vv$1<=9;++vv$1)BI_RC$1[rr$1++]=vv$1;rr$1="a".charCodeAt(0);for(vv$1=10;vv$1<36;++vv$1)BI_RC$1[rr$1++]=vv$1;rr$1="A".charCodeAt(0);for(vv$1=10;vv$1<36;++vv$1)BI_RC$1[rr$1++]=vv$1;function int2char$1(J){return BI_RM$1.charAt(J)}function intAt$1(J,E){return BI_RC$1[J.charCodeAt(E)]??-1}function bnpCopyTo$1(J){for(let E=this.t-1;E>=0;--E)J[E]=this[E];J.t=this.t,J.s=this.s}function bnpFromInt$1(J){this.t=1,this.s=J<0?-1:0,J>0?this[0]=J:J<-1?this[0]=J+this.DV:this.t=0}function nbv$1(J){const E=nbi$1();return E.fromInt(J),E}function bnpFromString$1(J,E){if(!E&&J.length>=2&&J[0]==="0"){let ie=!0;switch(J[1]){case"x":E=16;break;case"b":E=2;break;case"o":E=8;break;default:ie=!1}ie&&(J=J.substr(2))}let ee;if(E==16)ee=4;else if(E==8)ee=3;else if(E==256)ee=8;else if(E==2)ee=1;else if(E==32)ee=5;else if(E==4)ee=2;else{this.fromRadix(J,E);return}this.t=0,this.s=0;let te=J.length,re=!1,ne=0;for(;--te>=0;){const ie=ee==8?J[te]&255:intAt$1(J,te);if(ie<0){J.charAt(te)=="-"&&(re=!0);continue}re=!1,ne==0?this[this.t++]=ie:ne+ee>this.DB?(this[this.t-1]|=(ie&(1<<this.DB-ne)-1)<<ne,this[this.t++]=ie>>this.DB-ne):this[this.t-1]|=ie<<ne,ne+=ee,ne>=this.DB&&(ne-=this.DB)}ee==8&&J[0]&128&&(this.s=-1,ne>0&&(this[this.t-1]|=(1<<this.DB-ne)-1<<ne)),this.clamp(),re&&BigInteger$3.ZERO.subTo(this,this)}function bnpClamp$1(){const J=this.s&this.DM;for(;this.t>0&&this[this.t-1]==J;)--this.t}function bnToString$1(J){if(this.s<0)return"-"+this.negate().toString(J);let E;if(J==16)E=4;else if(J==8)E=3;else if(J==2)E=1;else if(J==32)E=5;else if(J==4)E=2;else return this.toRadix(J);let ee=(1<<E)-1,te,re=!1,ne="",ie=this.t,se=this.DB-ie*this.DB%E;if(ie-- >0)for(se<this.DB&&(te=this[ie]>>se)>0&&(re=!0,ne=int2char$1(te));ie>=0;)se<E?(te=(this[ie]&(1<<se)-1)<<E-se,te|=this[--ie]>>(se+=this.DB-E)):(te=this[ie]>>(se-=E)&ee,se<=0&&(se+=this.DB,--ie)),te>0&&(re=!0),re&&(ne+=int2char$1(te));return re?ne:"0"}function bnNegate$1(){const J=nbi$1();return BigInteger$3.ZERO.subTo(this,J),J}function bnAbs$1(){return this.s<0?this.negate():this}function bnCompareTo$1(J){let E=this.s-J.s;if(E!=0)return E;let ee=this.t;if(E=ee-J.t,E!=0)return this.s<0?-E:E;for(;--ee>=0;)if((E=this[ee]-J[ee])!=0)return E;return 0}function nbits$1(J){let E=1,ee;return(ee=J>>>16)!=0&&(J=ee,E+=16),(ee=J>>8)!=0&&(J=ee,E+=8),(ee=J>>4)!=0&&(J=ee,E+=4),(ee=J>>2)!=0&&(J=ee,E+=2),(ee=J>>1)!=0&&(J=ee,E+=1),E}function bnBitLength$1(){return this.t<=0?0:this.DB*(this.t-1)+nbits$1(this[this.t-1]^this.s&this.DM)}function bnpDLShiftTo$1(J,E){let ee;for(ee=this.t-1;ee>=0;--ee)E[ee+J]=this[ee];for(ee=J-1;ee>=0;--ee)E[ee]=0;E.t=this.t+J,E.s=this.s}function bnpDRShiftTo$1(J,E){for(let ee=J;ee<this.t;++ee)E[ee-J]=this[ee];E.t=Math.max(this.t-J,0),E.s=this.s}function bnpLShiftTo$1(J,E){const ee=J%this.DB,te=this.DB-ee,re=(1<<te)-1;let ne=Math.floor(J/this.DB),ie=this.s<<ee&this.DM,se;for(se=this.t-1;se>=0;--se)E[se+ne+1]=this[se]>>te|ie,ie=(this[se]&re)<<ee;for(se=ne-1;se>=0;--se)E[se]=0;E[ne]=ie,E.t=this.t+ne+1,E.s=this.s,E.clamp()}function bnpRShiftTo$1(J,E){E.s=this.s;const ee=Math.floor(J/this.DB);if(ee>=this.t){E.t=0;return}const te=J%this.DB,re=this.DB-te,ne=(1<<te)-1;E[0]=this[ee]>>te;for(let ie=ee+1;ie<this.t;++ie)E[ie-ee-1]|=(this[ie]&ne)<<re,E[ie-ee]=this[ie]>>te;te>0&&(E[this.t-ee-1]|=(this.s&ne)<<re),E.t=this.t-ee,E.clamp()}function bnpSubTo$1(J,E){let ee=0,te=0,re=Math.min(J.t,this.t);for(;ee<re;)te+=this[ee]-J[ee],E[ee++]=te&this.DM,te>>=this.DB;if(J.t<this.t){for(te-=J.s;ee<this.t;)te+=this[ee],E[ee++]=te&this.DM,te>>=this.DB;te+=this.s}else{for(te+=this.s;ee<J.t;)te-=J[ee],E[ee++]=te&this.DM,te>>=this.DB;te-=J.s}E.s=te<0?-1:0,te<-1?E[ee++]=this.DV+te:te>0&&(E[ee++]=te),E.t=ee,E.clamp()}function bnpMultiplyTo$1(J,E){const ee=this.abs(),te=J.abs();let re=ee.t;for(E.t=re+te.t;--re>=0;)E[re]=0;for(re=0;re<te.t;++re)E[re+ee.t]=ee.am(0,te[re],E,re,0,ee.t);E.s=0,E.clamp(),this.s!=J.s&&BigInteger$3.ZERO.subTo(E,E)}function bnpSquareTo$1(J){const E=this.abs();let ee=J.t=2*E.t;for(;--ee>=0;)J[ee]=0;for(ee=0;ee<E.t-1;++ee){const te=E.am(ee,E[ee],J,2*ee,0,1);(J[ee+E.t]+=E.am(ee+1,2*E[ee],J,2*ee+1,te,E.t-ee-1))>=E.DV&&(J[ee+E.t]-=E.DV,J[ee+E.t+1]=1)}J.t>0&&(J[J.t-1]+=E.am(ee,E[ee],J,2*ee,0,1)),J.s=0,J.clamp()}function bnpDivRemTo$1(J,E,ee){const te=J.abs();if(te.t<=0)return;const re=this.abs();if(re.t<te.t){E?.fromInt(0),ee!=null&&this.copyTo(ee);return}ee==null&&(ee=nbi$1());const ne=nbi$1(),ie=this.s,se=J.s,oe=this.DB-nbits$1(te[te.t-1]);oe>0?(te.lShiftTo(oe,ne),re.lShiftTo(oe,ee)):(te.copyTo(ne),re.copyTo(ee));const ce=ne.t,ae=ne[ce-1];if(ae==0)return;const le=ae*(1<<this.F1)+(ce>1?ne[ce-2]>>this.F2:0),ue=this.FV/le,he=(1<<this.F1)/le,pe=1<<this.F2;let de=ee.t,fe=de-ce,me=E??nbi$1();for(ne.dlShiftTo(fe,me),ee.compareTo(me)>=0&&(ee[ee.t++]=1,ee.subTo(me,ee)),BigInteger$3.ONE.dlShiftTo(ce,me),me.subTo(ne,ne);ne.t<ce;)ne[ne.t++]=0;for(;--fe>=0;){let _e=ee[--de]==ae?this.DM:Math.floor(ee[de]*ue+(ee[de-1]+pe)*he);if((ee[de]+=ne.am(0,_e,ee,fe,0,ce))<_e)for(ne.dlShiftTo(fe,me),ee.subTo(me,ee);ee[de]<--_e;)ee.subTo(me,ee)}E!=null&&(ee.drShiftTo(ce,E),ie!=se&&BigInteger$3.ZERO.subTo(E,E)),ee.t=ce,ee.clamp(),oe>0&&ee.rShiftTo(oe,ee),ie<0&&BigInteger$3.ZERO.subTo(ee,ee)}function bnMod$1(J){const E=nbi$1();return this.abs().divRemTo(J,null,E),this.s<0&&E.compareTo(BigInteger$3.ZERO)>0&&J.subTo(E,E),E}function Classic$1(J){this.m=J}function cConvert$1(J){return J.s<0||J.compareTo(this.m)>=0?J.mod(this.m):J}function cRevert$1(J){return J}function cReduce$1(J){J.divRemTo(this.m,null,J)}function cMulTo$1(J,E,ee){J.multiplyTo(E,ee),this.reduce(ee)}function cSqrTo$1(J,E){J.squareTo(E),this.reduce(E)}Classic$1.prototype.convert=cConvert$1;Classic$1.prototype.revert=cRevert$1;Classic$1.prototype.reduce=cReduce$1;Classic$1.prototype.mulTo=cMulTo$1;Classic$1.prototype.sqrTo=cSqrTo$1;function bnpInvDigit$1(){if(this.t<1)return 0;const J=this[0];if(!(J&1))return 0;let E=J&3;return E=E*(2-(J&15)*E)&15,E=E*(2-(J&255)*E)&255,E=E*(2-((J&65535)*E&65535))&65535,E=E*(2-J*E%this.DV)%this.DV,E>0?this.DV-E:-E}function Montgomery$1(J){this.m=J,this.mp=J.invDigit(),this.mpl=this.mp&32767,this.mph=this.mp>>15,this.um=(1<<J.DB-15)-1,this.mt2=2*J.t}function montConvert$1(J){const E=nbi$1();return J.abs().dlShiftTo(this.m.t,E),E.divRemTo(this.m,null,E),J.s<0&&E.compareTo(BigInteger$3.ZERO)>0&&this.m.subTo(E,E),E}function montRevert$1(J){const E=nbi$1();return J.copyTo(E),this.reduce(E),E}function montReduce$1(J){for(;J.t<=this.mt2;)J[J.t++]=0;for(let E=0;E<this.m.t;++E){let ee=J[E]&32767;const te=ee*this.mpl+((ee*this.mph+(J[E]>>15)*this.mpl&this.um)<<15)&J.DM;for(ee=E+this.m.t,J[ee]+=this.m.am(0,te,J,E,0,this.m.t);J[ee]>=J.DV;)J[ee]-=J.DV,J[++ee]++}J.clamp(),J.drShiftTo(this.m.t,J),J.compareTo(this.m)>=0&&J.subTo(this.m,J)}function montSqrTo$1(J,E){J.squareTo(E),this.reduce(E)}function montMulTo$1(J,E,ee){J.multiplyTo(E,ee),this.reduce(ee)}Montgomery$1.prototype.convert=montConvert$1;Montgomery$1.prototype.revert=montRevert$1;Montgomery$1.prototype.reduce=montReduce$1;Montgomery$1.prototype.mulTo=montMulTo$1;Montgomery$1.prototype.sqrTo=montSqrTo$1;function bnpIsEven$1(){return(this.t>0?this[0]&1:this.s)==0}function bnpExp$1(J,E){if(J>4294967295||J<1)return BigInteger$3.ONE;let ee=nbi$1(),te=nbi$1(),re=E.convert(this),ne=nbits$1(J)-1;for(re.copyTo(ee);--ne>=0;)if(E.sqrTo(ee,te),(J&1<<ne)>0)E.mulTo(te,re,ee);else{const ie=ee;ee=te,te=ie}return E.revert(ee)}function bnModPowInt$1(J,E){let ee;return J<256||E.isEven()?ee=new Classic$1(E):ee=new Montgomery$1(E),this.exp(J,ee)}BigInteger$3.prototype.copyTo=bnpCopyTo$1;BigInteger$3.prototype.fromInt=bnpFromInt$1;BigInteger$3.prototype.fromString=bnpFromString$1;BigInteger$3.prototype.clamp=bnpClamp$1;BigInteger$3.prototype.dlShiftTo=bnpDLShiftTo$1;BigInteger$3.prototype.drShiftTo=bnpDRShiftTo$1;BigInteger$3.prototype.lShiftTo=bnpLShiftTo$1;BigInteger$3.prototype.rShiftTo=bnpRShiftTo$1;BigInteger$3.prototype.subTo=bnpSubTo$1;BigInteger$3.prototype.multiplyTo=bnpMultiplyTo$1;BigInteger$3.prototype.squareTo=bnpSquareTo$1;BigInteger$3.prototype.divRemTo=bnpDivRemTo$1;BigInteger$3.prototype.invDigit=bnpInvDigit$1;BigInteger$3.prototype.isEven=bnpIsEven$1;BigInteger$3.prototype.exp=bnpExp$1;BigInteger$3.prototype.toString=bnToString$1;BigInteger$3.prototype.negate=bnNegate$1;BigInteger$3.prototype.abs=bnAbs$1;BigInteger$3.prototype.compareTo=bnCompareTo$1;BigInteger$3.prototype.bitLength=bnBitLength$1;BigInteger$3.prototype.mod=bnMod$1;BigInteger$3.prototype.modPowInt=bnModPowInt$1;BigInteger$3.ZERO=nbv$1(0);BigInteger$3.ONE=nbv$1(1);function bnClone$1(){const J=nbi$1();return this.copyTo(J),J}function bnIntValue$1(){if(this.s<0){if(this.t==1)return this[0]-this.DV;if(this.t==0)return-1}else{if(this.t==1)return this[0];if(this.t==0)return 0}return(this[1]&(1<<32-this.DB)-1)<<this.DB|this[0]}function bnByteValue$1(){return this.t==0?this.s:this[0]<<24>>24}function bnShortValue$1(){return this.t==0?this.s:this[0]<<16>>16}function bnpChunkSize$1(J){return Math.floor(Math.LN2*this.DB/Math.log(J))}function bnSigNum$1(){return this.s<0?-1:this.t<=0||this.t==1&&this[0]<=0?0:1}function bnpToRadix$1(J){if(J==null&&(J=10),this.signum()==0||J<2||J>36)return"0";const E=this.chunkSize(J),ee=Math.pow(J,E);let te=nbv$1(ee),re=nbi$1(),ne=nbi$1(),ie="";for(this.divRemTo(te,re,ne);re.signum()>0;)ie=(ee+ne.intValue()).toString(J).substr(1)+ie,re.divRemTo(te,re,ne);return ne.intValue().toString(J)+ie}function bnpFromRadix$1(J,E){this.fromInt(0),E==null&&(E=10);const ee=this.chunkSize(E);let te=Math.pow(E,ee),re=!1,ne=0,ie=0;for(let se=0;se<J.length;++se){const oe=intAt$1(J,se);if(oe<0){J.charAt(se)=="-"&&this.signum()==0&&(re=!0);continue}ie=E*ie+oe,++ne>=ee&&(this.dMultiply(te),this.dAddOffset(ie,0),ne=0,ie=0)}ne>0&&(this.dMultiply(Math.pow(E,ne)),this.dAddOffset(ie,0)),re&&BigInteger$3.ZERO.subTo(this,this)}function bnpFromNumber$1(J,E,ee){if(typeof E=="number")if(J<2)this.fromInt(1);else for(this.fromNumber(J,ee),this.testBit(J-1)||this.bitwiseTo(BigInteger$3.ONE.shiftLeft(J-1),op_or$1,this),this.isEven()&&this.dAddOffset(1,0);!this.isProbablePrime(E);)this.dAddOffset(2,0),this.bitLength()>J&&this.subTo(BigInteger$3.ONE.shiftLeft(J-1),this);else{const te=new Array,re=J&7;te.length=(J>>3)+1,E.nextBytes(te),re>0?te[0]&=(1<<re)-1:te[0]=0,this.fromString(te,256)}}function bnToByteArray$1(){let J=this.t,E=new Array;E[0]=this.s;let ee=this.DB-J*this.DB%8,te,re=0;if(J-- >0)for(ee<this.DB&&(te=this[J]>>ee)!=(this.s&this.DM)>>ee&&(E[re++]=te|this.s<<this.DB-ee);J>=0;)ee<8?(te=(this[J]&(1<<ee)-1)<<8-ee,te|=this[--J]>>(ee+=this.DB-8)):(te=this[J]>>(ee-=8)&255,ee<=0&&(ee+=this.DB,--J)),te&128&&(te|=-256),re==0&&(this.s&128)!=(te&128)&&++re,(re>0||te!=this.s)&&(E[re++]=te);return E}function bnEquals$1(J){return this.compareTo(J)==0}function bnMin$1(J){return this.compareTo(J)<0?this:J}function bnMax$1(J){return this.compareTo(J)>0?this:J}function bnpBitwiseTo$1(J,E,ee){let te,re,ne=Math.min(J.t,this.t);for(te=0;te<ne;++te)ee[te]=E(this[te],J[te]);if(J.t<this.t){for(re=J.s&this.DM,te=ne;te<this.t;++te)ee[te]=E(this[te],re);ee.t=this.t}else{for(re=this.s&this.DM,te=ne;te<J.t;++te)ee[te]=E(re,J[te]);ee.t=J.t}ee.s=E(this.s,J.s),ee.clamp()}function op_and$1(J,E){return J&E}function bnAnd$1(J){let E=nbi$1();return this.bitwiseTo(J,op_and$1,E),E}function op_or$1(J,E){return J|E}function bnOr$1(J){let E=nbi$1();return this.bitwiseTo(J,op_or$1,E),E}function op_xor$1(J,E){return J^E}function bnXor$1(J){let E=nbi$1();return this.bitwiseTo(J,op_xor$1,E),E}function op_andnot$1(J,E){return J&~E}function bnAndNot$1(J){let E=nbi$1();return this.bitwiseTo(J,op_andnot$1,E),E}function bnNot$1(){let J=nbi$1();for(let E=0;E<this.t;++E)J[E]=this.DM&~this[E];return J.t=this.t,J.s=~this.s,J}function bnShiftLeft$1(J){let E=nbi$1();return J<0?this.rShiftTo(-J,E):this.lShiftTo(J,E),E}function bnShiftRight$1(J){let E=nbi$1();return J<0?this.lShiftTo(-J,E):this.rShiftTo(J,E),E}function lbit$1(J){if(J==0)return-1;let E=0;return J&65535||(J>>=16,E+=16),J&255||(J>>=8,E+=8),J&15||(J>>=4,E+=4),J&3||(J>>=2,E+=2),J&1||++E,E}function bnGetLowestSetBit$1(){for(let J=0;J<this.t;++J)if(this[J]!=0)return J*this.DB+lbit$1(this[J]);return this.s<0?this.t*this.DB:-1}function cbit$1(J){let E=0;for(;J!=0;)J&=J-1,++E;return E}function bnBitCount$1(){let J=0,E=this.s&this.DM;for(let ee=0;ee<this.t;++ee)J+=cbit$1(this[ee]^E);return J}function bnTestBit$1(J){let E=Math.floor(J/this.DB);return E>=this.t?this.s!=0:(this[E]&1<<J%this.DB)!=0}function bnpChangeBit$1(J,E){let ee=BigInteger$3.ONE.shiftLeft(J);return this.bitwiseTo(ee,E,ee),ee}function bnSetBit$1(J){return this.changeBit(J,op_or$1)}function bnClearBit$1(J){return this.changeBit(J,op_andnot$1)}function bnFlipBit$1(J){return this.changeBit(J,op_xor$1)}function bnpAddTo$1(J,E){let ee=0,te=0,re=Math.min(J.t,this.t);for(;ee<re;)te+=this[ee]+J[ee],E[ee++]=te&this.DM,te>>=this.DB;if(J.t<this.t){for(te+=J.s;ee<this.t;)te+=this[ee],E[ee++]=te&this.DM,te>>=this.DB;te+=this.s}else{for(te+=this.s;ee<J.t;)te+=J[ee],E[ee++]=te&this.DM,te>>=this.DB;te+=J.s}E.s=te<0?-1:0,te>0?E[ee++]=te:te<-1&&(E[ee++]=this.DV+te),E.t=ee,E.clamp()}function bnAdd$1(J){let E=nbi$1();return this.addTo(J,E),E}function bnSubtract$1(J){let E=nbi$1();return this.subTo(J,E),E}function bnMultiply$1(J){let E=nbi$1();return this.multiplyTo(J,E),E}function bnSquare(){let J=nbi$1();return this.squareTo(J),J}function bnDivide$1(J){let E=nbi$1();return this.divRemTo(J,E,null),E}function bnRemainder$1(J){let E=nbi$1();return this.divRemTo(J,null,E),E}function bnDivideAndRemainder$1(J){let E=nbi$1(),ee=nbi$1();return this.divRemTo(J,E,ee),new Array(E,ee)}function bnpDMultiply$1(J){this[this.t]=this.am(0,J-1,this,0,0,this.t),++this.t,this.clamp()}function bnpDAddOffset$1(J,E){if(J!=0){for(;this.t<=E;)this[this.t++]=0;for(this[E]+=J;this[E]>=this.DV;)this[E]-=this.DV,++E>=this.t&&(this[this.t++]=0),++this[E]}}function NullExp$1(){}function nNop$1(J){return J}function nMulTo$1(J,E,ee){J.multiplyTo(E,ee)}function nSqrTo$1(J,E){J.squareTo(E)}NullExp$1.prototype.convert=nNop$1;NullExp$1.prototype.revert=nNop$1;NullExp$1.prototype.mulTo=nMulTo$1;NullExp$1.prototype.sqrTo=nSqrTo$1;function bnPow$1(J){return this.exp(J,new NullExp$1)}function bnpMultiplyLowerTo$1(J,E,ee){let te=Math.min(this.t+J.t,E);for(ee.s=0,ee.t=te;te>0;)ee[--te]=0;let re;for(re=ee.t-this.t;te<re;++te)ee[te+this.t]=this.am(0,J[te],ee,te,0,this.t);for(re=Math.min(J.t,E);te<re;++te)this.am(0,J[te],ee,te,0,E-te);ee.clamp()}function bnpMultiplyUpperTo$1(J,E,ee){--E;let te=ee.t=this.t+J.t-E;for(ee.s=0;--te>=0;)ee[te]=0;for(te=Math.max(E-this.t,0);te<J.t;++te)ee[this.t+te-E]=this.am(E-te,J[te],ee,0,0,this.t+te-E);ee.clamp(),ee.drShiftTo(1,ee)}function Barrett$1(J){this.r2=nbi$1(),this.q3=nbi$1(),BigInteger$3.ONE.dlShiftTo(2*J.t,this.r2),this.mu=this.r2.divide(J),this.m=J}function barrettConvert$1(J){if(J.s<0||J.t>2*this.m.t)return J.mod(this.m);if(J.compareTo(this.m)<0)return J;{let E=nbi$1();return J.copyTo(E),this.reduce(E),E}}function barrettRevert$1(J){return J}function barrettReduce$1(J){for(J.drShiftTo(this.m.t-1,this.r2),J.t>this.m.t+1&&(J.t=this.m.t+1,J.clamp()),this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3),this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);J.compareTo(this.r2)<0;)J.dAddOffset(1,this.m.t+1);for(J.subTo(this.r2,J);J.compareTo(this.m)>=0;)J.subTo(this.m,J)}function barrettSqrTo$1(J,E){J.squareTo(E),this.reduce(E)}function barrettMulTo$1(J,E,ee){J.multiplyTo(E,ee),this.reduce(ee)}Barrett$1.prototype.convert=barrettConvert$1;Barrett$1.prototype.revert=barrettRevert$1;Barrett$1.prototype.reduce=barrettReduce$1;Barrett$1.prototype.mulTo=barrettMulTo$1;Barrett$1.prototype.sqrTo=barrettSqrTo$1;function bnModPow$1(J,E){let ee=J.bitLength(),te,re=nbv$1(1),ne;if(ee<=0)return re;ee<18?te=1:ee<48?te=3:ee<144?te=4:ee<768?te=5:te=6,ee<8?ne=new Classic$1(E):E.isEven()?ne=new Barrett$1(E):ne=new Montgomery$1(E);let ie=new Array,se=3,oe=te-1,ce=(1<<te)-1;if(ie[1]=ne.convert(this),te>1){let de=nbi$1();for(ne.sqrTo(ie[1],de);se<=ce;)ie[se]=nbi$1(),ne.mulTo(de,ie[se-2],ie[se]),se+=2}let ae=J.t-1,le,ue=!0,he=nbi$1(),pe;for(ee=nbits$1(J[ae])-1;ae>=0;){for(ee>=oe?le=J[ae]>>ee-oe&ce:(le=(J[ae]&(1<<ee+1)-1)<<oe-ee,ae>0&&(le|=J[ae-1]>>this.DB+ee-oe)),se=te;!(le&1);)le>>=1,--se;if((ee-=se)<0&&(ee+=this.DB,--ae),ue)ie[le].copyTo(re),ue=!1;else{for(;se>1;)ne.sqrTo(re,he),ne.sqrTo(he,re),se-=2;se>0?ne.sqrTo(re,he):(pe=re,re=he,he=pe),ne.mulTo(he,ie[le],re)}for(;ae>=0&&!(J[ae]&1<<ee);)ne.sqrTo(re,he),pe=re,re=he,he=pe,--ee<0&&(ee=this.DB-1,--ae)}return ne.revert(re)}function bnGCD$1(J){let E=this.s<0?this.negate():this.clone(),ee=J.s<0?J.negate():J.clone();if(E.compareTo(ee)<0){let ne=E;E=ee,ee=ne}let te=E.getLowestSetBit(),re=ee.getLowestSetBit();if(re<0)return E;for(te<re&&(re=te),re>0&&(E.rShiftTo(re,E),ee.rShiftTo(re,ee));E.signum()>0;)(te=E.getLowestSetBit())>0&&E.rShiftTo(te,E),(te=ee.getLowestSetBit())>0&&ee.rShiftTo(te,ee),E.compareTo(ee)>=0?(E.subTo(ee,E),E.rShiftTo(1,E)):(ee.subTo(E,ee),ee.rShiftTo(1,ee));return re>0&&ee.lShiftTo(re,ee),ee}function bnpModInt$1(J){if(J<=0)return 0;let E=this.DV%J,ee=this.s<0?J-1:0;if(this.t>0)if(E==0)ee=this[0]%J;else for(let te=this.t-1;te>=0;--te)ee=(E*ee+this[te])%J;return ee}function bnModInverse$1(J){let E=J.isEven();if(this.isEven()&&E||J.signum()==0)return BigInteger$3.ZERO;let ee=J.clone(),te=this.clone(),re=nbv$1(1),ne=nbv$1(0),ie=nbv$1(0),se=nbv$1(1);for(;ee.signum()!=0;){for(;ee.isEven();)ee.rShiftTo(1,ee),E?((!re.isEven()||!ne.isEven())&&(re.addTo(this,re),ne.subTo(J,ne)),re.rShiftTo(1,re)):ne.isEven()||ne.subTo(J,ne),ne.rShiftTo(1,ne);for(;te.isEven();)te.rShiftTo(1,te),E?((!ie.isEven()||!se.isEven())&&(ie.addTo(this,ie),se.subTo(J,se)),ie.rShiftTo(1,ie)):se.isEven()||se.subTo(J,se),se.rShiftTo(1,se);ee.compareTo(te)>=0?(ee.subTo(te,ee),E&&re.subTo(ie,re),ne.subTo(se,ne)):(te.subTo(ee,te),E&&ie.subTo(re,ie),se.subTo(ne,se))}if(te.compareTo(BigInteger$3.ONE)!=0)return BigInteger$3.ZERO;if(se.compareTo(J)>=0)return se.subtract(J);if(se.signum()<0)se.addTo(J,se);else return se;return se.signum()<0?se.add(J):se}let lowprimes$1=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997],lplim$1=(1<<26)/lowprimes$1[lowprimes$1.length-1];function bnIsProbablePrime$1(J){let E,ee=this.abs();if(ee.t==1&&ee[0]<=lowprimes$1[lowprimes$1.length-1]){for(E=0;E<lowprimes$1.length;++E)if(ee[0]==lowprimes$1[E])return!0;return!1}if(ee.isEven())return!1;for(E=1;E<lowprimes$1.length;){let te=lowprimes$1[E],re=E+1;for(;re<lowprimes$1.length&&te<lplim$1;)te*=lowprimes$1[re++];for(te=ee.modInt(te);E<re;)if(te%lowprimes$1[E++]==0)return!1}return ee.millerRabin(J)}function bnpMillerRabin$1(J){let E=this.subtract(BigInteger$3.ONE),ee=E.getLowestSetBit();if(ee<=0)return!1;let te=E.shiftRight(ee);J=J+1>>1,J>lowprimes$1.length&&(J=lowprimes$1.length);let re=nbi$1();for(let ne=0;ne<J;++ne){re.fromInt(lowprimes$1[Math.floor(Math.random()*lowprimes$1.length)]);let ie=re.modPow(te,this);if(ie.compareTo(BigInteger$3.ONE)!=0&&ie.compareTo(E)!=0){let se=1;for(;se++<ee&&ie.compareTo(E)!=0;)if(ie=ie.modPowInt(2,this),ie.compareTo(BigInteger$3.ONE)==0)return!1;if(ie.compareTo(E)!=0)return!1}}return!0}BigInteger$3.prototype.chunkSize=bnpChunkSize$1;BigInteger$3.prototype.toRadix=bnpToRadix$1;BigInteger$3.prototype.fromRadix=bnpFromRadix$1;BigInteger$3.prototype.fromNumber=bnpFromNumber$1;BigInteger$3.prototype.bitwiseTo=bnpBitwiseTo$1;BigInteger$3.prototype.changeBit=bnpChangeBit$1;BigInteger$3.prototype.addTo=bnpAddTo$1;BigInteger$3.prototype.dMultiply=bnpDMultiply$1;BigInteger$3.prototype.dAddOffset=bnpDAddOffset$1;BigInteger$3.prototype.multiplyLowerTo=bnpMultiplyLowerTo$1;BigInteger$3.prototype.multiplyUpperTo=bnpMultiplyUpperTo$1;BigInteger$3.prototype.modInt=bnpModInt$1;BigInteger$3.prototype.millerRabin=bnpMillerRabin$1;BigInteger$3.prototype.clone=bnClone$1;BigInteger$3.prototype.intValue=bnIntValue$1;BigInteger$3.prototype.byteValue=bnByteValue$1;BigInteger$3.prototype.shortValue=bnShortValue$1;BigInteger$3.prototype.signum=bnSigNum$1;BigInteger$3.prototype.toByteArray=bnToByteArray$1;BigInteger$3.prototype.equals=bnEquals$1;BigInteger$3.prototype.min=bnMin$1;BigInteger$3.prototype.max=bnMax$1;BigInteger$3.prototype.and=bnAnd$1;BigInteger$3.prototype.or=bnOr$1;BigInteger$3.prototype.xor=bnXor$1;BigInteger$3.prototype.andNot=bnAndNot$1;BigInteger$3.prototype.not=bnNot$1;BigInteger$3.prototype.shiftLeft=bnShiftLeft$1;BigInteger$3.prototype.shiftRight=bnShiftRight$1;BigInteger$3.prototype.getLowestSetBit=bnGetLowestSetBit$1;BigInteger$3.prototype.bitCount=bnBitCount$1;BigInteger$3.prototype.testBit=bnTestBit$1;BigInteger$3.prototype.setBit=bnSetBit$1;BigInteger$3.prototype.clearBit=bnClearBit$1;BigInteger$3.prototype.flipBit=bnFlipBit$1;BigInteger$3.prototype.add=bnAdd$1;BigInteger$3.prototype.subtract=bnSubtract$1;BigInteger$3.prototype.multiply=bnMultiply$1;BigInteger$3.prototype.divide=bnDivide$1;BigInteger$3.prototype.remainder=bnRemainder$1;BigInteger$3.prototype.divideAndRemainder=bnDivideAndRemainder$1;BigInteger$3.prototype.modPow=bnModPow$1;BigInteger$3.prototype.modInverse=bnModInverse$1;BigInteger$3.prototype.pow=bnPow$1;BigInteger$3.prototype.gcd=bnGCD$1;BigInteger$3.prototype.isProbablePrime=bnIsProbablePrime$1;BigInteger$3.prototype.square=bnSquare;BigInteger$3.prototype.Barrett=Barrett$1;let rng_psize=256,rng_pool,rng_pptr;function rng_seed_int(J){rng_pool[rng_pptr++]^=J&255,rng_pool[rng_pptr++]^=J>>8&255,rng_pool[rng_pptr++]^=J>>16&255,rng_pool[rng_pptr++]^=J>>24&255,rng_pptr>=rng_psize&&(rng_pptr-=rng_psize)}function rng_seed_time(){rng_seed_int(new Date().getTime())}if(rng_pool==null){rng_pool=new Array,rng_pptr=0;let J;if(typeof dntGlobalThis<"u"&&globalThis.crypto){if(globalThis.crypto.getRandomValues){let E=new Uint8Array(32);for(globalThis.crypto.getRandomValues(E),J=0;J<32;++J)rng_pool[rng_pptr++]=E[J]}else if(navigator.appName=="Netscape"&&navigator.appVersion<"5"){let E=globalThis.crypto.random(32);for(J=0;J<E.length;++J)rng_pool[rng_pptr++]=E.charCodeAt(J)&255}}for(;rng_pptr<rng_psize;)J=Math.floor(65536*Math.random()),rng_pool[rng_pptr++]=J>>>8,rng_pool[rng_pptr++]=J&255;rng_pptr=0,rng_seed_time()}function fromNumber(J){return new BigInteger$3(J.toString(10))}const N0=BigInteger$3.ZERO,N1$4=BigInteger$3.ONE,N2$4=fromNumber(2),N3$4=fromNumber(3),N5$4=fromNumber(5),N128=fromNumber(128),N255=fromNumber(255);function sqr(J){return J.multiply(J)}const P=new BigInteger$3("726838724295606890549323807888004534353641360687318060281490199180612328166730772686396383698676545930088884461843637361053498018365439"),A24=new BigInteger$3("39081");function cswap(J,E,ee){const te=J.multiply(E.subtract(ee)).mod(P);return[E.subtract(te).mod(P),ee.add(te).mod(P)]}function X448$1(J,E){const ee=E;let te=N1$4,re=N0,ne=E,ie=N1$4,se=N0;for(let ae=448-1;ae>=0;--ae){const le=J.shiftRight(ae).and(N1$4);se=se.xor(le);{const[Ee,ve]=cswap(se,te,ne);te=Ee,ne=ve}{const[Ee,ve]=cswap(se,re,ie);re=Ee,ie=ve}se=le;const ue=te.add(re).mod(P),he=sqr(ue).mod(P),pe=te.subtract(re).mod(P),de=sqr(pe).mod(P),fe=he.subtract(de).mod(P),me=ne.add(ie).mod(P),_e=ne.subtract(ie).mod(P).multiply(ue).mod(P),be=me.multiply(pe).mod(P);ne=sqr(_e.add(be).mod(P)).mod(P),ie=ee.multiply(sqr(_e.subtract(be).mod(P))).mod(P),te=he.multiply(de).mod(P),re=fe.multiply(he.add(A24.multiply(fe).mod(P)).mod(P)).mod(P)}const[oe]=cswap(se,te,ne),[ce]=cswap(se,re,ie);return oe.multiply(ce.modPow(P.subtract(N2$4),P)).mod(P)}function decodeLittleEndian(J){return J.map((E,ee)=>fromNumber(E).shiftLeft(8*ee)).reduce((E,ee)=>E.add(ee),N0)}function decodeScalar448(J){const E=[...J];return E[0]&=252,E[55]|=128,decodeLittleEndian(E)}function unpack(J){if(J.length!==56)throw new Error(`Invalid Curve448 scalar (len=${J.length})`);return J.map((E,ee)=>fromNumber(E).shiftLeft(8*ee)).reduce((E,ee)=>E.add(ee),N0)}function pack(J){return Array.from({length:56},(E,ee)=>J.shiftRight(8*ee).and(N255).intValue())}function clamp(J){return J.andNot(N3$4).or(N128.shiftLeft(8*55))}function multscalar(J,E){const ee=clamp(decodeScalar448(J)),te=unpack(E);return pack(X448$1(ee,te))}function base_point_mult(J){const E=clamp(decodeScalar448(J));return pack(X448$1(E,N5$4))}function getPublicKey$2(J){if(!J)throw new Error("Missing private key");if(J.length!==56)throw new Error(`Invalid Curve448 private key (len=${J.length})`);return base_point_mult(Array.from(J))}function getSharedSecret(J,E){if(!J)throw new Error("Missing private key");if(!E)throw new Error("Missing public key");if(J.length!==56)throw new Error(`Invalid Curve448 private key (len=${J.length})`);const ee=multscalar(Array.from(J),Array.from(E));if(!ee.some(te=>te))throw new Error("Invalid Curve448 public key");return ee}const ALG_NAME="X448";class X448{constructor(E){Object.defineProperty(this,"_hkdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nPk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_nSk",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this._hkdf=E,this._nPk=56,this._nSk=56}async serializePublicKey(E){return await this._serializePublicKey(E)}async deserializePublicKey(E){return await this._deserializePublicKey(E)}async importKey(E,ee,te){if(E!=="raw")throw new Error("Unsupported format");return await this._importKey(ee,te)}async derivePublicKey(E){return await this._derivePublicKey(E)}async generateKeyPair(){const E=new Uint8Array(56);return(await loadCrypto()).getRandomValues(E),await this.deriveKeyPair(E)}async deriveKeyPair(E){const ee=await this._hkdf.labeledExtract(EMPTY,LABEL_DKP_PRK,new Uint8Array(E)),te=await this._hkdf.labeledExpand(ee,LABEL_SK,EMPTY,this._nSk),re=new XCryptoKey(ALG_NAME,new Uint8Array(te),"private");return{privateKey:re,publicKey:await this.derivePublicKey(re)}}async dh(E,ee){return await this._dh(E,ee)}_serializePublicKey(E){return new Promise(ee=>{ee(E.key.buffer)})}_deserializePublicKey(E){return new Promise((ee,te)=>{E.byteLength!==this._nPk?te(new Error("Invalid public key for the ciphersuite")):ee(new XCryptoKey(ALG_NAME,new Uint8Array(E),"public"))})}_importKey(E,ee){return new Promise((te,re)=>{ee&&E.byteLength!==this._nPk&&re(new Error("Invalid public key for the ciphersuite")),!ee&&E.byteLength!==this._nSk&&re(new Error("Invalid private key for the ciphersuite")),te(new XCryptoKey(ALG_NAME,new Uint8Array(E),ee?"public":"private"))})}_derivePublicKey(E){return new Promise(ee=>{ee(new XCryptoKey(ALG_NAME,Uint8Array.from(getPublicKey$2(E.key)),"public"))})}_dh(E,ee){return new Promise((te,re)=>{try{te(Uint8Array.from(getSharedSecret(E.key,ee.key)))}catch(ne){re(ne)}})}}class KemContext extends WebCrypto{constructor(E,ee){super(E),Object.defineProperty(this,"id",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"secretSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"encSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"publicKeySize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"privateKeySize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_prim",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_kdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.id=ee;let te=Kdf$1.HkdfSha256;switch(ee){case Kem$1.DhkemP256HkdfSha256:te=Kdf$1.HkdfSha256;break;case Kem$1.DhkemP384HkdfSha384:te=Kdf$1.HkdfSha384;break;case Kem$1.DhkemP521HkdfSha512:te=Kdf$1.HkdfSha512;break;case Kem$1.DhkemX25519HkdfSha256:te=Kdf$1.HkdfSha256;break;default:te=Kdf$1.HkdfSha512;break}const re=new Uint8Array(SUITE_ID_HEADER_KEM);switch(re.set(i2Osp(ee,2),3),this._kdf=new KdfContext(this._api,te,re),ee){case Kem$1.DhkemP256HkdfSha256:this._prim=new Ec(ee,this._kdf,this._api),this.secretSize=32,this.encSize=65,this.publicKeySize=65,this.privateKeySize=32;break;case Kem$1.DhkemP384HkdfSha384:this._prim=new Ec(ee,this._kdf,this._api),this.secretSize=48,this.encSize=97,this.publicKeySize=97,this.privateKeySize=48;break;case Kem$1.DhkemP521HkdfSha512:this._prim=new Ec(ee,this._kdf,this._api),this.secretSize=64,this.encSize=133,this.publicKeySize=133,this.privateKeySize=66;break;case Kem$1.DhkemX25519HkdfSha256:this._prim=new X25519(this._kdf),this.secretSize=32,this.encSize=32,this.publicKeySize=32,this.privateKeySize=32;break;default:this._prim=new X448(this._kdf),this.secretSize=64,this.encSize=56,this.publicKeySize=56,this.privateKeySize=56;break}}async generateKeyPair(){return await this._prim.generateKeyPair()}async deriveKeyPair(E){try{return await this._prim.deriveKeyPair(E)}catch(ee){throw new DeriveKeyPairError(ee)}}async importKey(E,ee,te){try{return await this._prim.importKey(E,ee,te)}catch(re){throw new DeserializeError(re)}}async encap(E){try{const ee=E.nonEphemeralKeyPair===void 0?await this.generateKeyPair():E.nonEphemeralKeyPair,te=await this._prim.serializePublicKey(ee.publicKey),re=await this._prim.serializePublicKey(E.recipientPublicKey);let ne;if(E.senderKey===void 0)ne=new Uint8Array(await this._prim.dh(ee.privateKey,E.recipientPublicKey));else{const oe=isCryptoKeyPair(E.senderKey)?E.senderKey.privateKey:E.senderKey,ce=new Uint8Array(await this._prim.dh(ee.privateKey,E.recipientPublicKey)),ae=new Uint8Array(await this._prim.dh(oe,E.recipientPublicKey));ne=concat$6(ce,ae)}let ie;if(E.senderKey===void 0)ie=concat$6(new Uint8Array(te),new Uint8Array(re));else{const oe=isCryptoKeyPair(E.senderKey)?E.senderKey.publicKey:await this._prim.derivePublicKey(E.senderKey),ce=await this._prim.serializePublicKey(oe);ie=concat3(new Uint8Array(te),new Uint8Array(re),new Uint8Array(ce))}const se=await this.generateSharedSecret(ne,ie);return{enc:te,sharedSecret:se}}catch(ee){throw new EncapError(ee)}}async decap(E){let ee;try{ee=await this._prim.deserializePublicKey(E.enc)}catch(te){throw new DeserializeError(te)}try{const te=isCryptoKeyPair(E.recipientKey)?E.recipientKey.privateKey:E.recipientKey,re=isCryptoKeyPair(E.recipientKey)?E.recipientKey.publicKey:await this._prim.derivePublicKey(E.recipientKey),ne=await this._prim.serializePublicKey(re);let ie;if(E.senderPublicKey===void 0)ie=new Uint8Array(await this._prim.dh(te,ee));else{const oe=new Uint8Array(await this._prim.dh(te,ee)),ce=new Uint8Array(await this._prim.dh(te,E.senderPublicKey));ie=concat$6(oe,ce)}let se;if(E.senderPublicKey===void 0)se=concat$6(new Uint8Array(E.enc),new Uint8Array(ne));else{const oe=await this._prim.serializePublicKey(E.senderPublicKey);se=new Uint8Array(E.enc.byteLength+ne.byteLength+oe.byteLength),se.set(new Uint8Array(E.enc),0),se.set(new Uint8Array(ne),E.enc.byteLength),se.set(new Uint8Array(oe),E.enc.byteLength+ne.byteLength)}return await this.generateSharedSecret(ie,se)}catch(te){throw new DecapError(te)}}async generateSharedSecret(E,ee){const te=this._kdf.buildLabeledIkm(LABEL_EAE_PRK,E),re=this._kdf.buildLabeledInfo(LABEL_SHARED_SECRET,ee,this.secretSize);return await this._kdf.extractAndExpand(EMPTY,te,re,this.secretSize)}}class RecipientContext extends EncryptionContext{async seal(E,ee=EMPTY){if(this._r.baseNonce.length===0)throw new SealError("Bidirectional encryption is not setup");let te;try{te=await this._r.key.seal(this.computeNonce(this._r),E,ee)}catch(re){throw new SealError(re)}return this.incrementSeq(this._r),te}async open(E,ee=EMPTY){let te;try{te=await this._f.key.open(this.computeNonce(this._f),E,ee)}catch(re){throw new OpenError(re)}return this.incrementSeq(this._f),te}}class SenderContext extends EncryptionContext{constructor(E,ee,te,re){super(E,ee,te),Object.defineProperty(this,"enc",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.enc=re}async seal(E,ee=EMPTY){let te;try{te=await this._f.key.seal(this.computeNonce(this._f),E,ee)}catch(re){throw new SealError(re)}return this.incrementSeq(this._f),te}async open(E,ee=EMPTY){if(this._r.baseNonce.length===0)throw new OpenError("Bidirectional encryption is not setup");let te;try{te=await this._r.key.open(this.computeNonce(this._r),E,ee)}catch(re){throw new OpenError(re)}return this.incrementSeq(this._r),te}}let CipherSuite$1=class{constructor(J){switch(Object.defineProperty(this,"kem",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"kdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"aead",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"kemSecretSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"kemEncSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"kemPublicKeySize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"kemPrivateKeySize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"aeadKeySize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"aeadNonceSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"aeadTagSize",{enumerable:!0,configurable:!0,writable:!0,value:0}),Object.defineProperty(this,"_api",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_kem",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_kdf",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"_suiteId",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),J.kem){case Kem$1.DhkemP256HkdfSha256:this.kemSecretSize=32,this.kemEncSize=65,this.kemPublicKeySize=65,this.kemPrivateKeySize=32;break;case Kem$1.DhkemP384HkdfSha384:this.kemSecretSize=48,this.kemEncSize=97,this.kemPublicKeySize=97,this.kemPrivateKeySize=48;break;case Kem$1.DhkemP521HkdfSha512:this.kemSecretSize=64,this.kemEncSize=133,this.kemPublicKeySize=133,this.kemPrivateKeySize=66;break;case Kem$1.DhkemX25519HkdfSha256:this.kemSecretSize=32,this.kemEncSize=32,this.kemPublicKeySize=32,this.kemPrivateKeySize=32;break;case Kem$1.DhkemX448HkdfSha512:this.kemSecretSize=64,this.kemEncSize=56,this.kemPublicKeySize=56,this.kemPrivateKeySize=56;break;default:throw new InvalidParamError("Invalid KEM id")}switch(this.kem=J.kem,J.kdf){case Kdf$1.HkdfSha256:case Kdf$1.HkdfSha384:case Kdf$1.HkdfSha512:break;default:throw new InvalidParamError("Invalid KDF id")}switch(this.kdf=J.kdf,J.aead){case Aead$1.Aes128Gcm:this.aeadKeySize=16,this.aeadNonceSize=12,this.aeadTagSize=16;break;case Aead$1.Aes256Gcm:this.aeadKeySize=32,this.aeadNonceSize=12,this.aeadTagSize=16;break;case Aead$1.Chacha20Poly1305:this.aeadKeySize=32,this.aeadNonceSize=12,this.aeadTagSize=16;break;case Aead$1.ExportOnly:break;default:throw new InvalidParamError("Invalid AEAD id")}this.aead=J.aead,this._suiteId=new Uint8Array(SUITE_ID_HEADER_HPKE),this._suiteId.set(i2Osp(this.kem,2),4),this._suiteId.set(i2Osp(this.kdf,2),6),this._suiteId.set(i2Osp(this.aead,2),8)}async kemContext(){return await this.setup(),this._kem}async kdfContext(){return await this.setup(),this._kdf}async createAeadKey(J){return await this.setup(),createAeadKey(this.aead,J,this._api)}async generateKeyPair(){return await this.setup(),await this._kem.generateKeyPair()}async deriveKeyPair(J){if(J.byteLength>INPUT_LENGTH_LIMIT)throw new InvalidParamError("Too long ikm");return await this.setup(),await this._kem.deriveKeyPair(J)}async importKey(J,E,ee=!0){return await this.setup(),await this._kem.importKey(J,E,ee)}async createSenderContext(J){this.validateInputLength(J),await this.setup();const E=await this._kem.encap(J);let ee;return J.psk!==void 0?ee=J.senderKey!==void 0?Mode$5.AuthPsk:Mode$5.Psk:ee=J.senderKey!==void 0?Mode$5.Auth:Mode$5.Base,await this.keyScheduleS(ee,E.sharedSecret,E.enc,J)}async createRecipientContext(J){this.validateInputLength(J),await this.setup();const E=await this._kem.decap(J);let ee;return J.psk!==void 0?ee=J.senderPublicKey!==void 0?Mode$5.AuthPsk:Mode$5.Psk:ee=J.senderPublicKey!==void 0?Mode$5.Auth:Mode$5.Base,await this.keyScheduleR(ee,E,J)}async seal(J,E,ee=EMPTY){const te=await this.createSenderContext(J);return{ct:await te.seal(E,ee),enc:te.enc}}async open(J,E,ee=EMPTY){return await(await this.createRecipientContext(J)).open(E,ee)}async setup(){this._api=await loadSubtleCrypto(),(this._kem===void 0||this._kdf===void 0)&&(this._kem=new KemContext(this._api,this.kem),this._kdf=new KdfContext(this._api,this.kdf,this._suiteId))}async keySchedule(J,E,ee){const te=new KdfContext(this._api,this.kdf,this._suiteId),re=ee.psk===void 0?EMPTY:new Uint8Array(ee.psk.id),ne=await te.labeledExtract(EMPTY,LABEL_PSK_ID_HASH,re),ie=ee.info===void 0?EMPTY:new Uint8Array(ee.info),se=await te.labeledExtract(EMPTY,LABEL_INFO_HASH,ie),oe=new Uint8Array(1+ne.byteLength+se.byteLength);oe.set(new Uint8Array([J]),0),oe.set(new Uint8Array(ne),1),oe.set(new Uint8Array(se),1+ne.byteLength);const ce=ee.psk===void 0?EMPTY:new Uint8Array(ee.psk.key),ae=te.buildLabeledIkm(LABEL_SECRET,ce),le=te.buildLabeledInfo(LABEL_EXP,oe,te.hashSize),ue=await te.extractAndExpand(E,ae,le,te.hashSize);if(this.aead===Aead$1.ExportOnly)return{params:{aead:this.aead,exporterSecret:ue},kdf:te};const he=te.buildLabeledInfo(LABEL_KEY,oe,this.aeadKeySize),pe=await te.extractAndExpand(E,ae,he,this.aeadKeySize),de=te.buildLabeledInfo(LABEL_BASE_NONCE,oe,this.aeadNonceSize),fe=await te.extractAndExpand(E,ae,de,this.aeadNonceSize);return{params:{aead:this.aead,exporterSecret:ue,key:pe,baseNonce:new Uint8Array(fe),seq:0},kdf:te}}async keyScheduleS(J,E,ee,te){const re=await this.keySchedule(J,E,te);return re.params.key===void 0?new SenderExporterContext(this._api,re.kdf,re.params.exporterSecret,ee):new SenderContext(this._api,re.kdf,re.params,ee)}async keyScheduleR(J,E,ee){const te=await this.keySchedule(J,E,ee);return te.params.key===void 0?new RecipientExporterContext(this._api,te.kdf,te.params.exporterSecret):new RecipientContext(this._api,te.kdf,te.params)}validateInputLength(J){if(J.info!==void 0&&J.info.byteLength>INPUT_LENGTH_LIMIT)throw new InvalidParamError("Too long info");if(J.psk!==void 0){if(J.psk.key.byteLength<MINIMUM_PSK_LENGTH)throw new InvalidParamError(`PSK must have at least ${MINIMUM_PSK_LENGTH} bytes`);if(J.psk.key.byteLength>INPUT_LENGTH_LIMIT)throw new InvalidParamError("Too long psk.key");if(J.psk.id.byteLength>INPUT_LENGTH_LIMIT)throw new InvalidParamError("Too long psk.id")}}};const hpke=Object.freeze(Object.defineProperty({__proto__:null,get Aead(){return Aead$1},CipherSuite:CipherSuite$1,DecapError,DeriveKeyPairError,DeserializeError,EncapError,ExportError,InvalidParamError,get Kdf(){return Kdf$1},get Kem(){return Kem$1},MessageLimitReachedError,NotSupportedError,OpenError,SealError,SerializeError,ValidationError},Symbol.toStringTag,{value:"Module"}));var ed25519$1={},random={},system={},browser$6={};Object.defineProperty(browser$6,"__esModule",{value:!0});browser$6.BrowserRandomSource=void 0;const QUOTA=65536;class BrowserRandomSource{constructor(){this.isAvailable=!1,this.isInstantiated=!1;const E=typeof self<"u"?self.crypto||self.msCrypto:null;E&&E.getRandomValues!==void 0&&(this._crypto=E,this.isAvailable=!0,this.isInstantiated=!0)}randomBytes(E){if(!this.isAvailable||!this._crypto)throw new Error("Browser random byte generator is not available.");const ee=new Uint8Array(E);for(let te=0;te<ee.length;te+=QUOTA)this._crypto.getRandomValues(ee.subarray(te,te+Math.min(ee.length-te,QUOTA)));return ee}}browser$6.BrowserRandomSource=BrowserRandomSource;function commonjsRequire(J){throw new Error('Could not dynamically require "'+J+'". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.')}var node={},wipe$1={};Object.defineProperty(wipe$1,"__esModule",{value:!0});function wipe(J){for(var E=0;E<J.length;E++)J[E]=0;return J}wipe$1.wipe=wipe;const net={},nodeCrypto=Object.freeze(Object.defineProperty({__proto__:null,default:net},Symbol.toStringTag,{value:"Module"})),require$$8=getAugmentedNamespace(nodeCrypto);Object.defineProperty(node,"__esModule",{value:!0});node.NodeRandomSource=void 0;const wipe_1$3=wipe$1;class NodeRandomSource{constructor(){if(this.isAvailable=!1,this.isInstantiated=!1,typeof commonjsRequire<"u"){const E=require$$8;E&&E.randomBytes&&(this._crypto=E,this.isAvailable=!0,this.isInstantiated=!0)}}randomBytes(E){if(!this.isAvailable||!this._crypto)throw new Error("Node.js random byte generator is not available.");let ee=this._crypto.randomBytes(E);if(ee.length!==E)throw new Error("NodeRandomSource: got fewer bytes than requested");const te=new Uint8Array(E);for(let re=0;re<te.length;re++)te[re]=ee[re];return(0,wipe_1$3.wipe)(ee),te}}node.NodeRandomSource=NodeRandomSource;Object.defineProperty(system,"__esModule",{value:!0});system.SystemRandomSource=void 0;const browser_1=browser$6,node_1=node;class SystemRandomSource{constructor(){if(this.isAvailable=!1,this.name="",this._source=new browser_1.BrowserRandomSource,this._source.isAvailable){this.isAvailable=!0,this.name="Browser";return}if(this._source=new node_1.NodeRandomSource,this._source.isAvailable){this.isAvailable=!0,this.name="Node";return}}randomBytes(E){if(!this.isAvailable)throw new Error("System random byte generator is not available.");return this._source.randomBytes(E)}}system.SystemRandomSource=SystemRandomSource;var binary={},int={};(function(J){Object.defineProperty(J,"__esModule",{value:!0});function E(se,oe){var ce=se>>>16&65535,ae=se&65535,le=oe>>>16&65535,ue=oe&65535;return ae*ue+(ce*ue+ae*le<<16>>>0)|0}J.mul=Math.imul||E;function ee(se,oe){return se+oe|0}J.add=ee;function te(se,oe){return se-oe|0}J.sub=te;function re(se,oe){return se<<oe|se>>>32-oe}J.rotl=re;function ne(se,oe){return se<<32-oe|se>>>oe}J.rotr=ne;function ie(se){return typeof se=="number"&&isFinite(se)&&Math.floor(se)===se}J.isInteger=Number.isInteger||ie,J.MAX_SAFE_INTEGER=9007199254740991,J.isSafeInteger=function(se){return J.isInteger(se)&&se>=-J.MAX_SAFE_INTEGER&&se<=J.MAX_SAFE_INTEGER}})(int);Object.defineProperty(binary,"__esModule",{value:!0});var int_1=int;function readInt16BE(J,E){return E===void 0&&(E=0),(J[E+0]<<8|J[E+1])<<16>>16}binary.readInt16BE=readInt16BE;function readUint16BE(J,E){return E===void 0&&(E=0),(J[E+0]<<8|J[E+1])>>>0}binary.readUint16BE=readUint16BE;function readInt16LE(J,E){return E===void 0&&(E=0),(J[E+1]<<8|J[E])<<16>>16}binary.readInt16LE=readInt16LE;function readUint16LE(J,E){return E===void 0&&(E=0),(J[E+1]<<8|J[E])>>>0}binary.readUint16LE=readUint16LE;function writeUint16BE(J,E,ee){return E===void 0&&(E=new Uint8Array(2)),ee===void 0&&(ee=0),E[ee+0]=J>>>8,E[ee+1]=J>>>0,E}binary.writeUint16BE=writeUint16BE;binary.writeInt16BE=writeUint16BE;function writeUint16LE(J,E,ee){return E===void 0&&(E=new Uint8Array(2)),ee===void 0&&(ee=0),E[ee+0]=J>>>0,E[ee+1]=J>>>8,E}binary.writeUint16LE=writeUint16LE;binary.writeInt16LE=writeUint16LE;function readInt32BE(J,E){return E===void 0&&(E=0),J[E]<<24|J[E+1]<<16|J[E+2]<<8|J[E+3]}binary.readInt32BE=readInt32BE;function readUint32BE(J,E){return E===void 0&&(E=0),(J[E]<<24|J[E+1]<<16|J[E+2]<<8|J[E+3])>>>0}binary.readUint32BE=readUint32BE;function readInt32LE(J,E){return E===void 0&&(E=0),J[E+3]<<24|J[E+2]<<16|J[E+1]<<8|J[E]}binary.readInt32LE=readInt32LE;function readUint32LE(J,E){return E===void 0&&(E=0),(J[E+3]<<24|J[E+2]<<16|J[E+1]<<8|J[E])>>>0}binary.readUint32LE=readUint32LE;function writeUint32BE(J,E,ee){return E===void 0&&(E=new Uint8Array(4)),ee===void 0&&(ee=0),E[ee+0]=J>>>24,E[ee+1]=J>>>16,E[ee+2]=J>>>8,E[ee+3]=J>>>0,E}binary.writeUint32BE=writeUint32BE;binary.writeInt32BE=writeUint32BE;function writeUint32LE(J,E,ee){return E===void 0&&(E=new Uint8Array(4)),ee===void 0&&(ee=0),E[ee+0]=J>>>0,E[ee+1]=J>>>8,E[ee+2]=J>>>16,E[ee+3]=J>>>24,E}binary.writeUint32LE=writeUint32LE;binary.writeInt32LE=writeUint32LE;function readInt64BE(J,E){E===void 0&&(E=0);var ee=readInt32BE(J,E),te=readInt32BE(J,E+4);return ee*4294967296+te-(te>>31)*4294967296}binary.readInt64BE=readInt64BE;function readUint64BE(J,E){E===void 0&&(E=0);var ee=readUint32BE(J,E),te=readUint32BE(J,E+4);return ee*4294967296+te}binary.readUint64BE=readUint64BE;function readInt64LE(J,E){E===void 0&&(E=0);var ee=readInt32LE(J,E),te=readInt32LE(J,E+4);return te*4294967296+ee-(ee>>31)*4294967296}binary.readInt64LE=readInt64LE;function readUint64LE(J,E){E===void 0&&(E=0);var ee=readUint32LE(J,E),te=readUint32LE(J,E+4);return te*4294967296+ee}binary.readUint64LE=readUint64LE;function writeUint64BE(J,E,ee){return E===void 0&&(E=new Uint8Array(8)),ee===void 0&&(ee=0),writeUint32BE(J/4294967296>>>0,E,ee),writeUint32BE(J>>>0,E,ee+4),E}binary.writeUint64BE=writeUint64BE;binary.writeInt64BE=writeUint64BE;function writeUint64LE(J,E,ee){return E===void 0&&(E=new Uint8Array(8)),ee===void 0&&(ee=0),writeUint32LE(J>>>0,E,ee),writeUint32LE(J/4294967296>>>0,E,ee+4),E}binary.writeUint64LE=writeUint64LE;binary.writeInt64LE=writeUint64LE;function readUintBE$1(J,E,ee){if(ee===void 0&&(ee=0),J%8!==0)throw new Error("readUintBE supports only bitLengths divisible by 8");if(J/8>E.length-ee)throw new Error("readUintBE: array is too short for the given bitLength");for(var te=0,re=1,ne=J/8+ee-1;ne>=ee;ne--)te+=E[ne]*re,re*=256;return te}binary.readUintBE=readUintBE$1;function readUintLE$1(J,E,ee){if(ee===void 0&&(ee=0),J%8!==0)throw new Error("readUintLE supports only bitLengths divisible by 8");if(J/8>E.length-ee)throw new Error("readUintLE: array is too short for the given bitLength");for(var te=0,re=1,ne=ee;ne<ee+J/8;ne++)te+=E[ne]*re,re*=256;return te}binary.readUintLE=readUintLE$1;function writeUintBE$1(J,E,ee,te){if(ee===void 0&&(ee=new Uint8Array(J/8)),te===void 0&&(te=0),J%8!==0)throw new Error("writeUintBE supports only bitLengths divisible by 8");if(!int_1.isSafeInteger(E))throw new Error("writeUintBE value must be an integer");for(var re=1,ne=J/8+te-1;ne>=te;ne--)ee[ne]=E/re&255,re*=256;return ee}binary.writeUintBE=writeUintBE$1;function writeUintLE$1(J,E,ee,te){if(ee===void 0&&(ee=new Uint8Array(J/8)),te===void 0&&(te=0),J%8!==0)throw new Error("writeUintLE supports only bitLengths divisible by 8");if(!int_1.isSafeInteger(E))throw new Error("writeUintLE value must be an integer");for(var re=1,ne=te;ne<te+J/8;ne++)ee[ne]=E/re&255,re*=256;return ee}binary.writeUintLE=writeUintLE$1;function readFloat32BE(J,E){E===void 0&&(E=0);var ee=new DataView(J.buffer,J.byteOffset,J.byteLength);return ee.getFloat32(E)}binary.readFloat32BE=readFloat32BE;function readFloat32LE(J,E){E===void 0&&(E=0);var ee=new DataView(J.buffer,J.byteOffset,J.byteLength);return ee.getFloat32(E,!0)}binary.readFloat32LE=readFloat32LE;function readFloat64BE(J,E){E===void 0&&(E=0);var ee=new DataView(J.buffer,J.byteOffset,J.byteLength);return ee.getFloat64(E)}binary.readFloat64BE=readFloat64BE;function readFloat64LE(J,E){E===void 0&&(E=0);var ee=new DataView(J.buffer,J.byteOffset,J.byteLength);return ee.getFloat64(E,!0)}binary.readFloat64LE=readFloat64LE;function writeFloat32BE(J,E,ee){E===void 0&&(E=new Uint8Array(4)),ee===void 0&&(ee=0);var te=new DataView(E.buffer,E.byteOffset,E.byteLength);return te.setFloat32(ee,J),E}binary.writeFloat32BE=writeFloat32BE;function writeFloat32LE(J,E,ee){E===void 0&&(E=new Uint8Array(4)),ee===void 0&&(ee=0);var te=new DataView(E.buffer,E.byteOffset,E.byteLength);return te.setFloat32(ee,J,!0),E}binary.writeFloat32LE=writeFloat32LE;function writeFloat64BE(J,E,ee){E===void 0&&(E=new Uint8Array(8)),ee===void 0&&(ee=0);var te=new DataView(E.buffer,E.byteOffset,E.byteLength);return te.setFloat64(ee,J),E}binary.writeFloat64BE=writeFloat64BE;function writeFloat64LE(J,E,ee){E===void 0&&(E=new Uint8Array(8)),ee===void 0&&(ee=0);var te=new DataView(E.buffer,E.byteOffset,E.byteLength);return te.setFloat64(ee,J,!0),E}binary.writeFloat64LE=writeFloat64LE;(function(J){Object.defineProperty(J,"__esModule",{value:!0}),J.randomStringForEntropy=J.randomString=J.randomUint32=J.randomBytes=J.defaultRandomSource=void 0;const E=system,ee=binary,te=wipe$1;J.defaultRandomSource=new E.SystemRandomSource;function re(ce,ae=J.defaultRandomSource){return ae.randomBytes(ce)}J.randomBytes=re;function ne(ce=J.defaultRandomSource){const ae=re(4,ce),le=(0,ee.readUint32LE)(ae);return(0,te.wipe)(ae),le}J.randomUint32=ne;const ie="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";function se(ce,ae=ie,le=J.defaultRandomSource){if(ae.length<2)throw new Error("randomString charset is too short");if(ae.length>256)throw new Error("randomString charset is too long");let ue="";const he=ae.length,pe=256-256%he;for(;ce>0;){const de=re(Math.ceil(ce*256/pe),le);for(let fe=0;fe<de.length&&ce>0;fe++){const me=de[fe];me<pe&&(ue+=ae.charAt(me%he),ce--)}(0,te.wipe)(de)}return ue}J.randomString=se;function oe(ce,ae=ie,le=J.defaultRandomSource){const ue=Math.ceil(ce/(Math.log(ae.length)/Math.LN2));return se(ue,ae,le)}J.randomStringForEntropy=oe})(random);var sha512$2={};(function(J){Object.defineProperty(J,"__esModule",{value:!0});var E=binary,ee=wipe$1;J.DIGEST_LENGTH=64,J.BLOCK_SIZE=128;var te=function(){function se(){this.digestLength=J.DIGEST_LENGTH,this.blockSize=J.BLOCK_SIZE,this._stateHi=new Int32Array(8),this._stateLo=new Int32Array(8),this._tempHi=new Int32Array(16),this._tempLo=new Int32Array(16),this._buffer=new Uint8Array(256),this._bufferLength=0,this._bytesHashed=0,this._finished=!1,this.reset()}return se.prototype._initState=function(){this._stateHi[0]=1779033703,this._stateHi[1]=3144134277,this._stateHi[2]=1013904242,this._stateHi[3]=2773480762,this._stateHi[4]=1359893119,this._stateHi[5]=2600822924,this._stateHi[6]=528734635,this._stateHi[7]=1541459225,this._stateLo[0]=4089235720,this._stateLo[1]=2227873595,this._stateLo[2]=4271175723,this._stateLo[3]=1595750129,this._stateLo[4]=2917565137,this._stateLo[5]=725511199,this._stateLo[6]=4215389547,this._stateLo[7]=327033209},se.prototype.reset=function(){return this._initState(),this._bufferLength=0,this._bytesHashed=0,this._finished=!1,this},se.prototype.clean=function(){ee.wipe(this._buffer),ee.wipe(this._tempHi),ee.wipe(this._tempLo),this.reset()},se.prototype.update=function(oe,ce){if(ce===void 0&&(ce=oe.length),this._finished)throw new Error("SHA512: can't update because hash was finished.");var ae=0;if(this._bytesHashed+=ce,this._bufferLength>0){for(;this._bufferLength<J.BLOCK_SIZE&&ce>0;)this._buffer[this._bufferLength++]=oe[ae++],ce--;this._bufferLength===this.blockSize&&(ne(this._tempHi,this._tempLo,this._stateHi,this._stateLo,this._buffer,0,this.blockSize),this._bufferLength=0)}for(ce>=this.blockSize&&(ae=ne(this._tempHi,this._tempLo,this._stateHi,this._stateLo,oe,ae,ce),ce%=this.blockSize);ce>0;)this._buffer[this._bufferLength++]=oe[ae++],ce--;return this},se.prototype.finish=function(oe){if(!this._finished){var ce=this._bytesHashed,ae=this._bufferLength,le=ce/536870912|0,ue=ce<<3,he=ce%128<112?128:256;this._buffer[ae]=128;for(var pe=ae+1;pe<he-8;pe++)this._buffer[pe]=0;E.writeUint32BE(le,this._buffer,he-8),E.writeUint32BE(ue,this._buffer,he-4),ne(this._tempHi,this._tempLo,this._stateHi,this._stateLo,this._buffer,0,he),this._finished=!0}for(var pe=0;pe<this.digestLength/8;pe++)E.writeUint32BE(this._stateHi[pe],oe,pe*8),E.writeUint32BE(this._stateLo[pe],oe,pe*8+4);return this},se.prototype.digest=function(){var oe=new Uint8Array(this.digestLength);return this.finish(oe),oe},se.prototype.saveState=function(){if(this._finished)throw new Error("SHA256: cannot save finished state");return{stateHi:new Int32Array(this._stateHi),stateLo:new Int32Array(this._stateLo),buffer:this._bufferLength>0?new Uint8Array(this._buffer):void 0,bufferLength:this._bufferLength,bytesHashed:this._bytesHashed}},se.prototype.restoreState=function(oe){return this._stateHi.set(oe.stateHi),this._stateLo.set(oe.stateLo),this._bufferLength=oe.bufferLength,oe.buffer&&this._buffer.set(oe.buffer),this._bytesHashed=oe.bytesHashed,this._finished=!1,this},se.prototype.cleanSavedState=function(oe){ee.wipe(oe.stateHi),ee.wipe(oe.stateLo),oe.buffer&&ee.wipe(oe.buffer),oe.bufferLength=0,oe.bytesHashed=0},se}();J.SHA512=te;var re=new Int32Array([1116352408,3609767458,1899447441,602891725,3049323471,3964484399,3921009573,2173295548,961987163,4081628472,1508970993,3053834265,2453635748,2937671579,2870763221,3664609560,3624381080,2734883394,310598401,1164996542,607225278,1323610764,1426881987,3590304994,1925078388,4068182383,2162078206,991336113,2614888103,633803317,3248222580,3479774868,3835390401,2666613458,4022224774,944711139,264347078,2341262773,604807628,2007800933,770255983,1495990901,1249150122,1856431235,1555081692,3175218132,1996064986,2198950837,2554220882,3999719339,2821834349,766784016,2952996808,2566594879,3210313671,3203337956,3336571891,1034457026,3584528711,2466948901,113926993,3758326383,338241895,168717936,666307205,1188179964,773529912,1546045734,1294757372,1522805485,1396182291,2643833823,1695183700,2343527390,1986661051,1014477480,2177026350,1206759142,2456956037,344077627,2730485921,1290863460,2820302411,3158454273,3259730800,3505952657,3345764771,106217008,3516065817,3606008344,3600352804,1432725776,4094571909,1467031594,275423344,851169720,430227734,3100823752,506948616,1363258195,659060556,3750685593,883997877,3785050280,958139571,3318307427,1322822218,3812723403,1537002063,2003034995,1747873779,3602036899,1955562222,1575990012,2024104815,1125592928,2227730452,2716904306,2361852424,442776044,2428436474,593698344,2756734187,3733110249,3204031479,2999351573,3329325298,3815920427,3391569614,3928383900,3515267271,566280711,3940187606,3454069534,4118630271,4000239992,116418474,1914138554,174292421,2731055270,289380356,3203993006,460393269,320620315,685471733,587496836,852142971,1086792851,1017036298,365543100,1126000580,2618297676,1288033470,3409855158,1501505948,4234509866,1607167915,987167468,1816402316,1246189591]);function ne(se,oe,ce,ae,le,ue,he){for(var pe=ce[0],de=ce[1],fe=ce[2],me=ce[3],_e=ce[4],be=ce[5],Ee=ce[6],ve=ce[7],we=ae[0],ge=ae[1],Se=ae[2],$e=ae[3],Pe=ae[4],Me=ae[5],xe=ae[6],Fe=ae[7],ke,Te,Ve,Ce,Ne,Oe,Le,Be;he>=128;){for(var ze=0;ze<16;ze++){var Ue=8*ze+ue;se[ze]=E.readUint32BE(le,Ue),oe[ze]=E.readUint32BE(le,Ue+4)}for(var ze=0;ze<80;ze++){var Ge=pe,je=de,We=fe,Ae=me,De=_e,Ie=be,ye=Ee,Re=ve,Ke=we,He=ge,qe=Se,Ye=$e,rt=Pe,ot=Me,ft=xe,gt=Fe;if(ke=ve,Te=Fe,Ne=Te&65535,Oe=Te>>>16,Le=ke&65535,Be=ke>>>16,ke=(_e>>>14|Pe<<32-14)^(_e>>>18|Pe<<32-18)^(Pe>>>41-32|_e<<32-(41-32)),Te=(Pe>>>14|_e<<32-14)^(Pe>>>18|_e<<32-18)^(_e>>>41-32|Pe<<32-(41-32)),Ne+=Te&65535,Oe+=Te>>>16,Le+=ke&65535,Be+=ke>>>16,ke=_e&be^~_e&Ee,Te=Pe&Me^~Pe&xe,Ne+=Te&65535,Oe+=Te>>>16,Le+=ke&65535,Be+=ke>>>16,ke=re[ze*2],Te=re[ze*2+1],Ne+=Te&65535,Oe+=Te>>>16,Le+=ke&65535,Be+=ke>>>16,ke=se[ze%16],Te=oe[ze%16],Ne+=Te&65535,Oe+=Te>>>16,Le+=ke&65535,Be+=ke>>>16,Oe+=Ne>>>16,Le+=Oe>>>16,Be+=Le>>>16,Ve=Le&65535|Be<<16,Ce=Ne&65535|Oe<<16,ke=Ve,Te=Ce,Ne=Te&65535,Oe=Te>>>16,Le=ke&65535,Be=ke>>>16,ke=(pe>>>28|we<<32-28)^(we>>>34-32|pe<<32-(34-32))^(we>>>39-32|pe<<32-(39-32)),Te=(we>>>28|pe<<32-28)^(pe>>>34-32|we<<32-(34-32))^(pe>>>39-32|we<<32-(39-32)),Ne+=Te&65535,Oe+=Te>>>16,Le+=ke&65535,Be+=ke>>>16,ke=pe&de^pe&fe^de&fe,Te=we&ge^we&Se^ge&Se,Ne+=Te&65535,Oe+=Te>>>16,Le+=ke&65535,Be+=ke>>>16,Oe+=Ne>>>16,Le+=Oe>>>16,Be+=Le>>>16,Re=Le&65535|Be<<16,gt=Ne&65535|Oe<<16,ke=Ae,Te=Ye,Ne=Te&65535,Oe=Te>>>16,Le=ke&65535,Be=ke>>>16,ke=Ve,Te=Ce,Ne+=Te&65535,Oe+=Te>>>16,Le+=ke&65535,Be+=ke>>>16,Oe+=Ne>>>16,Le+=Oe>>>16,Be+=Le>>>16,Ae=Le&65535|Be<<16,Ye=Ne&65535|Oe<<16,de=Ge,fe=je,me=We,_e=Ae,be=De,Ee=Ie,ve=ye,pe=Re,ge=Ke,Se=He,$e=qe,Pe=Ye,Me=rt,xe=ot,Fe=ft,we=gt,ze%16===15)for(var Ue=0;Ue<16;Ue++)ke=se[Ue],Te=oe[Ue],Ne=Te&65535,Oe=Te>>>16,Le=ke&65535,Be=ke>>>16,ke=se[(Ue+9)%16],Te=oe[(Ue+9)%16],Ne+=Te&65535,Oe+=Te>>>16,Le+=ke&65535,Be+=ke>>>16,Ve=se[(Ue+1)%16],Ce=oe[(Ue+1)%16],ke=(Ve>>>1|Ce<<32-1)^(Ve>>>8|Ce<<32-8)^Ve>>>7,Te=(Ce>>>1|Ve<<32-1)^(Ce>>>8|Ve<<32-8)^(Ce>>>7|Ve<<32-7),Ne+=Te&65535,Oe+=Te>>>16,Le+=ke&65535,Be+=ke>>>16,Ve=se[(Ue+14)%16],Ce=oe[(Ue+14)%16],ke=(Ve>>>19|Ce<<32-19)^(Ce>>>61-32|Ve<<32-(61-32))^Ve>>>6,Te=(Ce>>>19|Ve<<32-19)^(Ve>>>61-32|Ce<<32-(61-32))^(Ce>>>6|Ve<<32-6),Ne+=Te&65535,Oe+=Te>>>16,Le+=ke&65535,Be+=ke>>>16,Oe+=Ne>>>16,Le+=Oe>>>16,Be+=Le>>>16,se[Ue]=Le&65535|Be<<16,oe[Ue]=Ne&65535|Oe<<16}ke=pe,Te=we,Ne=Te&65535,Oe=Te>>>16,Le=ke&65535,Be=ke>>>16,ke=ce[0],Te=ae[0],Ne+=Te&65535,Oe+=Te>>>16,Le+=ke&65535,Be+=ke>>>16,Oe+=Ne>>>16,Le+=Oe>>>16,Be+=Le>>>16,ce[0]=pe=Le&65535|Be<<16,ae[0]=we=Ne&65535|Oe<<16,ke=de,Te=ge,Ne=Te&65535,Oe=Te>>>16,Le=ke&65535,Be=ke>>>16,ke=ce[1],Te=ae[1],Ne+=Te&65535,Oe+=Te>>>16,Le+=ke&65535,Be+=ke>>>16,Oe+=Ne>>>16,Le+=Oe>>>16,Be+=Le>>>16,ce[1]=de=Le&65535|Be<<16,ae[1]=ge=Ne&65535|Oe<<16,ke=fe,Te=Se,Ne=Te&65535,Oe=Te>>>16,Le=ke&65535,Be=ke>>>16,ke=ce[2],Te=ae[2],Ne+=Te&65535,Oe+=Te>>>16,Le+=ke&65535,Be+=ke>>>16,Oe+=Ne>>>16,Le+=Oe>>>16,Be+=Le>>>16,ce[2]=fe=Le&65535|Be<<16,ae[2]=Se=Ne&65535|Oe<<16,ke=me,Te=$e,Ne=Te&65535,Oe=Te>>>16,Le=ke&65535,Be=ke>>>16,ke=ce[3],Te=ae[3],Ne+=Te&65535,Oe+=Te>>>16,Le+=ke&65535,Be+=ke>>>16,Oe+=Ne>>>16,Le+=Oe>>>16,Be+=Le>>>16,ce[3]=me=Le&65535|Be<<16,ae[3]=$e=Ne&65535|Oe<<16,ke=_e,Te=Pe,Ne=Te&65535,Oe=Te>>>16,Le=ke&65535,Be=ke>>>16,ke=ce[4],Te=ae[4],Ne+=Te&65535,Oe+=Te>>>16,Le+=ke&65535,Be+=ke>>>16,Oe+=Ne>>>16,Le+=Oe>>>16,Be+=Le>>>16,ce[4]=_e=Le&65535|Be<<16,ae[4]=Pe=Ne&65535|Oe<<16,ke=be,Te=Me,Ne=Te&65535,Oe=Te>>>16,Le=ke&65535,Be=ke>>>16,ke=ce[5],Te=ae[5],Ne+=Te&65535,Oe+=Te>>>16,Le+=ke&65535,Be+=ke>>>16,Oe+=Ne>>>16,Le+=Oe>>>16,Be+=Le>>>16,ce[5]=be=Le&65535|Be<<16,ae[5]=Me=Ne&65535|Oe<<16,ke=Ee,Te=xe,Ne=Te&65535,Oe=Te>>>16,Le=ke&65535,Be=ke>>>16,ke=ce[6],Te=ae[6],Ne+=Te&65535,Oe+=Te>>>16,Le+=ke&65535,Be+=ke>>>16,Oe+=Ne>>>16,Le+=Oe>>>16,Be+=Le>>>16,ce[6]=Ee=Le&65535|Be<<16,ae[6]=xe=Ne&65535|Oe<<16,ke=ve,Te=Fe,Ne=Te&65535,Oe=Te>>>16,Le=ke&65535,Be=ke>>>16,ke=ce[7],Te=ae[7],Ne+=Te&65535,Oe+=Te>>>16,Le+=ke&65535,Be+=ke>>>16,Oe+=Ne>>>16,Le+=Oe>>>16,Be+=Le>>>16,ce[7]=ve=Le&65535|Be<<16,ae[7]=Fe=Ne&65535|Oe<<16,ue+=128,he-=128}return ue}function ie(se){var oe=new te;oe.update(se);var ce=oe.digest();return oe.clean(),ce}J.hash=ie})(sha512$2);(function(J){Object.defineProperty(J,"__esModule",{value:!0}),J.convertSecretKeyToX25519=J.convertPublicKeyToX25519=J.verify=J.sign=J.extractPublicKeyFromSecretKey=J.generateKeyPair=J.generateKeyPairFromSeed=J.SEED_LENGTH=J.SECRET_KEY_LENGTH=J.PUBLIC_KEY_LENGTH=J.SIGNATURE_LENGTH=void 0;const E=random,ee=sha512$2,te=wipe$1;J.SIGNATURE_LENGTH=64,J.PUBLIC_KEY_LENGTH=32,J.SECRET_KEY_LENGTH=64,J.SEED_LENGTH=32;function re(Ae){const De=new Float64Array(16);if(Ae)for(let Ie=0;Ie<Ae.length;Ie++)De[Ie]=Ae[Ie];return De}const ne=new Uint8Array(32);ne[0]=9;const ie=re(),se=re([1]),oe=re([30883,4953,19914,30187,55467,16705,2637,112,59544,30585,16505,36039,65139,11119,27886,20995]),ce=re([61785,9906,39828,60374,45398,33411,5274,224,53552,61171,33010,6542,64743,22239,55772,9222]),ae=re([54554,36645,11616,51542,42930,38181,51040,26924,56412,64982,57905,49316,21502,52590,14035,8553]),le=re([26200,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214,26214]),ue=re([41136,18958,6951,50414,58488,44335,6150,12099,55207,15867,153,11085,57099,20417,9344,11139]);function he(Ae,De){for(let Ie=0;Ie<16;Ie++)Ae[Ie]=De[Ie]|0}function pe(Ae){let De=1;for(let Ie=0;Ie<16;Ie++){let ye=Ae[Ie]+De+65535;De=Math.floor(ye/65536),Ae[Ie]=ye-De*65536}Ae[0]+=De-1+37*(De-1)}function de(Ae,De,Ie){const ye=~(Ie-1);for(let Re=0;Re<16;Re++){const Ke=ye&(Ae[Re]^De[Re]);Ae[Re]^=Ke,De[Re]^=Ke}}function fe(Ae,De){const Ie=re(),ye=re();for(let Re=0;Re<16;Re++)ye[Re]=De[Re];pe(ye),pe(ye),pe(ye);for(let Re=0;Re<2;Re++){Ie[0]=ye[0]-65517;for(let He=1;He<15;He++)Ie[He]=ye[He]-65535-(Ie[He-1]>>16&1),Ie[He-1]&=65535;Ie[15]=ye[15]-32767-(Ie[14]>>16&1);const Ke=Ie[15]>>16&1;Ie[14]&=65535,de(ye,Ie,1-Ke)}for(let Re=0;Re<16;Re++)Ae[2*Re]=ye[Re]&255,Ae[2*Re+1]=ye[Re]>>8}function me(Ae,De){let Ie=0;for(let ye=0;ye<32;ye++)Ie|=Ae[ye]^De[ye];return(1&Ie-1>>>8)-1}function _e(Ae,De){const Ie=new Uint8Array(32),ye=new Uint8Array(32);return fe(Ie,Ae),fe(ye,De),me(Ie,ye)}function be(Ae){const De=new Uint8Array(32);return fe(De,Ae),De[0]&1}function Ee(Ae,De){for(let Ie=0;Ie<16;Ie++)Ae[Ie]=De[2*Ie]+(De[2*Ie+1]<<8);Ae[15]&=32767}function ve(Ae,De,Ie){for(let ye=0;ye<16;ye++)Ae[ye]=De[ye]+Ie[ye]}function we(Ae,De,Ie){for(let ye=0;ye<16;ye++)Ae[ye]=De[ye]-Ie[ye]}function ge(Ae,De,Ie){let ye,Re,Ke=0,He=0,qe=0,Ye=0,rt=0,ot=0,ft=0,gt=0,it=0,nt=0,et=0,tt=0,Qe=0,Xe=0,Je=0,Ze=0,st=0,at=0,ct=0,lt=0,ut=0,ht=0,dt=0,pt=0,Dt=0,Nt=0,Mt=0,Lt=0,Ot=0,Bt=0,Ft=0,mt=Ie[0],yt=Ie[1],_t=Ie[2],bt=Ie[3],Et=Ie[4],wt=Ie[5],vt=Ie[6],St=Ie[7],$t=Ie[8],Rt=Ie[9],Tt=Ie[10],It=Ie[11],At=Ie[12],Ct=Ie[13],Pt=Ie[14],kt=Ie[15];ye=De[0],Ke+=ye*mt,He+=ye*yt,qe+=ye*_t,Ye+=ye*bt,rt+=ye*Et,ot+=ye*wt,ft+=ye*vt,gt+=ye*St,it+=ye*$t,nt+=ye*Rt,et+=ye*Tt,tt+=ye*It,Qe+=ye*At,Xe+=ye*Ct,Je+=ye*Pt,Ze+=ye*kt,ye=De[1],He+=ye*mt,qe+=ye*yt,Ye+=ye*_t,rt+=ye*bt,ot+=ye*Et,ft+=ye*wt,gt+=ye*vt,it+=ye*St,nt+=ye*$t,et+=ye*Rt,tt+=ye*Tt,Qe+=ye*It,Xe+=ye*At,Je+=ye*Ct,Ze+=ye*Pt,st+=ye*kt,ye=De[2],qe+=ye*mt,Ye+=ye*yt,rt+=ye*_t,ot+=ye*bt,ft+=ye*Et,gt+=ye*wt,it+=ye*vt,nt+=ye*St,et+=ye*$t,tt+=ye*Rt,Qe+=ye*Tt,Xe+=ye*It,Je+=ye*At,Ze+=ye*Ct,st+=ye*Pt,at+=ye*kt,ye=De[3],Ye+=ye*mt,rt+=ye*yt,ot+=ye*_t,ft+=ye*bt,gt+=ye*Et,it+=ye*wt,nt+=ye*vt,et+=ye*St,tt+=ye*$t,Qe+=ye*Rt,Xe+=ye*Tt,Je+=ye*It,Ze+=ye*At,st+=ye*Ct,at+=ye*Pt,ct+=ye*kt,ye=De[4],rt+=ye*mt,ot+=ye*yt,ft+=ye*_t,gt+=ye*bt,it+=ye*Et,nt+=ye*wt,et+=ye*vt,tt+=ye*St,Qe+=ye*$t,Xe+=ye*Rt,Je+=ye*Tt,Ze+=ye*It,st+=ye*At,at+=ye*Ct,ct+=ye*Pt,lt+=ye*kt,ye=De[5],ot+=ye*mt,ft+=ye*yt,gt+=ye*_t,it+=ye*bt,nt+=ye*Et,et+=ye*wt,tt+=ye*vt,Qe+=ye*St,Xe+=ye*$t,Je+=ye*Rt,Ze+=ye*Tt,st+=ye*It,at+=ye*At,ct+=ye*Ct,lt+=ye*Pt,ut+=ye*kt,ye=De[6],ft+=ye*mt,gt+=ye*yt,it+=ye*_t,nt+=ye*bt,et+=ye*Et,tt+=ye*wt,Qe+=ye*vt,Xe+=ye*St,Je+=ye*$t,Ze+=ye*Rt,st+=ye*Tt,at+=ye*It,ct+=ye*At,lt+=ye*Ct,ut+=ye*Pt,ht+=ye*kt,ye=De[7],gt+=ye*mt,it+=ye*yt,nt+=ye*_t,et+=ye*bt,tt+=ye*Et,Qe+=ye*wt,Xe+=ye*vt,Je+=ye*St,Ze+=ye*$t,st+=ye*Rt,at+=ye*Tt,ct+=ye*It,lt+=ye*At,ut+=ye*Ct,ht+=ye*Pt,dt+=ye*kt,ye=De[8],it+=ye*mt,nt+=ye*yt,et+=ye*_t,tt+=ye*bt,Qe+=ye*Et,Xe+=ye*wt,Je+=ye*vt,Ze+=ye*St,st+=ye*$t,at+=ye*Rt,ct+=ye*Tt,lt+=ye*It,ut+=ye*At,ht+=ye*Ct,dt+=ye*Pt,pt+=ye*kt,ye=De[9],nt+=ye*mt,et+=ye*yt,tt+=ye*_t,Qe+=ye*bt,Xe+=ye*Et,Je+=ye*wt,Ze+=ye*vt,st+=ye*St,at+=ye*$t,ct+=ye*Rt,lt+=ye*Tt,ut+=ye*It,ht+=ye*At,dt+=ye*Ct,pt+=ye*Pt,Dt+=ye*kt,ye=De[10],et+=ye*mt,tt+=ye*yt,Qe+=ye*_t,Xe+=ye*bt,Je+=ye*Et,Ze+=ye*wt,st+=ye*vt,at+=ye*St,ct+=ye*$t,lt+=ye*Rt,ut+=ye*Tt,ht+=ye*It,dt+=ye*At,pt+=ye*Ct,Dt+=ye*Pt,Nt+=ye*kt,ye=De[11],tt+=ye*mt,Qe+=ye*yt,Xe+=ye*_t,Je+=ye*bt,Ze+=ye*Et,st+=ye*wt,at+=ye*vt,ct+=ye*St,lt+=ye*$t,ut+=ye*Rt,ht+=ye*Tt,dt+=ye*It,pt+=ye*At,Dt+=ye*Ct,Nt+=ye*Pt,Mt+=ye*kt,ye=De[12],Qe+=ye*mt,Xe+=ye*yt,Je+=ye*_t,Ze+=ye*bt,st+=ye*Et,at+=ye*wt,ct+=ye*vt,lt+=ye*St,ut+=ye*$t,ht+=ye*Rt,dt+=ye*Tt,pt+=ye*It,Dt+=ye*At,Nt+=ye*Ct,Mt+=ye*Pt,Lt+=ye*kt,ye=De[13],Xe+=ye*mt,Je+=ye*yt,Ze+=ye*_t,st+=ye*bt,at+=ye*Et,ct+=ye*wt,lt+=ye*vt,ut+=ye*St,ht+=ye*$t,dt+=ye*Rt,pt+=ye*Tt,Dt+=ye*It,Nt+=ye*At,Mt+=ye*Ct,Lt+=ye*Pt,Ot+=ye*kt,ye=De[14],Je+=ye*mt,Ze+=ye*yt,st+=ye*_t,at+=ye*bt,ct+=ye*Et,lt+=ye*wt,ut+=ye*vt,ht+=ye*St,dt+=ye*$t,pt+=ye*Rt,Dt+=ye*Tt,Nt+=ye*It,Mt+=ye*At,Lt+=ye*Ct,Ot+=ye*Pt,Bt+=ye*kt,ye=De[15],Ze+=ye*mt,st+=ye*yt,at+=ye*_t,ct+=ye*bt,lt+=ye*Et,ut+=ye*wt,ht+=ye*vt,dt+=ye*St,pt+=ye*$t,Dt+=ye*Rt,Nt+=ye*Tt,Mt+=ye*It,Lt+=ye*At,Ot+=ye*Ct,Bt+=ye*Pt,Ft+=ye*kt,Ke+=38*st,He+=38*at,qe+=38*ct,Ye+=38*lt,rt+=38*ut,ot+=38*ht,ft+=38*dt,gt+=38*pt,it+=38*Dt,nt+=38*Nt,et+=38*Mt,tt+=38*Lt,Qe+=38*Ot,Xe+=38*Bt,Je+=38*Ft,Re=1,ye=Ke+Re+65535,Re=Math.floor(ye/65536),Ke=ye-Re*65536,ye=He+Re+65535,Re=Math.floor(ye/65536),He=ye-Re*65536,ye=qe+Re+65535,Re=Math.floor(ye/65536),qe=ye-Re*65536,ye=Ye+Re+65535,Re=Math.floor(ye/65536),Ye=ye-Re*65536,ye=rt+Re+65535,Re=Math.floor(ye/65536),rt=ye-Re*65536,ye=ot+Re+65535,Re=Math.floor(ye/65536),ot=ye-Re*65536,ye=ft+Re+65535,Re=Math.floor(ye/65536),ft=ye-Re*65536,ye=gt+Re+65535,Re=Math.floor(ye/65536),gt=ye-Re*65536,ye=it+Re+65535,Re=Math.floor(ye/65536),it=ye-Re*65536,ye=nt+Re+65535,Re=Math.floor(ye/65536),nt=ye-Re*65536,ye=et+Re+65535,Re=Math.floor(ye/65536),et=ye-Re*65536,ye=tt+Re+65535,Re=Math.floor(ye/65536),tt=ye-Re*65536,ye=Qe+Re+65535,Re=Math.floor(ye/65536),Qe=ye-Re*65536,ye=Xe+Re+65535,Re=Math.floor(ye/65536),Xe=ye-Re*65536,ye=Je+Re+65535,Re=Math.floor(ye/65536),Je=ye-Re*65536,ye=Ze+Re+65535,Re=Math.floor(ye/65536),Ze=ye-Re*65536,Ke+=Re-1+37*(Re-1),Re=1,ye=Ke+Re+65535,Re=Math.floor(ye/65536),Ke=ye-Re*65536,ye=He+Re+65535,Re=Math.floor(ye/65536),He=ye-Re*65536,ye=qe+Re+65535,Re=Math.floor(ye/65536),qe=ye-Re*65536,ye=Ye+Re+65535,Re=Math.floor(ye/65536),Ye=ye-Re*65536,ye=rt+Re+65535,Re=Math.floor(ye/65536),rt=ye-Re*65536,ye=ot+Re+65535,Re=Math.floor(ye/65536),ot=ye-Re*65536,ye=ft+Re+65535,Re=Math.floor(ye/65536),ft=ye-Re*65536,ye=gt+Re+65535,Re=Math.floor(ye/65536),gt=ye-Re*65536,ye=it+Re+65535,Re=Math.floor(ye/65536),it=ye-Re*65536,ye=nt+Re+65535,Re=Math.floor(ye/65536),nt=ye-Re*65536,ye=et+Re+65535,Re=Math.floor(ye/65536),et=ye-Re*65536,ye=tt+Re+65535,Re=Math.floor(ye/65536),tt=ye-Re*65536,ye=Qe+Re+65535,Re=Math.floor(ye/65536),Qe=ye-Re*65536,ye=Xe+Re+65535,Re=Math.floor(ye/65536),Xe=ye-Re*65536,ye=Je+Re+65535,Re=Math.floor(ye/65536),Je=ye-Re*65536,ye=Ze+Re+65535,Re=Math.floor(ye/65536),Ze=ye-Re*65536,Ke+=Re-1+37*(Re-1),Ae[0]=Ke,Ae[1]=He,Ae[2]=qe,Ae[3]=Ye,Ae[4]=rt,Ae[5]=ot,Ae[6]=ft,Ae[7]=gt,Ae[8]=it,Ae[9]=nt,Ae[10]=et,Ae[11]=tt,Ae[12]=Qe,Ae[13]=Xe,Ae[14]=Je,Ae[15]=Ze}function Se(Ae,De){ge(Ae,De,De)}function $e(Ae,De){const Ie=re();let ye;for(ye=0;ye<16;ye++)Ie[ye]=De[ye];for(ye=253;ye>=0;ye--)Se(Ie,Ie),ye!==2&&ye!==4&&ge(Ie,Ie,De);for(ye=0;ye<16;ye++)Ae[ye]=Ie[ye]}function Pe(Ae,De){const Ie=re();let ye;for(ye=0;ye<16;ye++)Ie[ye]=De[ye];for(ye=250;ye>=0;ye--)Se(Ie,Ie),ye!==1&&ge(Ie,Ie,De);for(ye=0;ye<16;ye++)Ae[ye]=Ie[ye]}function Me(Ae,De){const Ie=re(),ye=re(),Re=re(),Ke=re(),He=re(),qe=re(),Ye=re(),rt=re(),ot=re();we(Ie,Ae[1],Ae[0]),we(ot,De[1],De[0]),ge(Ie,Ie,ot),ve(ye,Ae[0],Ae[1]),ve(ot,De[0],De[1]),ge(ye,ye,ot),ge(Re,Ae[3],De[3]),ge(Re,Re,ce),ge(Ke,Ae[2],De[2]),ve(Ke,Ke,Ke),we(He,ye,Ie),we(qe,Ke,Re),ve(Ye,Ke,Re),ve(rt,ye,Ie),ge(Ae[0],He,qe),ge(Ae[1],rt,Ye),ge(Ae[2],Ye,qe),ge(Ae[3],He,rt)}function xe(Ae,De,Ie){for(let ye=0;ye<4;ye++)de(Ae[ye],De[ye],Ie)}function Fe(Ae,De){const Ie=re(),ye=re(),Re=re();$e(Re,De[2]),ge(Ie,De[0],Re),ge(ye,De[1],Re),fe(Ae,ye),Ae[31]^=be(Ie)<<7}function ke(Ae,De,Ie){he(Ae[0],ie),he(Ae[1],se),he(Ae[2],se),he(Ae[3],ie);for(let ye=255;ye>=0;--ye){const Re=Ie[ye/8|0]>>(ye&7)&1;xe(Ae,De,Re),Me(De,Ae),Me(Ae,Ae),xe(Ae,De,Re)}}function Te(Ae,De){const Ie=[re(),re(),re(),re()];he(Ie[0],ae),he(Ie[1],le),he(Ie[2],se),ge(Ie[3],ae,le),ke(Ae,Ie,De)}function Ve(Ae){if(Ae.length!==J.SEED_LENGTH)throw new Error(`ed25519: seed must be ${J.SEED_LENGTH} bytes`);const De=(0,ee.hash)(Ae);De[0]&=248,De[31]&=127,De[31]|=64;const Ie=new Uint8Array(32),ye=[re(),re(),re(),re()];Te(ye,De),Fe(Ie,ye);const Re=new Uint8Array(64);return Re.set(Ae),Re.set(Ie,32),{publicKey:Ie,secretKey:Re}}J.generateKeyPairFromSeed=Ve;function Ce(Ae){const De=(0,E.randomBytes)(32,Ae),Ie=Ve(De);return(0,te.wipe)(De),Ie}J.generateKeyPair=Ce;function Ne(Ae){if(Ae.length!==J.SECRET_KEY_LENGTH)throw new Error(`ed25519: secret key must be ${J.SECRET_KEY_LENGTH} bytes`);return new Uint8Array(Ae.subarray(32))}J.extractPublicKeyFromSecretKey=Ne;const Oe=new Float64Array([237,211,245,92,26,99,18,88,214,156,247,162,222,249,222,20,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16]);function Le(Ae,De){let Ie,ye,Re,Ke;for(ye=63;ye>=32;--ye){for(Ie=0,Re=ye-32,Ke=ye-12;Re<Ke;++Re)De[Re]+=Ie-16*De[ye]*Oe[Re-(ye-32)],Ie=Math.floor((De[Re]+128)/256),De[Re]-=Ie*256;De[Re]+=Ie,De[ye]=0}for(Ie=0,Re=0;Re<32;Re++)De[Re]+=Ie-(De[31]>>4)*Oe[Re],Ie=De[Re]>>8,De[Re]&=255;for(Re=0;Re<32;Re++)De[Re]-=Ie*Oe[Re];for(ye=0;ye<32;ye++)De[ye+1]+=De[ye]>>8,Ae[ye]=De[ye]&255}function Be(Ae){const De=new Float64Array(64);for(let Ie=0;Ie<64;Ie++)De[Ie]=Ae[Ie];for(let Ie=0;Ie<64;Ie++)Ae[Ie]=0;Le(Ae,De)}function ze(Ae,De){const Ie=new Float64Array(64),ye=[re(),re(),re(),re()],Re=(0,ee.hash)(Ae.subarray(0,32));Re[0]&=248,Re[31]&=127,Re[31]|=64;const Ke=new Uint8Array(64);Ke.set(Re.subarray(32),32);const He=new ee.SHA512;He.update(Ke.subarray(32)),He.update(De);const qe=He.digest();He.clean(),Be(qe),Te(ye,qe),Fe(Ke,ye),He.reset(),He.update(Ke.subarray(0,32)),He.update(Ae.subarray(32)),He.update(De);const Ye=He.digest();Be(Ye);for(let rt=0;rt<32;rt++)Ie[rt]=qe[rt];for(let rt=0;rt<32;rt++)for(let ot=0;ot<32;ot++)Ie[rt+ot]+=Ye[rt]*Re[ot];return Le(Ke.subarray(32),Ie),Ke}J.sign=ze;function Ue(Ae,De){const Ie=re(),ye=re(),Re=re(),Ke=re(),He=re(),qe=re(),Ye=re();return he(Ae[2],se),Ee(Ae[1],De),Se(Re,Ae[1]),ge(Ke,Re,oe),we(Re,Re,Ae[2]),ve(Ke,Ae[2],Ke),Se(He,Ke),Se(qe,He),ge(Ye,qe,He),ge(Ie,Ye,Re),ge(Ie,Ie,Ke),Pe(Ie,Ie),ge(Ie,Ie,Re),ge(Ie,Ie,Ke),ge(Ie,Ie,Ke),ge(Ae[0],Ie,Ke),Se(ye,Ae[0]),ge(ye,ye,Ke),_e(ye,Re)&&ge(Ae[0],Ae[0],ue),Se(ye,Ae[0]),ge(ye,ye,Ke),_e(ye,Re)?-1:(be(Ae[0])===De[31]>>7&&we(Ae[0],ie,Ae[0]),ge(Ae[3],Ae[0],Ae[1]),0)}function Ge(Ae,De,Ie){const ye=new Uint8Array(32),Re=[re(),re(),re(),re()],Ke=[re(),re(),re(),re()];if(Ie.length!==J.SIGNATURE_LENGTH)throw new Error(`ed25519: signature must be ${J.SIGNATURE_LENGTH} bytes`);if(Ue(Ke,Ae))return!1;const He=new ee.SHA512;He.update(Ie.subarray(0,32)),He.update(Ae),He.update(De);const qe=He.digest();return Be(qe),ke(Re,Ke,qe),Te(Ke,Ie.subarray(32)),Me(Re,Ke),Fe(ye,Re),!me(Ie,ye)}J.verify=Ge;function je(Ae){let De=[re(),re(),re(),re()];if(Ue(De,Ae))throw new Error("Ed25519: invalid public key");let Ie=re(),ye=re(),Re=De[1];ve(Ie,se,Re),we(ye,se,Re),$e(ye,ye),ge(Ie,Ie,ye);let Ke=new Uint8Array(32);return fe(Ke,Ie),Ke}J.convertPublicKeyToX25519=je;function We(Ae){const De=(0,ee.hash)(Ae.subarray(0,32));De[0]&=248,De[31]&=127,De[31]|=64;const Ie=new Uint8Array(De.subarray(0,32));return(0,te.wipe)(De),Ie}J.convertSecretKeyToX25519=We})(ed25519$1);const ed25519=getDefaultExportFromCjs(ed25519$1);function asUint8Array$2(J){return globalThis.Buffer!=null?new Uint8Array(J.buffer,J.byteOffset,J.byteLength):J}function allocUnsafe$6(J=0){return globalThis.Buffer?.allocUnsafe!=null?asUint8Array$2(globalThis.Buffer.allocUnsafe(J)):new Uint8Array(J)}function concat$5(J,E){E==null&&(E=J.reduce((re,ne)=>re+ne.length,0));const ee=allocUnsafe$6(E);let te=0;for(const re of J)ee.set(re,te),te+=re.length;return asUint8Array$2(ee)}function equals$3(J,E){if(J===E)return!0;if(J.byteLength!==E.byteLength)return!1;for(let ee=0;ee<J.byteLength;ee++)if(J[ee]!==E[ee])return!1;return!0}function base$5(J,E){if(J.length>=255)throw new TypeError("Alphabet too long");for(var ee=new Uint8Array(256),te=0;te<ee.length;te++)ee[te]=255;for(var re=0;re<J.length;re++){var ne=J.charAt(re),ie=ne.charCodeAt(0);if(ee[ie]!==255)throw new TypeError(ne+" is ambiguous");ee[ie]=re}var se=J.length,oe=J.charAt(0),ce=Math.log(se)/Math.log(256),ae=Math.log(256)/Math.log(se);function le(pe){if(pe instanceof Uint8Array||(ArrayBuffer.isView(pe)?pe=new Uint8Array(pe.buffer,pe.byteOffset,pe.byteLength):Array.isArray(pe)&&(pe=Uint8Array.from(pe))),!(pe instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(pe.length===0)return"";for(var de=0,fe=0,me=0,_e=pe.length;me!==_e&&pe[me]===0;)me++,de++;for(var be=(_e-me)*ae+1>>>0,Ee=new Uint8Array(be);me!==_e;){for(var ve=pe[me],we=0,ge=be-1;(ve!==0||we<fe)&&ge!==-1;ge--,we++)ve+=256*Ee[ge]>>>0,Ee[ge]=ve%se>>>0,ve=ve/se>>>0;if(ve!==0)throw new Error("Non-zero carry");fe=we,me++}for(var Se=be-fe;Se!==be&&Ee[Se]===0;)Se++;for(var $e=oe.repeat(de);Se<be;++Se)$e+=J.charAt(Ee[Se]);return $e}function ue(pe){if(typeof pe!="string")throw new TypeError("Expected String");if(pe.length===0)return new Uint8Array;var de=0;if(pe[de]!==" "){for(var fe=0,me=0;pe[de]===oe;)fe++,de++;for(var _e=(pe.length-de)*ce+1>>>0,be=new Uint8Array(_e);pe[de];){var Ee=ee[pe.charCodeAt(de)];if(Ee===255)return;for(var ve=0,we=_e-1;(Ee!==0||ve<me)&&we!==-1;we--,ve++)Ee+=se*be[we]>>>0,be[we]=Ee%256>>>0,Ee=Ee/256>>>0;if(Ee!==0)throw new Error("Non-zero carry");me=ve,de++}if(pe[de]!==" "){for(var ge=_e-me;ge!==_e&&be[ge]===0;)ge++;for(var Se=new Uint8Array(fe+(_e-ge)),$e=fe;ge!==_e;)Se[$e++]=be[ge++];return Se}}}function he(pe){var de=ue(pe);if(de)return de;throw new Error(`Non-${E} character`)}return{encode:le,decodeUnsafe:ue,decode:he}}var src$6=base$5,_brrp__multiformats_scope_baseX$2=src$6;const coerce$2=J=>{if(J instanceof Uint8Array&&J.constructor.name==="Uint8Array")return J;if(J instanceof ArrayBuffer)return new Uint8Array(J);if(ArrayBuffer.isView(J))return new Uint8Array(J.buffer,J.byteOffset,J.byteLength);throw new Error("Unknown type, must be binary type")},fromString$8=J=>new TextEncoder().encode(J),toString$8=J=>new TextDecoder().decode(J);let Encoder$4=class{constructor(J,E,ee){this.name=J,this.prefix=E,this.baseEncode=ee}encode(J){if(J instanceof Uint8Array)return`${this.prefix}${this.baseEncode(J)}`;throw Error("Unknown type, must be binary type")}},Decoder$6=class{constructor(J,E,ee){if(this.name=J,this.prefix=E,E.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=E.codePointAt(0),this.baseDecode=ee}decode(J){if(typeof J=="string"){if(J.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(J)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(J.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(J){return or$3(this,J)}},ComposedDecoder$2=class{constructor(J){this.decoders=J}or(J){return or$3(this,J)}decode(J){const E=J[0],ee=this.decoders[E];if(ee)return ee.decode(J);throw RangeError(`Unable to decode multibase string ${JSON.stringify(J)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};const or$3=(J,E)=>new ComposedDecoder$2({...J.decoders||{[J.prefix]:J},...E.decoders||{[E.prefix]:E}});let Codec$2=class{constructor(J,E,ee,te){this.name=J,this.prefix=E,this.baseEncode=ee,this.baseDecode=te,this.encoder=new Encoder$4(J,E,ee),this.decoder=new Decoder$6(J,E,te)}encode(J){return this.encoder.encode(J)}decode(J){return this.decoder.decode(J)}};const from$3=({name:J,prefix:E,encode:ee,decode:te})=>new Codec$2(J,E,ee,te),baseX$3=({prefix:J,name:E,alphabet:ee})=>{const{encode:te,decode:re}=_brrp__multiformats_scope_baseX$2(ee,E);return from$3({prefix:J,name:E,encode:te,decode:ne=>coerce$2(re(ne))})},decode$k=(J,E,ee,te)=>{const re={};for(let ae=0;ae<E.length;++ae)re[E[ae]]=ae;let ne=J.length;for(;J[ne-1]==="=";)--ne;const ie=new Uint8Array(ne*ee/8|0);let se=0,oe=0,ce=0;for(let ae=0;ae<ne;++ae){const le=re[J[ae]];if(le===void 0)throw new SyntaxError(`Non-${te} character`);oe=oe<<ee|le,se+=ee,se>=8&&(se-=8,ie[ce++]=255&oe>>se)}if(se>=ee||255&oe<<8-se)throw new SyntaxError("Unexpected end of data");return ie},encode$j=(J,E,ee)=>{const te=E[E.length-1]==="=",re=(1<<ee)-1;let ne="",ie=0,se=0;for(let oe=0;oe<J.length;++oe)for(se=se<<8|J[oe],ie+=8;ie>ee;)ie-=ee,ne+=E[re&se>>ie];if(ie&&(ne+=E[re&se<<ee-ie]),te)for(;ne.length*ee&7;)ne+="=";return ne},rfc4648$4=({name:J,prefix:E,bitsPerChar:ee,alphabet:te})=>from$3({prefix:E,name:J,encode(re){return encode$j(re,te,ee)},decode(re){return decode$k(re,te,ee,J)}}),identity$4=from$3({prefix:"\0",name:"identity",encode:J=>toString$8(J),decode:J=>fromString$8(J)}),identityBase$2=Object.freeze(Object.defineProperty({__proto__:null,identity:identity$4},Symbol.toStringTag,{value:"Module"})),base2$4=rfc4648$4({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),base2$5=Object.freeze(Object.defineProperty({__proto__:null,base2:base2$4},Symbol.toStringTag,{value:"Module"})),base8$4=rfc4648$4({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),base8$5=Object.freeze(Object.defineProperty({__proto__:null,base8:base8$4},Symbol.toStringTag,{value:"Module"})),base10$4=baseX$3({prefix:"9",name:"base10",alphabet:"0123456789"}),base10$5=Object.freeze(Object.defineProperty({__proto__:null,base10:base10$4},Symbol.toStringTag,{value:"Module"})),base16$4=rfc4648$4({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),base16upper$2=rfc4648$4({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),base16$5=Object.freeze(Object.defineProperty({__proto__:null,base16:base16$4,base16upper:base16upper$2},Symbol.toStringTag,{value:"Module"})),base32$4=rfc4648$4({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),base32upper$2=rfc4648$4({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),base32pad$2=rfc4648$4({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),base32padupper$2=rfc4648$4({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),base32hex$2=rfc4648$4({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),base32hexupper$2=rfc4648$4({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),base32hexpad$2=rfc4648$4({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),base32hexpadupper$2=rfc4648$4({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),base32z$2=rfc4648$4({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),base32$5=Object.freeze(Object.defineProperty({__proto__:null,base32:base32$4,base32hex:base32hex$2,base32hexpad:base32hexpad$2,base32hexpadupper:base32hexpadupper$2,base32hexupper:base32hexupper$2,base32pad:base32pad$2,base32padupper:base32padupper$2,base32upper:base32upper$2,base32z:base32z$2},Symbol.toStringTag,{value:"Module"})),base36$4=baseX$3({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),base36upper$2=baseX$3({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),base36$5=Object.freeze(Object.defineProperty({__proto__:null,base36:base36$4,base36upper:base36upper$2},Symbol.toStringTag,{value:"Module"})),base58btc$2=baseX$3({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),base58flickr$2=baseX$3({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),base58$2=Object.freeze(Object.defineProperty({__proto__:null,base58btc:base58btc$2,base58flickr:base58flickr$2},Symbol.toStringTag,{value:"Module"})),base64$6=rfc4648$4({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),base64pad$2=rfc4648$4({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),base64url$2=rfc4648$4({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),base64urlpad$2=rfc4648$4({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),base64$7=Object.freeze(Object.defineProperty({__proto__:null,base64:base64$6,base64pad:base64pad$2,base64url:base64url$2,base64urlpad:base64urlpad$2},Symbol.toStringTag,{value:"Module"})),alphabet$2=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),alphabetBytesToChars$2=alphabet$2.reduce((J,E,ee)=>(J[ee]=E,J),[]),alphabetCharsToBytes$2=alphabet$2.reduce((J,E,ee)=>(J[E.codePointAt(0)]=ee,J),[]);function encode$i(J){return J.reduce((E,ee)=>(E+=alphabetBytesToChars$2[ee],E),"")}function decode$j(J){const E=[];for(const ee of J){const te=alphabetCharsToBytes$2[ee.codePointAt(0)];if(te===void 0)throw new Error(`Non-base256emoji character: ${ee}`);E.push(te)}return new Uint8Array(E)}const base256emoji$4=from$3({prefix:"🚀",name:"base256emoji",encode:encode$i,decode:decode$j}),base256emoji$5=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:base256emoji$4},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const bases$2={...identityBase$2,...base2$5,...base8$5,...base10$5,...base16$5,...base32$5,...base36$5,...base58$2,...base64$7,...base256emoji$5};function createCodec$3(J,E,ee,te){return{name:J,prefix:E,encoder:{name:J,prefix:E,encode:ee},decoder:{decode:te}}}const string$2=createCodec$3("utf8","u",J=>"u"+new TextDecoder("utf8").decode(J),J=>new TextEncoder().encode(J.substring(1))),ascii$2=createCodec$3("ascii","a",J=>{let E="a";for(let ee=0;ee<J.length;ee++)E+=String.fromCharCode(J[ee]);return E},J=>{J=J.substring(1);const E=allocUnsafe$6(J.length);for(let ee=0;ee<J.length;ee++)E[ee]=J.charCodeAt(ee);return E}),BASES$2={utf8:string$2,"utf-8":string$2,hex:bases$2.base16,latin1:ascii$2,ascii:ascii$2,binary:ascii$2,...bases$2};function fromString$7(J,E="utf8"){const ee=BASES$2[E];if(ee==null)throw new Error(`Unsupported encoding "${E}"`);return(E==="utf8"||E==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?asUint8Array$2(globalThis.Buffer.from(J,"utf-8")):ee.decoder.decode(`${ee.prefix}${J}`)}function toString$7(J,E="utf8"){const ee=BASES$2[E];if(ee==null)throw new Error(`Unsupported encoding "${E}"`);return(E==="utf8"||E==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(J.buffer,J.byteOffset,J.byteLength).toString("utf8"):ee.encoder.encode(J).substring(1)}const{Kem,Kdf,Aead,CipherSuite}=hpke,EMPTY_SALT=new Uint8Array(0),LABEL_CHANNEL_ID=new TextEncoder().encode("channel_id"),EXPORT_LABEL_NONCE=new TextEncoder().encode("5edm nonce"),EXPORT_LABEL_KEY=new TextEncoder().encode("5edm key"),EXPORT_LABEL_SESSIONID_RECIPIENT=new TextEncoder().encode("5edm recipient session id"),EXPORT_LABEL_SESSIONID_SENDER=new TextEncoder().encode("5edm sender session id"),concatBuffers=function(J,E){return concat$5([new Uint8Array(J),new Uint8Array(E)])};class Encrypter{constructor(E=new CipherSuite({kem:Kem.DhkemX25519HkdfSha256,kdf:Kdf.HkdfSha256,aead:Aead.Aes256Gcm})){this.suite=E}sessionId;toSessionId;context;async seal(E,ee){if(!this.context||!this.toSessionId)throw new Error("CryptoContext not initialized");const te=ee?concatBuffers(this.toSessionId,ee):this.toSessionId;return{header:te,payload:await this.context.seal(E,te)}}async open(E,ee,te){if(!this.context)throw new Error("CryptoContext not initialized");const re=te?concatBuffers(ee,te):ee;try{return await this.context.open(E,re)}catch(ne){throw console.log("failed to decrypt.",ne),ne}}async deriveChannelId(E){const ee=await(await this.suite.kdfContext()).labeledExtract(EMPTY_SALT,LABEL_CHANNEL_ID,new Uint8Array(E)),te=new Uint8Array(16);return te.set(new Uint8Array(ee,0,16)),te.buffer}}class InitiatorCryptoContext extends Encrypter{#e;handshakeChannelId;async init(){const E=ed25519.generateKeyPair(),ee=ed25519.convertSecretKeyToX25519(E.secretKey);this.#e=await this.suite.importKey("raw",ee,!1);const te=E.publicKey,re=await this.deriveChannelId(te);return this.handshakeChannelId=re,{serializedPublicKey:te,handshakeChannelId:re}}async handleJoin(E){if(!this.#e)throw new Error("CryptoContext not initialized");const[ee,te]=E.header,[re,ne]=E.payload;let ie;try{ie=await this.suite.open({recipientKey:this.#e,enc:ee},te,ne)}catch(pe){throw console.log("failed to decrypt sender public key.",pe),pe}if(!ie)throw new Error("Could not decrypt handshake payload");const se=await this.suite.importKey("raw",ed25519.convertPublicKeyToX25519(new Uint8Array(ie))),oe=await this.suite.createRecipientContext({recipientKey:this.#e,enc:re,senderPublicKey:se}),ce=await oe.export(EXPORT_LABEL_KEY,32),ae=await oe.export(EXPORT_LABEL_NONCE,32),le=await oe.export(EXPORT_LABEL_SESSIONID_RECIPIENT,16),ue=await oe.export(EXPORT_LABEL_SESSIONID_SENDER,16);await oe.setupBidirectional(ce,ae),this.context=oe,this.sessionId=le,this.toSessionId=ue;let he=new ArrayBuffer(0);try{he=await this.context.open(ne,this.handshakeChannelId)}catch(pe){throw console.log("failed to decrypt.",pe),pe}return{plaintext:he,sessionId:le,toSessionId:ue}}}class JoinerCryptoContext extends Encrypter{toChannelId;async initSender(E,ee){const te=ed25519.generateKeyPair(),re=ed25519.convertSecretKeyToX25519(te.secretKey),ne=await this.suite.importKey("raw",re,!1),ie=await this.suite.importKey("raw",ed25519.convertPublicKeyToX25519(new Uint8Array(E))),se=await this.suite.createSenderContext({recipientPublicKey:ie,senderKey:ne}),oe=await se.export(EXPORT_LABEL_KEY,32),ce=await se.export(EXPORT_LABEL_NONCE,32),ae=await se.export(EXPORT_LABEL_SESSIONID_RECIPIENT,16),le=await se.export(EXPORT_LABEL_SESSIONID_SENDER,16);await se.setupBidirectional(oe,ce);const ue=await this.deriveChannelId(E);this.toChannelId=ue,this.sessionId=le,this.toSessionId=ae,this.context=se;const he=await this.context.seal(ee,ue),pe=te.publicKey,{ct:de,enc:fe}=await this.suite.seal({recipientPublicKey:ie},pe,he);return{toChannelId:ue,sessionId:le,toSessionId:ae,envelope:{payload:[se.enc,he],header:[fe,de]}}}}function encodeUrlParam(J){return base64$8.encodeURLSafe(new Uint8Array(J))}class EventStreamSource{constructor(E,ee,te){this.eventTarget=E,this.eventNames=ee,this.options=te}#e;#t={};start(E){for(const ee of this.eventNames)this.#t[ee]=te=>{E.enqueue(te)},this.eventTarget.addEventListener(ee,this.#t[ee]);this.#e=ee=>{this.options?.onError?this.options.onError(E,ee):E.enqueue(ee)},this.eventTarget.addEventListener("error",this.#e)}pull(){}cancel(){for(const E of Object.keys(this.#t))this.eventTarget.removeEventListener(E,this.#t[E]);this.#e&&this.eventTarget.removeEventListener("error",this.#e),this.options?.onCancel&&this.options?.onCancel(this.eventTarget)}}function streamAsyncIterator(J){return async function*(){const E=J.getReader();try{for(;;){const{done:ee,value:te}=await E.read();if(ee)return;yield te}}finally{E.releaseLock()}}()}let EventIterator$2=class{constructor(J,E,ee){this.eventTarget=J,this.#e=new EventStreamSource(this.eventTarget,E,ee),this.#t=new ReadableStream(this.#e)}#e;#t;#r;cancelSource(){this.#e.cancel()}[Symbol.asyncIterator](){return this.#r||(this.#r=streamAsyncIterator(this.#t)),this.#r}};class SseTransport{constructor(E="/api/sse?channelId=",ee=EventSource){this.baseUrl=E,this.EventSourceClass=ee}#e=[];listen(E){const ee=new this.EventSourceClass(`${this.baseUrl}${E}`),te=new EventIterator$2(ee,["open","message"],{onCancel:()=>ee.close()});return this.#e.push(te),te[Symbol.asyncIterator]()}close(){for(const E of this.#e)E.cancelSource();return this.#e=[],Promise.resolve()}}class FetchSenderTransport{constructor(E="/api/send?channelId="){this.baseUrl=E}send(E,ee){return this.#e(E,ee)}async#e(E,ee){let te=0;do{let re;try{return re=await fetch(`${this.baseUrl}${ee}`,{method:"POST",body:E}),{ok:re.ok,status:re.status,statusText:re.statusText}}catch(ne){console.warn(te,ne)}re?.ok||await new Promise(ne=>setTimeout(ne,1e3*te++))}while(te<5);throw new Error("could not send")}close(){return Promise.resolve()}}class HttpTransportCreator{constructor(E={baseSendApiUrl:"/api/send?channelId=",baseRecieveApiUrl:"/api/sse?channelId="},ee=FetchSenderTransport,te=SseTransport){this.options=E,this.SenderClass=ee,this.ReceiverClass=te}async createSenderTransport(E){return new this.SenderClass(E?.connectingAddress??this.options.baseSendApiUrl)}async createReceiverTransport(E){return new this.ReceiverClass(E?.connectingAddress??this.options.baseRecieveApiUrl)}}var browser$5={exports:{}},ms$1,hasRequiredMs;function requireMs(){if(hasRequiredMs)return ms$1;hasRequiredMs=1;var J=1e3,E=J*60,ee=E*60,te=ee*24,re=te*7,ne=te*365.25;ms$1=function(ae,le){le=le||{};var ue=typeof ae;if(ue==="string"&&ae.length>0)return ie(ae);if(ue==="number"&&isFinite(ae))return le.long?oe(ae):se(ae);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(ae))};function ie(ae){if(ae=String(ae),!(ae.length>100)){var le=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(ae);if(le){var ue=parseFloat(le[1]),he=(le[2]||"ms").toLowerCase();switch(he){case"years":case"year":case"yrs":case"yr":case"y":return ue*ne;case"weeks":case"week":case"w":return ue*re;case"days":case"day":case"d":return ue*te;case"hours":case"hour":case"hrs":case"hr":case"h":return ue*ee;case"minutes":case"minute":case"mins":case"min":case"m":return ue*E;case"seconds":case"second":case"secs":case"sec":case"s":return ue*J;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return ue;default:return}}}}function se(ae){var le=Math.abs(ae);return le>=te?Math.round(ae/te)+"d":le>=ee?Math.round(ae/ee)+"h":le>=E?Math.round(ae/E)+"m":le>=J?Math.round(ae/J)+"s":ae+"ms"}function oe(ae){var le=Math.abs(ae);return le>=te?ce(ae,le,te,"day"):le>=ee?ce(ae,le,ee,"hour"):le>=E?ce(ae,le,E,"minute"):le>=J?ce(ae,le,J,"second"):ae+" ms"}function ce(ae,le,ue,he){var pe=le>=ue*1.5;return Math.round(ae/ue)+" "+he+(pe?"s":"")}return ms$1}function setup(J){ee.debug=ee,ee.default=ee,ee.coerce=oe,ee.disable=ne,ee.enable=re,ee.enabled=ie,ee.humanize=requireMs(),ee.destroy=ce,Object.keys(J).forEach(ae=>{ee[ae]=J[ae]}),ee.names=[],ee.skips=[],ee.formatters={};function E(ae){let le=0;for(let ue=0;ue<ae.length;ue++)le=(le<<5)-le+ae.charCodeAt(ue),le|=0;return ee.colors[Math.abs(le)%ee.colors.length]}ee.selectColor=E;function ee(ae){let le,ue=null,he,pe;function de(...fe){if(!de.enabled)return;const me=de,_e=Number(new Date),be=_e-(le||_e);me.diff=be,me.prev=le,me.curr=_e,le=_e,fe[0]=ee.coerce(fe[0]),typeof fe[0]!="string"&&fe.unshift("%O");let Ee=0;fe[0]=fe[0].replace(/%([a-zA-Z%])/g,(ve,we)=>{if(ve==="%%")return"%";Ee++;const ge=ee.formatters[we];if(typeof ge=="function"){const Se=fe[Ee];ve=ge.call(me,Se),fe.splice(Ee,1),Ee--}return ve}),ee.formatArgs.call(me,fe),(me.log||ee.log).apply(me,fe)}return de.namespace=ae,de.useColors=ee.useColors(),de.color=ee.selectColor(ae),de.extend=te,de.destroy=ee.destroy,Object.defineProperty(de,"enabled",{enumerable:!0,configurable:!1,get:()=>ue!==null?ue:(he!==ee.namespaces&&(he=ee.namespaces,pe=ee.enabled(ae)),pe),set:fe=>{ue=fe}}),typeof ee.init=="function"&&ee.init(de),de}function te(ae,le){const ue=ee(this.namespace+(typeof le>"u"?":":le)+ae);return ue.log=this.log,ue}function re(ae){ee.save(ae),ee.namespaces=ae,ee.names=[],ee.skips=[];let le;const ue=(typeof ae=="string"?ae:"").split(/[\s,]+/),he=ue.length;for(le=0;le<he;le++)ue[le]&&(ae=ue[le].replace(/\*/g,".*?"),ae[0]==="-"?ee.skips.push(new RegExp("^"+ae.slice(1)+"$")):ee.names.push(new RegExp("^"+ae+"$")))}function ne(){const ae=[...ee.names.map(se),...ee.skips.map(se).map(le=>"-"+le)].join(",");return ee.enable(""),ae}function ie(ae){if(ae[ae.length-1]==="*")return!0;let le,ue;for(le=0,ue=ee.skips.length;le<ue;le++)if(ee.skips[le].test(ae))return!1;for(le=0,ue=ee.names.length;le<ue;le++)if(ee.names[le].test(ae))return!0;return!1}function se(ae){return ae.toString().substring(2,ae.toString().length-2).replace(/\.\*\?$/,"*")}function oe(ae){return ae instanceof Error?ae.stack||ae.message:ae}function ce(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return ee.enable(ee.load()),ee}var common=setup;(function(J,E){E.formatArgs=te,E.save=re,E.load=ne,E.useColors=ee,E.storage=ie(),E.destroy=(()=>{let oe=!1;return()=>{oe||(oe=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),E.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function ee(){return typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}function te(oe){if(oe[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+oe[0]+(this.useColors?"%c ":" ")+"+"+J.exports.humanize(this.diff),!this.useColors)return;const ce="color: "+this.color;oe.splice(1,0,ce,"color: inherit");let ae=0,le=0;oe[0].replace(/%[a-zA-Z%]/g,ue=>{ue!=="%%"&&(ae++,ue==="%c"&&(le=ae))}),oe.splice(le,0,ce)}E.log=console.debug||console.log||(()=>{});function re(oe){try{oe?E.storage.setItem("debug",oe):E.storage.removeItem("debug")}catch{}}function ne(){let oe;try{oe=E.storage.getItem("debug")}catch{}return!oe&&typeof process<"u"&&"env"in process&&(oe={}.DEBUG),oe}function ie(){try{return localStorage}catch{}}J.exports=common(E);const{formatters:se}=J.exports;se.j=function(oe){try{return JSON.stringify(oe)}catch(ce){return"[UnexpectedJSONParseError]: "+ce.message}}})(browser$5,browser$5.exports);var browserExports$1=browser$5.exports;const debug=getDefaultExportFromCjs(browserExports$1);function base$4(J,E){if(J.length>=255)throw new TypeError("Alphabet too long");for(var ee=new Uint8Array(256),te=0;te<ee.length;te++)ee[te]=255;for(var re=0;re<J.length;re++){var ne=J.charAt(re),ie=ne.charCodeAt(0);if(ee[ie]!==255)throw new TypeError(ne+" is ambiguous");ee[ie]=re}var se=J.length,oe=J.charAt(0),ce=Math.log(se)/Math.log(256),ae=Math.log(256)/Math.log(se);function le(pe){if(pe instanceof Uint8Array||(ArrayBuffer.isView(pe)?pe=new Uint8Array(pe.buffer,pe.byteOffset,pe.byteLength):Array.isArray(pe)&&(pe=Uint8Array.from(pe))),!(pe instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(pe.length===0)return"";for(var de=0,fe=0,me=0,_e=pe.length;me!==_e&&pe[me]===0;)me++,de++;for(var be=(_e-me)*ae+1>>>0,Ee=new Uint8Array(be);me!==_e;){for(var ve=pe[me],we=0,ge=be-1;(ve!==0||we<fe)&&ge!==-1;ge--,we++)ve+=256*Ee[ge]>>>0,Ee[ge]=ve%se>>>0,ve=ve/se>>>0;if(ve!==0)throw new Error("Non-zero carry");fe=we,me++}for(var Se=be-fe;Se!==be&&Ee[Se]===0;)Se++;for(var $e=oe.repeat(de);Se<be;++Se)$e+=J.charAt(Ee[Se]);return $e}function ue(pe){if(typeof pe!="string")throw new TypeError("Expected String");if(pe.length===0)return new Uint8Array;var de=0;if(pe[de]!==" "){for(var fe=0,me=0;pe[de]===oe;)fe++,de++;for(var _e=(pe.length-de)*ce+1>>>0,be=new Uint8Array(_e);pe[de];){var Ee=ee[pe.charCodeAt(de)];if(Ee===255)return;for(var ve=0,we=_e-1;(Ee!==0||ve<me)&&we!==-1;we--,ve++)Ee+=se*be[we]>>>0,be[we]=Ee%256>>>0,Ee=Ee/256>>>0;if(Ee!==0)throw new Error("Non-zero carry");me=ve,de++}if(pe[de]!==" "){for(var ge=_e-me;ge!==_e&&be[ge]===0;)ge++;for(var Se=new Uint8Array(fe+(_e-ge)),$e=fe;ge!==_e;)Se[$e++]=be[ge++];return Se}}}function he(pe){var de=ue(pe);if(de)return de;throw new Error(`Non-${E} character`)}return{encode:le,decodeUnsafe:ue,decode:he}}var src$5=base$4,_brrp__multiformats_scope_baseX$1=src$5;const empty=new Uint8Array(0),fromHex=J=>{const E=J.match(/../g);return E?new Uint8Array(E.map(ee=>parseInt(ee,16))):empty},equals$2=(J,E)=>{if(J===E)return!0;if(J.byteLength!==E.byteLength)return!1;for(let ee=0;ee<J.byteLength;ee++)if(J[ee]!==E[ee])return!1;return!0},coerce$1=J=>{if(J instanceof Uint8Array&&J.constructor.name==="Uint8Array")return J;if(J instanceof ArrayBuffer)return new Uint8Array(J);if(ArrayBuffer.isView(J))return new Uint8Array(J.buffer,J.byteOffset,J.byteLength);throw new Error("Unknown type, must be binary type")},fromString$6=J=>new TextEncoder().encode(J),toString$6=J=>new TextDecoder().decode(J);let Encoder$3=class{constructor(J,E,ee){this.name=J,this.prefix=E,this.baseEncode=ee}encode(J){if(J instanceof Uint8Array)return`${this.prefix}${this.baseEncode(J)}`;throw Error("Unknown type, must be binary type")}},Decoder$5=class{constructor(J,E,ee){if(this.name=J,this.prefix=E,E.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=E.codePointAt(0),this.baseDecode=ee}decode(J){if(typeof J=="string"){if(J.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(J)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(J.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(J){return or$2(this,J)}},ComposedDecoder$1=class{constructor(J){this.decoders=J}or(J){return or$2(this,J)}decode(J){const E=J[0],ee=this.decoders[E];if(ee)return ee.decode(J);throw RangeError(`Unable to decode multibase string ${JSON.stringify(J)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}};const or$2=(J,E)=>new ComposedDecoder$1({...J.decoders||{[J.prefix]:J},...E.decoders||{[E.prefix]:E}});let Codec$1=class{constructor(J,E,ee,te){this.name=J,this.prefix=E,this.baseEncode=ee,this.baseDecode=te,this.encoder=new Encoder$3(J,E,ee),this.decoder=new Decoder$5(J,E,te)}encode(J){return this.encoder.encode(J)}decode(J){return this.decoder.decode(J)}};const from$2=({name:J,prefix:E,encode:ee,decode:te})=>new Codec$1(J,E,ee,te),baseX$2=({prefix:J,name:E,alphabet:ee})=>{const{encode:te,decode:re}=_brrp__multiformats_scope_baseX$1(ee,E);return from$2({prefix:J,name:E,encode:te,decode:ne=>coerce$1(re(ne))})},decode$i=(J,E,ee,te)=>{const re={};for(let ae=0;ae<E.length;++ae)re[E[ae]]=ae;let ne=J.length;for(;J[ne-1]==="=";)--ne;const ie=new Uint8Array(ne*ee/8|0);let se=0,oe=0,ce=0;for(let ae=0;ae<ne;++ae){const le=re[J[ae]];if(le===void 0)throw new SyntaxError(`Non-${te} character`);oe=oe<<ee|le,se+=ee,se>=8&&(se-=8,ie[ce++]=255&oe>>se)}if(se>=ee||255&oe<<8-se)throw new SyntaxError("Unexpected end of data");return ie},encode$h=(J,E,ee)=>{const te=E[E.length-1]==="=",re=(1<<ee)-1;let ne="",ie=0,se=0;for(let oe=0;oe<J.length;++oe)for(se=se<<8|J[oe],ie+=8;ie>ee;)ie-=ee,ne+=E[re&se>>ie];if(ie&&(ne+=E[re&se<<ee-ie]),te)for(;ne.length*ee&7;)ne+="=";return ne},rfc4648$3=({name:J,prefix:E,bitsPerChar:ee,alphabet:te})=>from$2({prefix:E,name:J,encode(re){return encode$h(re,te,ee)},decode(re){return decode$i(re,te,ee,J)}}),base58btc$1=baseX$2({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),base58flickr$1=baseX$2({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),base58$1=Object.freeze(Object.defineProperty({__proto__:null,base58btc:base58btc$1,base58flickr:base58flickr$1},Symbol.toStringTag,{value:"Module"})),base32$2=rfc4648$3({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),base32upper$1=rfc4648$3({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),base32pad$1=rfc4648$3({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),base32padupper$1=rfc4648$3({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),base32hex$1=rfc4648$3({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),base32hexupper$1=rfc4648$3({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),base32hexpad$1=rfc4648$3({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),base32hexpadupper$1=rfc4648$3({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),base32z$1=rfc4648$3({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),base32$3=Object.freeze(Object.defineProperty({__proto__:null,base32:base32$2,base32hex:base32hex$1,base32hexpad:base32hexpad$1,base32hexpadupper:base32hexpadupper$1,base32hexupper:base32hexupper$1,base32pad:base32pad$1,base32padupper:base32padupper$1,base32upper:base32upper$1,base32z:base32z$1},Symbol.toStringTag,{value:"Module"})),base64$4=rfc4648$3({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),base64pad$1=rfc4648$3({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),base64url$1=rfc4648$3({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),base64urlpad$1=rfc4648$3({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),base64$5=Object.freeze(Object.defineProperty({__proto__:null,base64:base64$4,base64pad:base64pad$1,base64url:base64url$1,base64urlpad:base64urlpad$1},Symbol.toStringTag,{value:"Module"}));debug.formatters.b=J=>J==null?"undefined":base58btc$1.baseEncode(J);debug.formatters.t=J=>J==null?"undefined":base32$2.baseEncode(J);debug.formatters.m=J=>J==null?"undefined":base64$4.baseEncode(J);debug.formatters.p=J=>J==null?"undefined":J.toString();debug.formatters.c=J=>J==null?"undefined":J.toString();debug.formatters.k=J=>J==null?"undefined":J.toString();function createDisabledLogger(J){const E=()=>{};return E.enabled=!1,E.color="",E.diff=0,E.log=()=>{},E.namespace=J,E.destroy=()=>!0,E.extend=()=>E,E}function logger$1(J){let E=createDisabledLogger(`${J}:trace`);return debug.enabled(`${J}:trace`)&&debug.names.map(ee=>ee.toString()).find(ee=>ee.includes(":trace"))!=null&&(E=debug(`${J}:trace`)),Object.assign(debug(J),{error:debug(`${J}:error`),trace:E})}let EventEmitter$3=class extends EventTarget{#e=new Map;listenerCount(J){const E=this.#e.get(J);return E==null?0:E.length}addEventListener(J,E,ee){super.addEventListener(J,E,ee);let te=this.#e.get(J);te==null&&(te=[],this.#e.set(J,te)),te.push({callback:E,once:(ee!==!0&&ee!==!1&&ee?.once)??!1})}removeEventListener(J,E,ee){super.removeEventListener(J.toString(),E??null,ee);let te=this.#e.get(J);te!=null&&(te=te.filter(({callback:re})=>re!==E),this.#e.set(J,te))}dispatchEvent(J){const E=super.dispatchEvent(J);let ee=this.#e.get(J.type);return ee==null||(ee=ee.filter(({once:te})=>!te),this.#e.set(J.type,ee)),E}safeDispatchEvent(J,E){return this.dispatchEvent(new CustomEvent$2(J,E))}};class CustomEventPolyfill extends Event{detail;constructor(E,ee){super(E,ee),this.detail=ee?.detail}}const CustomEvent$2=globalThis.CustomEvent??CustomEventPolyfill;let AbortError$5=class xt extends Error{code;type;constructor(E="The operation was aborted"){super(E),this.code=xt.code,this.type=xt.type}static code="ABORT_ERR";static type="aborted"};class CodeError extends Error{code;props;constructor(E,ee,te){super(E),this.code=ee,this.name=te?.name??"CodeError",this.props=te??{}}}var encode_1$2=encode$g,MSB$6=128,REST$6=127,MSBALL$2=~REST$6,INT$2=Math.pow(2,31);function encode$g(J,E,ee){E=E||[],ee=ee||0;for(var te=ee;J>=INT$2;)E[ee++]=J&255|MSB$6,J/=128;for(;J&MSBALL$2;)E[ee++]=J&255|MSB$6,J>>>=7;return E[ee]=J|0,encode$g.bytes=ee-te+1,E}var decode$h=read$3,MSB$1$1=128,REST$1$1=127;function read$3(J,te){var ee=0,te=te||0,re=0,ne=te,ie,se=J.length;do{if(ne>=se)throw read$3.bytes=0,new RangeError("Could not decode varint");ie=J[ne++],ee+=re<28?(ie&REST$1$1)<<re:(ie&REST$1$1)*Math.pow(2,re),re+=7}while(ie>=MSB$1$1);return read$3.bytes=ne-te,ee}var N1$3=Math.pow(2,7),N2$3=Math.pow(2,14),N3$3=Math.pow(2,21),N4$3=Math.pow(2,28),N5$3=Math.pow(2,35),N6$3=Math.pow(2,42),N7$3=Math.pow(2,49),N8$3=Math.pow(2,56),N9$3=Math.pow(2,63),length$3=function(J){return J<N1$3?1:J<N2$3?2:J<N3$3?3:J<N4$3?4:J<N5$3?5:J<N6$3?6:J<N7$3?7:J<N8$3?8:J<N9$3?9:10},varint$5={encode:encode_1$2,decode:decode$h,encodingLength:length$3},_brrp_varint=varint$5;const decode$g=(J,E=0)=>[_brrp_varint.decode(J,E),_brrp_varint.decode.bytes],encodeTo=(J,E,ee=0)=>(_brrp_varint.encode(J,E,ee),E),encodingLength=J=>_brrp_varint.encodingLength(J),create$3=(J,E)=>{const ee=E.byteLength,te=encodingLength(J),re=te+encodingLength(ee),ne=new Uint8Array(re+ee);return encodeTo(J,ne,0),encodeTo(ee,ne,te),ne.set(E,re),new Digest(J,ee,E,ne)},decode$f=J=>{const E=coerce$1(J),[ee,te]=decode$g(E),[re,ne]=decode$g(E.subarray(te)),ie=E.subarray(te+ne);if(ie.byteLength!==re)throw new Error("Incorrect length");return new Digest(ee,re,ie,E)},equals$1=(J,E)=>{if(J===E)return!0;{const ee=E;return J.code===ee.code&&J.size===ee.size&&ee.bytes instanceof Uint8Array&&equals$2(J.bytes,ee.bytes)}};class Digest{constructor(E,ee,te,re){this.code=E,this.size=ee,this.digest=te,this.bytes=re}}const format$3=(J,E)=>{const{bytes:ee,version:te}=J;switch(te){case 0:return toStringV0(ee,baseCache(J),E||base58btc$1.encoder);default:return toStringV1(ee,baseCache(J),E||base32$2.encoder)}},cache$2=new WeakMap,baseCache=J=>{const E=cache$2.get(J);if(E==null){const ee=new Map;return cache$2.set(J,ee),ee}return E};class CID{constructor(E,ee,te,re){this.code=ee,this.version=E,this.multihash=te,this.bytes=re,this["/"]=re}get asCID(){return this}get byteOffset(){return this.bytes.byteOffset}get byteLength(){return this.bytes.byteLength}toV0(){switch(this.version){case 0:return this;case 1:{const{code:E,multihash:ee}=this;if(E!==DAG_PB_CODE)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(ee.code!==SHA_256_CODE)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return CID.createV0(ee)}default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}toV1(){switch(this.version){case 0:{const{code:E,digest:ee}=this.multihash,te=create$3(E,ee);return CID.createV1(this.code,te)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`)}}equals(E){return CID.equals(this,E)}static equals(E,ee){const te=ee;return te&&E.code===te.code&&E.version===te.version&&equals$1(E.multihash,te.multihash)}toString(E){return format$3(this,E)}toJSON(){return{"/":format$3(this)}}link(){return this}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return`CID(${this.toString()})`}static asCID(E){if(E==null)return null;const ee=E;if(ee instanceof CID)return ee;if(ee["/"]!=null&&ee["/"]===ee.bytes||ee.asCID===ee){const{version:te,code:re,multihash:ne,bytes:ie}=ee;return new CID(te,re,ne,ie||encodeCID(te,re,ne.bytes))}else if(ee[cidSymbol]===!0){const{version:te,multihash:re,code:ne}=ee,ie=decode$f(re);return CID.create(te,ne,ie)}else return null}static create(E,ee,te){if(typeof ee!="number")throw new Error("String codecs are no longer supported");if(!(te.bytes instanceof Uint8Array))throw new Error("Invalid digest");switch(E){case 0:{if(ee!==DAG_PB_CODE)throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);return new CID(E,ee,te,te.bytes)}case 1:{const re=encodeCID(E,ee,te.bytes);return new CID(E,ee,te,re)}default:throw new Error("Invalid version")}}static createV0(E){return CID.create(0,DAG_PB_CODE,E)}static createV1(E,ee){return CID.create(1,E,ee)}static decode(E){const[ee,te]=CID.decodeFirst(E);if(te.length)throw new Error("Incorrect length");return ee}static decodeFirst(E){const ee=CID.inspectBytes(E),te=ee.size-ee.multihashSize,re=coerce$1(E.subarray(te,te+ee.multihashSize));if(re.byteLength!==ee.multihashSize)throw new Error("Incorrect length");const ne=re.subarray(ee.multihashSize-ee.digestSize),ie=new Digest(ee.multihashCode,ee.digestSize,ne,re);return[ee.version===0?CID.createV0(ie):CID.createV1(ee.codec,ie),E.subarray(ee.size)]}static inspectBytes(E){let ee=0;const te=()=>{const[le,ue]=decode$g(E.subarray(ee));return ee+=ue,le};let re=te(),ne=DAG_PB_CODE;if(re===18?(re=0,ee=0):ne=te(),re!==0&&re!==1)throw new RangeError(`Invalid CID version ${re}`);const ie=ee,se=te(),oe=te(),ce=ee+oe,ae=ce-ie;return{version:re,codec:ne,multihashCode:se,digestSize:oe,multihashSize:ae,size:ce}}static parse(E,ee){const[te,re]=parseCIDtoBytes(E,ee),ne=CID.decode(re);if(ne.version===0&&E[0]!=="Q")throw Error("Version 0 CID string must not include multibase prefix");return baseCache(ne).set(te,E),ne}}const parseCIDtoBytes=(J,E)=>{switch(J[0]){case"Q":{const ee=E||base58btc$1;return[base58btc$1.prefix,ee.decode(`${base58btc$1.prefix}${J}`)]}case base58btc$1.prefix:{const ee=E||base58btc$1;return[base58btc$1.prefix,ee.decode(J)]}case base32$2.prefix:{const ee=E||base32$2;return[base32$2.prefix,ee.decode(J)]}default:{if(E==null)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[J[0],E.decode(J)]}}},toStringV0=(J,E,ee)=>{const{prefix:te}=ee;if(te!==base58btc$1.prefix)throw Error(`Cannot string encode V0 in ${ee.name} encoding`);const re=E.get(te);if(re==null){const ne=ee.encode(J).slice(1);return E.set(te,ne),ne}else return re},toStringV1=(J,E,ee)=>{const{prefix:te}=ee,re=E.get(te);if(re==null){const ne=ee.encode(J);return E.set(te,ne),ne}else return re},DAG_PB_CODE=112,SHA_256_CODE=18,encodeCID=(J,E,ee)=>{const te=encodingLength(J),re=te+encodingLength(E),ne=new Uint8Array(re+ee.byteLength);return encodeTo(J,ne,0),encodeTo(E,ne,te),ne.set(ee,re),ne},cidSymbol=Symbol.for("@ipld/js-cid/CID");function equals(J,E){if(J===E)return!0;if(J.byteLength!==E.byteLength)return!1;for(let ee=0;ee<J.byteLength;ee++)if(J[ee]!==E[ee])return!1;return!0}const identity$3=from$2({prefix:"\0",name:"identity",encode:J=>toString$6(J),decode:J=>fromString$6(J)}),identityBase$1=Object.freeze(Object.defineProperty({__proto__:null,identity:identity$3},Symbol.toStringTag,{value:"Module"})),base2$2=rfc4648$3({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),base2$3=Object.freeze(Object.defineProperty({__proto__:null,base2:base2$2},Symbol.toStringTag,{value:"Module"})),base8$2=rfc4648$3({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),base8$3=Object.freeze(Object.defineProperty({__proto__:null,base8:base8$2},Symbol.toStringTag,{value:"Module"})),base10$2=baseX$2({prefix:"9",name:"base10",alphabet:"0123456789"}),base10$3=Object.freeze(Object.defineProperty({__proto__:null,base10:base10$2},Symbol.toStringTag,{value:"Module"})),base16$2=rfc4648$3({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),base16upper$1=rfc4648$3({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),base16$3=Object.freeze(Object.defineProperty({__proto__:null,base16:base16$2,base16upper:base16upper$1},Symbol.toStringTag,{value:"Module"})),base36$2=baseX$2({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),base36upper$1=baseX$2({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),base36$3=Object.freeze(Object.defineProperty({__proto__:null,base36:base36$2,base36upper:base36upper$1},Symbol.toStringTag,{value:"Module"})),alphabet$1=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),alphabetBytesToChars$1=alphabet$1.reduce((J,E,ee)=>(J[ee]=E,J),[]),alphabetCharsToBytes$1=alphabet$1.reduce((J,E,ee)=>(J[E.codePointAt(0)]=ee,J),[]);function encode$f(J){return J.reduce((E,ee)=>(E+=alphabetBytesToChars$1[ee],E),"")}function decode$e(J){const E=[];for(const ee of J){const te=alphabetCharsToBytes$1[ee.codePointAt(0)];if(te===void 0)throw new Error(`Non-base256emoji character: ${ee}`);E.push(te)}return new Uint8Array(E)}const base256emoji$2=from$2({prefix:"🚀",name:"base256emoji",encode:encode$f,decode:decode$e}),base256emoji$3=Object.freeze(Object.defineProperty({__proto__:null,base256emoji:base256emoji$2},Symbol.toStringTag,{value:"Module"})),from$1=({name:J,code:E,encode:ee})=>new Hasher(J,E,ee);class Hasher{constructor(E,ee,te){this.name=E,this.code=ee,this.encode=te}digest(E){if(E instanceof Uint8Array){const ee=this.encode(E);return ee instanceof Uint8Array?create$3(this.code,ee):ee.then(te=>create$3(this.code,te))}else throw Error("Unknown type, must be binary type")}}const sha=J=>async E=>new Uint8Array(await crypto.subtle.digest(J,E)),sha256$3=from$1({name:"sha2-256",code:18,encode:sha("SHA-256")}),sha512$1=from$1({name:"sha2-512",code:19,encode:sha("SHA-512")}),code$3=0,name$3="identity",encode$e=coerce$1,digest=J=>create$3(code$3,encode$e(J)),identity$2={code:code$3,name:name$3,encode:encode$e,digest},name$2="raw",code$2=85,encode$d=J=>coerce$1(J),decode$d=J=>coerce$1(J),raw=Object.freeze(Object.defineProperty({__proto__:null,code:code$2,decode:decode$d,encode:encode$d,name:name$2},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const bases$1={...identityBase$1,...base2$3,...base8$3,...base10$3,...base16$3,...base32$3,...base36$3,...base58$1,...base64$5,...base256emoji$3};function asUint8Array$1(J){return globalThis.Buffer!=null?new Uint8Array(J.buffer,J.byteOffset,J.byteLength):J}function alloc$1(J=0){return globalThis.Buffer?.alloc!=null?asUint8Array$1(globalThis.Buffer.alloc(J)):new Uint8Array(J)}function allocUnsafe$5(J=0){return globalThis.Buffer?.allocUnsafe!=null?asUint8Array$1(globalThis.Buffer.allocUnsafe(J)):new Uint8Array(J)}function createCodec$2(J,E,ee,te){return{name:J,prefix:E,encoder:{name:J,prefix:E,encode:ee},decoder:{decode:te}}}const string$1=createCodec$2("utf8","u",J=>"u"+new TextDecoder("utf8").decode(J),J=>new TextEncoder().encode(J.substring(1))),ascii$1=createCodec$2("ascii","a",J=>{let E="a";for(let ee=0;ee<J.length;ee++)E+=String.fromCharCode(J[ee]);return E},J=>{J=J.substring(1);const E=allocUnsafe$5(J.length);for(let ee=0;ee<J.length;ee++)E[ee]=J.charCodeAt(ee);return E}),BASES$1={utf8:string$1,"utf-8":string$1,hex:bases$1.base16,latin1:ascii$1,ascii:ascii$1,binary:ascii$1,...bases$1};function toString$5(J,E="utf8"){const ee=BASES$1[E];if(ee==null)throw new Error(`Unsupported encoding "${E}"`);return(E==="utf8"||E==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(J.buffer,J.byteOffset,J.byteLength).toString("utf8"):ee.encoder.encode(J).substring(1)}var encode_1$1=encode$c,MSB$5=128,REST$5=127,MSBALL$1=~REST$5,INT$1=Math.pow(2,31);function encode$c(J,E,ee){if(Number.MAX_SAFE_INTEGER&&J>Number.MAX_SAFE_INTEGER)throw encode$c.bytes=0,new RangeError("Could not encode varint");E=E||[],ee=ee||0;for(var te=ee;J>=INT$1;)E[ee++]=J&255|MSB$5,J/=128;for(;J&MSBALL$1;)E[ee++]=J&255|MSB$5,J>>>=7;return E[ee]=J|0,encode$c.bytes=ee-te+1,E}var decode$c=read$2,MSB$4=128,REST$4=127;function read$2(J,te){var ee=0,te=te||0,re=0,ne=te,ie,se=J.length;do{if(ne>=se||re>49)throw read$2.bytes=0,new RangeError("Could not decode varint");ie=J[ne++],ee+=re<28?(ie&REST$4)<<re:(ie&REST$4)*Math.pow(2,re),re+=7}while(ie>=MSB$4);return read$2.bytes=ne-te,ee}var N1$2=Math.pow(2,7),N2$2=Math.pow(2,14),N3$2=Math.pow(2,21),N4$2=Math.pow(2,28),N5$2=Math.pow(2,35),N6$2=Math.pow(2,42),N7$2=Math.pow(2,49),N8$2=Math.pow(2,56),N9$2=Math.pow(2,63),length$2=function(J){return J<N1$2?1:J<N2$2?2:J<N3$2?3:J<N4$2?4:J<N5$2?5:J<N6$2?6:J<N7$2?7:J<N8$2?8:J<N9$2?9:10},varint$3={encode:encode_1$1,decode:decode$c,encodingLength:length$2};const varint$4=getDefaultExportFromCjs(varint$3);function concat$4(J,E){E==null&&(E=J.reduce((re,ne)=>re+ne.length,0));const ee=allocUnsafe$5(E);let te=0;for(const re of J)ee.set(re,te),te+=re.length;return asUint8Array$1(ee)}class Parser{index=0;input="";new(E){return this.index=0,this.input=E,this}readAtomically(E){const ee=this.index,te=E();return te===void 0&&(this.index=ee),te}parseWith(E){const ee=E();if(this.index===this.input.length)return ee}peekChar(){if(!(this.index>=this.input.length))return this.input[this.index]}readChar(){if(!(this.index>=this.input.length))return this.input[this.index++]}readGivenChar(E){return this.readAtomically(()=>{const ee=this.readChar();if(ee===E)return ee})}readSeparator(E,ee,te){return this.readAtomically(()=>{if(!(ee>0&&this.readGivenChar(E)===void 0))return te()})}readNumber(E,ee,te,re){return this.readAtomically(()=>{let ne=0,ie=0;const se=this.peekChar();if(se===void 0)return;const oe=se==="0",ce=2**(8*re)-1;for(;;){const ae=this.readAtomically(()=>{const le=this.readChar();if(le===void 0)return;const ue=Number.parseInt(le,E);if(!Number.isNaN(ue))return ue});if(ae===void 0)break;if(ne*=E,ne+=ae,ne>ce||(ie+=1,ee!==void 0&&ie>ee))return}if(ie!==0)return!te&&oe&&ie>1?void 0:ne})}readIPv4Addr(){return this.readAtomically(()=>{const E=new Uint8Array(4);for(let ee=0;ee<E.length;ee++){const te=this.readSeparator(".",ee,()=>this.readNumber(10,3,!1,1));if(te===void 0)return;E[ee]=te}return E})}readIPv6Addr(){const E=ee=>{for(let te=0;te<ee.length/2;te++){const re=te*2;if(te<ee.length-3){const ie=this.readSeparator(":",te,()=>this.readIPv4Addr());if(ie!==void 0)return ee[re]=ie[0],ee[re+1]=ie[1],ee[re+2]=ie[2],ee[re+3]=ie[3],[re+4,!0]}const ne=this.readSeparator(":",te,()=>this.readNumber(16,4,!0,2));if(ne===void 0)return[re,!1];ee[re]=ne>>8,ee[re+1]=ne&255}return[ee.length,!1]};return this.readAtomically(()=>{const ee=new Uint8Array(16),[te,re]=E(ee);if(te===16)return ee;if(re||this.readGivenChar(":")===void 0||this.readGivenChar(":")===void 0)return;const ne=new Uint8Array(14),ie=16-(te+2),[se]=E(ne.subarray(0,ie));return ee.set(ne.subarray(0,se),16-se),ee})}readIPAddr(){return this.readIPv4Addr()??this.readIPv6Addr()}}const MAX_IPV6_LENGTH=45,MAX_IPV4_LENGTH=15,parser=new Parser;function parseIPv4(J){if(!(J.length>MAX_IPV4_LENGTH))return parser.new(J).parseWith(()=>parser.readIPv4Addr())}function parseIPv6(J){if(!(J.length>MAX_IPV6_LENGTH))return parser.new(J).parseWith(()=>parser.readIPv6Addr())}function parseIP(J){if(!(J.length>MAX_IPV6_LENGTH))return parser.new(J).parseWith(()=>parser.readIPAddr())}function fromString$5(J,E="utf8"){const ee=BASES$1[E];if(ee==null)throw new Error(`Unsupported encoding "${E}"`);return(E==="utf8"||E==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?asUint8Array$1(globalThis.Buffer.from(J,"utf-8")):ee.decoder.decode(`${ee.prefix}${J}`)}function isIPv4(J){return!!parseIPv4(J)}function isIPv6(J){return!!parseIPv6(J)}function isIP(J){return!!parseIP(J)}const isV4=isIPv4,isV6=isIPv6,toBytes$1=function(J){let E=0;if(J=J.toString().trim(),isV4(J)){const ee=new Uint8Array(E+4);return J.split(/\./g).forEach(te=>{ee[E++]=parseInt(te,10)&255}),ee}if(isV6(J)){const ee=J.split(":",8);let te;for(te=0;te<ee.length;te++){const ne=isV4(ee[te]);let ie;ne&&(ie=toBytes$1(ee[te]),ee[te]=toString$5(ie.slice(0,2),"base16")),ie!=null&&++te<8&&ee.splice(te,0,toString$5(ie.slice(2,4),"base16"))}if(ee[0]==="")for(;ee.length<8;)ee.unshift("0");else if(ee[ee.length-1]==="")for(;ee.length<8;)ee.push("0");else if(ee.length<8){for(te=0;te<ee.length&&ee[te]!=="";te++);const ne=[te,1];for(te=9-ee.length;te>0;te--)ne.push("0");ee.splice.apply(ee,ne)}const re=new Uint8Array(E+16);for(te=0;te<ee.length;te++){const ne=parseInt(ee[te],16);re[E++]=ne>>8&255,re[E++]=ne&255}return re}throw new Error("invalid ip address")},toString$4=function(J,E=0,ee){E=~~E,ee=ee??J.length-E;const te=new DataView(J.buffer);if(ee===4){const re=[];for(let ne=0;ne<ee;ne++)re.push(J[E+ne]);return re.join(".")}if(ee===16){const re=[];for(let ne=0;ne<ee;ne+=2)re.push(te.getUint16(E+ne).toString(16));return re.join(":").replace(/(^|:)0(:0)*:0(:|$)/,"$1::$3").replace(/:{3,4}/,"::")}return""},V=-1,names$3={},codes$9={},table=[[4,32,"ip4"],[6,16,"tcp"],[33,16,"dccp"],[41,128,"ip6"],[42,V,"ip6zone"],[43,8,"ipcidr"],[53,V,"dns",!0],[54,V,"dns4",!0],[55,V,"dns6",!0],[56,V,"dnsaddr",!0],[132,16,"sctp"],[273,16,"udp"],[275,0,"p2p-webrtc-star"],[276,0,"p2p-webrtc-direct"],[277,0,"p2p-stardust"],[280,0,"webrtc-direct"],[281,0,"webrtc"],[290,0,"p2p-circuit"],[301,0,"udt"],[302,0,"utp"],[400,V,"unix",!1,!0],[421,V,"ipfs"],[421,V,"p2p"],[443,0,"https"],[444,96,"onion"],[445,296,"onion3"],[446,V,"garlic64"],[448,0,"tls"],[449,V,"sni"],[460,0,"quic"],[461,0,"quic-v1"],[465,0,"webtransport"],[466,V,"certhash"],[477,0,"ws"],[478,0,"wss"],[479,0,"p2p-websocket-star"],[480,0,"http"],[777,V,"memory"]];table.forEach(J=>{const E=createProtocol(...J);codes$9[E.code]=E,names$3[E.name]=E});function createProtocol(J,E,ee,te,re){return{code:J,size:E,name:ee,resolvable:!!te,path:!!re}}function getProtocol(J){if(typeof J=="number"){if(codes$9[J]!=null)return codes$9[J];throw new Error(`no protocol with code: ${J}`)}else if(typeof J=="string"){if(names$3[J]!=null)return names$3[J];throw new Error(`no protocol with name: ${J}`)}throw new Error(`invalid protocol id type: ${typeof J}`)}getProtocol("ip4");getProtocol("ip6");getProtocol("ipcidr");function convertToString(J,E){switch(getProtocol(J).code){case 4:case 41:return bytes2ip(E);case 42:return bytes2str(E);case 6:case 273:case 33:case 132:return bytes2port(E).toString();case 53:case 54:case 55:case 56:case 400:case 449:case 777:return bytes2str(E);case 421:return bytes2mh(E);case 444:return bytes2onion(E);case 445:return bytes2onion(E);case 466:return bytes2mb(E);default:return toString$5(E,"base16")}}function convertToBytes(J,E){switch(getProtocol(J).code){case 4:return ip2bytes(E);case 41:return ip2bytes(E);case 42:return str2bytes(E);case 6:case 273:case 33:case 132:return port2bytes(parseInt(E,10));case 53:case 54:case 55:case 56:case 400:case 449:case 777:return str2bytes(E);case 421:return mh2bytes(E);case 444:return onion2bytes(E);case 445:return onion32bytes(E);case 466:return mb2bytes(E);default:return fromString$5(E,"base16")}}const decoders=Object.values(bases$1).map(J=>J.decoder),anybaseDecoder=function(){let J=decoders[0].or(decoders[1]);return decoders.slice(2).forEach(E=>J=J.or(E)),J}();function ip2bytes(J){if(!isIP(J))throw new Error("invalid ip address");return toBytes$1(J)}function bytes2ip(J){const E=toString$4(J,0,J.length);if(E==null)throw new Error("ipBuff is required");if(!isIP(E))throw new Error("invalid ip address");return E}function port2bytes(J){const E=new ArrayBuffer(2);return new DataView(E).setUint16(0,J),new Uint8Array(E)}function bytes2port(J){return new DataView(J.buffer).getUint16(J.byteOffset)}function str2bytes(J){const E=fromString$5(J),ee=Uint8Array.from(varint$4.encode(E.length));return concat$4([ee,E],ee.length+E.length)}function bytes2str(J){const E=varint$4.decode(J);if(J=J.slice(varint$4.decode.bytes),J.length!==E)throw new Error("inconsistent lengths");return toString$5(J)}function mh2bytes(J){let E;J[0]==="Q"||J[0]==="1"?E=decode$f(base58btc$1.decode(`z${J}`)).bytes:E=CID.parse(J).multihash.bytes;const ee=Uint8Array.from(varint$4.encode(E.length));return concat$4([ee,E],ee.length+E.length)}function mb2bytes(J){const E=anybaseDecoder.decode(J),ee=Uint8Array.from(varint$4.encode(E.length));return concat$4([ee,E],ee.length+E.length)}function bytes2mb(J){const E=varint$4.decode(J),ee=J.slice(varint$4.decode.bytes);if(ee.length!==E)throw new Error("inconsistent lengths");return"u"+toString$5(ee,"base64url")}function bytes2mh(J){const E=varint$4.decode(J),ee=J.slice(varint$4.decode.bytes);if(ee.length!==E)throw new Error("inconsistent lengths");return toString$5(ee,"base58btc")}function onion2bytes(J){const E=J.split(":");if(E.length!==2)throw new Error(`failed to parse onion addr: ["'${E.join('", "')}'"]' does not contain a port number`);if(E[0].length!==16)throw new Error(`failed to parse onion addr: ${E[0]} not a Tor onion address.`);const ee=base32$2.decode("b"+E[0]),te=parseInt(E[1],10);if(te<1||te>65536)throw new Error("Port number is not in range(1, 65536)");const re=port2bytes(te);return concat$4([ee,re],ee.length+re.length)}function onion32bytes(J){const E=J.split(":");if(E.length!==2)throw new Error(`failed to parse onion addr: ["'${E.join('", "')}'"]' does not contain a port number`);if(E[0].length!==56)throw new Error(`failed to parse onion addr: ${E[0]} not a Tor onion3 address.`);const ee=base32$2.decode(`b${E[0]}`),te=parseInt(E[1],10);if(te<1||te>65536)throw new Error("Port number is not in range(1, 65536)");const re=port2bytes(te);return concat$4([ee,re],ee.length+re.length)}function bytes2onion(J){const E=J.slice(0,J.length-2),ee=J.slice(J.length-2),te=toString$5(E,"base32"),re=bytes2port(ee);return`${te}:${re}`}function stringToStringTuples(J){const E=[],ee=J.split("/").slice(1);if(ee.length===1&&ee[0]==="")return[];for(let te=0;te<ee.length;te++){const re=ee[te],ne=getProtocol(re);if(ne.size===0){E.push([re]);continue}if(te++,te>=ee.length)throw ParseError("invalid address: "+J);if(ne.path===!0){E.push([re,cleanPath(ee.slice(te).join("/"))]);break}E.push([re,ee[te]])}return E}function stringTuplesToString(J){const E=[];return J.map(ee=>{const te=protoFromTuple(ee);return E.push(te.name),ee.length>1&&ee[1]!=null&&E.push(ee[1]),null}),cleanPath(E.join("/"))}function stringTuplesToTuples(J){return J.map(E=>{Array.isArray(E)||(E=[E]);const ee=protoFromTuple(E);return E.length>1?[ee.code,convertToBytes(ee.code,E[1])]:[ee.code]})}function tuplesToStringTuples(J){return J.map(E=>{const ee=protoFromTuple(E);return E[1]!=null?[ee.code,convertToString(ee.code,E[1])]:[ee.code]})}function tuplesToBytes(J){return fromBytes(concat$4(J.map(E=>{const ee=protoFromTuple(E);let te=Uint8Array.from(varint$4.encode(ee.code));return E.length>1&&E[1]!=null&&(te=concat$4([te,E[1]])),te})))}function sizeForAddr(J,E){return J.size>0?J.size/8:J.size===0?0:varint$4.decode(E)+(varint$4.decode.bytes??0)}function bytesToTuples(J){const E=[];let ee=0;for(;ee<J.length;){const te=varint$4.decode(J,ee),re=varint$4.decode.bytes??0,ne=getProtocol(te),ie=sizeForAddr(ne,J.slice(ee+re));if(ie===0){E.push([te]),ee+=re;continue}const se=J.slice(ee+re,ee+re+ie);if(ee+=ie+re,ee>J.length)throw ParseError("Invalid address Uint8Array: "+toString$5(J,"base16"));E.push([te,se])}return E}function bytesToString(J){const E=bytesToTuples(J),ee=tuplesToStringTuples(E);return stringTuplesToString(ee)}function stringToBytes(J){J=cleanPath(J);const E=stringToStringTuples(J),ee=stringTuplesToTuples(E);return tuplesToBytes(ee)}function fromString$4(J){return stringToBytes(J)}function fromBytes(J){const E=validateBytes(J);if(E!=null)throw E;return Uint8Array.from(J)}function validateBytes(J){try{bytesToTuples(J)}catch(E){return E}}function cleanPath(J){return"/"+J.trim().split("/").filter(E=>E).join("/")}function ParseError(J){return new Error("Error parsing address: "+J)}function protoFromTuple(J){return getProtocol(J[0])}const inspect$1=Symbol.for("nodejs.util.inspect.custom"),DNS_CODES=[getProtocol("dns").code,getProtocol("dns4").code,getProtocol("dns6").code,getProtocol("dnsaddr").code],resolvers$1=new Map,symbol$4=Symbol.for("@multiformats/js-multiaddr/multiaddr");function isMultiaddr(J){return!!J?.[symbol$4]}class DefaultMultiaddr{bytes;#e;#t;#r;#n;[symbol$4]=!0;constructor(E){if(E==null&&(E=""),E instanceof Uint8Array)this.bytes=fromBytes(E);else if(typeof E=="string"){if(E.length>0&&E.charAt(0)!=="/")throw new Error(`multiaddr "${E}" must start with a "/"`);this.bytes=fromString$4(E)}else if(isMultiaddr(E))this.bytes=fromBytes(E.bytes);else throw new Error("addr must be a string, Buffer, or another Multiaddr")}toString(){return this.#e==null&&(this.#e=bytesToString(this.bytes)),this.#e}toJSON(){return this.toString()}toOptions(){let E,ee,te,re,ne="";const ie=getProtocol("tcp"),se=getProtocol("udp"),oe=getProtocol("ip4"),ce=getProtocol("ip6"),ae=getProtocol("dns6"),le=getProtocol("ip6zone");for(const[ue,he]of this.stringTuples())ue===le.code&&(ne=`%${he??""}`),DNS_CODES.includes(ue)&&(ee=ie.name,re=443,te=`${he??""}${ne}`,E=ue===ae.code?6:4),(ue===ie.code||ue===se.code)&&(ee=getProtocol(ue).name,re=parseInt(he??"")),(ue===oe.code||ue===ce.code)&&(ee=getProtocol(ue).name,te=`${he??""}${ne}`,E=ue===ce.code?6:4);if(E==null||ee==null||te==null||re==null)throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6, dnsaddr}/{address}/{tcp, udp}/{port}".');return{family:E,host:te,transport:ee,port:re}}protos(){return this.protoCodes().map(E=>Object.assign({},getProtocol(E)))}protoCodes(){const E=[],ee=this.bytes;let te=0;for(;te<ee.length;){const re=varint$4.decode(ee,te),ne=varint$4.decode.bytes??0,ie=getProtocol(re),se=sizeForAddr(ie,ee.slice(te+ne));te+=se+ne,E.push(re)}return E}protoNames(){return this.protos().map(E=>E.name)}tuples(){return this.#t==null&&(this.#t=bytesToTuples(this.bytes)),this.#t}stringTuples(){return this.#r==null&&(this.#r=tuplesToStringTuples(this.tuples())),this.#r}encapsulate(E){return E=new DefaultMultiaddr(E),new DefaultMultiaddr(this.toString()+E.toString())}decapsulate(E){const ee=E.toString(),te=this.toString(),re=te.lastIndexOf(ee);if(re<0)throw new Error(`Address ${this.toString()} does not contain subaddress: ${E.toString()}`);return new DefaultMultiaddr(te.slice(0,re))}decapsulateCode(E){const ee=this.tuples();for(let te=ee.length-1;te>=0;te--)if(ee[te][0]===E)return new DefaultMultiaddr(tuplesToBytes(ee.slice(0,te)));return this}getPeerId(){try{const E=this.stringTuples().filter(ee=>ee[0]===names$3.ipfs.code).pop();if(E?.[1]!=null){const ee=E[1];return ee[0]==="Q"||ee[0]==="1"?toString$5(base58btc$1.decode(`z${ee}`),"base58btc"):toString$5(CID.parse(ee).multihash.bytes,"base58btc")}return null}catch{return null}}getPath(){if(this.#n===void 0)try{this.#n=this.stringTuples().filter(E=>getProtocol(E[0]).path===!0)[0][1],this.#n==null&&(this.#n=null)}catch{this.#n=null}return this.#n}equals(E){return equals(this.bytes,E.bytes)}async resolve(E){const ee=this.protos().find(re=>re.resolvable);if(ee==null)return[this];const te=resolvers$1.get(ee.name);if(te==null)throw new CodeError(`no available resolver for ${ee.name}`,"ERR_NO_AVAILABLE_RESOLVER");return(await te(this,E)).map(re=>new DefaultMultiaddr(re))}nodeAddress(){const E=this.toOptions();if(E.transport!=="tcp"&&E.transport!=="udp")throw new Error(`multiaddr must have a valid format - no protocol with name: "${E.transport}". Must have a valid transport protocol: "{tcp, udp}"`);return{family:E.family,address:E.host,port:E.port}}isThinWaistAddress(E){const ee=(E??this).protos();return!(ee.length!==2||ee[0].code!==4&&ee[0].code!==41||ee[1].code!==6&&ee[1].code!==273)}[inspect$1](){return`Multiaddr(${bytesToString(this.bytes)})`}}function multiaddr(J){return new DefaultMultiaddr(J)}let nanoid=(J=21)=>crypto.getRandomValues(new Uint8Array(J)).reduce((E,ee)=>(ee&=63,ee<36?E+=ee.toString(36):ee<62?E+=(ee-26).toString(36).toUpperCase():ee>62?E+="-":E+="_",E),"");const pathSepS="/",pathSepB=new TextEncoder().encode(pathSepS),pathSep=pathSepB[0];class Key{_buf;constructor(E,ee){if(typeof E=="string")this._buf=fromString$5(E);else if(E instanceof Uint8Array)this._buf=E;else throw new Error("Invalid key, should be String of Uint8Array");if(ee==null&&(ee=!0),ee&&this.clean(),this._buf.byteLength===0||this._buf[0]!==pathSep)throw new Error("Invalid key")}toString(E="utf8"){return toString$5(this._buf,E)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(E){return new Key(E.join(pathSepS))}static random(){return new Key(nanoid().replace(/-/g,""))}static asKey(E){return E instanceof Uint8Array||typeof E=="string"?new Key(E):typeof E.uint8Array=="function"?new Key(E.uint8Array()):null}clean(){if((this._buf==null||this._buf.byteLength===0)&&(this._buf=pathSepB),this._buf[0]!==pathSep){const E=new Uint8Array(this._buf.byteLength+1);E.fill(pathSep,0,1),E.set(this._buf,1),this._buf=E}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===pathSep;)this._buf=this._buf.subarray(0,-1)}less(E){const ee=this.list(),te=E.list();for(let re=0;re<ee.length;re++){if(te.length<re+1)return!1;const ne=ee[re],ie=te[re];if(ne<ie)return!0;if(ne>ie)return!1}return ee.length<te.length}reverse(){return Key.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){const E=this.namespaces();return E[E.length-1]}list(){return this.toString().split(pathSepS).slice(1)}type(){return namespaceType(this.baseNamespace())}name(){return namespaceValue(this.baseNamespace())}instance(E){return new Key(this.toString()+":"+E)}path(){let E=this.parent().toString();return E.endsWith(pathSepS)||(E+=pathSepS),E+=this.type(),new Key(E)}parent(){const E=this.list();return E.length===1?new Key(pathSepS):new Key(E.slice(0,-1).join(pathSepS))}child(E){return this.toString()===pathSepS?E:E.toString()===pathSepS?this:new Key(this.toString()+E.toString(),!1)}isAncestorOf(E){return E.toString()===this.toString()?!1:E.toString().startsWith(this.toString())}isDecendantOf(E){return E.toString()===this.toString()?!1:this.toString().startsWith(E.toString())}isTopLevel(){return this.list().length===1}concat(...E){return Key.withNamespaces([...this.namespaces(),...flatten(E.map(ee=>ee.namespaces()))])}}function namespaceType(J){const E=J.split(":");return E.length<2?"":E.slice(0,-1).join(":")}function namespaceValue(J){const E=J.split(":");return E[E.length-1]}function flatten(J){return[].concat(...J)}function isAsyncIterable$f(J){return J[Symbol.asyncIterator]!=null}function drain(J){if(isAsyncIterable$f(J))return(async()=>{for await(const E of J);})();for(const E of J);}function peekable(J){const[E,ee]=J[Symbol.asyncIterator]!=null?[J[Symbol.asyncIterator](),Symbol.asyncIterator]:[J[Symbol.iterator](),Symbol.iterator],te=[];return{peek:()=>E.next(),push:re=>{te.push(re)},next:()=>te.length>0?{done:!1,value:te.shift()}:E.next(),[ee](){return this}}}function isAsyncIterable$e(J){return J[Symbol.asyncIterator]!=null}function filter(J,E){if(isAsyncIterable$e(J))return async function*(){for await(const se of J)await E(se)&&(yield se)}();const ee=peekable(J),{value:te,done:re}=ee.next();if(re===!0)return function*(){}();const ne=E(te);if(typeof ne.then=="function")return async function*(){await ne&&(yield te);for await(const se of ee)await E(se)&&(yield se)}();const ie=E;return function*(){ne===!0&&(yield te);for(const se of ee)ie(se)&&(yield se)}()}function isAsyncIterable$d(J){return J[Symbol.asyncIterator]!=null}function all$1(J){if(isAsyncIterable$d(J))return(async()=>{const ee=[];for await(const te of J)ee.push(te);return ee})();const E=[];for(const ee of J)E.push(ee);return E}function isAsyncIterable$c(J){return J[Symbol.asyncIterator]!=null}function sort(J,E){return isAsyncIterable$c(J)?async function*(){yield*(await all$1(J)).sort(E)}():function*(){yield*all$1(J).sort(E)}()}function isAsyncIterable$b(J){return J[Symbol.asyncIterator]!=null}function take(J,E){return isAsyncIterable$b(J)?async function*(){let ee=0;if(!(E<1)){for await(const te of J)if(yield te,ee++,ee===E)return}}():function*(){let ee=0;if(!(E<1)){for(const te of J)if(yield te,ee++,ee===E)return}}()}class BaseDatastore{put(E,ee,te){return Promise.reject(new Error(".put is not implemented"))}get(E,ee){return Promise.reject(new Error(".get is not implemented"))}has(E,ee){return Promise.reject(new Error(".has is not implemented"))}delete(E,ee){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(E,ee={}){for await(const{key:te,value:re}of E)await this.put(te,re,ee),yield te}async*getMany(E,ee={}){for await(const te of E)yield{key:te,value:await this.get(te,ee)}}async*deleteMany(E,ee={}){for await(const te of E)await this.delete(te,ee),yield te}batch(){let E=[],ee=[];return{put(te,re){E.push({key:te,value:re})},delete(te){ee.push(te)},commit:async te=>{await drain(this.putMany(E,te)),E=[],await drain(this.deleteMany(ee,te)),ee=[]}}}async*_all(E,ee){throw new Error("._all is not implemented")}async*_allKeys(E,ee){throw new Error("._allKeys is not implemented")}query(E,ee){let te=this._all(E,ee);if(E.prefix!=null){const re=E.prefix;te=filter(te,ne=>ne.key.toString().startsWith(re))}if(Array.isArray(E.filters)&&(te=E.filters.reduce((re,ne)=>filter(re,ne),te)),Array.isArray(E.orders)&&(te=E.orders.reduce((re,ne)=>sort(re,ne),te)),E.offset!=null){let re=0;const ne=E.offset;te=filter(te,()=>re++>=ne)}return E.limit!=null&&(te=take(te,E.limit)),te}queryKeys(E,ee){let te=this._allKeys(E,ee);if(E.prefix!=null){const re=E.prefix;te=filter(te,ne=>ne.toString().startsWith(re))}if(Array.isArray(E.filters)&&(te=E.filters.reduce((re,ne)=>filter(re,ne),te)),Array.isArray(E.orders)&&(te=E.orders.reduce((re,ne)=>sort(re,ne),te)),E.offset!=null){const re=E.offset;let ne=0;te=filter(te,()=>ne++>=re)}return E.limit!=null&&(te=take(te,E.limit)),te}}function assign(J,E){for(const ee in E)Object.defineProperty(J,ee,{value:E[ee],enumerable:!0,configurable:!0});return J}function createError(J,E,ee){if(!J||typeof J=="string")throw new TypeError("Please pass an Error to err-code");ee||(ee={}),typeof E=="object"&&(ee=E,E=""),E&&(ee.code=E);try{return assign(J,ee)}catch{ee.message=J.message,ee.stack=J.stack;const te=function(){};return te.prototype=Object.create(Object.getPrototypeOf(J)),assign(new te,ee)}}var errCode=createError;const errCode$1=getDefaultExportFromCjs(errCode);function notFoundError$1(J){return J=J??new Error("Not Found"),errCode$1(J,"ERR_NOT_FOUND")}class MemoryDatastore extends BaseDatastore{data;constructor(){super(),this.data=new Map}put(E,ee){return this.data.set(E.toString(),ee),E}get(E){const ee=this.data.get(E.toString());if(ee==null)throw notFoundError$1();return ee}has(E){return this.data.has(E.toString())}delete(E){this.data.delete(E.toString())}*_all(){for(const[E,ee]of this.data.entries())yield{key:new Key(E),value:ee}}*_allKeys(){for(const E of this.data.keys())yield new Key(E)}}var messages$1;(function(J){J.NOT_STARTED_YET="The libp2p node is not started yet",J.DHT_DISABLED="DHT is not available",J.PUBSUB_DISABLED="PubSub is not available",J.CONN_ENCRYPTION_REQUIRED="At least one connection encryption module is required",J.ERR_TRANSPORTS_REQUIRED="At least one transport module is required",J.ERR_PROTECTOR_REQUIRED="Private network is enforced, but no protector was provided",J.NOT_FOUND="Not found"})(messages$1||(messages$1={}));var codes$8;(function(J){J.DHT_DISABLED="ERR_DHT_DISABLED",J.ERR_PUBSUB_DISABLED="ERR_PUBSUB_DISABLED",J.PUBSUB_NOT_STARTED="ERR_PUBSUB_NOT_STARTED",J.DHT_NOT_STARTED="ERR_DHT_NOT_STARTED",J.CONN_ENCRYPTION_REQUIRED="ERR_CONN_ENCRYPTION_REQUIRED",J.ERR_TRANSPORTS_REQUIRED="ERR_TRANSPORTS_REQUIRED",J.ERR_PROTECTOR_REQUIRED="ERR_PROTECTOR_REQUIRED",J.ERR_PEER_DIAL_INTERCEPTED="ERR_PEER_DIAL_INTERCEPTED",J.ERR_CONNECTION_INTERCEPTED="ERR_CONNECTION_INTERCEPTED",J.ERR_INVALID_PROTOCOLS_FOR_STREAM="ERR_INVALID_PROTOCOLS_FOR_STREAM",J.ERR_CONNECTION_ENDED="ERR_CONNECTION_ENDED",J.ERR_CONNECTION_FAILED="ERR_CONNECTION_FAILED",J.ERR_NODE_NOT_STARTED="ERR_NODE_NOT_STARTED",J.ERR_ALREADY_ABORTED="ERR_ALREADY_ABORTED",J.ERR_TOO_MANY_ADDRESSES="ERR_TOO_MANY_ADDRESSES",J.ERR_NO_VALID_ADDRESSES="ERR_NO_VALID_ADDRESSES",J.ERR_RELAYED_DIAL="ERR_RELAYED_DIAL",J.ERR_DIALED_SELF="ERR_DIALED_SELF",J.ERR_DISCOVERED_SELF="ERR_DISCOVERED_SELF",J.ERR_DUPLICATE_TRANSPORT="ERR_DUPLICATE_TRANSPORT",J.ERR_ENCRYPTION_FAILED="ERR_ENCRYPTION_FAILED",J.ERR_HOP_REQUEST_FAILED="ERR_HOP_REQUEST_FAILED",J.ERR_INVALID_KEY="ERR_INVALID_KEY",J.ERR_INVALID_MESSAGE="ERR_INVALID_MESSAGE",J.ERR_INVALID_PARAMETERS="ERR_INVALID_PARAMETERS",J.ERR_INVALID_PEER="ERR_INVALID_PEER",J.ERR_MUXER_UNAVAILABLE="ERR_MUXER_UNAVAILABLE",J.ERR_NOT_FOUND="ERR_NOT_FOUND",J.ERR_TIMEOUT="ERR_TIMEOUT",J.ERR_TRANSPORT_UNAVAILABLE="ERR_TRANSPORT_UNAVAILABLE",J.ERR_TRANSPORT_DIAL_FAILED="ERR_TRANSPORT_DIAL_FAILED",J.ERR_UNSUPPORTED_PROTOCOL="ERR_UNSUPPORTED_PROTOCOL",J.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED="ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED",J.ERR_INVALID_MULTIADDR="ERR_INVALID_MULTIADDR",J.ERR_SIGNATURE_NOT_VALID="ERR_SIGNATURE_NOT_VALID",J.ERR_FIND_SELF="ERR_FIND_SELF",J.ERR_NO_ROUTERS_AVAILABLE="ERR_NO_ROUTERS_AVAILABLE",J.ERR_CONNECTION_NOT_MULTIPLEXED="ERR_CONNECTION_NOT_MULTIPLEXED",J.ERR_NO_DIAL_TOKENS="ERR_NO_DIAL_TOKENS",J.ERR_KEYCHAIN_REQUIRED="ERR_KEYCHAIN_REQUIRED",J.ERR_INVALID_CMS="ERR_INVALID_CMS",J.ERR_MISSING_KEYS="ERR_MISSING_KEYS",J.ERR_NO_KEY="ERR_NO_KEY",J.ERR_INVALID_KEY_NAME="ERR_INVALID_KEY_NAME",J.ERR_INVALID_KEY_TYPE="ERR_INVALID_KEY_TYPE",J.ERR_KEY_ALREADY_EXISTS="ERR_KEY_ALREADY_EXISTS",J.ERR_INVALID_KEY_SIZE="ERR_INVALID_KEY_SIZE",J.ERR_KEY_NOT_FOUND="ERR_KEY_NOT_FOUND",J.ERR_OLD_KEY_NAME_INVALID="ERR_OLD_KEY_NAME_INVALID",J.ERR_NEW_KEY_NAME_INVALID="ERR_NEW_KEY_NAME_INVALID",J.ERR_PASSWORD_REQUIRED="ERR_PASSWORD_REQUIRED",J.ERR_PEM_REQUIRED="ERR_PEM_REQUIRED",J.ERR_CANNOT_READ_KEY="ERR_CANNOT_READ_KEY",J.ERR_MISSING_PRIVATE_KEY="ERR_MISSING_PRIVATE_KEY",J.ERR_MISSING_PUBLIC_KEY="ERR_MISSING_PUBLIC_KEY",J.ERR_INVALID_OLD_PASS_TYPE="ERR_INVALID_OLD_PASS_TYPE",J.ERR_INVALID_NEW_PASS_TYPE="ERR_INVALID_NEW_PASS_TYPE",J.ERR_INVALID_PASS_LENGTH="ERR_INVALID_PASS_LENGTH",J.ERR_NOT_IMPLEMENTED="ERR_NOT_IMPLEMENTED",J.ERR_WRONG_PING_ACK="ERR_WRONG_PING_ACK",J.ERR_INVALID_RECORD="ERR_INVALID_RECORD",J.ERR_ALREADY_SUCCEEDED="ERR_ALREADY_SUCCEEDED",J.ERR_NO_HANDLER_FOR_PROTOCOL="ERR_NO_HANDLER_FOR_PROTOCOL",J.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS="ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS",J.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS="ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS",J.ERR_CONNECTION_DENIED="ERR_CONNECTION_DENIED",J.ERR_TRANSFER_LIMIT_EXCEEDED="ERR_TRANSFER_LIMIT_EXCEEDED"})(codes$8||(codes$8={}));function isAsyncIterable$a(J){return J[Symbol.asyncIterator]!=null}function map$1(J,E){if(isAsyncIterable$a(J))return async function*(){for await(const se of J)yield E(se)}();const ee=peekable(J),{value:te,done:re}=ee.next();if(re===!0)return function*(){}();const ne=E(te);if(typeof ne.then=="function")return async function*(){yield await ne;for await(const se of ee)yield E(se)}();const ie=E;return function*(){yield ne;for(const se of ee)yield ie(se)}()}async function*storeAddresses$1(J,E){yield*map$1(J,async ee=>(await E.merge(ee.id,{multiaddrs:ee.multiaddrs}),ee))}function uniquePeers$1(J){const E=new Set;return filter(J,ee=>E.has(ee.id.toString())?!1:(E.add(ee.id.toString()),!0))}async function*requirePeers$1(J,E=1){let ee=0;for await(const te of J)ee++,yield te;if(ee<E)throw new CodeError(`more peers required, seen: ${ee}  min: ${E}`,"NOT_FOUND")}class FixedFIFO{constructor(E){if(!(E>0)||E-1&E)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(E),this.mask=E-1,this.top=0,this.btm=0,this.next=null}push(E){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=E,this.top=this.top+1&this.mask,!0)}shift(){const E=this.buffer[this.btm];if(E!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,E}isEmpty(){return this.buffer[this.btm]===void 0}}class FIFO{constructor(E={}){this.hwm=E.splitLimit??16,this.head=new FixedFIFO(this.hwm),this.tail=this.head,this.size=0}calculateSize(E){return E?.byteLength!=null?E.byteLength:1}push(E){if(E?.value!=null&&(this.size+=this.calculateSize(E.value)),!this.head.push(E)){const ee=this.head;this.head=ee.next=new FixedFIFO(2*this.head.buffer.length),this.head.push(E)}}shift(){let E=this.tail.shift();if(E===void 0&&this.tail.next!=null){const ee=this.tail.next;this.tail.next=null,this.tail=ee,E=this.tail.shift()}return E?.value!=null&&(this.size-=this.calculateSize(E.value)),E}isEmpty(){return this.head.isEmpty()}}function pushable(J={}){return _pushable(E=>{const ee=E.shift();if(ee==null)return{done:!0};if(ee.error!=null)throw ee.error;return{done:ee.done===!0,value:ee.value}},J)}function pushableV(J={}){return _pushable(E=>{let ee;const te=[];for(;!E.isEmpty()&&(ee=E.shift(),ee!=null);){if(ee.error!=null)throw ee.error;ee.done===!1&&te.push(ee.value)}return ee==null?{done:!0}:{done:ee.done===!0,value:te}},J)}function _pushable(J,E){E=E??{};let ee=E.onEnd,te=new FIFO,re,ne,ie;const se=async()=>te.isEmpty()?ie?{done:!0}:await new Promise((de,fe)=>{ne=me=>{ne=null,te.push(me);try{de(J(te))}catch(_e){fe(_e)}return re}}):J(te),oe=de=>ne!=null?ne(de):(te.push(de),re),ce=de=>(te=new FIFO,ne!=null?ne({error:de}):(te.push({error:de}),re)),ae=de=>{if(ie)return re;if(E?.objectMode!==!0&&de?.byteLength==null)throw new Error("objectMode was not true but tried to push non-Uint8Array value");return oe({done:!1,value:de})},le=de=>ie?re:(ie=!0,de!=null?ce(de):oe({done:!0})),ue=()=>(te=new FIFO,le(),{done:!0}),he=de=>(le(de),{done:!0});if(re={[Symbol.asyncIterator](){return this},next:se,return:ue,throw:he,push:ae,end:le,get readableLength(){return te.size}},ee==null)return re;const pe=re;return re={[Symbol.asyncIterator](){return this},next(){return pe.next()},throw(de){return pe.throw(de),ee!=null&&(ee(de),ee=void 0),{done:!0}},return(){return pe.return(),ee!=null&&(ee(),ee=void 0),{done:!0}},push:ae,end(de){return pe.end(de),ee!=null&&(ee(de),ee=void 0),re},get readableLength(){return pe.readableLength}},re}function isAsyncIterable$9(J){return J[Symbol.asyncIterator]!=null}function merge$2(...J){const E=[];for(const ee of J)isAsyncIterable$9(ee)||E.push(ee);return E.length===J.length?function*(){for(const ee of E)yield*ee}():async function*(){const ee=pushable({objectMode:!0});Promise.resolve().then(async()=>{try{await Promise.all(J.map(async te=>{for await(const re of te)ee.push(re)})),ee.end()}catch(te){ee.end(te)}}),yield*ee}()}function pipe$1(J,...E){if(J==null)throw new Error("Empty pipeline");if(isDuplex$1(J)){const te=J;J=()=>te.source}else if(isIterable$2(J)||isAsyncIterable$8(J)){const te=J;J=()=>te}const ee=[J,...E];if(ee.length>1&&isDuplex$1(ee[ee.length-1])&&(ee[ee.length-1]=ee[ee.length-1].sink),ee.length>2)for(let te=1;te<ee.length-1;te++)isDuplex$1(ee[te])&&(ee[te]=duplexPipelineFn$1(ee[te]));return rawPipe$1(...ee)}const rawPipe$1=(...J)=>{let E;for(;J.length>0;)E=J.shift()(E);return E},isAsyncIterable$8=J=>J?.[Symbol.asyncIterator]!=null,isIterable$2=J=>J?.[Symbol.iterator]!=null,isDuplex$1=J=>J==null?!1:J.sink!=null&&J.source!=null,duplexPipelineFn$1=J=>E=>{const ee=J.sink(E);if(ee?.then!=null){const te=pushable({objectMode:!0});ee.then(()=>{te.end()},ie=>{te.end(ie)});let re;const ne=J.source;if(isAsyncIterable$8(ne))re=async function*(){yield*ne,te.end()};else if(isIterable$2(ne))re=function*(){yield*ne,te.end()};else throw new Error("Unknown duplex source type - must be Iterable or AsyncIterable");return merge$2(te,re())}return J.source};function isAsyncIterable$7(J){return J[Symbol.asyncIterator]!=null}function first(J){if(isAsyncIterable$7(J))return(async()=>{for await(const E of J)return E})();for(const E of J)return E}const log$1q=logger$1("libp2p:peer-routing");let DefaultPeerRouting$1=class{constructor(J,E){this.components=J,this.routers=E.routers??[]}async findPeer(J,E){if(this.routers.length===0)throw new CodeError("No peer routers available",codes$8.ERR_NO_ROUTERS_AVAILABLE);if(J.toString()===this.components.peerId.toString())throw new CodeError("Should not try to find self",codes$8.ERR_FIND_SELF);const ee=await pipe$1(merge$2(...this.routers.map(te=>async function*(){try{yield await te.findPeer(J,E)}catch(re){log$1q.error(re)}}())),te=>filter(te,Boolean),te=>storeAddresses$1(te,this.components.peerStore),async te=>await first(te));if(ee!=null)return ee;throw new CodeError(messages$1.NOT_FOUND,codes$8.ERR_NOT_FOUND)}async*getClosestPeers(J,E){if(this.routers.length===0)throw new CodeError("No peer routers available",codes$8.ERR_NO_ROUTERS_AVAILABLE);yield*pipe$1(merge$2(...this.routers.map(ee=>ee.getClosestPeers(J,E))),ee=>storeAddresses$1(ee,this.components.peerStore),ee=>uniquePeers$1(ee),ee=>requirePeers$1(ee))}},CompoundContentRouting$1=class{constructor(J,E){this.routers=E.routers??[],this.started=!1,this.components=J}isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(J,E={}){if(this.routers.length===0)throw new CodeError("No content routers available",codes$8.ERR_NO_ROUTERS_AVAILABLE);yield*pipe$1(merge$2(...this.routers.map(ee=>ee.findProviders(J,E))),ee=>storeAddresses$1(ee,this.components.peerStore),ee=>uniquePeers$1(ee),ee=>requirePeers$1(ee))}async provide(J,E={}){if(this.routers.length===0)throw new CodeError("No content routers available",codes$8.ERR_NO_ROUTERS_AVAILABLE);await Promise.all(this.routers.map(async ee=>{await ee.provide(J,E)}))}async put(J,E,ee){if(!this.isStarted())throw new CodeError(messages$1.NOT_STARTED_YET,codes$8.DHT_NOT_STARTED);await Promise.all(this.routers.map(async te=>{await te.put(J,E,ee)}))}async get(J,E){if(!this.isStarted())throw new CodeError(messages$1.NOT_STARTED_YET,codes$8.DHT_NOT_STARTED);return await Promise.any(this.routers.map(async ee=>await ee.get(J,E)))}};const symbol$3=Symbol.for("@libp2p/peer-id");function isPeerId(J){return J!=null&&!!J[symbol$3]}const inspect=Symbol.for("nodejs.util.inspect.custom"),baseDecoder=Object.values(bases$1).map(J=>J.decoder).reduce((J,E)=>J.or(E),bases$1.identity.decoder),LIBP2P_KEY_CODE=114,MARSHALLED_ED225519_PUBLIC_KEY_LENGTH=36,MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH=37;class PeerIdImpl{constructor(E){this.type=E.type,this.multihash=E.multihash,this.privateKey=E.privateKey,Object.defineProperty(this,"string",{enumerable:!1,writable:!0})}get[Symbol.toStringTag](){return`PeerId(${this.toString()})`}get[symbol$3](){return!0}toString(){return this.string==null&&(this.string=base58btc$1.encode(this.multihash.bytes).slice(1)),this.string}toCID(){return CID.createV1(LIBP2P_KEY_CODE,this.multihash)}toBytes(){return this.multihash.bytes}toJSON(){return this.toString()}equals(E){if(E instanceof Uint8Array)return equals(this.multihash.bytes,E);if(typeof E=="string")return peerIdFromString(E).equals(this);if(E?.multihash?.bytes!=null)return equals(this.multihash.bytes,E.multihash.bytes);throw new Error("not valid Id")}[inspect](){return`PeerId(${this.toString()})`}}class RSAPeerIdImpl extends PeerIdImpl{constructor(E){super({...E,type:"RSA"}),this.type="RSA",this.publicKey=E.publicKey}}class Ed25519PeerIdImpl extends PeerIdImpl{constructor(E){super({...E,type:"Ed25519"}),this.type="Ed25519",this.publicKey=E.multihash.digest}}class Secp256k1PeerIdImpl extends PeerIdImpl{constructor(E){super({...E,type:"secp256k1"}),this.type="secp256k1",this.publicKey=E.multihash.digest}}function peerIdFromString(J,E){if(J.charAt(0)==="1"||J.charAt(0)==="Q"){const ee=decode$f(base58btc$1.decode(`z${J}`));return J.startsWith("12D")?new Ed25519PeerIdImpl({multihash:ee}):J.startsWith("16U")?new Secp256k1PeerIdImpl({multihash:ee}):new RSAPeerIdImpl({multihash:ee})}return peerIdFromBytes(baseDecoder.decode(J))}function peerIdFromBytes(J){try{const E=decode$f(J);if(E.code===identity$2.code){if(E.digest.length===MARSHALLED_ED225519_PUBLIC_KEY_LENGTH)return new Ed25519PeerIdImpl({multihash:E});if(E.digest.length===MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH)return new Secp256k1PeerIdImpl({multihash:E})}if(E.code===sha256$3.code)return new RSAPeerIdImpl({multihash:E})}catch{return peerIdFromCID(CID.decode(J))}throw new Error("Supplied PeerID CID is invalid")}function peerIdFromCID(J){if(J==null||J.multihash==null||J.version==null||J.version===1&&J.code!==LIBP2P_KEY_CODE)throw new Error("Supplied PeerID CID is invalid");const E=J.multihash;if(E.code===sha256$3.code)return new RSAPeerIdImpl({multihash:J.multihash});if(E.code===identity$2.code){if(E.digest.length===MARSHALLED_ED225519_PUBLIC_KEY_LENGTH)return new Ed25519PeerIdImpl({multihash:J.multihash});if(E.digest.length===MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH)return new Secp256k1PeerIdImpl({multihash:J.multihash})}throw new Error("Supplied PeerID CID is invalid")}async function peerIdFromKeys(J,E){return J.length===MARSHALLED_ED225519_PUBLIC_KEY_LENGTH?new Ed25519PeerIdImpl({multihash:create$3(identity$2.code,J),privateKey:E}):J.length===MARSHALLED_SECP256K1_PUBLIC_KEY_LENGTH?new Secp256k1PeerIdImpl({multihash:create$3(identity$2.code,J),privateKey:E}):new RSAPeerIdImpl({multihash:await sha256$3.digest(J),publicKey:J,privateKey:E})}function debounce$3(J,E){let ee;return function(){const te=function(){ee=void 0,J()};clearTimeout(ee),ee=setTimeout(te,E)}}const log$1p=logger$1("libp2p:address-manager"),defaultAddressFilter$1=J=>J;function stripPeerId$1(J,E){const ee=J.getPeerId();return ee!=null&&peerIdFromString(ee).equals(E)&&(J=J.decapsulate(multiaddr(`/p2p/${E.toString()}`))),J}let DefaultAddressManager$1=class{constructor(J,E={}){const{listen:ee=[],announce:te=[]}=E;this.components=J,this.listen=ee.map(re=>re.toString()),this.announce=new Set(te.map(re=>re.toString())),this.observed=new Map,this.announceFilter=E.announceFilter??defaultAddressFilter$1,this._updatePeerStoreAddresses=debounce$3(this._updatePeerStoreAddresses.bind(this),1e3),J.events.addEventListener("transport:listening",()=>{this._updatePeerStoreAddresses()}),J.events.addEventListener("transport:close",()=>{this._updatePeerStoreAddresses()})}_updatePeerStoreAddresses(){const J=this.getAnnounceAddrs().concat(this.components.transportManager.getAddrs()).concat([...this.observed.entries()].filter(([E,ee])=>ee.confident).map(([E])=>multiaddr(E))).map(E=>E.getPeerId()===this.components.peerId.toString()?E.decapsulate(`/p2p/${this.components.peerId.toString()}`):E);this.components.peerStore.patch(this.components.peerId,{multiaddrs:J}).catch(E=>{log$1p.error("error updating addresses",E)})}getListenAddrs(){return Array.from(this.listen).map(J=>multiaddr(J))}getAnnounceAddrs(){return Array.from(this.announce).map(J=>multiaddr(J))}getObservedAddrs(){return Array.from(this.observed).map(([J])=>multiaddr(J))}addObservedAddr(J){J=stripPeerId$1(J,this.components.peerId);const E=J.toString();this.observed.has(E)||this.observed.set(E,{confident:!1})}confirmObservedAddr(J){J=stripPeerId$1(J,this.components.peerId);const E=J.toString(),ee=(this.observed.get(E)??{confident:!1}).confident;this.observed.set(E,{confident:!0}),ee||this._updatePeerStoreAddresses()}removeObservedAddr(J){J=stripPeerId$1(J,this.components.peerId);const E=J.toString();this.observed.delete(E)}getAddresses(){let J=this.getAnnounceAddrs().map(ee=>ee.toString());J.length===0&&(J=this.components.transportManager.getAddrs().map(ee=>ee.toString())),J=J.concat(Array.from(this.observed).filter(([ee,te])=>te.confident).map(([ee])=>ee));const E=new Set(J);return this.announceFilter(Array.from(E).map(ee=>multiaddr(ee))).map(ee=>ee.protos().pop()?.path===!0||ee.getPeerId()===this.components.peerId.toString()?ee:ee.encapsulate(`/p2p/${this.components.peerId.toString()}`))}};const KEEP_ALIVE="keep-alive";var RateLimiterAbstract_1=class{constructor(J={}){this.points=J.points,this.duration=J.duration,this.blockDuration=J.blockDuration,this.execEvenly=J.execEvenly,this.execEvenlyMinDelayMs=J.execEvenlyMinDelayMs,this.keyPrefix=J.keyPrefix}get points(){return this._points}set points(J){this._points=J>=0?J:4}get duration(){return this._duration}set duration(J){this._duration=typeof J>"u"?1:J}get msDuration(){return this.duration*1e3}get blockDuration(){return this._blockDuration}set blockDuration(J){this._blockDuration=typeof J>"u"?0:J}get msBlockDuration(){return this.blockDuration*1e3}get execEvenly(){return this._execEvenly}set execEvenly(J){this._execEvenly=typeof J>"u"?!1:!!J}get execEvenlyMinDelayMs(){return this._execEvenlyMinDelayMs}set execEvenlyMinDelayMs(J){this._execEvenlyMinDelayMs=typeof J>"u"?Math.ceil(this.msDuration/this.points):J}get keyPrefix(){return this._keyPrefix}set keyPrefix(J){if(typeof J>"u"&&(J="rlflx"),typeof J!="string")throw new Error("keyPrefix must be string");this._keyPrefix=J}_getKeySecDuration(J={}){return J&&J.customDuration>=0?J.customDuration:this.duration}getKey(J){return this.keyPrefix.length>0?`${this.keyPrefix}:${J}`:J}parseKey(J){return J.substring(this.keyPrefix.length)}consume(){throw new Error("You have to implement the method 'consume'!")}penalty(){throw new Error("You have to implement the method 'penalty'!")}reward(){throw new Error("You have to implement the method 'reward'!")}get(){throw new Error("You have to implement the method 'get'!")}set(){throw new Error("You have to implement the method 'set'!")}block(){throw new Error("You have to implement the method 'block'!")}delete(){throw new Error("You have to implement the method 'delete'!")}},BlockedKeys_1$1=class{constructor(){this._keys={},this._addedKeysAmount=0}collectExpired(){const J=Date.now();Object.keys(this._keys).forEach(E=>{this._keys[E]<=J&&delete this._keys[E]}),this._addedKeysAmount=Object.keys(this._keys).length}add(J,E){this.addMs(J,E*1e3)}addMs(J,E){this._keys[J]=Date.now()+E,this._addedKeysAmount++,this._addedKeysAmount>999&&this.collectExpired()}msBeforeExpire(J){const E=this._keys[J];if(E&&E>=Date.now()){this.collectExpired();const ee=Date.now();return E>=ee?E-ee:0}return 0}delete(J){J?delete this._keys[J]:Object.keys(this._keys).forEach(E=>{delete this._keys[E]})}};const BlockedKeys$1=BlockedKeys_1$1;var BlockedKeys_1=BlockedKeys$1,RateLimiterRes_1=class{constructor(J,E,ee,te){this.remainingPoints=typeof J>"u"?0:J,this.msBeforeNext=typeof E>"u"?0:E,this.consumedPoints=typeof ee>"u"?0:ee,this.isFirstInDuration=typeof te>"u"?!1:te}get msBeforeNext(){return this._msBeforeNext}set msBeforeNext(J){return this._msBeforeNext=J,this}get remainingPoints(){return this._remainingPoints}set remainingPoints(J){return this._remainingPoints=J,this}get consumedPoints(){return this._consumedPoints}set consumedPoints(J){return this._consumedPoints=J,this}get isFirstInDuration(){return this._isFirstInDuration}set isFirstInDuration(J){this._isFirstInDuration=!!J}_getDecoratedProperties(){return{remainingPoints:this.remainingPoints,msBeforeNext:this.msBeforeNext,consumedPoints:this.consumedPoints,isFirstInDuration:this.isFirstInDuration}}[Symbol.for("nodejs.util.inspect.custom")](){return this._getDecoratedProperties()}toString(){return JSON.stringify(this._getDecoratedProperties())}toJSON(){return this._getDecoratedProperties()}};const RateLimiterAbstract$3=RateLimiterAbstract_1,BlockedKeys=BlockedKeys_1,RateLimiterRes$b=RateLimiterRes_1;var RateLimiterStoreAbstract_1=class extends RateLimiterAbstract$3{constructor(J={}){super(J),this.inMemoryBlockOnConsumed=J.inMemoryBlockOnConsumed||J.inmemoryBlockOnConsumed,this.inMemoryBlockDuration=J.inMemoryBlockDuration||J.inmemoryBlockDuration,this.insuranceLimiter=J.insuranceLimiter,this._inMemoryBlockedKeys=new BlockedKeys}get client(){return this._client}set client(J){if(typeof J>"u")throw new Error("storeClient is not set");this._client=J}_afterConsume(J,E,ee,te,re,ne={}){const ie=this._getRateLimiterRes(ee,te,re);if(this.inMemoryBlockOnConsumed>0&&!(this.inMemoryBlockDuration>0)&&ie.consumedPoints>=this.inMemoryBlockOnConsumed)return this._inMemoryBlockedKeys.addMs(ee,ie.msBeforeNext),ie.consumedPoints>this.points?E(ie):J(ie);if(ie.consumedPoints>this.points){let se=Promise.resolve();this.blockDuration>0&&ie.consumedPoints<=this.points+te&&(ie.msBeforeNext=this.msBlockDuration,se=this._block(ee,ie.consumedPoints,this.msBlockDuration,ne)),this.inMemoryBlockOnConsumed>0&&ie.consumedPoints>=this.inMemoryBlockOnConsumed&&(this._inMemoryBlockedKeys.add(ee,this.inMemoryBlockDuration),ie.msBeforeNext=this.msInMemoryBlockDuration),se.then(()=>{E(ie)}).catch(oe=>{E(oe)})}else if(this.execEvenly&&ie.msBeforeNext>0&&!ie.isFirstInDuration){let se=Math.ceil(ie.msBeforeNext/(ie.remainingPoints+2));se<this.execEvenlyMinDelayMs&&(se=ie.consumedPoints*this.execEvenlyMinDelayMs),setTimeout(J,se,ie)}else J(ie)}_handleError(J,E,ee,te,re,ne=!1,ie={}){this.insuranceLimiter instanceof RateLimiterAbstract$3?this.insuranceLimiter[E](re,ne,ie).then(se=>{ee(se)}).catch(se=>{te(se)}):te(J)}get _inmemoryBlockedKeys(){return this._inMemoryBlockedKeys}getInmemoryBlockMsBeforeExpire(J){return this.getInMemoryBlockMsBeforeExpire(J)}get inmemoryBlockOnConsumed(){return this.inMemoryBlockOnConsumed}set inmemoryBlockOnConsumed(J){this.inMemoryBlockOnConsumed=J}get inmemoryBlockDuration(){return this.inMemoryBlockDuration}set inmemoryBlockDuration(J){this.inMemoryBlockDuration=J}get msInmemoryBlockDuration(){return this.inMemoryBlockDuration*1e3}getInMemoryBlockMsBeforeExpire(J){return this.inMemoryBlockOnConsumed>0?this._inMemoryBlockedKeys.msBeforeExpire(J):0}get inMemoryBlockOnConsumed(){return this._inMemoryBlockOnConsumed}set inMemoryBlockOnConsumed(J){if(this._inMemoryBlockOnConsumed=J?parseInt(J):0,this.inMemoryBlockOnConsumed>0&&this.points>this.inMemoryBlockOnConsumed)throw new Error('inMemoryBlockOnConsumed option must be greater or equal "points" option')}get inMemoryBlockDuration(){return this._inMemoryBlockDuration}set inMemoryBlockDuration(J){if(this._inMemoryBlockDuration=J?parseInt(J):0,this.inMemoryBlockDuration>0&&this.inMemoryBlockOnConsumed===0)throw new Error("inMemoryBlockOnConsumed option must be set up")}get msInMemoryBlockDuration(){return this._inMemoryBlockDuration*1e3}get insuranceLimiter(){return this._insuranceLimiter}set insuranceLimiter(J){if(typeof J<"u"&&!(J instanceof RateLimiterAbstract$3))throw new Error("insuranceLimiter must be instance of RateLimiterAbstract");this._insuranceLimiter=J,this._insuranceLimiter&&(this._insuranceLimiter.blockDuration=this.blockDuration,this._insuranceLimiter.execEvenly=this.execEvenly)}block(J,E,ee={}){const te=E*1e3;return this._block(this.getKey(J),this.points+1,te,ee)}set(J,E,ee,te={}){const re=(ee>=0?ee:this.duration)*1e3;return this._block(this.getKey(J),E,re,te)}consume(J,E=1,ee={}){return new Promise((te,re)=>{const ne=this.getKey(J),ie=this.getInMemoryBlockMsBeforeExpire(ne);if(ie>0)return re(new RateLimiterRes$b(0,ie));this._upsert(ne,E,this._getKeySecDuration(ee)*1e3,!1,ee).then(se=>{this._afterConsume(te,re,ne,E,se)}).catch(se=>{this._handleError(se,"consume",te,re,J,E,ee)})})}penalty(J,E=1,ee={}){const te=this.getKey(J);return new Promise((re,ne)=>{this._upsert(te,E,this._getKeySecDuration(ee)*1e3,!1,ee).then(ie=>{re(this._getRateLimiterRes(te,E,ie))}).catch(ie=>{this._handleError(ie,"penalty",re,ne,J,E,ee)})})}reward(J,E=1,ee={}){const te=this.getKey(J);return new Promise((re,ne)=>{this._upsert(te,-E,this._getKeySecDuration(ee)*1e3,!1,ee).then(ie=>{re(this._getRateLimiterRes(te,-E,ie))}).catch(ie=>{this._handleError(ie,"reward",re,ne,J,E,ee)})})}get(J,E={}){const ee=this.getKey(J);return new Promise((te,re)=>{this._get(ee,E).then(ne=>{te(ne===null||typeof ne>"u"?null:this._getRateLimiterRes(ee,0,ne))}).catch(ne=>{this._handleError(ne,"get",te,re,J,E)})})}delete(J,E={}){const ee=this.getKey(J);return new Promise((te,re)=>{this._delete(ee,E).then(ne=>{this._inMemoryBlockedKeys.delete(ee),te(ne)}).catch(ne=>{this._handleError(ne,"delete",te,re,J,E)})})}deleteInMemoryBlockedAll(){this._inMemoryBlockedKeys.delete()}_getRateLimiterRes(J,E,ee){throw new Error("You have to implement the method '_getRateLimiterRes'!")}_block(J,E,ee,te={}){return new Promise((re,ne)=>{this._upsert(J,E,ee,!0,te).then(()=>{re(new RateLimiterRes$b(0,ee>0?ee:-1,E))}).catch(ie=>{this._handleError(ie,"block",re,ne,this.parseKey(J),ee/1e3,te)})})}_get(J,E={}){throw new Error("You have to implement the method '_get'!")}_delete(J,E={}){throw new Error("You have to implement the method '_delete'!")}_upsert(J,E,ee,te=!1,re={}){throw new Error("You have to implement the method '_upsert'!")}};const RateLimiterStoreAbstract$4=RateLimiterStoreAbstract_1,RateLimiterRes$a=RateLimiterRes_1,incrTtlLuaScript="redis.call('set', KEYS[1], 0, 'EX', ARGV[2], 'NX') local consumed = redis.call('incrby', KEYS[1], ARGV[1]) local ttl = redis.call('pttl', KEYS[1]) if ttl == -1 then   redis.call('expire', KEYS[1], ARGV[2])   ttl = 1000 * ARGV[2] end return {consumed, ttl} ";let RateLimiterRedis$1=class extends RateLimiterStoreAbstract$4{constructor(J){super(J),J.redis?this.client=J.redis:this.client=J.storeClient,this._rejectIfRedisNotReady=!!J.rejectIfRedisNotReady,typeof this.client.defineCommand=="function"&&this.client.defineCommand("rlflxIncr",{numberOfKeys:1,lua:incrTtlLuaScript})}_isRedisReady(){return this._rejectIfRedisNotReady?!(this.client.status&&this.client.status!=="ready"||typeof this.client.isReady=="function"&&!this.client.isReady()):!0}_getRateLimiterRes(J,E,ee){let[te,re]=ee;Array.isArray(te)&&([,te]=te,[,re]=re);const ne=new RateLimiterRes$a;return ne.consumedPoints=parseInt(te),ne.isFirstInDuration=ne.consumedPoints===E,ne.remainingPoints=Math.max(this.points-ne.consumedPoints,0),ne.msBeforeNext=re,ne}_upsert(J,E,ee,te=!1){return new Promise((re,ne)=>{if(!this._isRedisReady())return ne(new Error("Redis connection is not ready"));const ie=Math.floor(ee/1e3),se=this.client.multi();if(te)ie>0?se.set(J,E,"EX",ie):se.set(J,E),se.pttl(J).exec((oe,ce)=>oe?ne(oe):re(ce));else if(ie>0){const oe=function(ce,ae){return ce?ne(ce):re(ae)};typeof this.client.rlflxIncr=="function"?this.client.rlflxIncr(J,E,ie,oe):this.client.eval(incrTtlLuaScript,1,J,E,ie,oe)}else se.incrby(J,E).pttl(J).exec((oe,ce)=>oe?ne(oe):re(ce))})}_get(J){return new Promise((E,ee)=>{if(!this._isRedisReady())return ee(new Error("Redis connection is not ready"));this.client.multi().get(J).pttl(J).exec((te,re)=>{if(te)ee(te);else{const[ne]=re;if(ne===null)return E(null);E(re)}})})}_delete(J){return new Promise((E,ee)=>{this.client.del(J,(te,re)=>{te?ee(te):E(re>0)})})}};var RateLimiterRedis_1=RateLimiterRedis$1;const RateLimiterStoreAbstract$3=RateLimiterStoreAbstract_1,RateLimiterRes$9=RateLimiterRes_1;function getDriverVersion(J){try{const E=J.client?J.client:J,{version:ee}=E.topology.s.options.metadata.driver,te=ee.split(".").map(re=>parseInt(re));return{major:te[0],feature:te[1],patch:te[2]}}catch{return{major:0,feature:0,patch:0}}}let RateLimiterMongo$1=class Kt extends RateLimiterStoreAbstract$3{constructor(E){super(E),this.dbName=E.dbName,this.tableName=E.tableName,this.indexKeyPrefix=E.indexKeyPrefix,E.mongo?this.client=E.mongo:this.client=E.storeClient,typeof this.client.then=="function"?this.client.then(ee=>{this.client=ee,this._initCollection(),this._driverVersion=getDriverVersion(this.client)}):(this._initCollection(),this._driverVersion=getDriverVersion(this.client))}get dbName(){return this._dbName}set dbName(E){this._dbName=typeof E>"u"?Kt.getDbName():E}static getDbName(){return"node-rate-limiter-flexible"}get tableName(){return this._tableName}set tableName(E){this._tableName=typeof E>"u"?this.keyPrefix:E}get client(){return this._client}set client(E){if(typeof E>"u")throw new Error("mongo is not set");this._client=E}get indexKeyPrefix(){return this._indexKeyPrefix}set indexKeyPrefix(E){this._indexKeyPrefix=E||{}}_initCollection(){const E=(typeof this.client.db=="function"?this.client.db(this.dbName):this.client).collection(this.tableName);E.createIndex({expire:-1},{expireAfterSeconds:0}),E.createIndex(Object.assign({},this.indexKeyPrefix,{key:1}),{unique:!0}),this._collection=E}_getRateLimiterRes(E,ee,te){const re=new RateLimiterRes$9;let ne;return typeof te.value>"u"?ne=te:ne=te.value,re.isFirstInDuration=ne.points===ee,re.consumedPoints=ne.points,re.remainingPoints=Math.max(this.points-re.consumedPoints,0),re.msBeforeNext=ne.expire!==null?Math.max(new Date(ne.expire).getTime()-Date.now(),0):-1,re}_upsert(E,ee,te,re=!1,ne={}){if(!this._collection)return Promise.reject(Error("Mongo connection is not established"));const ie=ne.attrs||{};let se,oe;re?(se={key:E},se=Object.assign(se,ie),oe={$set:{key:E,points:ee,expire:te>0?new Date(Date.now()+te):null}},oe.$set=Object.assign(oe.$set,ie)):(se={$or:[{expire:{$gt:new Date}},{expire:{$eq:null}}],key:E},se=Object.assign(se,ie),oe={$setOnInsert:{key:E,expire:te>0?new Date(Date.now()+te):null},$inc:{points:ee}},oe.$setOnInsert=Object.assign(oe.$setOnInsert,ie));const ce={upsert:!0};return this._driverVersion.major>=4||this._driverVersion.major===3&&this._driverVersion.feature>=7||this._driverVersion.feature>=6&&this._driverVersion.patch>=7?ce.returnDocument="after":ce.returnOriginal=!1,new Promise((ae,le)=>{this._collection.findOneAndUpdate(se,oe,ce).then(ue=>{ae(ue)}).catch(ue=>{if(ue&&ue.code===11e3){const he=Object.assign({$or:[{expire:{$lte:new Date}},{expire:{$eq:null}}],key:E},ie),pe={$set:Object.assign({key:E,points:ee,expire:te>0?new Date(Date.now()+te):null},ie)};this._collection.findOneAndUpdate(he,pe,ce).then(de=>{ae(de)}).catch(de=>{de&&de.code===11e3?this._upsert(E,ee,te,re).then(fe=>ae(fe)).catch(fe=>le(fe)):le(de)})}else le(ue)})})}_get(E,ee={}){if(!this._collection)return Promise.reject(Error("Mongo connection is not established"));const te=ee.attrs||{},re=Object.assign({key:E,$or:[{expire:{$gt:new Date}},{expire:{$eq:null}}]},te);return this._collection.findOne(re)}_delete(E,ee={}){if(!this._collection)return Promise.reject(Error("Mongo connection is not established"));const te=ee.attrs||{},re=Object.assign({key:E},te);return this._collection.deleteOne(re).then(ne=>ne.deletedCount>0)}};var RateLimiterMongo_1=RateLimiterMongo$1;const RateLimiterStoreAbstract$2=RateLimiterStoreAbstract_1,RateLimiterRes$8=RateLimiterRes_1;let RateLimiterMySQL$1=class extends RateLimiterStoreAbstract$2{constructor(J,E=null){super(J),this.client=J.storeClient,this.clientType=J.storeType,this.dbName=J.dbName,this.tableName=J.tableName,this.clearExpiredByTimeout=J.clearExpiredByTimeout,this.tableCreated=J.tableCreated,this.tableCreated?(this.clearExpiredByTimeout&&this._clearExpiredHourAgo(),typeof E=="function"&&E()):this._createDbAndTable().then(()=>{this.tableCreated=!0,this.clearExpiredByTimeout&&this._clearExpiredHourAgo(),typeof E=="function"&&E()}).catch(ee=>{if(typeof E=="function")E(ee);else throw ee})}clearExpired(J){return new Promise(E=>{this._getConnection().then(ee=>{ee.query("DELETE FROM ??.?? WHERE expire < ?",[this.dbName,this.tableName,J],()=>{this._releaseConnection(ee),E()})}).catch(()=>{E()})})}_clearExpiredHourAgo(){this._clearExpiredTimeoutId&&clearTimeout(this._clearExpiredTimeoutId),this._clearExpiredTimeoutId=setTimeout(()=>{this.clearExpired(Date.now()-36e5).then(()=>{this._clearExpiredHourAgo()})},3e5),this._clearExpiredTimeoutId.unref()}_getConnection(){switch(this.clientType){case"pool":return new Promise((J,E)=>{this.client.getConnection((ee,te)=>{if(ee)return E(ee);J(te)})});case"sequelize":return this.client.connectionManager.getConnection();case"knex":return this.client.client.acquireConnection();default:return Promise.resolve(this.client)}}_releaseConnection(J){switch(this.clientType){case"pool":return J.release();case"sequelize":return this.client.connectionManager.releaseConnection(J);case"knex":return this.client.client.releaseConnection(J);default:return!0}}_createDbAndTable(){return new Promise((J,E)=>{this._getConnection().then(ee=>{ee.query(`CREATE DATABASE IF NOT EXISTS \`${this.dbName}\`;`,te=>{if(te)return this._releaseConnection(ee),E(te);ee.query(this._getCreateTableStmt(),re=>{if(re)return this._releaseConnection(ee),E(re);this._releaseConnection(ee),J()})})}).catch(ee=>{E(ee)})})}_getCreateTableStmt(){return`CREATE TABLE IF NOT EXISTS \`${this.dbName}\`.\`${this.tableName}\` (\`key\` VARCHAR(255) CHARACTER SET utf8 NOT NULL,\`points\` INT(9) NOT NULL default 0,\`expire\` BIGINT UNSIGNED,PRIMARY KEY (\`key\`)) ENGINE = INNODB;`}get clientType(){return this._clientType}set clientType(J){if(typeof J>"u")if(this.client.constructor.name==="Connection")J="connection";else if(this.client.constructor.name==="Pool")J="pool";else if(this.client.constructor.name==="Sequelize")J="sequelize";else throw new Error("storeType is not defined");this._clientType=J.toLowerCase()}get dbName(){return this._dbName}set dbName(J){this._dbName=typeof J>"u"?"rtlmtrflx":J}get tableName(){return this._tableName}set tableName(J){this._tableName=typeof J>"u"?this.keyPrefix:J}get tableCreated(){return this._tableCreated}set tableCreated(J){this._tableCreated=typeof J>"u"?!1:!!J}get clearExpiredByTimeout(){return this._clearExpiredByTimeout}set clearExpiredByTimeout(J){this._clearExpiredByTimeout=typeof J>"u"?!0:!!J}_getRateLimiterRes(J,E,ee){const te=new RateLimiterRes$8,[re]=ee;return te.isFirstInDuration=E===re.points,te.consumedPoints=te.isFirstInDuration?E:re.points,te.remainingPoints=Math.max(this.points-te.consumedPoints,0),te.msBeforeNext=re.expire?Math.max(re.expire-Date.now(),0):-1,te}_upsertTransaction(J,E,ee,te,re){return new Promise((ne,ie)=>{J.query("BEGIN",se=>{if(se)return J.rollback(),ie(se);const oe=Date.now(),ce=te>0?oe+te:null;let ae,le;re?(ae=`INSERT INTO ??.?? VALUES (?, ?, ?)
          ON DUPLICATE KEY UPDATE 
            points = ?, 
            expire = ?;`,le=[this.dbName,this.tableName,E,ee,ce,ee,ce]):(ae=`INSERT INTO ??.?? VALUES (?, ?, ?)
          ON DUPLICATE KEY UPDATE 
            points = IF(expire <= ?, ?, points + (?)), 
            expire = IF(expire <= ?, ?, expire);`,le=[this.dbName,this.tableName,E,ee,ce,oe,ee,ee,oe,ce]),J.query(ae,le,ue=>{if(ue)return J.rollback(),ie(ue);J.query("SELECT points, expire FROM ??.?? WHERE `key` = ?;",[this.dbName,this.tableName,E],(he,pe)=>{if(he)return J.rollback(),ie(he);J.query("COMMIT",de=>{if(de)return J.rollback(),ie(de);ne(pe)})})})})})}_upsert(J,E,ee,te=!1){return this.tableCreated?new Promise((re,ne)=>{this._getConnection().then(ie=>{this._upsertTransaction(ie,J,E,ee,te).then(se=>{re(se),this._releaseConnection(ie)}).catch(se=>{ne(se),this._releaseConnection(ie)})}).catch(ie=>{ne(ie)})}):Promise.reject(Error("Table is not created yet"))}_get(J){return this.tableCreated?new Promise((E,ee)=>{this._getConnection().then(te=>{te.query("SELECT points, expire FROM ??.?? WHERE `key` = ? AND (`expire` > ? OR `expire` IS NULL)",[this.dbName,this.tableName,J,Date.now()],(re,ne)=>{re?ee(re):ne.length===0?E(null):E(ne),this._releaseConnection(te)})}).catch(te=>{ee(te)})}):Promise.reject(Error("Table is not created yet"))}_delete(J){return this.tableCreated?new Promise((E,ee)=>{this._getConnection().then(te=>{te.query("DELETE FROM ??.?? WHERE `key` = ?",[this.dbName,this.tableName,J],(re,ne)=>{re?ee(re):E(ne.affectedRows>0),this._releaseConnection(te)})}).catch(te=>{ee(te)})}):Promise.reject(Error("Table is not created yet"))}};var RateLimiterMySQL_1=RateLimiterMySQL$1;const RateLimiterStoreAbstract$1=RateLimiterStoreAbstract_1,RateLimiterRes$7=RateLimiterRes_1;let RateLimiterPostgres$1=class extends RateLimiterStoreAbstract$1{constructor(J,E=null){super(J),this.client=J.storeClient,this.clientType=J.storeType,this.tableName=J.tableName,this.clearExpiredByTimeout=J.clearExpiredByTimeout,this.tableCreated=J.tableCreated,this.tableCreated?typeof E=="function"&&E():this._createTable().then(()=>{this.tableCreated=!0,this.clearExpiredByTimeout&&this._clearExpiredHourAgo(),typeof E=="function"&&E()}).catch(ee=>{if(typeof E=="function")E(ee);else throw ee})}clearExpired(J){return new Promise(E=>{const ee={name:"rlflx-clear-expired",text:`DELETE FROM ${this.tableName} WHERE expire < $1`,values:[J]};this._query(ee).then(()=>{E()}).catch(()=>{E()})})}_clearExpiredHourAgo(){this._clearExpiredTimeoutId&&clearTimeout(this._clearExpiredTimeoutId),this._clearExpiredTimeoutId=setTimeout(()=>{this.clearExpired(Date.now()-36e5).then(()=>{this._clearExpiredHourAgo()})},3e5),this._clearExpiredTimeoutId.unref()}_getConnection(){switch(this.clientType){case"pool":return Promise.resolve(this.client);case"sequelize":return this.client.connectionManager.getConnection();case"knex":return this.client.client.acquireConnection();case"typeorm":return Promise.resolve(this.client.driver.master);default:return Promise.resolve(this.client)}}_releaseConnection(J){switch(this.clientType){case"pool":return!0;case"sequelize":return this.client.connectionManager.releaseConnection(J);case"knex":return this.client.client.releaseConnection(J);case"typeorm":return!0;default:return!0}}_createTable(){return new Promise((J,E)=>{this._query({text:this._getCreateTableStmt()}).then(()=>{J()}).catch(ee=>{ee.code==="23505"?J():E(ee)})})}_getCreateTableStmt(){return`CREATE TABLE IF NOT EXISTS ${this.tableName} ( 
      key varchar(255) PRIMARY KEY,
      points integer NOT NULL DEFAULT 0,
      expire bigint
    );`}get clientType(){return this._clientType}set clientType(J){const E=this.client.constructor.name;if(typeof J>"u")if(E==="Client")J="client";else if(E==="Pool"||E==="BoundPool")J="pool";else if(E==="Sequelize")J="sequelize";else throw new Error("storeType is not defined");this._clientType=J.toLowerCase()}get tableName(){return this._tableName}set tableName(J){this._tableName=typeof J>"u"?this.keyPrefix:J}get tableCreated(){return this._tableCreated}set tableCreated(J){this._tableCreated=typeof J>"u"?!1:!!J}get clearExpiredByTimeout(){return this._clearExpiredByTimeout}set clearExpiredByTimeout(J){this._clearExpiredByTimeout=typeof J>"u"?!0:!!J}_getRateLimiterRes(J,E,ee){const te=new RateLimiterRes$7,re=ee.rows[0];return te.isFirstInDuration=E===re.points,te.consumedPoints=te.isFirstInDuration?E:re.points,te.remainingPoints=Math.max(this.points-te.consumedPoints,0),te.msBeforeNext=re.expire?Math.max(re.expire-Date.now(),0):-1,te}_query(J){const E={name:`${this.tableName.toLowerCase()}:${J.name}`,text:J.text,values:J.values};return new Promise((ee,te)=>{this._getConnection().then(re=>{re.query(E).then(ne=>{ee(ne),this._releaseConnection(re)}).catch(ne=>{te(ne),this._releaseConnection(re)})}).catch(re=>{te(re)})})}_upsert(J,E,ee,te=!1){if(!this.tableCreated)return Promise.reject(Error("Table is not created yet"));const re=ee>0?Date.now()+ee:null,ne=te?" $3 ":` CASE
             WHEN ${this.tableName}.expire <= $4 THEN $3
             ELSE ${this.tableName}.expire
            END `;return this._query({name:te?"rlflx-upsert-force":"rlflx-upsert",text:`
            INSERT INTO ${this.tableName} VALUES ($1, $2, $3)
              ON CONFLICT(key) DO UPDATE SET
                points = CASE
                          WHEN (${this.tableName}.expire <= $4 OR 1=${te?1:0}) THEN $2
                          ELSE ${this.tableName}.points + ($2)
                         END,
                expire = ${ne}
            RETURNING points, expire;`,values:[J,E,re,Date.now()]})}_get(J){return this.tableCreated?new Promise((E,ee)=>{this._query({name:"rlflx-get",text:`
            SELECT points, expire FROM ${this.tableName} WHERE key = $1 AND (expire > $2 OR expire IS NULL);`,values:[J,Date.now()]}).then(te=>{te.rowCount===0&&(te=null),E(te)}).catch(te=>{ee(te)})}):Promise.reject(Error("Table is not created yet"))}_delete(J){return this.tableCreated?this._query({name:"rlflx-delete",text:`DELETE FROM ${this.tableName} WHERE key = $1`,values:[J]}).then(E=>E.rowCount>0):Promise.reject(Error("Table is not created yet"))}};var RateLimiterPostgres_1=RateLimiterPostgres$1,Record_1=class{constructor(J,E,ee=null){this.value=J,this.expiresAt=E,this.timeoutId=ee}get value(){return this._value}set value(J){this._value=parseInt(J)}get expiresAt(){return this._expiresAt}set expiresAt(J){!(J instanceof Date)&&Number.isInteger(J)&&(J=new Date(J)),this._expiresAt=J}get timeoutId(){return this._timeoutId}set timeoutId(J){this._timeoutId=J}};const Record$2=Record_1,RateLimiterRes$6=RateLimiterRes_1;var MemoryStorage_1=class{constructor(){this._storage={}}incrby(J,E,ee){if(this._storage[J]){const te=this._storage[J].expiresAt?this._storage[J].expiresAt.getTime()-new Date().getTime():-1;return te!==0?(this._storage[J].value=this._storage[J].value+E,new RateLimiterRes$6(0,te,this._storage[J].value,!1)):this.set(J,E,ee)}return this.set(J,E,ee)}set(J,E,ee){const te=ee*1e3;return this._storage[J]&&this._storage[J].timeoutId&&clearTimeout(this._storage[J].timeoutId),this._storage[J]=new Record$2(E,te>0?new Date(Date.now()+te):null),te>0&&(this._storage[J].timeoutId=setTimeout(()=>{delete this._storage[J]},te),this._storage[J].timeoutId.unref&&this._storage[J].timeoutId.unref()),new RateLimiterRes$6(0,te===0?-1:te,this._storage[J].value,!0)}get(J){if(this._storage[J]){const E=this._storage[J].expiresAt?this._storage[J].expiresAt.getTime()-new Date().getTime():-1;return new RateLimiterRes$6(0,E,this._storage[J].value,!1)}return null}delete(J){return this._storage[J]?(this._storage[J].timeoutId&&clearTimeout(this._storage[J].timeoutId),delete this._storage[J],!0):!1}};const RateLimiterAbstract$2=RateLimiterAbstract_1,MemoryStorage=MemoryStorage_1,RateLimiterRes$5=RateLimiterRes_1;let RateLimiterMemory$2=class extends RateLimiterAbstract$2{constructor(J={}){super(J),this._memoryStorage=new MemoryStorage}consume(J,E=1,ee={}){return new Promise((te,re)=>{const ne=this.getKey(J),ie=this._getKeySecDuration(ee);let se=this._memoryStorage.incrby(ne,E,ie);if(se.remainingPoints=Math.max(this.points-se.consumedPoints,0),se.consumedPoints>this.points)this.blockDuration>0&&se.consumedPoints<=this.points+E&&(se=this._memoryStorage.set(ne,se.consumedPoints,this.blockDuration)),re(se);else if(this.execEvenly&&se.msBeforeNext>0&&!se.isFirstInDuration){let oe=Math.ceil(se.msBeforeNext/(se.remainingPoints+2));oe<this.execEvenlyMinDelayMs&&(oe=se.consumedPoints*this.execEvenlyMinDelayMs),setTimeout(te,oe,se)}else te(se)})}penalty(J,E=1,ee={}){const te=this.getKey(J);return new Promise(re=>{const ne=this._getKeySecDuration(ee),ie=this._memoryStorage.incrby(te,E,ne);ie.remainingPoints=Math.max(this.points-ie.consumedPoints,0),re(ie)})}reward(J,E=1,ee={}){const te=this.getKey(J);return new Promise(re=>{const ne=this._getKeySecDuration(ee),ie=this._memoryStorage.incrby(te,-E,ne);ie.remainingPoints=Math.max(this.points-ie.consumedPoints,0),re(ie)})}block(J,E){const ee=E*1e3,te=this.points+1;return this._memoryStorage.set(this.getKey(J),te,E),Promise.resolve(new RateLimiterRes$5(0,ee===0?-1:ee,te))}set(J,E,ee){const te=(ee>=0?ee:this.duration)*1e3;return this._memoryStorage.set(this.getKey(J),E,ee),Promise.resolve(new RateLimiterRes$5(0,te===0?-1:te,E))}get(J){const E=this._memoryStorage.get(this.getKey(J));return E!==null&&(E.remainingPoints=Math.max(this.points-E.consumedPoints,0)),Promise.resolve(E)}delete(J){return Promise.resolve(this._memoryStorage.delete(this.getKey(J)))}};var RateLimiterMemory_1=RateLimiterMemory$2;const cluster=require$$8,crypto$5=require$$8,RateLimiterAbstract$1=RateLimiterAbstract_1,RateLimiterMemory$1=RateLimiterMemory_1,RateLimiterRes$4=RateLimiterRes_1,channel="rate_limiter_flexible";let masterInstance=null;const masterSendToWorker=function(J,E,ee,te){let re;te===null||te===!0||te===!1?re=te:re={remainingPoints:te.remainingPoints,msBeforeNext:te.msBeforeNext,consumedPoints:te.consumedPoints,isFirstInDuration:te.isFirstInDuration},J.send({channel,keyPrefix:E.keyPrefix,promiseId:E.promiseId,type:ee,data:re})},workerWaitInit=function(J){setTimeout(()=>{this._initiated?process.send(J):typeof this._promises[J.promiseId]<"u"&&workerWaitInit.call(this,J)},30)},workerSendToMaster=function(J,E,ee,te,re){const ne={channel,keyPrefix:this.keyPrefix,func:J,promiseId:E,data:{key:ee,arg:te,opts:re}};this._initiated?process.send(ne):workerWaitInit.call(this,ne)},masterProcessMsg=function(J,E){if(!E||E.channel!==channel||typeof this._rateLimiters[E.keyPrefix]>"u")return!1;let ee;switch(E.func){case"consume":ee=this._rateLimiters[E.keyPrefix].consume(E.data.key,E.data.arg,E.data.opts);break;case"penalty":ee=this._rateLimiters[E.keyPrefix].penalty(E.data.key,E.data.arg,E.data.opts);break;case"reward":ee=this._rateLimiters[E.keyPrefix].reward(E.data.key,E.data.arg,E.data.opts);break;case"block":ee=this._rateLimiters[E.keyPrefix].block(E.data.key,E.data.arg,E.data.opts);break;case"get":ee=this._rateLimiters[E.keyPrefix].get(E.data.key,E.data.opts);break;case"delete":ee=this._rateLimiters[E.keyPrefix].delete(E.data.key,E.data.opts);break;default:return!1}ee&&ee.then(te=>{masterSendToWorker(J,E,"resolve",te)}).catch(te=>{masterSendToWorker(J,E,"reject",te)})},workerProcessMsg=function(J){if(!J||J.channel!==channel||J.keyPrefix!==this.keyPrefix)return!1;if(this._promises[J.promiseId]){clearTimeout(this._promises[J.promiseId].timeoutId);let E;switch(J.data===null||J.data===!0||J.data===!1?E=J.data:E=new RateLimiterRes$4(J.data.remainingPoints,J.data.msBeforeNext,J.data.consumedPoints,J.data.isFirstInDuration),J.type){case"resolve":this._promises[J.promiseId].resolve(E);break;case"reject":this._promises[J.promiseId].reject(E);break;default:throw new Error(`RateLimiterCluster: no such message type '${J.type}'`)}delete this._promises[J.promiseId]}},getOpts=function(){return{points:this.points,duration:this.duration,blockDuration:this.blockDuration,execEvenly:this.execEvenly,execEvenlyMinDelayMs:this.execEvenlyMinDelayMs,keyPrefix:this.keyPrefix}},savePromise=function(J,E){const ee=process.hrtime();let te=ee[0].toString()+ee[1].toString();return typeof this._promises[te]<"u"&&(te+=crypto$5.randomBytes(12).toString("base64")),this._promises[te]={resolve:J,reject:E,timeoutId:setTimeout(()=>{delete this._promises[te],E(new Error("RateLimiterCluster timeout: no answer from master in time"))},this.timeoutMs)},te};let RateLimiterClusterMaster$1=class{constructor(){if(masterInstance)return masterInstance;this._rateLimiters={},cluster.setMaxListeners(0),cluster.on("message",(J,E)=>{E&&E.channel===channel&&E.type==="init"?(typeof this._rateLimiters[E.opts.keyPrefix]>"u"&&(this._rateLimiters[E.opts.keyPrefix]=new RateLimiterMemory$1(E.opts)),J.send({channel,type:"init",keyPrefix:E.opts.keyPrefix})):masterProcessMsg.call(this,J,E)}),masterInstance=this}},RateLimiterClusterMasterPM2$1=class{constructor(J){if(masterInstance)return masterInstance;this._rateLimiters={},J.launchBus((E,ee)=>{ee.on("process:msg",te=>{const re=te.raw;if(re&&re.channel===channel&&re.type==="init")typeof this._rateLimiters[re.opts.keyPrefix]>"u"&&(this._rateLimiters[re.opts.keyPrefix]=new RateLimiterMemory$1(re.opts)),J.sendDataToProcessId(te.process.pm_id,{data:{},topic:channel,channel,type:"init",keyPrefix:re.opts.keyPrefix},(ne,ie)=>{ne&&console.log(ne,ie)});else{const ne={send:ie=>{const se=ie;se.topic=channel,typeof se.data>"u"&&(se.data={}),J.sendDataToProcessId(te.process.pm_id,se,(oe,ce)=>{oe&&console.log(oe,ce)})}};masterProcessMsg.call(this,ne,re)}})}),masterInstance=this}};class RateLimiterClusterWorker extends RateLimiterAbstract$1{get timeoutMs(){return this._timeoutMs}set timeoutMs(E){this._timeoutMs=typeof E>"u"?5e3:Math.abs(parseInt(E))}constructor(E={}){super(E),process.setMaxListeners(0),this.timeoutMs=E.timeoutMs,this._initiated=!1,process.on("message",ee=>{ee&&ee.channel===channel&&ee.type==="init"&&ee.keyPrefix===this.keyPrefix?this._initiated=!0:workerProcessMsg.call(this,ee)}),process.send({channel,type:"init",opts:getOpts.call(this)}),this._promises={}}consume(E,ee=1,te={}){return new Promise((re,ne)=>{const ie=savePromise.call(this,re,ne);workerSendToMaster.call(this,"consume",ie,E,ee,te)})}penalty(E,ee=1,te={}){return new Promise((re,ne)=>{const ie=savePromise.call(this,re,ne);workerSendToMaster.call(this,"penalty",ie,E,ee,te)})}reward(E,ee=1,te={}){return new Promise((re,ne)=>{const ie=savePromise.call(this,re,ne);workerSendToMaster.call(this,"reward",ie,E,ee,te)})}block(E,ee,te={}){return new Promise((re,ne)=>{const ie=savePromise.call(this,re,ne);workerSendToMaster.call(this,"block",ie,E,ee,te)})}get(E,ee={}){return new Promise((te,re)=>{const ne=savePromise.call(this,te,re);workerSendToMaster.call(this,"get",ne,E,ee)})}delete(E,ee={}){return new Promise((te,re)=>{const ne=savePromise.call(this,te,re);workerSendToMaster.call(this,"delete",ne,E,ee)})}}var RateLimiterCluster$1={RateLimiterClusterMaster:RateLimiterClusterMaster$1,RateLimiterClusterMasterPM2:RateLimiterClusterMasterPM2$1,RateLimiterCluster:RateLimiterClusterWorker};const RateLimiterStoreAbstract=RateLimiterStoreAbstract_1,RateLimiterRes$3=RateLimiterRes_1;let RateLimiterMemcache$1=class extends RateLimiterStoreAbstract{constructor(J){super(J),this.client=J.storeClient}_getRateLimiterRes(J,E,ee){const te=new RateLimiterRes$3;return te.consumedPoints=parseInt(ee.consumedPoints),te.isFirstInDuration=ee.consumedPoints===E,te.remainingPoints=Math.max(this.points-te.consumedPoints,0),te.msBeforeNext=ee.msBeforeNext,te}_upsert(J,E,ee,te=!1,re={}){return new Promise((ne,ie)=>{const se=Date.now(),oe=Math.floor(ee/1e3);te?this.client.set(J,E,oe,ce=>{ce?ie(ce):this.client.set(`${J}_expire`,oe>0?se+oe*1e3:-1,oe,()=>{const ae={consumedPoints:E,msBeforeNext:oe>0?oe*1e3:-1};ne(ae)})}):this.client.incr(J,E,(ce,ae)=>{ce||ae===!1?this.client.add(J,E,oe,(le,ue)=>{if(le||!ue)if(typeof re.attemptNumber>"u"||re.attemptNumber<3){const he=Object.assign({},re);he.attemptNumber=he.attemptNumber?he.attemptNumber+1:1,this._upsert(J,E,ee,te,he).then(pe=>ne(pe)).catch(pe=>ie(pe))}else ie(new Error("Can not add key"));else this.client.add(`${J}_expire`,oe>0?se+oe*1e3:-1,oe,()=>{const he={consumedPoints:E,msBeforeNext:oe>0?oe*1e3:-1};ne(he)})}):this.client.get(`${J}_expire`,(le,ue)=>{if(le)ie(le);else{const he=ue===!1?0:ue,pe={consumedPoints:ae,msBeforeNext:he>=0?Math.max(he-se,0):-1};ne(pe)}})})})}_get(J){return new Promise((E,ee)=>{const te=Date.now();this.client.get(J,(re,ne)=>{ne?this.client.get(`${J}_expire`,(ie,se)=>{if(ie)ee(ie);else{const oe=se===!1?0:se,ce={consumedPoints:ne,msBeforeNext:oe>=0?Math.max(oe-te,0):-1};E(ce)}}):E(null)})})}_delete(J){return new Promise((E,ee)=>{this.client.del(J,(te,re)=>{te?ee(te):re===!1?E(re):this.client.del(`${J}_expire`,ne=>{ne?ee(ne):E(re)})})})}};var RateLimiterMemcache_1=RateLimiterMemcache$1;const RateLimiterRes$2=RateLimiterRes_1;var RLWrapperBlackAndWhite_1=class{constructor(J={}){this.limiter=J.limiter,this.blackList=J.blackList,this.whiteList=J.whiteList,this.isBlackListed=J.isBlackListed,this.isWhiteListed=J.isWhiteListed,this.runActionAnyway=J.runActionAnyway}get limiter(){return this._limiter}set limiter(J){if(typeof J>"u")throw new Error("limiter is not set");this._limiter=J}get runActionAnyway(){return this._runActionAnyway}set runActionAnyway(J){this._runActionAnyway=typeof J>"u"?!1:J}get blackList(){return this._blackList}set blackList(J){this._blackList=Array.isArray(J)?J:[]}get isBlackListed(){return this._isBlackListed}set isBlackListed(J){if(typeof J>"u"&&(J=()=>!1),typeof J!="function")throw new Error("isBlackListed must be function");this._isBlackListed=J}get whiteList(){return this._whiteList}set whiteList(J){this._whiteList=Array.isArray(J)?J:[]}get isWhiteListed(){return this._isWhiteListed}set isWhiteListed(J){if(typeof J>"u"&&(J=()=>!1),typeof J!="function")throw new Error("isWhiteListed must be function");this._isWhiteListed=J}isBlackListedSomewhere(J){return this.blackList.indexOf(J)>=0||this.isBlackListed(J)}isWhiteListedSomewhere(J){return this.whiteList.indexOf(J)>=0||this.isWhiteListed(J)}getBlackRes(){return new RateLimiterRes$2(0,Number.MAX_SAFE_INTEGER,0,!1)}getWhiteRes(){return new RateLimiterRes$2(Number.MAX_SAFE_INTEGER,0,0,!1)}rejectBlack(){return Promise.reject(this.getBlackRes())}resolveBlack(){return Promise.resolve(this.getBlackRes())}resolveWhite(){return Promise.resolve(this.getWhiteRes())}consume(J,E=1){let ee;return this.isWhiteListedSomewhere(J)?ee=this.resolveWhite():this.isBlackListedSomewhere(J)&&(ee=this.rejectBlack()),typeof ee>"u"?this.limiter.consume(J,E):(this.runActionAnyway&&this.limiter.consume(J,E).catch(()=>{}),ee)}block(J,E){let ee;return this.isWhiteListedSomewhere(J)?ee=this.resolveWhite():this.isBlackListedSomewhere(J)&&(ee=this.resolveBlack()),typeof ee>"u"?this.limiter.block(J,E):(this.runActionAnyway&&this.limiter.block(J,E).catch(()=>{}),ee)}penalty(J,E){let ee;return this.isWhiteListedSomewhere(J)?ee=this.resolveWhite():this.isBlackListedSomewhere(J)&&(ee=this.resolveBlack()),typeof ee>"u"?this.limiter.penalty(J,E):(this.runActionAnyway&&this.limiter.penalty(J,E).catch(()=>{}),ee)}reward(J,E){let ee;return this.isWhiteListedSomewhere(J)?ee=this.resolveWhite():this.isBlackListedSomewhere(J)&&(ee=this.resolveBlack()),typeof ee>"u"?this.limiter.reward(J,E):(this.runActionAnyway&&this.limiter.reward(J,E).catch(()=>{}),ee)}get(J){let E;return this.isWhiteListedSomewhere(J)?E=this.resolveWhite():this.isBlackListedSomewhere(J)&&(E=this.resolveBlack()),typeof E>"u"||this.runActionAnyway?this.limiter.get(J):E}delete(J){return this.limiter.delete(J)}};const RateLimiterAbstract=RateLimiterAbstract_1;var RateLimiterUnion_1=class{constructor(...J){if(J.length<1)throw new Error("RateLimiterUnion: at least one limiter have to be passed");J.forEach(E=>{if(!(E instanceof RateLimiterAbstract))throw new Error("RateLimiterUnion: all limiters have to be instance of RateLimiterAbstract")}),this._limiters=J}consume(J,E=1){return new Promise((ee,te)=>{const re=[];this._limiters.forEach(ne=>{re.push(ne.consume(J,E).catch(ie=>({rejected:!0,rej:ie})))}),Promise.all(re).then(ne=>{const ie={};let se=!1;ne.forEach(oe=>{oe.rejected===!0&&(se=!0)});for(let oe=0;oe<ne.length;oe++)se&&ne[oe].rejected===!0?ie[this._limiters[oe].keyPrefix]=ne[oe].rej:se||(ie[this._limiters[oe].keyPrefix]=ne[oe]);se?te(ie):ee(ie)})})}},RateLimiterQueueError_1=class extends Error{constructor(J,E){super(),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor),this.name="CustomError",this.message=J,E&&(this.extra=E)}};const RateLimiterQueueError=RateLimiterQueueError_1,MAX_QUEUE_SIZE=4294967295,KEY_DEFAULT="limiter";var RateLimiterQueue_1=class{constructor(J,E={maxQueueSize:MAX_QUEUE_SIZE}){this._queueLimiters={KEY_DEFAULT:new RateLimiterQueueInternal(J,E)},this._limiterFlexible=J,this._maxQueueSize=E.maxQueueSize}getTokensRemaining(J=KEY_DEFAULT){return this._queueLimiters[J]?this._queueLimiters[J].getTokensRemaining():Promise.resolve(this._limiterFlexible.points)}removeTokens(J,E=KEY_DEFAULT){return this._queueLimiters[E]||(this._queueLimiters[E]=new RateLimiterQueueInternal(this._limiterFlexible,{key:E,maxQueueSize:this._maxQueueSize})),this._queueLimiters[E].removeTokens(J)}};class RateLimiterQueueInternal{constructor(E,ee={maxQueueSize:MAX_QUEUE_SIZE,key:KEY_DEFAULT}){this._key=ee.key,this._waitTimeout=null,this._queue=[],this._limiterFlexible=E,this._maxQueueSize=ee.maxQueueSize}getTokensRemaining(){return this._limiterFlexible.get(this._key).then(E=>E!==null?E.remainingPoints:this._limiterFlexible.points)}removeTokens(E){const ee=this;return new Promise((te,re)=>{if(E>ee._limiterFlexible.points){re(new RateLimiterQueueError(`Requested tokens ${E} exceeds maximum ${ee._limiterFlexible.points} tokens per interval`));return}ee._queue.length>0?ee._queueRequest.call(ee,te,re,E):ee._limiterFlexible.consume(ee._key,E).then(ne=>{te(ne.remainingPoints)}).catch(ne=>{ne instanceof Error?re(ne):(ee._queueRequest.call(ee,te,re,E),ee._waitTimeout===null&&(ee._waitTimeout=setTimeout(ee._processFIFO.bind(ee),ne.msBeforeNext)))})})}_queueRequest(E,ee,te){const re=this;re._queue.length<re._maxQueueSize?re._queue.push({resolve:E,reject:ee,tokens:te}):ee(new RateLimiterQueueError(`Number of requests reached it's maximum ${re._maxQueueSize}`))}_processFIFO(){const E=this;if(E._waitTimeout!==null&&(clearTimeout(E._waitTimeout),E._waitTimeout=null),E._queue.length===0)return;const ee=E._queue.shift();E._limiterFlexible.consume(E._key,ee.tokens).then(te=>{ee.resolve(te.remainingPoints),E._processFIFO.call(E)}).catch(te=>{te instanceof Error?(ee.reject(te),E._processFIFO.call(E)):(E._queue.unshift(ee),E._waitTimeout===null&&(E._waitTimeout=setTimeout(E._processFIFO.bind(E),te.msBeforeNext)))})}}const RateLimiterRes$1=RateLimiterRes_1;var BurstyRateLimiter_1=class{constructor(J,E){this._rateLimiter=J,this._burstLimiter=E}_combineRes(J,E){return new RateLimiterRes$1(J.remainingPoints,Math.min(J.msBeforeNext,E.msBeforeNext),J.consumedPoints,J.isFirstInDuration)}consume(J,E=1,ee={}){return this._rateLimiter.consume(J,E,ee).catch(te=>te instanceof RateLimiterRes$1?this._burstLimiter.consume(J,E,ee).then(re=>Promise.resolve(this._combineRes(te,re))).catch(re=>re instanceof RateLimiterRes$1?Promise.reject(this._combineRes(te,re)):Promise.reject(re)):Promise.reject(te))}get(J){return Promise.all([this._rateLimiter.get(J),this._burstLimiter.get(J)]).then(([E,ee])=>this._combineRes(E,ee))}get points(){return this._rateLimiter.points}};const RateLimiterRedis=RateLimiterRedis_1,RateLimiterMongo=RateLimiterMongo_1,RateLimiterMySQL=RateLimiterMySQL_1,RateLimiterPostgres=RateLimiterPostgres_1,{RateLimiterClusterMaster,RateLimiterClusterMasterPM2,RateLimiterCluster}=RateLimiterCluster$1,RateLimiterMemory=RateLimiterMemory_1,RateLimiterMemcache=RateLimiterMemcache_1,RLWrapperBlackAndWhite=RLWrapperBlackAndWhite_1,RateLimiterUnion=RateLimiterUnion_1,RateLimiterQueue=RateLimiterQueue_1,BurstyRateLimiter=BurstyRateLimiter_1,RateLimiterRes=RateLimiterRes_1;var rateLimiterFlexible={RateLimiterRedis,RateLimiterMongo,RateLimiterMySQL,RateLimiterPostgres,RateLimiterMemory,RateLimiterMemcache,RateLimiterClusterMaster,RateLimiterClusterMasterPM2,RateLimiterCluster,RLWrapperBlackAndWhite,RateLimiterUnion,RateLimiterQueue,BurstyRateLimiter,RateLimiterRes};const log$1o=logger$1("libp2p:get-peer");function getPeerAddress$1(J){if(isPeerId(J))return{peerId:J,multiaddrs:[]};Array.isArray(J)||(J=[J]);let E;if(J.length>0){const ee=J[0].getPeerId();E=ee==null?void 0:peerIdFromString(ee),J.forEach(te=>{if(!isMultiaddr(te))throw log$1o.error("multiaddr %s was invalid",te),new CodeError("Invalid Multiaddr",codes$8.ERR_INVALID_MULTIADDR);const re=te.getPeerId();if(re==null){if(E!=null)throw new CodeError("Multiaddrs must all have the same peer id or have no peer id",codes$8.ERR_INVALID_PARAMETERS)}else{const ne=peerIdFromString(re);if(E==null||!E.equals(ne))throw new CodeError("Multiaddrs must all have the same peer id or have no peer id",codes$8.ERR_INVALID_PARAMETERS)}})}return{peerId:E,multiaddrs:J}}function mapIterable(J,E){const ee={[Symbol.iterator]:()=>ee,next:()=>{const te=J.next(),re=te.value;return te.done===!0||re==null?{done:!0,value:void 0}:{done:!1,value:E(re)}}};return ee}class PeerMap{constructor(E){if(this.map=new Map,E!=null)for(const[ee,te]of E.entries())this.map.set(ee.toString(),te)}[Symbol.iterator](){return this.entries()}clear(){this.map.clear()}delete(E){this.map.delete(E.toString())}entries(){return mapIterable(this.map.entries(),E=>[peerIdFromString(E[0]),E[1]])}forEach(E){this.map.forEach((ee,te)=>{E(ee,peerIdFromString(te),this)})}get(E){return this.map.get(E.toString())}has(E){return this.map.has(E.toString())}set(E,ee){this.map.set(E.toString(),ee)}keys(){return mapIterable(this.map.keys(),E=>peerIdFromString(E))}values(){return this.map.values()}get size(){return this.map.size}}class PeerSet{constructor(E){if(this.set=new Set,E!=null)for(const ee of E)this.set.add(ee.toString())}get size(){return this.set.size}[Symbol.iterator](){return this.values()}add(E){this.set.add(E.toString())}clear(){this.set.clear()}delete(E){this.set.delete(E.toString())}entries(){return mapIterable(this.set.entries(),E=>{const ee=peerIdFromString(E[0]);return[ee,ee]})}forEach(E){this.set.forEach(ee=>{const te=peerIdFromString(ee);E(te,te,this)})}has(E){return this.set.has(E.toString())}values(){return mapIterable(this.set.values(),E=>peerIdFromString(E))}intersection(E){const ee=new PeerSet;for(const te of E)this.has(te)&&ee.add(te);return ee}difference(E){const ee=new PeerSet;for(const te of this)E.has(te)||ee.add(te);return ee}union(E){const ee=new PeerSet;for(const te of E)ee.add(te);for(const te of this)ee.add(te);return ee}}var eventemitter3={exports:{}};(function(J){var E=Object.prototype.hasOwnProperty,ee="~";function te(){}Object.create&&(te.prototype=Object.create(null),new te().__proto__||(ee=!1));function re(oe,ce,ae){this.fn=oe,this.context=ce,this.once=ae||!1}function ne(oe,ce,ae,le,ue){if(typeof ae!="function")throw new TypeError("The listener must be a function");var he=new re(ae,le||oe,ue),pe=ee?ee+ce:ce;return oe._events[pe]?oe._events[pe].fn?oe._events[pe]=[oe._events[pe],he]:oe._events[pe].push(he):(oe._events[pe]=he,oe._eventsCount++),oe}function ie(oe,ce){--oe._eventsCount===0?oe._events=new te:delete oe._events[ce]}function se(){this._events=new te,this._eventsCount=0}se.prototype.eventNames=function(){var oe=[],ce,ae;if(this._eventsCount===0)return oe;for(ae in ce=this._events)E.call(ce,ae)&&oe.push(ee?ae.slice(1):ae);return Object.getOwnPropertySymbols?oe.concat(Object.getOwnPropertySymbols(ce)):oe},se.prototype.listeners=function(oe){var ce=ee?ee+oe:oe,ae=this._events[ce];if(!ae)return[];if(ae.fn)return[ae.fn];for(var le=0,ue=ae.length,he=new Array(ue);le<ue;le++)he[le]=ae[le].fn;return he},se.prototype.listenerCount=function(oe){var ce=ee?ee+oe:oe,ae=this._events[ce];return ae?ae.fn?1:ae.length:0},se.prototype.emit=function(oe,ce,ae,le,ue,he){var pe=ee?ee+oe:oe;if(!this._events[pe])return!1;var de=this._events[pe],fe=arguments.length,me,_e;if(de.fn){switch(de.once&&this.removeListener(oe,de.fn,void 0,!0),fe){case 1:return de.fn.call(de.context),!0;case 2:return de.fn.call(de.context,ce),!0;case 3:return de.fn.call(de.context,ce,ae),!0;case 4:return de.fn.call(de.context,ce,ae,le),!0;case 5:return de.fn.call(de.context,ce,ae,le,ue),!0;case 6:return de.fn.call(de.context,ce,ae,le,ue,he),!0}for(_e=1,me=new Array(fe-1);_e<fe;_e++)me[_e-1]=arguments[_e];de.fn.apply(de.context,me)}else{var be=de.length,Ee;for(_e=0;_e<be;_e++)switch(de[_e].once&&this.removeListener(oe,de[_e].fn,void 0,!0),fe){case 1:de[_e].fn.call(de[_e].context);break;case 2:de[_e].fn.call(de[_e].context,ce);break;case 3:de[_e].fn.call(de[_e].context,ce,ae);break;case 4:de[_e].fn.call(de[_e].context,ce,ae,le);break;default:if(!me)for(Ee=1,me=new Array(fe-1);Ee<fe;Ee++)me[Ee-1]=arguments[Ee];de[_e].fn.apply(de[_e].context,me)}}return!0},se.prototype.on=function(oe,ce,ae){return ne(this,oe,ce,ae,!1)},se.prototype.once=function(oe,ce,ae){return ne(this,oe,ce,ae,!0)},se.prototype.removeListener=function(oe,ce,ae,le){var ue=ee?ee+oe:oe;if(!this._events[ue])return this;if(!ce)return ie(this,ue),this;var he=this._events[ue];if(he.fn)he.fn===ce&&(!le||he.once)&&(!ae||he.context===ae)&&ie(this,ue);else{for(var pe=0,de=[],fe=he.length;pe<fe;pe++)(he[pe].fn!==ce||le&&!he[pe].once||ae&&he[pe].context!==ae)&&de.push(he[pe]);de.length?this._events[ue]=de.length===1?de[0]:de:ie(this,ue)}return this},se.prototype.removeAllListeners=function(oe){var ce;return oe?(ce=ee?ee+oe:oe,this._events[ce]&&ie(this,ce)):(this._events=new te,this._eventsCount=0),this},se.prototype.off=se.prototype.removeListener,se.prototype.addListener=se.prototype.on,se.prefixed=ee,se.EventEmitter=se,J.exports=se})(eventemitter3);var eventemitter3Exports=eventemitter3.exports;const EventEmitter$2=getDefaultExportFromCjs(eventemitter3Exports);let TimeoutError$1=class extends Error{constructor(J){super(J),this.name="TimeoutError"}},AbortError$4=class extends Error{constructor(J){super(),this.name="AbortError",this.message=J}};const getDOMException$1=J=>globalThis.DOMException===void 0?new AbortError$4(J):new DOMException(J),getAbortedReason$1=J=>{const E=J.reason===void 0?getDOMException$1("This operation was aborted."):J.reason;return E instanceof Error?E:getDOMException$1(E)};function pTimeout$1(J,E,ee,te){let re;const ne=new Promise((ie,se)=>{if(typeof E!="number"||Math.sign(E)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${E}\``);if(E===Number.POSITIVE_INFINITY){ie(J);return}if(te={customTimers:{setTimeout,clearTimeout},...te},te.signal){const{signal:oe}=te;oe.aborted&&se(getAbortedReason$1(oe)),oe.addEventListener("abort",()=>{se(getAbortedReason$1(oe))})}re=te.customTimers.setTimeout.call(void 0,()=>{if(typeof ee=="function"){try{ie(ee())}catch(ae){se(ae)}return}const oe=typeof ee=="string"?ee:`Promise timed out after ${E} milliseconds`,ce=ee instanceof Error?ee:new TimeoutError$1(oe);typeof J.cancel=="function"&&J.cancel(),se(ce)},E),(async()=>{try{ie(await J)}catch(oe){se(oe)}finally{te.customTimers.clearTimeout.call(void 0,re)}})()});return ne.clear=()=>{clearTimeout(re),re=void 0},ne}function lowerBound(J,E,ee){let te=0,re=J.length;for(;re>0;){const ne=Math.trunc(re/2);let ie=te+ne;ee(J[ie],E)<=0?(te=++ie,re-=ne+1):re=ne}return te}var __classPrivateFieldGet$5=globalThis&&globalThis.__classPrivateFieldGet||function(J,E,ee,te){if(ee==="a"&&!te)throw new TypeError("Private accessor was defined without a getter");if(typeof E=="function"?J!==E||!te:!E.has(J))throw new TypeError("Cannot read private member from an object whose class did not declare it");return ee==="m"?te:ee==="a"?te.call(J):te?te.value:E.get(J)},_PriorityQueue_queue;class PriorityQueue{constructor(){_PriorityQueue_queue.set(this,[])}enqueue(E,ee){ee={priority:0,...ee};const te={priority:ee.priority,run:E};if(this.size&&__classPrivateFieldGet$5(this,_PriorityQueue_queue,"f")[this.size-1].priority>=ee.priority){__classPrivateFieldGet$5(this,_PriorityQueue_queue,"f").push(te);return}const re=lowerBound(__classPrivateFieldGet$5(this,_PriorityQueue_queue,"f"),te,(ne,ie)=>ie.priority-ne.priority);__classPrivateFieldGet$5(this,_PriorityQueue_queue,"f").splice(re,0,te)}dequeue(){return __classPrivateFieldGet$5(this,_PriorityQueue_queue,"f").shift()?.run}filter(E){return __classPrivateFieldGet$5(this,_PriorityQueue_queue,"f").filter(ee=>ee.priority===E.priority).map(ee=>ee.run)}get size(){return __classPrivateFieldGet$5(this,_PriorityQueue_queue,"f").length}}_PriorityQueue_queue=new WeakMap;var __classPrivateFieldSet$1=globalThis&&globalThis.__classPrivateFieldSet||function(J,E,ee,te,re){if(te==="m")throw new TypeError("Private method is not writable");if(te==="a"&&!re)throw new TypeError("Private accessor was defined without a setter");if(typeof E=="function"?J!==E||!re:!E.has(J))throw new TypeError("Cannot write private member to an object whose class did not declare it");return te==="a"?re.call(J,ee):re?re.value=ee:E.set(J,ee),ee},__classPrivateFieldGet$4=globalThis&&globalThis.__classPrivateFieldGet||function(J,E,ee,te){if(ee==="a"&&!te)throw new TypeError("Private accessor was defined without a getter");if(typeof E=="function"?J!==E||!te:!E.has(J))throw new TypeError("Cannot read private member from an object whose class did not declare it");return ee==="m"?te:ee==="a"?te.call(J):te?te.value:E.get(J)},_PQueue_instances,_PQueue_carryoverConcurrencyCount,_PQueue_isIntervalIgnored,_PQueue_intervalCount,_PQueue_intervalCap,_PQueue_interval,_PQueue_intervalEnd,_PQueue_intervalId,_PQueue_timeoutId,_PQueue_queue,_PQueue_queueClass,_PQueue_pending,_PQueue_concurrency,_PQueue_isPaused,_PQueue_throwOnTimeout,_PQueue_doesIntervalAllowAnother_get,_PQueue_doesConcurrentAllowAnother_get,_PQueue_next,_PQueue_onResumeInterval,_PQueue_isIntervalPaused_get,_PQueue_tryToStartAnother,_PQueue_initializeIntervalIfNeeded,_PQueue_onInterval,_PQueue_processQueue,_PQueue_throwOnAbort,_PQueue_onEvent;let AbortError$3=class extends Error{};class PQueue extends EventEmitter$2{constructor(E){var ee,te,re,ne;if(super(),_PQueue_instances.add(this),_PQueue_carryoverConcurrencyCount.set(this,void 0),_PQueue_isIntervalIgnored.set(this,void 0),_PQueue_intervalCount.set(this,0),_PQueue_intervalCap.set(this,void 0),_PQueue_interval.set(this,void 0),_PQueue_intervalEnd.set(this,0),_PQueue_intervalId.set(this,void 0),_PQueue_timeoutId.set(this,void 0),_PQueue_queue.set(this,void 0),_PQueue_queueClass.set(this,void 0),_PQueue_pending.set(this,0),_PQueue_concurrency.set(this,void 0),_PQueue_isPaused.set(this,void 0),_PQueue_throwOnTimeout.set(this,void 0),Object.defineProperty(this,"timeout",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),E={carryoverConcurrencyCount:!1,intervalCap:Number.POSITIVE_INFINITY,interval:0,concurrency:Number.POSITIVE_INFINITY,autoStart:!0,queueClass:PriorityQueue,...E},!(typeof E.intervalCap=="number"&&E.intervalCap>=1))throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(te=(ee=E.intervalCap)===null||ee===void 0?void 0:ee.toString())!==null&&te!==void 0?te:""}\` (${typeof E.intervalCap})`);if(E.interval===void 0||!(Number.isFinite(E.interval)&&E.interval>=0))throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(ne=(re=E.interval)===null||re===void 0?void 0:re.toString())!==null&&ne!==void 0?ne:""}\` (${typeof E.interval})`);__classPrivateFieldSet$1(this,_PQueue_carryoverConcurrencyCount,E.carryoverConcurrencyCount,"f"),__classPrivateFieldSet$1(this,_PQueue_isIntervalIgnored,E.intervalCap===Number.POSITIVE_INFINITY||E.interval===0,"f"),__classPrivateFieldSet$1(this,_PQueue_intervalCap,E.intervalCap,"f"),__classPrivateFieldSet$1(this,_PQueue_interval,E.interval,"f"),__classPrivateFieldSet$1(this,_PQueue_queue,new E.queueClass,"f"),__classPrivateFieldSet$1(this,_PQueue_queueClass,E.queueClass,"f"),this.concurrency=E.concurrency,this.timeout=E.timeout,__classPrivateFieldSet$1(this,_PQueue_throwOnTimeout,E.throwOnTimeout===!0,"f"),__classPrivateFieldSet$1(this,_PQueue_isPaused,E.autoStart===!1,"f")}get concurrency(){return __classPrivateFieldGet$4(this,_PQueue_concurrency,"f")}set concurrency(E){if(!(typeof E=="number"&&E>=1))throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${E}\` (${typeof E})`);__classPrivateFieldSet$1(this,_PQueue_concurrency,E,"f"),__classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_processQueue).call(this)}async add(E,ee={}){return ee={timeout:this.timeout,throwOnTimeout:__classPrivateFieldGet$4(this,_PQueue_throwOnTimeout,"f"),...ee},new Promise((te,re)=>{__classPrivateFieldGet$4(this,_PQueue_queue,"f").enqueue(async()=>{var ne,ie,se;__classPrivateFieldSet$1(this,_PQueue_pending,(ie=__classPrivateFieldGet$4(this,_PQueue_pending,"f"),ie++,ie),"f"),__classPrivateFieldSet$1(this,_PQueue_intervalCount,(se=__classPrivateFieldGet$4(this,_PQueue_intervalCount,"f"),se++,se),"f");try{if(!((ne=ee.signal)===null||ne===void 0)&&ne.aborted)throw new AbortError$3("The task was aborted.");let oe=E({signal:ee.signal});ee.timeout&&(oe=pTimeout$1(Promise.resolve(oe),ee.timeout)),ee.signal&&(oe=Promise.race([oe,__classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_throwOnAbort).call(this,ee.signal)]));const ce=await oe;te(ce),this.emit("completed",ce)}catch(oe){if(oe instanceof TimeoutError$1&&!ee.throwOnTimeout){te();return}re(oe),this.emit("error",oe)}finally{__classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_next).call(this)}},ee),this.emit("add"),__classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_tryToStartAnother).call(this)})}async addAll(E,ee){return Promise.all(E.map(async te=>this.add(te,ee)))}start(){return __classPrivateFieldGet$4(this,_PQueue_isPaused,"f")?(__classPrivateFieldSet$1(this,_PQueue_isPaused,!1,"f"),__classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_processQueue).call(this),this):this}pause(){__classPrivateFieldSet$1(this,_PQueue_isPaused,!0,"f")}clear(){__classPrivateFieldSet$1(this,_PQueue_queue,new(__classPrivateFieldGet$4(this,_PQueue_queueClass,"f")),"f")}async onEmpty(){__classPrivateFieldGet$4(this,_PQueue_queue,"f").size!==0&&await __classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_onEvent).call(this,"empty")}async onSizeLessThan(E){__classPrivateFieldGet$4(this,_PQueue_queue,"f").size<E||await __classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_onEvent).call(this,"next",()=>__classPrivateFieldGet$4(this,_PQueue_queue,"f").size<E)}async onIdle(){__classPrivateFieldGet$4(this,_PQueue_pending,"f")===0&&__classPrivateFieldGet$4(this,_PQueue_queue,"f").size===0||await __classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_onEvent).call(this,"idle")}get size(){return __classPrivateFieldGet$4(this,_PQueue_queue,"f").size}sizeBy(E){return __classPrivateFieldGet$4(this,_PQueue_queue,"f").filter(E).length}get pending(){return __classPrivateFieldGet$4(this,_PQueue_pending,"f")}get isPaused(){return __classPrivateFieldGet$4(this,_PQueue_isPaused,"f")}}_PQueue_carryoverConcurrencyCount=new WeakMap,_PQueue_isIntervalIgnored=new WeakMap,_PQueue_intervalCount=new WeakMap,_PQueue_intervalCap=new WeakMap,_PQueue_interval=new WeakMap,_PQueue_intervalEnd=new WeakMap,_PQueue_intervalId=new WeakMap,_PQueue_timeoutId=new WeakMap,_PQueue_queue=new WeakMap,_PQueue_queueClass=new WeakMap,_PQueue_pending=new WeakMap,_PQueue_concurrency=new WeakMap,_PQueue_isPaused=new WeakMap,_PQueue_throwOnTimeout=new WeakMap,_PQueue_instances=new WeakSet,_PQueue_doesIntervalAllowAnother_get=function(){return __classPrivateFieldGet$4(this,_PQueue_isIntervalIgnored,"f")||__classPrivateFieldGet$4(this,_PQueue_intervalCount,"f")<__classPrivateFieldGet$4(this,_PQueue_intervalCap,"f")},_PQueue_doesConcurrentAllowAnother_get=function(){return __classPrivateFieldGet$4(this,_PQueue_pending,"f")<__classPrivateFieldGet$4(this,_PQueue_concurrency,"f")},_PQueue_next=function(){var J;__classPrivateFieldSet$1(this,_PQueue_pending,(J=__classPrivateFieldGet$4(this,_PQueue_pending,"f"),J--,J),"f"),__classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_tryToStartAnother).call(this),this.emit("next")},_PQueue_onResumeInterval=function(){__classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_onInterval).call(this),__classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_initializeIntervalIfNeeded).call(this),__classPrivateFieldSet$1(this,_PQueue_timeoutId,void 0,"f")},_PQueue_isIntervalPaused_get=function(){const J=Date.now();if(__classPrivateFieldGet$4(this,_PQueue_intervalId,"f")===void 0){const E=__classPrivateFieldGet$4(this,_PQueue_intervalEnd,"f")-J;if(E<0)__classPrivateFieldSet$1(this,_PQueue_intervalCount,__classPrivateFieldGet$4(this,_PQueue_carryoverConcurrencyCount,"f")?__classPrivateFieldGet$4(this,_PQueue_pending,"f"):0,"f");else return __classPrivateFieldGet$4(this,_PQueue_timeoutId,"f")===void 0&&__classPrivateFieldSet$1(this,_PQueue_timeoutId,setTimeout(()=>{__classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_onResumeInterval).call(this)},E),"f"),!0}return!1},_PQueue_tryToStartAnother=function(){if(__classPrivateFieldGet$4(this,_PQueue_queue,"f").size===0)return __classPrivateFieldGet$4(this,_PQueue_intervalId,"f")&&clearInterval(__classPrivateFieldGet$4(this,_PQueue_intervalId,"f")),__classPrivateFieldSet$1(this,_PQueue_intervalId,void 0,"f"),this.emit("empty"),__classPrivateFieldGet$4(this,_PQueue_pending,"f")===0&&this.emit("idle"),!1;if(!__classPrivateFieldGet$4(this,_PQueue_isPaused,"f")){const J=!__classPrivateFieldGet$4(this,_PQueue_instances,"a",_PQueue_isIntervalPaused_get);if(__classPrivateFieldGet$4(this,_PQueue_instances,"a",_PQueue_doesIntervalAllowAnother_get)&&__classPrivateFieldGet$4(this,_PQueue_instances,"a",_PQueue_doesConcurrentAllowAnother_get)){const E=__classPrivateFieldGet$4(this,_PQueue_queue,"f").dequeue();return E?(this.emit("active"),E(),J&&__classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_initializeIntervalIfNeeded).call(this),!0):!1}}return!1},_PQueue_initializeIntervalIfNeeded=function(){__classPrivateFieldGet$4(this,_PQueue_isIntervalIgnored,"f")||__classPrivateFieldGet$4(this,_PQueue_intervalId,"f")!==void 0||(__classPrivateFieldSet$1(this,_PQueue_intervalId,setInterval(()=>{__classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_onInterval).call(this)},__classPrivateFieldGet$4(this,_PQueue_interval,"f")),"f"),__classPrivateFieldSet$1(this,_PQueue_intervalEnd,Date.now()+__classPrivateFieldGet$4(this,_PQueue_interval,"f"),"f"))},_PQueue_onInterval=function(){__classPrivateFieldGet$4(this,_PQueue_intervalCount,"f")===0&&__classPrivateFieldGet$4(this,_PQueue_pending,"f")===0&&__classPrivateFieldGet$4(this,_PQueue_intervalId,"f")&&(clearInterval(__classPrivateFieldGet$4(this,_PQueue_intervalId,"f")),__classPrivateFieldSet$1(this,_PQueue_intervalId,void 0,"f")),__classPrivateFieldSet$1(this,_PQueue_intervalCount,__classPrivateFieldGet$4(this,_PQueue_carryoverConcurrencyCount,"f")?__classPrivateFieldGet$4(this,_PQueue_pending,"f"):0,"f"),__classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_processQueue).call(this)},_PQueue_processQueue=function(){for(;__classPrivateFieldGet$4(this,_PQueue_instances,"m",_PQueue_tryToStartAnother).call(this););},_PQueue_throwOnAbort=async function(J){return new Promise((E,ee)=>{J.addEventListener("abort",()=>{ee(new AbortError$3("The task was aborted."))},{once:!0})})},_PQueue_onEvent=async function(J,E){return new Promise(ee=>{const te=()=>{E&&!E()||(this.off(J,te),ee())};this.on(J,te)})};const DIAL_TIMEOUT$1=3e4,INBOUND_UPGRADE_TIMEOUT$1=3e4,MAX_PARALLEL_DIALS$1=100,MAX_PEER_ADDRS_TO_DIAL$1=25,MAX_PARALLEL_DIALS_PER_PEER$1=10,MIN_CONNECTIONS$1=50,MAX_CONNECTIONS$1=300,AUTO_DIAL_INTERVAL$1=5e3,AUTO_DIAL_CONCURRENCY$1=25,AUTO_DIAL_PRIORITY$1=0,INBOUND_CONNECTION_THRESHOLD$1=5,MAX_INCOMING_PENDING_CONNECTIONS$1=10,log$1n=logger$1("libp2p:connection-manager:auto-dial"),defaultOptions$k={minConnections:MIN_CONNECTIONS$1,autoDialConcurrency:AUTO_DIAL_CONCURRENCY$1,autoDialPriority:AUTO_DIAL_PRIORITY$1,autoDialInterval:AUTO_DIAL_INTERVAL$1};let AutoDial$1=class{constructor(J,E){this.connectionManager=J.connectionManager,this.peerStore=J.peerStore,this.minConnections=E.minConnections??defaultOptions$k.minConnections,this.autoDialPriority=E.autoDialPriority??defaultOptions$k.autoDialPriority,this.autoDialIntervalMs=E.autoDialInterval??defaultOptions$k.autoDialInterval,this.started=!1,this.queue=new PQueue({concurrency:E.autoDialConcurrency??defaultOptions$k.autoDialConcurrency}),this.queue.addListener("error",ee=>{log$1n.error("error during auto-dial",ee)}),J.events.addEventListener("connection:close",()=>{this.autoDial().catch(ee=>{log$1n.error(ee)})})}isStarted(){return this.started}start(){this.autoDialInterval=setInterval(()=>{this.autoDial().catch(J=>{log$1n.error("error while autodialing",J)})},this.autoDialIntervalMs),this.started=!0}afterStart(){this.autoDial().catch(J=>{log$1n.error("error while autodialing",J)})}stop(){this.queue.clear(),clearInterval(this.autoDialInterval),this.started=!1}async autoDial(){if(!this.started)return;const J=this.connectionManager.getConnectionsMap(),E=J.size,ee=new PeerSet(this.connectionManager.getDialQueue().map(se=>se.peerId).filter(Boolean));if(E>=this.minConnections){log$1n("have enough connections %d/%d",E,this.minConnections);return}log$1n("not enough connections %d/%d - will dial peers to increase the number of connections",E,this.minConnections);const te=await this.peerStore.all(),re=te.filter(se=>!(se.addresses.length===0||J.has(se.id)||ee.has(se.id))).sort(()=>Math.random()>.5?1:-1),ne=new PeerMap;for(const se of re)ne.has(se.id)||ne.set(se.id,[...se.tags.values()].reduce((oe,ce)=>oe+ce.value,0));const ie=re.sort((se,oe)=>{const ce=ne.get(se.id)??0,ae=ne.get(oe.id)??0;return ce>ae?-1:ce<ae?1:0});log$1n("selected %d/%d peers to dial",ie.length,te.length);for(const se of ie)this.queue.add(async()=>{const oe=this.connectionManager.getConnectionsMap().size;if(oe>=this.minConnections){log$1n("got enough connections now %d/%d",oe,this.minConnections),this.queue.clear();return}log$1n("connecting to a peerStore stored peer %p",se.id),await this.connectionManager.openConnection(se.id,{priority:this.autoDialPriority})}).catch(oe=>{log$1n.error("could not connect to peerStore stored peer",oe)})}};var Netmask_1;(function(){var J,E,ee,te,re,ne,ie,se;se=function(oe){var ce,ae,le,ue;return ce=(oe&255<<24)>>>24,ae=(oe&255<<16)>>>16,le=(oe&65280)>>>8,ue=oe&255,[ce,ae,le,ue].join(".")},ie=function(oe){var ce,ae,le,ue,he,pe;for(ce=[],le=ue=0;ue<=3&&oe.length!==0;le=++ue){if(le>0){if(oe[0]!==".")throw new Error("Invalid IP");oe=oe.substring(1)}pe=E(oe),he=pe[0],ae=pe[1],oe=oe.substring(ae),ce.push(he)}if(oe.length!==0)throw new Error("Invalid IP");switch(ce.length){case 1:if(ce[0]>4294967295)throw new Error("Invalid IP");return ce[0]>>>0;case 2:if(ce[0]>255||ce[1]>16777215)throw new Error("Invalid IP");return(ce[0]<<24|ce[1])>>>0;case 3:if(ce[0]>255||ce[1]>255||ce[2]>65535)throw new Error("Invalid IP");return(ce[0]<<24|ce[1]<<16|ce[2])>>>0;case 4:if(ce[0]>255||ce[1]>255||ce[2]>255||ce[3]>255)throw new Error("Invalid IP");return(ce[0]<<24|ce[1]<<16|ce[2]<<8|ce[3])>>>0;default:throw new Error("Invalid IP")}},ee=function(oe){return oe.charCodeAt(0)},te=ee("0"),ne=ee("a"),re=ee("A"),E=function(oe){var ce,ae,le,ue,he;for(ue=0,ce=10,ae="9",le=0,oe.length>1&&oe[le]==="0"&&(oe[le+1]==="x"||oe[le+1]==="X"?(le+=2,ce=16):"0"<=oe[le+1]&&oe[le+1]<="9"&&(le++,ce=8,ae="7")),he=le;le<oe.length;){if("0"<=oe[le]&&oe[le]<=ae)ue=ue*ce+(ee(oe[le])-te)>>>0;else if(ce===16)if("a"<=oe[le]&&oe[le]<="f")ue=ue*ce+(10+ee(oe[le])-ne)>>>0;else if("A"<=oe[le]&&oe[le]<="F")ue=ue*ce+(10+ee(oe[le])-re)>>>0;else break;else break;if(ue>4294967295)throw new Error("too large");le++}if(le===he)throw new Error("empty octet");return[ue,le]},J=function(){function oe(ce,ae){var le,ue,he;if(typeof ce!="string")throw new Error("Missing `net' parameter");if(ae||(he=ce.split("/",2),ce=he[0],ae=he[1]),ae||(ae=32),typeof ae=="string"&&ae.indexOf(".")>-1){try{this.maskLong=ie(ae)}catch{throw new Error("Invalid mask: "+ae)}for(le=ue=32;ue>=0;le=--ue)if(this.maskLong===4294967295<<32-le>>>0){this.bitmask=le;break}}else if(ae||ae===0)this.bitmask=parseInt(ae,10),this.maskLong=0,this.bitmask>0&&(this.maskLong=4294967295<<32-this.bitmask>>>0);else throw new Error("Invalid mask: empty");try{this.netLong=(ie(ce)&this.maskLong)>>>0}catch{throw new Error("Invalid net address: "+ce)}if(!(this.bitmask<=32))throw new Error("Invalid mask for ip4: "+ae);this.size=Math.pow(2,32-this.bitmask),this.base=se(this.netLong),this.mask=se(this.maskLong),this.hostmask=se(~this.maskLong),this.first=this.bitmask<=30?se(this.netLong+1):this.base,this.last=this.bitmask<=30?se(this.netLong+this.size-2):se(this.netLong+this.size-1),this.broadcast=this.bitmask<=30?se(this.netLong+this.size-1):void 0}return oe.prototype.contains=function(ce){return typeof ce=="string"&&(ce.indexOf("/")>0||ce.split(".").length!==4)&&(ce=new oe(ce)),ce instanceof oe?this.contains(ce.base)&&this.contains(ce.broadcast||ce.last):(ie(ce)&this.maskLong)>>>0===(this.netLong&this.maskLong)>>>0},oe.prototype.next=function(ce){return ce==null&&(ce=1),new oe(se(this.netLong+this.size*ce),this.mask)},oe.prototype.forEach=function(ce){var ae,le,ue;for(ue=ie(this.first),le=ie(this.last),ae=0;ue<=le;)ce(se(ue),ue,ae),ae++,ue++},oe.prototype.toString=function(){return this.base+"/"+this.bitmask},oe}(),Netmask_1=J}).call(commonjsGlobal);const word="[a-fA-F\\d:]",boundry=J=>J&&J.includeBoundaries?`(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))`:"",v4="(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}",v6segment="[a-fA-F\\d]{1,4}",v6=`
(?:
(?:${v6segment}:){7}(?:${v6segment}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6segment}:){6}(?:${v4}|:${v6segment}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6segment}:){5}(?::${v4}|(?::${v6segment}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6segment}:){4}(?:(?::${v6segment}){0,1}:${v4}|(?::${v6segment}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6segment}:){3}(?:(?::${v6segment}){0,2}:${v4}|(?::${v6segment}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6segment}:){2}(?:(?::${v6segment}){0,3}:${v4}|(?::${v6segment}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6segment}:){1}(?:(?::${v6segment}){0,4}:${v4}|(?::${v6segment}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6segment}){0,5}:${v4}|(?::${v6segment}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm,"").replace(/\n/g,"").trim(),v46Exact=new RegExp(`(?:^${v4}$)|(?:^${v6}$)`),v4exact=new RegExp(`^${v4}$`),v6exact=new RegExp(`^${v6}$`),ipRegex=J=>J&&J.exact?v46Exact:new RegExp(`(?:${boundry(J)}${v4}${boundry(J)})|(?:${boundry(J)}${v6}${boundry(J)})`,"g");ipRegex.v4=J=>J&&J.exact?v4exact:new RegExp(`${boundry(J)}${v4}${boundry(J)}`,"g");ipRegex.v6=J=>J&&J.exact?v6exact:new RegExp(`${boundry(J)}${v6}${boundry(J)}`,"g");var ipaddr$1={exports:{}};(function(J){(function(E){const ee="(0?\\d+|0x[a-f0-9]+)",te={fourOctet:new RegExp(`^${ee}\\.${ee}\\.${ee}\\.${ee}$`,"i"),threeOctet:new RegExp(`^${ee}\\.${ee}\\.${ee}$`,"i"),twoOctet:new RegExp(`^${ee}\\.${ee}$`,"i"),longValue:new RegExp(`^${ee}$`,"i")},re=new RegExp("^0[0-7]+$","i"),ne=new RegExp("^0x[a-f0-9]+$","i"),ie="%[0-9a-z]{1,}",se="(?:[0-9a-f]+::?)+",oe={zoneIndex:new RegExp(ie,"i"),native:new RegExp(`^(::)?(${se})?([0-9a-f]+)?(::)?(${ie})?$`,"i"),deprecatedTransitional:new RegExp(`^(?:::)(${ee}\\.${ee}\\.${ee}\\.${ee}(${ie})?)$`,"i"),transitional:new RegExp(`^((?:${se})|(?:::)(?:${se})?)${ee}\\.${ee}\\.${ee}\\.${ee}(${ie})?$`,"i")};function ce(pe,de){if(pe.indexOf("::")!==pe.lastIndexOf("::"))return null;let fe=0,me=-1,_e=(pe.match(oe.zoneIndex)||[])[0],be,Ee;for(_e&&(_e=_e.substring(1),pe=pe.replace(/%.+$/,""));(me=pe.indexOf(":",me+1))>=0;)fe++;if(pe.substr(0,2)==="::"&&fe--,pe.substr(-2,2)==="::"&&fe--,fe>de)return null;for(Ee=de-fe,be=":";Ee--;)be+="0:";return pe=pe.replace("::",be),pe[0]===":"&&(pe=pe.slice(1)),pe[pe.length-1]===":"&&(pe=pe.slice(0,-1)),de=function(){const ve=pe.split(":"),we=[];for(let ge=0;ge<ve.length;ge++)we.push(parseInt(ve[ge],16));return we}(),{parts:de,zoneId:_e}}function ae(pe,de,fe,me){if(pe.length!==de.length)throw new Error("ipaddr: cannot match CIDR for objects with different lengths");let _e=0,be;for(;me>0;){if(be=fe-me,be<0&&(be=0),pe[_e]>>be!==de[_e]>>be)return!1;me-=fe,_e+=1}return!0}function le(pe){if(ne.test(pe))return parseInt(pe,16);if(pe[0]==="0"&&!isNaN(parseInt(pe[1],10))){if(re.test(pe))return parseInt(pe,8);throw new Error(`ipaddr: cannot parse ${pe} as octal`)}return parseInt(pe,10)}function ue(pe,de){for(;pe.length<de;)pe=`0${pe}`;return pe}const he={};he.IPv4=function(){function pe(de){if(de.length!==4)throw new Error("ipaddr: ipv4 octet count should be 4");let fe,me;for(fe=0;fe<de.length;fe++)if(me=de[fe],!(0<=me&&me<=255))throw new Error("ipaddr: ipv4 octet should fit in 8 bits");this.octets=de}return pe.prototype.SpecialRanges={unspecified:[[new pe([0,0,0,0]),8]],broadcast:[[new pe([255,255,255,255]),32]],multicast:[[new pe([224,0,0,0]),4]],linkLocal:[[new pe([169,254,0,0]),16]],loopback:[[new pe([127,0,0,0]),8]],carrierGradeNat:[[new pe([100,64,0,0]),10]],private:[[new pe([10,0,0,0]),8],[new pe([172,16,0,0]),12],[new pe([192,168,0,0]),16]],reserved:[[new pe([192,0,0,0]),24],[new pe([192,0,2,0]),24],[new pe([192,88,99,0]),24],[new pe([198,51,100,0]),24],[new pe([203,0,113,0]),24],[new pe([240,0,0,0]),4]]},pe.prototype.kind=function(){return"ipv4"},pe.prototype.match=function(de,fe){let me;if(fe===void 0&&(me=de,de=me[0],fe=me[1]),de.kind()!=="ipv4")throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");return ae(this.octets,de.octets,8,fe)},pe.prototype.prefixLengthFromSubnetMask=function(){let de=0,fe=!1;const me={0:8,128:7,192:6,224:5,240:4,248:3,252:2,254:1,255:0};let _e,be,Ee;for(_e=3;_e>=0;_e-=1)if(be=this.octets[_e],be in me){if(Ee=me[be],fe&&Ee!==0)return null;Ee!==8&&(fe=!0),de+=Ee}else return null;return 32-de},pe.prototype.range=function(){return he.subnetMatch(this,this.SpecialRanges)},pe.prototype.toByteArray=function(){return this.octets.slice(0)},pe.prototype.toIPv4MappedAddress=function(){return he.IPv6.parse(`::ffff:${this.toString()}`)},pe.prototype.toNormalizedString=function(){return this.toString()},pe.prototype.toString=function(){return this.octets.join(".")},pe}(),he.IPv4.broadcastAddressFromCIDR=function(pe){try{const de=this.parseCIDR(pe),fe=de[0].toByteArray(),me=this.subnetMaskFromPrefixLength(de[1]).toByteArray(),_e=[];let be=0;for(;be<4;)_e.push(parseInt(fe[be],10)|parseInt(me[be],10)^255),be++;return new this(_e)}catch{throw new Error("ipaddr: the address does not have IPv4 CIDR format")}},he.IPv4.isIPv4=function(pe){return this.parser(pe)!==null},he.IPv4.isValid=function(pe){try{return new this(this.parser(pe)),!0}catch{return!1}},he.IPv4.isValidFourPartDecimal=function(pe){return!!(he.IPv4.isValid(pe)&&pe.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/))},he.IPv4.networkAddressFromCIDR=function(pe){let de,fe,me,_e,be;try{for(de=this.parseCIDR(pe),me=de[0].toByteArray(),be=this.subnetMaskFromPrefixLength(de[1]).toByteArray(),_e=[],fe=0;fe<4;)_e.push(parseInt(me[fe],10)&parseInt(be[fe],10)),fe++;return new this(_e)}catch{throw new Error("ipaddr: the address does not have IPv4 CIDR format")}},he.IPv4.parse=function(pe){const de=this.parser(pe);if(de===null)throw new Error("ipaddr: string is not formatted like an IPv4 Address");return new this(de)},he.IPv4.parseCIDR=function(pe){let de;if(de=pe.match(/^(.+)\/(\d+)$/)){const fe=parseInt(de[2]);if(fe>=0&&fe<=32){const me=[this.parse(de[1]),fe];return Object.defineProperty(me,"toString",{value:function(){return this.join("/")}}),me}}throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range")},he.IPv4.parser=function(pe){let de,fe,me;if(de=pe.match(te.fourOctet))return function(){const _e=de.slice(1,6),be=[];for(let Ee=0;Ee<_e.length;Ee++)fe=_e[Ee],be.push(le(fe));return be}();if(de=pe.match(te.longValue)){if(me=le(de[1]),me>4294967295||me<0)throw new Error("ipaddr: address outside defined range");return function(){const _e=[];let be;for(be=0;be<=24;be+=8)_e.push(me>>be&255);return _e}().reverse()}else return(de=pe.match(te.twoOctet))?function(){const _e=de.slice(1,4),be=[];if(me=le(_e[1]),me>16777215||me<0)throw new Error("ipaddr: address outside defined range");return be.push(le(_e[0])),be.push(me>>16&255),be.push(me>>8&255),be.push(me&255),be}():(de=pe.match(te.threeOctet))?function(){const _e=de.slice(1,5),be=[];if(me=le(_e[2]),me>65535||me<0)throw new Error("ipaddr: address outside defined range");return be.push(le(_e[0])),be.push(le(_e[1])),be.push(me>>8&255),be.push(me&255),be}():null},he.IPv4.subnetMaskFromPrefixLength=function(pe){if(pe=parseInt(pe),pe<0||pe>32)throw new Error("ipaddr: invalid IPv4 prefix length");const de=[0,0,0,0];let fe=0;const me=Math.floor(pe/8);for(;fe<me;)de[fe]=255,fe++;return me<4&&(de[me]=Math.pow(2,pe%8)-1<<8-pe%8),new this(de)},he.IPv6=function(){function pe(de,fe){let me,_e;if(de.length===16)for(this.parts=[],me=0;me<=14;me+=2)this.parts.push(de[me]<<8|de[me+1]);else if(de.length===8)this.parts=de;else throw new Error("ipaddr: ipv6 part count should be 8 or 16");for(me=0;me<this.parts.length;me++)if(_e=this.parts[me],!(0<=_e&&_e<=65535))throw new Error("ipaddr: ipv6 part should fit in 16 bits");fe&&(this.zoneId=fe)}return pe.prototype.SpecialRanges={unspecified:[new pe([0,0,0,0,0,0,0,0]),128],linkLocal:[new pe([65152,0,0,0,0,0,0,0]),10],multicast:[new pe([65280,0,0,0,0,0,0,0]),8],loopback:[new pe([0,0,0,0,0,0,0,1]),128],uniqueLocal:[new pe([64512,0,0,0,0,0,0,0]),7],ipv4Mapped:[new pe([0,0,0,0,0,65535,0,0]),96],rfc6145:[new pe([0,0,0,0,65535,0,0,0]),96],rfc6052:[new pe([100,65435,0,0,0,0,0,0]),96],"6to4":[new pe([8194,0,0,0,0,0,0,0]),16],teredo:[new pe([8193,0,0,0,0,0,0,0]),32],reserved:[[new pe([8193,3512,0,0,0,0,0,0]),32]]},pe.prototype.isIPv4MappedAddress=function(){return this.range()==="ipv4Mapped"},pe.prototype.kind=function(){return"ipv6"},pe.prototype.match=function(de,fe){let me;if(fe===void 0&&(me=de,de=me[0],fe=me[1]),de.kind()!=="ipv6")throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");return ae(this.parts,de.parts,16,fe)},pe.prototype.prefixLengthFromSubnetMask=function(){let de=0,fe=!1;const me={0:16,32768:15,49152:14,57344:13,61440:12,63488:11,64512:10,65024:9,65280:8,65408:7,65472:6,65504:5,65520:4,65528:3,65532:2,65534:1,65535:0};let _e,be;for(let Ee=7;Ee>=0;Ee-=1)if(_e=this.parts[Ee],_e in me){if(be=me[_e],fe&&be!==0)return null;be!==16&&(fe=!0),de+=be}else return null;return 128-de},pe.prototype.range=function(){return he.subnetMatch(this,this.SpecialRanges)},pe.prototype.toByteArray=function(){let de;const fe=[],me=this.parts;for(let _e=0;_e<me.length;_e++)de=me[_e],fe.push(de>>8),fe.push(de&255);return fe},pe.prototype.toFixedLengthString=function(){const de=function(){const me=[];for(let _e=0;_e<this.parts.length;_e++)me.push(ue(this.parts[_e].toString(16),4));return me}.call(this).join(":");let fe="";return this.zoneId&&(fe=`%${this.zoneId}`),de+fe},pe.prototype.toIPv4Address=function(){if(!this.isIPv4MappedAddress())throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");const de=this.parts.slice(-2),fe=de[0],me=de[1];return new he.IPv4([fe>>8,fe&255,me>>8,me&255])},pe.prototype.toNormalizedString=function(){const de=function(){const me=[];for(let _e=0;_e<this.parts.length;_e++)me.push(this.parts[_e].toString(16));return me}.call(this).join(":");let fe="";return this.zoneId&&(fe=`%${this.zoneId}`),de+fe},pe.prototype.toRFC5952String=function(){const de=/((^|:)(0(:|$)){2,})/g,fe=this.toNormalizedString();let me=0,_e=-1,be;for(;be=de.exec(fe);)be[0].length>_e&&(me=be.index,_e=be[0].length);return _e<0?fe:`${fe.substring(0,me)}::${fe.substring(me+_e)}`},pe.prototype.toString=function(){return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/,"::")},pe}(),he.IPv6.broadcastAddressFromCIDR=function(pe){try{const de=this.parseCIDR(pe),fe=de[0].toByteArray(),me=this.subnetMaskFromPrefixLength(de[1]).toByteArray(),_e=[];let be=0;for(;be<16;)_e.push(parseInt(fe[be],10)|parseInt(me[be],10)^255),be++;return new this(_e)}catch(de){throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${de})`)}},he.IPv6.isIPv6=function(pe){return this.parser(pe)!==null},he.IPv6.isValid=function(pe){if(typeof pe=="string"&&pe.indexOf(":")===-1)return!1;try{const de=this.parser(pe);return new this(de.parts,de.zoneId),!0}catch{return!1}},he.IPv6.networkAddressFromCIDR=function(pe){let de,fe,me,_e,be;try{for(de=this.parseCIDR(pe),me=de[0].toByteArray(),be=this.subnetMaskFromPrefixLength(de[1]).toByteArray(),_e=[],fe=0;fe<16;)_e.push(parseInt(me[fe],10)&parseInt(be[fe],10)),fe++;return new this(_e)}catch(Ee){throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${Ee})`)}},he.IPv6.parse=function(pe){const de=this.parser(pe);if(de.parts===null)throw new Error("ipaddr: string is not formatted like an IPv6 Address");return new this(de.parts,de.zoneId)},he.IPv6.parseCIDR=function(pe){let de,fe,me;if((fe=pe.match(/^(.+)\/(\d+)$/))&&(de=parseInt(fe[2]),de>=0&&de<=128))return me=[this.parse(fe[1]),de],Object.defineProperty(me,"toString",{value:function(){return this.join("/")}}),me;throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range")},he.IPv6.parser=function(pe){let de,fe,me,_e,be,Ee;if(me=pe.match(oe.deprecatedTransitional))return this.parser(`::ffff:${me[1]}`);if(oe.native.test(pe))return ce(pe,8);if((me=pe.match(oe.transitional))&&(Ee=me[6]||"",de=ce(me[1].slice(0,-1)+Ee,6),de.parts)){for(be=[parseInt(me[2]),parseInt(me[3]),parseInt(me[4]),parseInt(me[5])],fe=0;fe<be.length;fe++)if(_e=be[fe],!(0<=_e&&_e<=255))return null;return de.parts.push(be[0]<<8|be[1]),de.parts.push(be[2]<<8|be[3]),{parts:de.parts,zoneId:de.zoneId}}return null},he.IPv6.subnetMaskFromPrefixLength=function(pe){if(pe=parseInt(pe),pe<0||pe>128)throw new Error("ipaddr: invalid IPv6 prefix length");const de=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];let fe=0;const me=Math.floor(pe/8);for(;fe<me;)de[fe]=255,fe++;return me<16&&(de[me]=Math.pow(2,pe%8)-1<<8-pe%8),new this(de)},he.fromByteArray=function(pe){const de=pe.length;if(de===4)return new he.IPv4(pe);if(de===16)return new he.IPv6(pe);throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address")},he.isValid=function(pe){return he.IPv6.isValid(pe)||he.IPv4.isValid(pe)},he.parse=function(pe){if(he.IPv6.isValid(pe))return he.IPv6.parse(pe);if(he.IPv4.isValid(pe))return he.IPv4.parse(pe);throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format")},he.parseCIDR=function(pe){try{return he.IPv6.parseCIDR(pe)}catch{try{return he.IPv4.parseCIDR(pe)}catch{throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format")}}},he.process=function(pe){const de=this.parse(pe);return de.kind()==="ipv6"&&de.isIPv4MappedAddress()?de.toIPv4Address():de},he.subnetMatch=function(pe,de,fe){let me,_e,be,Ee;fe==null&&(fe="unicast");for(_e in de)if(Object.prototype.hasOwnProperty.call(de,_e)){for(be=de[_e],be[0]&&!(be[0]instanceof Array)&&(be=[be]),me=0;me<be.length;me++)if(Ee=be[me],pe.kind()===Ee[0].kind()&&pe.match.apply(pe,Ee))return _e}return fe},J.exports?J.exports=he:E.ipaddr=he})(commonjsGlobal)})(ipaddr$1);var ipaddrExports=ipaddr$1.exports;const ipaddr=getDefaultExportFromCjs(ipaddrExports),{isValid:is_valid,parse:parse$1}=ipaddr,PRIVATE_IP_RANGES=["0.0.0.0/8","10.0.0.0/8","100.64.0.0/10","127.0.0.0/8","169.254.0.0/16","172.16.0.0/12","192.0.0.0/24","192.0.0.0/29","192.0.0.8/32","192.0.0.9/32","192.0.0.10/32","192.0.0.170/32","192.0.0.171/32","192.0.2.0/24","192.31.196.0/24","192.52.193.0/24","192.88.99.0/24","192.168.0.0/16","192.175.48.0/24","198.18.0.0/15","198.51.100.0/24","203.0.113.0/24","240.0.0.0/4","255.255.255.255/32"],NETMASK_RANGES=PRIVATE_IP_RANGES.map(J=>new Netmask_1(J));function ipv4_check(J){for(let E of NETMASK_RANGES)if(E.contains(J))return!0;return!1}function ipv6_check(J){return/^::$/.test(J)||/^::1$/.test(J)||/^::f{4}:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(J)||/^::f{4}:0.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(J)||/^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(J)||/^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(J)||/^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(J)||/^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(J)||/^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(J)||/^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(J)||/^f[c-d]([0-9a-fA-F]{2,2}):/i.test(J)||/^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(J)||/^ff([0-9a-fA-F]{2,2}):/i.test(J)}const is_ip_private=J=>{if(is_valid(J)){const E=parse$1(J);if(E.kind()==="ipv4")return ipv4_check(E.toNormalizedString());if(E.kind()==="ipv6")return ipv6_check(J)}else if(isIP(J)&&ipRegex.v6().test(J))return ipv6_check(J)};function isPrivate(J){try{const{address:E}=J.nodeAddress();return!!is_ip_private(E)}catch{return!0}}function publicAddressesFirst(J,E){const ee=isPrivate(J.multiaddr),te=isPrivate(E.multiaddr);return ee&&!te?1:!ee&&te||J.isCertified&&!E.isCertified?-1:!J.isCertified&&E.isCertified?1:0}var s$1=1e3,m=s$1*60,h=m*60,d=h*24,w=d*7,y=d*365.25,ms=function(J,E){E=E||{};var ee=typeof J;if(ee==="string"&&J.length>0)return parse(J);if(ee==="number"&&isFinite(J))return E.long?fmtLong(J):fmtShort(J);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(J))};function parse(J){if(J=String(J),!(J.length>100)){var E=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(J);if(E){var ee=parseFloat(E[1]),te=(E[2]||"ms").toLowerCase();switch(te){case"years":case"year":case"yrs":case"yr":case"y":return ee*y;case"weeks":case"week":case"w":return ee*w;case"days":case"day":case"d":return ee*d;case"hours":case"hour":case"hrs":case"hr":case"h":return ee*h;case"minutes":case"minute":case"mins":case"min":case"m":return ee*m;case"seconds":case"second":case"secs":case"sec":case"s":return ee*s$1;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return ee;default:return}}}}function fmtShort(J){var E=Math.abs(J);return E>=d?Math.round(J/d)+"d":E>=h?Math.round(J/h)+"h":E>=m?Math.round(J/m)+"m":E>=s$1?Math.round(J/s$1)+"s":J+"ms"}function fmtLong(J){var E=Math.abs(J);return E>=d?plural(J,E,d,"day"):E>=h?plural(J,E,h,"hour"):E>=m?plural(J,E,m,"minute"):E>=s$1?plural(J,E,s$1,"second"):J+" ms"}function plural(J,E,ee,te){var re=E>=ee*1.5;return Math.round(J/ee)+" "+te+(re?"s":"")}var receptacle=Receptacle,toMS=ms,cache$1=Receptacle.prototype,counter=new Date%1e9;function getUID(){return(Math.random()*1e9>>>0)+counter++}function Receptacle(J){J=J||{},this.id=J.id||getUID(),this.max=J.max||1/0,this.items=J.items||[],this._lookup={},this.size=this.items.length,this.lastModified=new Date(J.lastModified||new Date);for(var E,ee,te=this.items.length;te--;)E=this.items[te],ee=new Date(E.expires)-new Date,this._lookup[E.key]=E,ee>0?this.expire(E.key,ee):ee<=0&&this.delete(E.key)}cache$1.has=function(J){return J in this._lookup};cache$1.get=function(J){if(!this.has(J))return null;var E=this._lookup[J];return E.refresh&&this.expire(J,E.refresh),this.items.splice(this.items.indexOf(E),1),this.items.push(E),E.value};cache$1.meta=function(J){if(!this.has(J))return null;var E=this._lookup[J];return"meta"in E?E.meta:null};cache$1.set=function(J,E,ee){var te=this._lookup[J],re=this._lookup[J]={key:J,value:E};return this.lastModified=new Date,te?(clearTimeout(te.timeout),this.items.splice(this.items.indexOf(te),1,re)):(this.size>=this.max&&this.delete(this.items[0].key),this.items.push(re),this.size++),ee&&("ttl"in ee&&this.expire(J,ee.ttl),"meta"in ee&&(re.meta=ee.meta),ee.refresh&&(re.refresh=ee.ttl)),this};cache$1.delete=function(J){var E=this._lookup[J];return E?(this.lastModified=new Date,this.items.splice(this.items.indexOf(E),1),clearTimeout(E.timeout),delete this._lookup[J],this.size--,this):!1};cache$1.expire=function(J,E){var ee=E||0,te=this._lookup[J];if(!te)return this;if(typeof ee=="string"&&(ee=toMS(E)),typeof ee!="number")throw new TypeError("Expiration time must be a string or number.");return clearTimeout(te.timeout),te.timeout=setTimeout(this.delete.bind(this,te.key),ee),te.expires=Number(new Date)+ee,this};cache$1.clear=function(){for(var J=this.items.length;J--;)this.delete(this.items[J].key);return this};cache$1.toJSON=function(){for(var J=new Array(this.items.length),E,ee=J.length;ee--;)E=this.items[ee],J[ee]={key:E.key,meta:E.meta,value:E.value,expires:E.expires,refresh:E.refresh};return{id:this.id,max:isFinite(this.max)?this.max:void 0,lastModified:this.lastModified,items:J}};const Receptacle$1=getDefaultExportFromCjs(receptacle),globalFetch=globalThis.fetch,globalHeaders=globalThis.Headers;function buildResource(J,E,ee){return`${J}?name=${E}&type=${ee}`}async function request(J,E){return await(await globalFetch(J,{headers:new globalHeaders({accept:"application/dns-json"}),signal:E})).json()}function getCacheKey(J,E){return`${E}_${J}`}const log$1m=Object.assign(debug("dns-over-http-resolver"),{error:debug("dns-over-http-resolver:error")});class Resolver{constructor(E={}){this._cache=new Receptacle$1({max:E?.maxCache??100}),this._TXTcache=new Receptacle$1({max:E?.maxCache??100}),this._servers=["https://cloudflare-dns.com/dns-query","https://dns.google/resolve"],this._request=E.request??request,this._abortControllers=[]}cancel(){this._abortControllers.forEach(E=>E.abort())}getServers(){return this._servers}_getShuffledServers(){const E=[...this._servers];for(let ee=E.length-1;ee>0;ee--){const te=Math.floor(Math.random()*ee),re=E[ee];E[ee]=E[te],E[te]=re}return E}setServers(E){this._servers=E}async resolve(E,ee="A"){switch(ee){case"A":return await this.resolve4(E);case"AAAA":return await this.resolve6(E);case"TXT":return await this.resolveTxt(E);default:throw new Error(`${ee} is not supported`)}}async resolve4(E){const ee="A",te=this._cache.get(getCacheKey(E,ee));if(te!=null)return te;let re=!1;for(const ne of this._getShuffledServers()){const ie=new AbortController;this._abortControllers.push(ie);try{const se=await this._request(buildResource(ne,E,ee),ie.signal),oe=se.Answer.map(ae=>ae.data),ce=Math.min(...se.Answer.map(ae=>ae.TTL));return this._cache.set(getCacheKey(E,ee),oe,{ttl:ce}),oe}catch{ie.signal.aborted&&(re=!0),log$1m.error(`${ne} could not resolve ${E} record ${ee}`)}finally{this._abortControllers=this._abortControllers.filter(se=>se!==ie)}}throw re?Object.assign(new Error("queryA ECANCELLED"),{code:"ECANCELLED"}):new Error(`Could not resolve ${E} record ${ee}`)}async resolve6(E){const ee="AAAA",te=this._cache.get(getCacheKey(E,ee));if(te!=null)return te;let re=!1;for(const ne of this._getShuffledServers()){const ie=new AbortController;this._abortControllers.push(ie);try{const se=await this._request(buildResource(ne,E,ee),ie.signal),oe=se.Answer.map(ae=>ae.data),ce=Math.min(...se.Answer.map(ae=>ae.TTL));return this._cache.set(getCacheKey(E,ee),oe,{ttl:ce}),oe}catch{ie.signal.aborted&&(re=!0),log$1m.error(`${ne} could not resolve ${E} record ${ee}`)}finally{this._abortControllers=this._abortControllers.filter(se=>se!==ie)}}throw re?Object.assign(new Error("queryAaaa ECANCELLED"),{code:"ECANCELLED"}):new Error(`Could not resolve ${E} record ${ee}`)}async resolveTxt(E){const ee="TXT",te=this._TXTcache.get(getCacheKey(E,ee));if(te!=null)return te;let re=!1;for(const ne of this._getShuffledServers()){const ie=new AbortController;this._abortControllers.push(ie);try{const se=await this._request(buildResource(ne,E,ee),ie.signal),oe=se.Answer.map(ae=>[ae.data.replace(/['"]+/g,"")]),ce=Math.min(...se.Answer.map(ae=>ae.TTL));return this._TXTcache.set(getCacheKey(E,ee),oe,{ttl:ce}),oe}catch{ie.signal.aborted&&(re=!0),log$1m.error(`${ne} could not resolve ${E} record ${ee}`)}finally{this._abortControllers=this._abortControllers.filter(se=>se!==ie)}}throw re?Object.assign(new Error("queryTxt ECANCELLED"),{code:"ECANCELLED"}):new Error(`Could not resolve ${E} record ${ee}`)}clearCache(){this._cache.clear(),this._TXTcache.clear()}}const{code:dnsaddrCode}=getProtocol("dnsaddr");async function dnsaddrResolver(J,E={}){const ee=new Resolver;E.signal!=null&&E.signal.addEventListener("abort",()=>{ee.cancel()});const te=J.getPeerId(),[,re]=J.stringTuples().find(([ie])=>ie===dnsaddrCode)??[];if(re==null)throw new Error("No hostname found in multiaddr");let ne=(await ee.resolveTxt(`_dnsaddr.${re}`)).flat().map(ie=>ie.split("=")[1]).filter(Boolean);return te!=null&&(ne=ne.filter(ie=>ie.includes(te))),ne}function anySignal(J){const E=new globalThis.AbortController;function ee(){E.abort();for(const ne of J)ne?.removeEventListener!=null&&ne.removeEventListener("abort",ee)}for(const ne of J){if(ne?.aborted===!0){ee();break}ne?.addEventListener!=null&&ne.addEventListener("abort",ee)}function te(){for(const ne of J)ne?.removeEventListener!=null&&ne.removeEventListener("abort",ee)}const re=E.signal;return re.clear=te,re}var domain;function EventHandlers(){}EventHandlers.prototype=Object.create(null);function EventEmitter$1(){EventEmitter$1.init.call(this)}function setMaxListeners(J,...E){if(typeof J!="number"||J<0||isNaN(J))throw new TypeError('"n" argument must be a positive number');if(E.length===0)EventEmitter$1.defaultMaxListeners=J;else for(let ee=0;ee<E.length;ee++){const te=E[ee];if(typeof te.setMaxListeners=="function")te.setMaxListeners(J);else throw new TypeError('"eventTargets" must be instances of "EventEmitter"')}}EventEmitter$1.setMaxListeners=setMaxListeners;EventEmitter$1.EventEmitter=EventEmitter$1;EventEmitter$1.usingDomains=!1;EventEmitter$1.prototype.domain=void 0;EventEmitter$1.prototype._events=void 0;EventEmitter$1.prototype._maxListeners=void 0;EventEmitter$1.defaultMaxListeners=10;EventEmitter$1.init=function(){this.domain=null,EventEmitter$1.usingDomains&&domain.active,(!this._events||this._events===Object.getPrototypeOf(this)._events)&&(this._events=new EventHandlers,this._eventsCount=0),this._maxListeners=this._maxListeners||void 0};EventEmitter$1.prototype.setMaxListeners=function(J){if(typeof J!="number"||J<0||isNaN(J))throw new TypeError('"n" argument must be a positive number');return this._maxListeners=J,this};function $getMaxListeners(J){return J._maxListeners===void 0?EventEmitter$1.defaultMaxListeners:J._maxListeners}EventEmitter$1.prototype.getMaxListeners=function(){return $getMaxListeners(this)};function emitNone(J,E,ee){if(E)J.call(ee);else for(var te=J.length,re=arrayClone(J,te),ne=0;ne<te;++ne)re[ne].call(ee)}function emitOne(J,E,ee,te){if(E)J.call(ee,te);else for(var re=J.length,ne=arrayClone(J,re),ie=0;ie<re;++ie)ne[ie].call(ee,te)}function emitTwo(J,E,ee,te,re){if(E)J.call(ee,te,re);else for(var ne=J.length,ie=arrayClone(J,ne),se=0;se<ne;++se)ie[se].call(ee,te,re)}function emitThree(J,E,ee,te,re,ne){if(E)J.call(ee,te,re,ne);else for(var ie=J.length,se=arrayClone(J,ie),oe=0;oe<ie;++oe)se[oe].call(ee,te,re,ne)}function emitMany(J,E,ee,te){if(E)J.apply(ee,te);else for(var re=J.length,ne=arrayClone(J,re),ie=0;ie<re;++ie)ne[ie].apply(ee,te)}EventEmitter$1.prototype.emit=function(J){var E,ee,te,re,ne,ie,se,oe=J==="error";if(ie=this._events,ie)oe=oe&&ie.error==null;else if(!oe)return!1;if(se=this.domain,oe){if(E=arguments[1],se)E||(E=new Error('Uncaught, unspecified "error" event')),E.domainEmitter=this,E.domain=se,E.domainThrown=!1,se.emit("error",E);else{if(E instanceof Error)throw E;var ce=new Error('Uncaught, unspecified "error" event. ('+E+")");throw ce.context=E,ce}return!1}if(ee=ie[J],!ee)return!1;var ae=typeof ee=="function";switch(te=arguments.length,te){case 1:emitNone(ee,ae,this);break;case 2:emitOne(ee,ae,this,arguments[1]);break;case 3:emitTwo(ee,ae,this,arguments[1],arguments[2]);break;case 4:emitThree(ee,ae,this,arguments[1],arguments[2],arguments[3]);break;default:for(re=new Array(te-1),ne=1;ne<te;ne++)re[ne-1]=arguments[ne];emitMany(ee,ae,this,re)}return!0};function _addListener(J,E,ee,te){var re,ne,ie;if(typeof ee!="function")throw new TypeError('"listener" argument must be a function');if(ne=J._events,ne?(ne.newListener&&(J.emit("newListener",E,ee.listener?ee.listener:ee),ne=J._events),ie=ne[E]):(ne=J._events=new EventHandlers,J._eventsCount=0),!ie)ie=ne[E]=ee,++J._eventsCount;else if(typeof ie=="function"?ie=ne[E]=te?[ee,ie]:[ie,ee]:te?ie.unshift(ee):ie.push(ee),!ie.warned&&(re=$getMaxListeners(J),re&&re>0&&ie.length>re)){ie.warned=!0;var se=new Error("Possible EventEmitter memory leak detected. "+ie.length+" "+E+" listeners added. Use emitter.setMaxListeners() to increase limit");se.name="MaxListenersExceededWarning",se.emitter=J,se.type=E,se.count=ie.length,emitWarning(se)}return J}function emitWarning(J){typeof console.warn=="function"?console.warn(J):console.log(J)}EventEmitter$1.prototype.addListener=function(J,E){return _addListener(this,J,E,!1)};EventEmitter$1.prototype.on=EventEmitter$1.prototype.addListener;EventEmitter$1.prototype.prependListener=function(J,E){return _addListener(this,J,E,!0)};function _onceWrap(J,E,ee){var te=!1;function re(){J.removeListener(E,re),te||(te=!0,ee.apply(J,arguments))}return re.listener=ee,re}EventEmitter$1.prototype.once=function(J,E){if(typeof E!="function")throw new TypeError('"listener" argument must be a function');return this.on(J,_onceWrap(this,J,E)),this};EventEmitter$1.prototype.prependOnceListener=function(J,E){if(typeof E!="function")throw new TypeError('"listener" argument must be a function');return this.prependListener(J,_onceWrap(this,J,E)),this};EventEmitter$1.prototype.removeListener=function(J,E){var ee,te,re,ne,ie;if(typeof E!="function")throw new TypeError('"listener" argument must be a function');if(te=this._events,!te)return this;if(ee=te[J],!ee)return this;if(ee===E||ee.listener&&ee.listener===E)--this._eventsCount===0?this._events=new EventHandlers:(delete te[J],te.removeListener&&this.emit("removeListener",J,ee.listener||E));else if(typeof ee!="function"){for(re=-1,ne=ee.length;ne-- >0;)if(ee[ne]===E||ee[ne].listener&&ee[ne].listener===E){ie=ee[ne].listener,re=ne;break}if(re<0)return this;if(ee.length===1){if(ee[0]=void 0,--this._eventsCount===0)return this._events=new EventHandlers,this;delete te[J]}else spliceOne(ee,re);te.removeListener&&this.emit("removeListener",J,ie||E)}return this};EventEmitter$1.prototype.removeAllListeners=function(J){var E,ee;if(ee=this._events,!ee)return this;if(!ee.removeListener)return arguments.length===0?(this._events=new EventHandlers,this._eventsCount=0):ee[J]&&(--this._eventsCount===0?this._events=new EventHandlers:delete ee[J]),this;if(arguments.length===0){for(var te=Object.keys(ee),re=0,ne;re<te.length;++re)ne=te[re],ne!=="removeListener"&&this.removeAllListeners(ne);return this.removeAllListeners("removeListener"),this._events=new EventHandlers,this._eventsCount=0,this}if(E=ee[J],typeof E=="function")this.removeListener(J,E);else if(E)do this.removeListener(J,E[E.length-1]);while(E[0]);return this};EventEmitter$1.prototype.listeners=function(J){var E,ee,te=this._events;return te?(E=te[J],E?typeof E=="function"?ee=[E.listener||E]:ee=unwrapListeners(E):ee=[]):ee=[],ee};EventEmitter$1.listenerCount=function(J,E){return typeof J.listenerCount=="function"?J.listenerCount(E):listenerCount.call(J,E)};EventEmitter$1.prototype.listenerCount=listenerCount;function listenerCount(J){var E=this._events;if(E){var ee=E[J];if(typeof ee=="function")return 1;if(ee)return ee.length}return 0}EventEmitter$1.prototype.eventNames=function(){return this._eventsCount>0?Reflect.ownKeys(this._events):[]};function spliceOne(J,E){for(var ee=E,te=ee+1,re=J.length;te<re;ee+=1,te+=1)J[ee]=J[te];J.pop()}function arrayClone(J,E){for(var ee=new Array(E);E--;)ee[E]=J[E];return ee}function unwrapListeners(J){for(var E=new Array(J.length),ee=0;ee<E.length;++ee)E[ee]=J[ee].listener||J[ee];return E}const log$1l=logger$1("libp2p:connection-manager:utils");async function resolveMultiaddrs$1(J,E){if(!J.protoNames().includes("dnsaddr"))return[J];const ee=await resolveRecord$1(J,E),te=(await Promise.all(ee.map(async re=>await resolveMultiaddrs$1(re,E)))).flat().reduce((re,ne)=>(re.find(ie=>ie.equals(ne))==null&&re.push(ne),re),[]);return log$1l("resolved %s to",J,te.map(re=>re.toString())),te}async function resolveRecord$1(J,E){try{return J=multiaddr(J.toString()),await J.resolve(E)}catch(ee){return log$1l.error(`multiaddr ${J.toString()} could not be resolved`,ee),[]}}function combineSignals$1(...J){const E=[];for(const te of J)if(te!=null){try{setMaxListeners?.(1/0,te)}catch{}E.push(te)}const ee=anySignal(E);try{setMaxListeners?.(1/0,ee)}catch{}return ee}function pDefer(){const J={};return J.promise=new Promise((E,ee)=>{J.resolve=E,J.reject=ee}),J}const log$1k=logger$1("libp2p:connection-manager:dial-queue"),defaultOptions$j={addressSorter:publicAddressesFirst,maxParallelDials:MAX_PARALLEL_DIALS$1,maxPeerAddrsToDial:MAX_PEER_ADDRS_TO_DIAL$1,maxParallelDialsPerPeer:MAX_PARALLEL_DIALS_PER_PEER$1,dialTimeout:DIAL_TIMEOUT$1,resolvers:{dnsaddr:dnsaddrResolver}};let DialQueue$1=class{constructor(J,E={}){this.addressSorter=E.addressSorter??defaultOptions$j.addressSorter,this.maxPeerAddrsToDial=E.maxPeerAddrsToDial??defaultOptions$j.maxPeerAddrsToDial,this.maxParallelDialsPerPeer=E.maxParallelDialsPerPeer??defaultOptions$j.maxParallelDialsPerPeer,this.dialTimeout=E.dialTimeout??defaultOptions$j.dialTimeout,this.peerId=J.peerId,this.peerStore=J.peerStore,this.connectionGater=J.connectionGater,this.transportManager=J.transportManager,this.shutDownController=new AbortController;try{setMaxListeners?.(1/0,this.shutDownController.signal)}catch{}this.pendingDialCount=J.metrics?.registerMetric("libp2p_dialler_pending_dials"),this.inProgressDialCount=J.metrics?.registerMetric("libp2p_dialler_in_progress_dials"),this.pendingDials=[];for(const[ee,te]of Object.entries(E.resolvers??{}))resolvers$1.set(ee,te);this.queue=new PQueue({concurrency:E.maxParallelDials??defaultOptions$j.maxParallelDials}),this.queue.on("add",()=>{this.pendingDialCount?.update(this.queue.size),this.inProgressDialCount?.update(this.queue.pending)}),this.queue.on("active",()=>{this.pendingDialCount?.update(this.queue.size),this.inProgressDialCount?.update(this.queue.pending)}),this.queue.on("completed",()=>{this.pendingDialCount?.update(this.queue.size),this.inProgressDialCount?.update(this.queue.pending)}),this.queue.on("error",ee=>{log$1k.error("error in dial queue",ee),this.pendingDialCount?.update(this.queue.size),this.inProgressDialCount?.update(this.queue.pending)}),this.queue.on("empty",()=>{this.pendingDialCount?.update(this.queue.size),this.inProgressDialCount?.update(this.queue.pending)}),this.queue.on("idle",()=>{this.pendingDialCount?.update(this.queue.size),this.inProgressDialCount?.update(this.queue.pending)})}stop(){this.shutDownController.abort()}async dial(J,E={}){const{peerId:ee,multiaddrs:te}=getPeerAddress$1(J),re=te.map(ce=>({multiaddr:ce,isCertified:!1})),ne=this.createDialAbortControllers(E.signal);let ie;try{ie=await this.calculateMultiaddrs(ee,re,{...E,signal:ne})}catch(ce){throw ne.clear(),ce}const se=this.pendingDials.find(ce=>!!(ce.peerId!=null&&ee!=null&&ce.peerId.equals(ee)||ie.map(({multiaddr:ae})=>ae.toString()).join()===ce.multiaddrs.map(ae=>ae.toString()).join()));if(se!=null)return log$1k("joining existing dial target for %p",ee),ne.clear(),await se.promise;log$1k("creating dial target for",ie.map(({multiaddr:ce})=>ce.toString()));const oe={id:randomId$1(),status:"queued",peerId:ee,multiaddrs:ie.map(({multiaddr:ce})=>ce)};return oe.promise=this.performDial(oe,{...E,signal:ne}).finally(()=>{this.pendingDials=this.pendingDials.filter(ce=>ce.id!==oe.id),ne.clear()}).catch(ce=>{throw log$1k.error("dial failed to %s",oe.multiaddrs.map(ae=>ae.toString()).join(", "),ce),ne.aborted?new CodeError(ce.message,codes$8.ERR_TIMEOUT):ce}),this.pendingDials.push(oe),await oe.promise}createDialAbortControllers(J){const E=anySignal([AbortSignal.timeout(this.dialTimeout),this.shutDownController.signal,J]);try{setMaxListeners?.(1/0,E)}catch{}return E}async calculateMultiaddrs(J,E=[],ee={}){if(J!=null){if(this.peerId.equals(J))throw new CodeError("Tried to dial self",codes$8.ERR_DIALED_SELF);if(await this.connectionGater.denyDialPeer?.(J)===!0)throw new CodeError("The dial request is blocked by gater.allowDialPeer",codes$8.ERR_PEER_DIAL_INTERCEPTED);if(E.length===0){log$1k("loading multiaddrs for %p",J);try{const ce=await this.peerStore.get(J);E.push(...ce.addresses),log$1k("loaded multiaddrs for %p",J,E.map(({multiaddr:ae})=>ae.toString()))}catch(ce){if(ce.code!==codes$8.ERR_NOT_FOUND)throw ce}}}const te=(await Promise.all(E.map(async ce=>{const ae=await resolveMultiaddrs$1(ce.multiaddr,ee);return ae.length===1&&ae[0].equals(ce.multiaddr)?ce:ae.map(le=>({multiaddr:le,isCertified:!1}))}))).flat(),re=te.filter(ce=>!!this.transportManager.transportForMultiaddr(ce.multiaddr)),ne=new Map;for(const ce of re){const ae=ce.multiaddr.toString(),le=ne.get(ae);if(le!=null){le.isCertified=le.isCertified||ce.isCertified||!1;continue}ne.set(ae,ce)}let ie=[...ne.values()];if((ie.length===0||ie.length>this.maxPeerAddrsToDial)&&(log$1k("addresses for %p before filtering",J??"unknown peer",te.map(({multiaddr:ce})=>ce.toString())),log$1k("addresses for %p after filtering",J??"unknown peer",ie.map(({multiaddr:ce})=>ce.toString()))),ie.length===0)throw new CodeError("The dial request has no valid addresses",codes$8.ERR_NO_VALID_ADDRESSES);if(ie.length>this.maxPeerAddrsToDial)throw new CodeError("dial with more addresses than allowed",codes$8.ERR_TOO_MANY_ADDRESSES);if(J!=null){const ce=`/p2p/${J.toString()}`;ie=ie.map(ae=>{const le=ae.multiaddr.getPeerId();return ae.multiaddr.protos().pop()?.path===!0?ae:le!==J.toString()?{multiaddr:ae.multiaddr.encapsulate(ce),isCertified:ae.isCertified}:ae})}const se=[];for(const ce of ie)this.connectionGater.denyDialMultiaddr!=null&&await this.connectionGater.denyDialMultiaddr(ce.multiaddr)||se.push(ce);const oe=se.sort(this.addressSorter);if(oe.length===0)throw new CodeError("The connection gater denied all addresses in the dial request",codes$8.ERR_NO_VALID_ADDRESSES);return oe}async performDial(J,E={}){const ee=J.multiaddrs.map(()=>new AbortController);try{const te=new PQueue({concurrency:this.maxParallelDialsPerPeer});te.on("error",ne=>{log$1k.error("error dialling",ne)});const re=await Promise.any(J.multiaddrs.map(async(ne,ie)=>{const se=ee[ie];if(se==null)throw new CodeError("dialAction did not come with an AbortController",codes$8.ERR_INVALID_PARAMETERS);const oe=combineSignals$1(se.signal,E.signal);oe.addEventListener("abort",()=>{log$1k("dial to %s aborted",ne)});const ce=pDefer();return await te.add(async()=>{if(oe.aborted){log$1k("dial to %s was aborted before reaching the head of the peer dial queue",ne),ce.reject(new AbortError$5);return}await this.queue.add(async()=>{try{if(oe.aborted){log$1k("dial to %s was aborted before reaching the head of the dial queue",ne),ce.reject(new AbortError$5);return}J.status="active";const ae=await this.transportManager.dial(ne,{...E,signal:oe});if(se.signal.aborted){log$1k("multiple dials succeeded, closing superfluous connection"),ae.close().catch(le=>{log$1k.error("error closing superfluous connection",le)}),ce.reject(new AbortError$5);return}ee[ie]=void 0,ee.forEach(le=>{le!==void 0&&le.abort()}),log$1k("dial to %s succeeded",ne),ce.resolve(ae)}catch(ae){log$1k.error("error during dial of %s",ne,ae),ce.reject(ae)}},{...E,signal:oe}).catch(ae=>{ce.reject(ae)})},{signal:oe}).catch(ae=>{ce.reject(ae)}).finally(()=>{oe.clear()}),await ce.promise}));if(re==null)throw new CodeError("successful dial led to empty object returned from peer dial queue",codes$8.ERR_TRANSPORT_DIAL_FAILED);return J.status="success",re}catch(te){throw J.status="error",J.multiaddrs.length===1&&te.name==="AggregateError"?te.errors[0]:te}}};function randomId$1(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}const log$1j=logger$1("libp2p:connection-manager:connection-pruner"),defaultOptions$i={maxConnections:MAX_CONNECTIONS$1,allow:[]};let ConnectionPruner$1=class{constructor(J,E={}){this.maxConnections=E.maxConnections??defaultOptions$i.maxConnections,this.allow=E.allow??defaultOptions$i.allow,this.connectionManager=J.connectionManager,this.peerStore=J.peerStore,this.events=J.events,J.events.addEventListener("connection:open",()=>{this.maybePruneConnections().catch(ee=>{log$1j.error(ee)})})}async maybePruneConnections(){const J=this.connectionManager.getConnections(),E=J.length,ee=Math.max(E-this.maxConnections,0);if(log$1j("checking max connections limit %d/%d",E,this.maxConnections),E<=this.maxConnections)return;log$1j("max connections limit exceeded %d/%d, pruning %d connection(s)",E,this.maxConnections,ee);const te=new PeerMap;for(const ie of J){const se=ie.remotePeer;if(!te.has(se)){te.set(se,0);try{const oe=await this.peerStore.get(se);te.set(se,[...oe.tags.values()].reduce((ce,ae)=>ce+ae.value,0))}catch(oe){oe.code!=="ERR_NOT_FOUND"&&log$1j.error("error loading peer tags",oe)}}}const re=J.sort((ie,se)=>{const oe=te.get(ie.remotePeer)??0,ce=te.get(se.remotePeer)??0;if(oe>ce)return 1;if(oe<ce)return-1;const ae=ie.stat.timeline.open,le=se.stat.timeline.open;return ae<le?1:ae>le?-1:0}),ne=[];for(const ie of re)if(log$1j("too many connections open - closing a connection to %p",ie.remotePeer),this.allow.some(se=>ie.remoteAddr.toString().startsWith(se.toString()))||ne.push(ie),ne.length===ee)break;await Promise.all(ne.map(async ie=>{try{await ie.close()}catch(se){log$1j.error(se)}})),this.events.safeDispatchEvent("connection:prune",{detail:ne})}};const log$1i=logger$1("libp2p:connection-manager"),DEFAULT_DIAL_PRIORITY$1=50,defaultOptions$h={minConnections:MIN_CONNECTIONS$1,maxConnections:MAX_CONNECTIONS$1,inboundConnectionThreshold:INBOUND_CONNECTION_THRESHOLD$1,maxIncomingPendingConnections:MAX_INCOMING_PENDING_CONNECTIONS$1,autoDialConcurrency:AUTO_DIAL_CONCURRENCY$1,autoDialPriority:AUTO_DIAL_PRIORITY$1};let DefaultConnectionManager$1=class{constructor(J,E={}){this.maxConnections=E.maxConnections??defaultOptions$h.maxConnections;const ee=E.minConnections??defaultOptions$h.minConnections;if(this.maxConnections<ee)throw new CodeError("Connection Manager maxConnections must be greater than minConnections",codes$8.ERR_INVALID_PARAMETERS);this.connections=new PeerMap,this.started=!1,this.peerStore=J.peerStore,this.metrics=J.metrics,this.events=J.events,this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),this.allow=(E.allow??[]).map(te=>multiaddr(te)),this.deny=(E.deny??[]).map(te=>multiaddr(te)),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=E.maxIncomingPendingConnections??defaultOptions$h.maxIncomingPendingConnections,this.inboundConnectionRateLimiter=new rateLimiterFlexible.RateLimiterMemory({points:E.inboundConnectionThreshold??defaultOptions$h.inboundConnectionThreshold,duration:1}),this.autoDial=new AutoDial$1({connectionManager:this,peerStore:J.peerStore,events:J.events},{minConnections:ee,autoDialConcurrency:E.autoDialConcurrency??defaultOptions$h.autoDialConcurrency,autoDialPriority:E.autoDialPriority??defaultOptions$h.autoDialPriority}),this.connectionPruner=new ConnectionPruner$1({connectionManager:this,peerStore:J.peerStore,events:J.events},{maxConnections:this.maxConnections,allow:this.allow}),this.dialQueue=new DialQueue$1({peerId:J.peerId,metrics:J.metrics,peerStore:J.peerStore,transportManager:J.transportManager,connectionGater:J.connectionGater},{addressSorter:E.addressSorter??publicAddressesFirst,maxParallelDials:E.maxParallelDials??MAX_PARALLEL_DIALS$1,maxPeerAddrsToDial:E.maxPeerAddrsToDial??MAX_PEER_ADDRS_TO_DIAL$1,dialTimeout:E.dialTimeout??DIAL_TIMEOUT$1,resolvers:E.resolvers??{dnsaddr:dnsaddrResolver}})}isStarted(){return this.started}async start(){this.metrics?.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const J={inbound:0,outbound:0};for(const E of this.connections.values())for(const ee of E)ee.stat.direction==="inbound"?J.inbound++:J.outbound++;return J}}),this.metrics?.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const J={};for(const E of this.connections.values())for(const ee of E)for(const te of ee.streams){const re=`${te.stat.direction} ${te.stat.protocol??"unnegotiated"}`;J[re]=(J[re]??0)+1}return J}}),this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const J={};for(const ee of this.connections.values())for(const te of ee){const re={};for(const ne of te.streams){const ie=`${ne.stat.direction} ${ne.stat.protocol??"unnegotiated"}`;re[ie]=(re[ie]??0)+1}for(const[ne,ie]of Object.entries(re))J[ne]=J[ne]??[],J[ne].push(ie)}const E={};for(let[ee,te]of Object.entries(J)){te=te.sort((ne,ie)=>ne-ie);const re=Math.floor(te.length*.9);E[ee]=te[re]}return E}}),this.autoDial.start(),this.started=!0,log$1i("started")}async afterStart(){Promise.resolve().then(async()=>{const J=[];for(const E of await this.peerStore.all())E.tags.has(KEEP_ALIVE)&&J.push(E.id);await Promise.all(J.map(async E=>{await this.openConnection(E).catch(ee=>{log$1i.error(ee)})}))}).catch(J=>{log$1i.error(J)}),this.autoDial.afterStart()}async stop(){this.dialQueue.stop(),this.autoDial.stop();const J=[];for(const E of this.connections.values())for(const ee of E)J.push((async()=>{try{await ee.close()}catch(te){log$1i.error(te)}})());log$1i("closing %d connections",J.length),await Promise.all(J),this.connections.clear(),log$1i("stopped")}onConnect(J){this._onConnect(J).catch(E=>{log$1i.error(E)})}async _onConnect(J){const{detail:E}=J;if(!this.started){await E.close();return}const ee=E.remotePeer,te=this.connections.get(ee);let re=!1;te!=null?te.push(E):(re=!0,this.connections.set(ee,[E])),ee.publicKey!=null&&ee.type==="RSA"&&await this.peerStore.patch(ee,{publicKey:ee.publicKey}),re&&this.events.safeDispatchEvent("peer:connect",{detail:E.remotePeer})}onDisconnect(J){const{detail:E}=J;if(!this.started)return;const ee=E.remotePeer;let te=this.connections.get(ee);te!=null&&te.length>1?(te=te.filter(re=>re.id!==E.id),this.connections.set(ee,te)):te!=null&&(this.connections.delete(ee),this.events.safeDispatchEvent("peer:disconnect",{detail:E.remotePeer}))}getConnections(J){if(J!=null)return this.connections.get(J)??[];let E=[];for(const ee of this.connections.values())E=E.concat(ee);return E}getConnectionsMap(){return this.connections}async openConnection(J,E={}){if(!this.isStarted())throw new CodeError("Not started",codes$8.ERR_NODE_NOT_STARTED);const{peerId:ee}=getPeerAddress$1(J);if(ee!=null){log$1i("dial %p",ee);const ie=this.getConnections(ee);if(ie.length>0)return log$1i("had an existing connection to %p",ee),ie[0]}const te=await this.dialQueue.dial(J,{...E,priority:E.priority??DEFAULT_DIAL_PRIORITY$1});let re=this.connections.get(te.remotePeer);re==null&&(re=[],this.connections.set(te.remotePeer,re));let ne=!1;for(const ie of re)ie.id===te.id&&(ne=!0);return ne||re.push(te),te}async closeConnections(J){const E=this.connections.get(J)??[];await Promise.all(E.map(async ee=>{await ee.close()}))}async acceptIncomingConnection(J){if(this.deny.some(E=>J.remoteAddr.toString().startsWith(E.toString())))return log$1i("connection from %s refused - connection remote address was in deny list",J.remoteAddr),!1;if(this.allow.some(E=>J.remoteAddr.toString().startsWith(E.toString())))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return log$1i("connection from %s refused - incomingPendingConnections exceeded by peer %s",J.remoteAddr),!1;if(J.remoteAddr.isThinWaistAddress()){const E=J.remoteAddr.nodeAddress().address;try{await this.inboundConnectionRateLimiter.consume(E,1)}catch{return log$1i("connection from %s refused - inboundConnectionThreshold exceeded by host %s",E,J.remoteAddr),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(log$1i("connection from %s refused - maxConnections exceeded",J.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){return this.dialQueue.pendingDials}};function isHighSurrogate$1(J){return J>=55296&&J<=56319}function isLowSurrogate$1(J){return J>=56320&&J<=57343}var truncate$2=function(J,E,ee){if(typeof E!="string")throw new Error("Input must be string");for(var te=E.length,re=0,ne,ie,se=0;se<te;se+=1){if(ne=E.charCodeAt(se),ie=E[se],isHighSurrogate$1(ne)&&isLowSurrogate$1(E.charCodeAt(se+1))&&(se+=1,ie+=E[se]),re+=J(ie),re===ee)return E.slice(0,se+1);if(re>ee)return E.slice(0,se-ie.length+1)}return E};function isHighSurrogate(J){return J>=55296&&J<=56319}function isLowSurrogate(J){return J>=56320&&J<=57343}var browser$4=function(J){if(typeof J!="string")throw new Error("Input must be string");for(var E=J.length,ee=0,te=null,re=null,ne=0;ne<E;ne++)te=J.charCodeAt(ne),isLowSurrogate(te)?re!=null&&isHighSurrogate(re)?ee+=1:ee+=3:te<=127?ee+=1:te>=128&&te<=2047?ee+=2:te>=2048&&te<=65535&&(ee+=3),re=te;return ee},truncate$1=truncate$2,getLength=browser$4,browser$3=truncate$1.bind(null,getLength),truncate=browser$3,illegalRe=/[\/\?<>\\:\*\|"]/g,controlRe=/[\x00-\x1f\x80-\x9f]/g,reservedRe=/^\.+$/,windowsReservedRe=/^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i,windowsTrailingRe=/[\. ]+$/;function sanitize(J,E){if(typeof J!="string")throw new Error("Input must be string");var ee=J.replace(illegalRe,E).replace(controlRe,E).replace(reservedRe,E).replace(windowsReservedRe,E).replace(windowsTrailingRe,E);return truncate(ee,255)}var sanitizeFilename=function(J,E){var ee=E&&E.replacement||"",te=sanitize(J,ee);return ee===""?te:sanitize(te,"")};const sanitize$1=getDefaultExportFromCjs(sanitizeFilename);var isPlainObj=J=>{if(Object.prototype.toString.call(J)!=="[object Object]")return!1;const E=Object.getPrototypeOf(J);return E===null||E===Object.prototype};const isOptionObject=isPlainObj,{hasOwnProperty}=Object.prototype,{propertyIsEnumerable}=Object,defineProperty=(J,E,ee)=>Object.defineProperty(J,E,{value:ee,writable:!0,enumerable:!0,configurable:!0}),globalThis$1=commonjsGlobal,defaultMergeOptions={concatArrays:!1,ignoreUndefined:!1},getEnumerableOwnPropertyKeys=J=>{const E=[];for(const ee in J)hasOwnProperty.call(J,ee)&&E.push(ee);if(Object.getOwnPropertySymbols){const ee=Object.getOwnPropertySymbols(J);for(const te of ee)propertyIsEnumerable.call(J,te)&&E.push(te)}return E};function clone(J){return Array.isArray(J)?cloneArray(J):isOptionObject(J)?cloneOptionObject(J):J}function cloneArray(J){const E=J.slice(0,0);return getEnumerableOwnPropertyKeys(J).forEach(ee=>{defineProperty(E,ee,clone(J[ee]))}),E}function cloneOptionObject(J){const E=Object.getPrototypeOf(J)===null?Object.create(null):{};return getEnumerableOwnPropertyKeys(J).forEach(ee=>{defineProperty(E,ee,clone(J[ee]))}),E}const mergeKeys=(J,E,ee,te)=>(ee.forEach(re=>{typeof E[re]>"u"&&te.ignoreUndefined||(re in J&&J[re]!==Object.getPrototypeOf(J)?defineProperty(J,re,merge$1(J[re],E[re],te)):defineProperty(J,re,clone(E[re])))}),J),concatArrays=(J,E,ee)=>{let te=J.slice(0,0),re=0;return[J,E].forEach(ne=>{const ie=[];for(let se=0;se<ne.length;se++)hasOwnProperty.call(ne,se)&&(ie.push(String(se)),ne===J?defineProperty(te,re++,ne[se]):defineProperty(te,re++,clone(ne[se])));te=mergeKeys(te,ne,getEnumerableOwnPropertyKeys(ne).filter(se=>!ie.includes(se)),ee)}),te};function merge$1(J,E,ee){return ee.concatArrays&&Array.isArray(J)&&Array.isArray(E)?concatArrays(J,E,ee):!isOptionObject(E)||!isOptionObject(J)?clone(E):mergeKeys(J,E,getEnumerableOwnPropertyKeys(E),ee)}var mergeOptions$8=function(...J){const E=merge$1(clone(defaultMergeOptions),this!==globalThis$1&&this||{},defaultMergeOptions);let ee={_:{}};for(const te of J)if(te!==void 0){if(!isOptionObject(te))throw new TypeError("`"+te+"` is not an Option Object");ee=merge$1(ee,{_:te},E)}return ee._};const mergeOptions$9=getDefaultExportFromCjs(mergeOptions$8);var codes$7;(function(J){J.ERR_INVALID_PARAMETERS="ERR_INVALID_PARAMETERS",J.ERR_INVALID_KEY_NAME="ERR_INVALID_KEY_NAME",J.ERR_INVALID_KEY_TYPE="ERR_INVALID_KEY_TYPE",J.ERR_KEY_ALREADY_EXISTS="ERR_KEY_ALREADY_EXISTS",J.ERR_INVALID_KEY_SIZE="ERR_INVALID_KEY_SIZE",J.ERR_KEY_NOT_FOUND="ERR_KEY_NOT_FOUND",J.ERR_OLD_KEY_NAME_INVALID="ERR_OLD_KEY_NAME_INVALID",J.ERR_NEW_KEY_NAME_INVALID="ERR_NEW_KEY_NAME_INVALID",J.ERR_PASSWORD_REQUIRED="ERR_PASSWORD_REQUIRED",J.ERR_PEM_REQUIRED="ERR_PEM_REQUIRED",J.ERR_CANNOT_READ_KEY="ERR_CANNOT_READ_KEY",J.ERR_MISSING_PRIVATE_KEY="ERR_MISSING_PRIVATE_KEY",J.ERR_INVALID_OLD_PASS_TYPE="ERR_INVALID_OLD_PASS_TYPE",J.ERR_INVALID_NEW_PASS_TYPE="ERR_INVALID_NEW_PASS_TYPE",J.ERR_INVALID_PASS_LENGTH="ERR_INVALID_PASS_LENGTH"})(codes$7||(codes$7={}));var forge$m={options:{usePureJavaScript:!1}};const forge$n=getDefaultExportFromCjs(forge$m);var util$8={exports:{}},api={},baseN$1=api,_reverseAlphabets={};api.encode=function(J,E,ee){if(typeof E!="string")throw new TypeError('"alphabet" must be a string.');if(ee!==void 0&&typeof ee!="number")throw new TypeError('"maxline" must be a number.');var te="";if(!(J instanceof Uint8Array))te=_encodeWithByteBuffer(J,E);else{var re=0,ne=E.length,ie=E.charAt(0),se=[0];for(re=0;re<J.length;++re){for(var oe=0,ce=J[re];oe<se.length;++oe)ce+=se[oe]<<8,se[oe]=ce%ne,ce=ce/ne|0;for(;ce>0;)se.push(ce%ne),ce=ce/ne|0}for(re=0;J[re]===0&&re<J.length-1;++re)te+=ie;for(re=se.length-1;re>=0;--re)te+=E[se[re]]}if(ee){var ae=new RegExp(".{1,"+ee+"}","g");te=te.match(ae).join(`\r
`)}return te};api.decode=function(J,E){if(typeof J!="string")throw new TypeError('"input" must be a string.');if(typeof E!="string")throw new TypeError('"alphabet" must be a string.');var ee=_reverseAlphabets[E];if(!ee){ee=_reverseAlphabets[E]=[];for(var te=0;te<E.length;++te)ee[E.charCodeAt(te)]=te}J=J.replace(/\s/g,"");for(var re=E.length,ne=E.charAt(0),ie=[0],te=0;te<J.length;te++){var se=ee[J.charCodeAt(te)];if(se===void 0)return;for(var oe=0,ce=se;oe<ie.length;++oe)ce+=ie[oe]*re,ie[oe]=ce&255,ce>>=8;for(;ce>0;)ie.push(ce&255),ce>>=8}for(var ae=0;J[ae]===ne&&ae<J.length-1;++ae)ie.push(0);return typeof Buffer<"u"?Buffer.from(ie.reverse()):new Uint8Array(ie.reverse())};function _encodeWithByteBuffer(J,E){var ee=0,te=E.length,re=E.charAt(0),ne=[0];for(ee=0;ee<J.length();++ee){for(var ie=0,se=J.at(ee);ie<ne.length;++ie)se+=ne[ie]<<8,ne[ie]=se%te,se=se/te|0;for(;se>0;)ne.push(se%te),se=se/te|0}var oe="";for(ee=0;J.at(ee)===0&&ee<J.length()-1;++ee)oe+=re;for(ee=ne.length-1;ee>=0;--ee)oe+=E[ne[ee]];return oe}var forge$l=forge$m,baseN=baseN$1,util$7=util$8.exports=forge$l.util=forge$l.util||{};(function(){if(typeof process<"u"&&process.nextTick&&!process.browser){util$7.nextTick=process.nextTick,typeof setImmediate=="function"?util$7.setImmediate=setImmediate:util$7.setImmediate=util$7.nextTick;return}if(typeof setImmediate=="function"){util$7.setImmediate=function(){return setImmediate.apply(void 0,arguments)},util$7.nextTick=function(ie){return setImmediate(ie)};return}if(util$7.setImmediate=function(ie){setTimeout(ie,0)},typeof window<"u"&&typeof window.postMessage=="function"){let ie=function(se){if(se.source===window&&se.data===J){se.stopPropagation();var oe=E.slice();E.length=0,oe.forEach(function(ce){ce()})}};var J="forge.setImmediate",E=[];util$7.setImmediate=function(se){E.push(se),E.length===1&&window.postMessage(J,"*")},window.addEventListener("message",ie,!0)}if(typeof MutationObserver<"u"){var ee=Date.now(),te=!0,re=document.createElement("div"),E=[];new MutationObserver(function(){var se=E.slice();E.length=0,se.forEach(function(oe){oe()})}).observe(re,{attributes:!0});var ne=util$7.setImmediate;util$7.setImmediate=function(se){Date.now()-ee>15?(ee=Date.now(),ne(se)):(E.push(se),E.length===1&&re.setAttribute("a",te=!te))}}util$7.nextTick=util$7.setImmediate})();util$7.isNodejs=typeof process<"u"&&process.versions&&process.versions.node;util$7.globalScope=function(){return util$7.isNodejs?commonjsGlobal:typeof self>"u"?window:self}();util$7.isArray=Array.isArray||function(J){return Object.prototype.toString.call(J)==="[object Array]"};util$7.isArrayBuffer=function(J){return typeof ArrayBuffer<"u"&&J instanceof ArrayBuffer};util$7.isArrayBufferView=function(J){return J&&util$7.isArrayBuffer(J.buffer)&&J.byteLength!==void 0};function _checkBitsParam(J){if(!(J===8||J===16||J===24||J===32))throw new Error("Only 8, 16, 24, or 32 bits supported: "+J)}util$7.ByteBuffer=ByteStringBuffer;function ByteStringBuffer(J){if(this.data="",this.read=0,typeof J=="string")this.data=J;else if(util$7.isArrayBuffer(J)||util$7.isArrayBufferView(J))if(typeof Buffer<"u"&&J instanceof Buffer)this.data=J.toString("binary");else{var E=new Uint8Array(J);try{this.data=String.fromCharCode.apply(null,E)}catch{for(var ee=0;ee<E.length;++ee)this.putByte(E[ee])}}else(J instanceof ByteStringBuffer||typeof J=="object"&&typeof J.data=="string"&&typeof J.read=="number")&&(this.data=J.data,this.read=J.read);this._constructedStringLength=0}util$7.ByteStringBuffer=ByteStringBuffer;var _MAX_CONSTRUCTED_STRING_LENGTH=4096;util$7.ByteStringBuffer.prototype._optimizeConstructedString=function(J){this._constructedStringLength+=J,this._constructedStringLength>_MAX_CONSTRUCTED_STRING_LENGTH&&(this.data.substr(0,1),this._constructedStringLength=0)};util$7.ByteStringBuffer.prototype.length=function(){return this.data.length-this.read};util$7.ByteStringBuffer.prototype.isEmpty=function(){return this.length()<=0};util$7.ByteStringBuffer.prototype.putByte=function(J){return this.putBytes(String.fromCharCode(J))};util$7.ByteStringBuffer.prototype.fillWithByte=function(J,E){J=String.fromCharCode(J);for(var ee=this.data;E>0;)E&1&&(ee+=J),E>>>=1,E>0&&(J+=J);return this.data=ee,this._optimizeConstructedString(E),this};util$7.ByteStringBuffer.prototype.putBytes=function(J){return this.data+=J,this._optimizeConstructedString(J.length),this};util$7.ByteStringBuffer.prototype.putString=function(J){return this.putBytes(util$7.encodeUtf8(J))};util$7.ByteStringBuffer.prototype.putInt16=function(J){return this.putBytes(String.fromCharCode(J>>8&255)+String.fromCharCode(J&255))};util$7.ByteStringBuffer.prototype.putInt24=function(J){return this.putBytes(String.fromCharCode(J>>16&255)+String.fromCharCode(J>>8&255)+String.fromCharCode(J&255))};util$7.ByteStringBuffer.prototype.putInt32=function(J){return this.putBytes(String.fromCharCode(J>>24&255)+String.fromCharCode(J>>16&255)+String.fromCharCode(J>>8&255)+String.fromCharCode(J&255))};util$7.ByteStringBuffer.prototype.putInt16Le=function(J){return this.putBytes(String.fromCharCode(J&255)+String.fromCharCode(J>>8&255))};util$7.ByteStringBuffer.prototype.putInt24Le=function(J){return this.putBytes(String.fromCharCode(J&255)+String.fromCharCode(J>>8&255)+String.fromCharCode(J>>16&255))};util$7.ByteStringBuffer.prototype.putInt32Le=function(J){return this.putBytes(String.fromCharCode(J&255)+String.fromCharCode(J>>8&255)+String.fromCharCode(J>>16&255)+String.fromCharCode(J>>24&255))};util$7.ByteStringBuffer.prototype.putInt=function(J,E){_checkBitsParam(E);var ee="";do E-=8,ee+=String.fromCharCode(J>>E&255);while(E>0);return this.putBytes(ee)};util$7.ByteStringBuffer.prototype.putSignedInt=function(J,E){return J<0&&(J+=2<<E-1),this.putInt(J,E)};util$7.ByteStringBuffer.prototype.putBuffer=function(J){return this.putBytes(J.getBytes())};util$7.ByteStringBuffer.prototype.getByte=function(){return this.data.charCodeAt(this.read++)};util$7.ByteStringBuffer.prototype.getInt16=function(){var J=this.data.charCodeAt(this.read)<<8^this.data.charCodeAt(this.read+1);return this.read+=2,J};util$7.ByteStringBuffer.prototype.getInt24=function(){var J=this.data.charCodeAt(this.read)<<16^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2);return this.read+=3,J};util$7.ByteStringBuffer.prototype.getInt32=function(){var J=this.data.charCodeAt(this.read)<<24^this.data.charCodeAt(this.read+1)<<16^this.data.charCodeAt(this.read+2)<<8^this.data.charCodeAt(this.read+3);return this.read+=4,J};util$7.ByteStringBuffer.prototype.getInt16Le=function(){var J=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8;return this.read+=2,J};util$7.ByteStringBuffer.prototype.getInt24Le=function(){var J=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2)<<16;return this.read+=3,J};util$7.ByteStringBuffer.prototype.getInt32Le=function(){var J=this.data.charCodeAt(this.read)^this.data.charCodeAt(this.read+1)<<8^this.data.charCodeAt(this.read+2)<<16^this.data.charCodeAt(this.read+3)<<24;return this.read+=4,J};util$7.ByteStringBuffer.prototype.getInt=function(J){_checkBitsParam(J);var E=0;do E=(E<<8)+this.data.charCodeAt(this.read++),J-=8;while(J>0);return E};util$7.ByteStringBuffer.prototype.getSignedInt=function(J){var E=this.getInt(J),ee=2<<J-2;return E>=ee&&(E-=ee<<1),E};util$7.ByteStringBuffer.prototype.getBytes=function(J){var E;return J?(J=Math.min(this.length(),J),E=this.data.slice(this.read,this.read+J),this.read+=J):J===0?E="":(E=this.read===0?this.data:this.data.slice(this.read),this.clear()),E};util$7.ByteStringBuffer.prototype.bytes=function(J){return typeof J>"u"?this.data.slice(this.read):this.data.slice(this.read,this.read+J)};util$7.ByteStringBuffer.prototype.at=function(J){return this.data.charCodeAt(this.read+J)};util$7.ByteStringBuffer.prototype.setAt=function(J,E){return this.data=this.data.substr(0,this.read+J)+String.fromCharCode(E)+this.data.substr(this.read+J+1),this};util$7.ByteStringBuffer.prototype.last=function(){return this.data.charCodeAt(this.data.length-1)};util$7.ByteStringBuffer.prototype.copy=function(){var J=util$7.createBuffer(this.data);return J.read=this.read,J};util$7.ByteStringBuffer.prototype.compact=function(){return this.read>0&&(this.data=this.data.slice(this.read),this.read=0),this};util$7.ByteStringBuffer.prototype.clear=function(){return this.data="",this.read=0,this};util$7.ByteStringBuffer.prototype.truncate=function(J){var E=Math.max(0,this.length()-J);return this.data=this.data.substr(this.read,E),this.read=0,this};util$7.ByteStringBuffer.prototype.toHex=function(){for(var J="",E=this.read;E<this.data.length;++E){var ee=this.data.charCodeAt(E);ee<16&&(J+="0"),J+=ee.toString(16)}return J};util$7.ByteStringBuffer.prototype.toString=function(){return util$7.decodeUtf8(this.bytes())};function DataBuffer(J,E){E=E||{},this.read=E.readOffset||0,this.growSize=E.growSize||1024;var ee=util$7.isArrayBuffer(J),te=util$7.isArrayBufferView(J);if(ee||te){ee?this.data=new DataView(J):this.data=new DataView(J.buffer,J.byteOffset,J.byteLength),this.write="writeOffset"in E?E.writeOffset:this.data.byteLength;return}this.data=new DataView(new ArrayBuffer(0)),this.write=0,J!=null&&this.putBytes(J),"writeOffset"in E&&(this.write=E.writeOffset)}util$7.DataBuffer=DataBuffer;util$7.DataBuffer.prototype.length=function(){return this.write-this.read};util$7.DataBuffer.prototype.isEmpty=function(){return this.length()<=0};util$7.DataBuffer.prototype.accommodate=function(J,E){if(this.length()>=J)return this;E=Math.max(E||this.growSize,J);var ee=new Uint8Array(this.data.buffer,this.data.byteOffset,this.data.byteLength),te=new Uint8Array(this.length()+E);return te.set(ee),this.data=new DataView(te.buffer),this};util$7.DataBuffer.prototype.putByte=function(J){return this.accommodate(1),this.data.setUint8(this.write++,J),this};util$7.DataBuffer.prototype.fillWithByte=function(J,E){this.accommodate(E);for(var ee=0;ee<E;++ee)this.data.setUint8(J);return this};util$7.DataBuffer.prototype.putBytes=function(J,E){if(util$7.isArrayBufferView(J)){var ee=new Uint8Array(J.buffer,J.byteOffset,J.byteLength),te=ee.byteLength-ee.byteOffset;this.accommodate(te);var re=new Uint8Array(this.data.buffer,this.write);return re.set(ee),this.write+=te,this}if(util$7.isArrayBuffer(J)){var ee=new Uint8Array(J);this.accommodate(ee.byteLength);var re=new Uint8Array(this.data.buffer);return re.set(ee,this.write),this.write+=ee.byteLength,this}if(J instanceof util$7.DataBuffer||typeof J=="object"&&typeof J.read=="number"&&typeof J.write=="number"&&util$7.isArrayBufferView(J.data)){var ee=new Uint8Array(J.data.byteLength,J.read,J.length());this.accommodate(ee.byteLength);var re=new Uint8Array(J.data.byteLength,this.write);return re.set(ee),this.write+=ee.byteLength,this}if(J instanceof util$7.ByteStringBuffer&&(J=J.data,E="binary"),E=E||"binary",typeof J=="string"){var ne;if(E==="hex")return this.accommodate(Math.ceil(J.length/2)),ne=new Uint8Array(this.data.buffer,this.write),this.write+=util$7.binary.hex.decode(J,ne,this.write),this;if(E==="base64")return this.accommodate(Math.ceil(J.length/4)*3),ne=new Uint8Array(this.data.buffer,this.write),this.write+=util$7.binary.base64.decode(J,ne,this.write),this;if(E==="utf8"&&(J=util$7.encodeUtf8(J),E="binary"),E==="binary"||E==="raw")return this.accommodate(J.length),ne=new Uint8Array(this.data.buffer,this.write),this.write+=util$7.binary.raw.decode(ne),this;if(E==="utf16")return this.accommodate(J.length*2),ne=new Uint16Array(this.data.buffer,this.write),this.write+=util$7.text.utf16.encode(ne),this;throw new Error("Invalid encoding: "+E)}throw Error("Invalid parameter: "+J)};util$7.DataBuffer.prototype.putBuffer=function(J){return this.putBytes(J),J.clear(),this};util$7.DataBuffer.prototype.putString=function(J){return this.putBytes(J,"utf16")};util$7.DataBuffer.prototype.putInt16=function(J){return this.accommodate(2),this.data.setInt16(this.write,J),this.write+=2,this};util$7.DataBuffer.prototype.putInt24=function(J){return this.accommodate(3),this.data.setInt16(this.write,J>>8&65535),this.data.setInt8(this.write,J>>16&255),this.write+=3,this};util$7.DataBuffer.prototype.putInt32=function(J){return this.accommodate(4),this.data.setInt32(this.write,J),this.write+=4,this};util$7.DataBuffer.prototype.putInt16Le=function(J){return this.accommodate(2),this.data.setInt16(this.write,J,!0),this.write+=2,this};util$7.DataBuffer.prototype.putInt24Le=function(J){return this.accommodate(3),this.data.setInt8(this.write,J>>16&255),this.data.setInt16(this.write,J>>8&65535,!0),this.write+=3,this};util$7.DataBuffer.prototype.putInt32Le=function(J){return this.accommodate(4),this.data.setInt32(this.write,J,!0),this.write+=4,this};util$7.DataBuffer.prototype.putInt=function(J,E){_checkBitsParam(E),this.accommodate(E/8);do E-=8,this.data.setInt8(this.write++,J>>E&255);while(E>0);return this};util$7.DataBuffer.prototype.putSignedInt=function(J,E){return _checkBitsParam(E),this.accommodate(E/8),J<0&&(J+=2<<E-1),this.putInt(J,E)};util$7.DataBuffer.prototype.getByte=function(){return this.data.getInt8(this.read++)};util$7.DataBuffer.prototype.getInt16=function(){var J=this.data.getInt16(this.read);return this.read+=2,J};util$7.DataBuffer.prototype.getInt24=function(){var J=this.data.getInt16(this.read)<<8^this.data.getInt8(this.read+2);return this.read+=3,J};util$7.DataBuffer.prototype.getInt32=function(){var J=this.data.getInt32(this.read);return this.read+=4,J};util$7.DataBuffer.prototype.getInt16Le=function(){var J=this.data.getInt16(this.read,!0);return this.read+=2,J};util$7.DataBuffer.prototype.getInt24Le=function(){var J=this.data.getInt8(this.read)^this.data.getInt16(this.read+1,!0)<<8;return this.read+=3,J};util$7.DataBuffer.prototype.getInt32Le=function(){var J=this.data.getInt32(this.read,!0);return this.read+=4,J};util$7.DataBuffer.prototype.getInt=function(J){_checkBitsParam(J);var E=0;do E=(E<<8)+this.data.getInt8(this.read++),J-=8;while(J>0);return E};util$7.DataBuffer.prototype.getSignedInt=function(J){var E=this.getInt(J),ee=2<<J-2;return E>=ee&&(E-=ee<<1),E};util$7.DataBuffer.prototype.getBytes=function(J){var E;return J?(J=Math.min(this.length(),J),E=this.data.slice(this.read,this.read+J),this.read+=J):J===0?E="":(E=this.read===0?this.data:this.data.slice(this.read),this.clear()),E};util$7.DataBuffer.prototype.bytes=function(J){return typeof J>"u"?this.data.slice(this.read):this.data.slice(this.read,this.read+J)};util$7.DataBuffer.prototype.at=function(J){return this.data.getUint8(this.read+J)};util$7.DataBuffer.prototype.setAt=function(J,E){return this.data.setUint8(J,E),this};util$7.DataBuffer.prototype.last=function(){return this.data.getUint8(this.write-1)};util$7.DataBuffer.prototype.copy=function(){return new util$7.DataBuffer(this)};util$7.DataBuffer.prototype.compact=function(){if(this.read>0){var J=new Uint8Array(this.data.buffer,this.read),E=new Uint8Array(J.byteLength);E.set(J),this.data=new DataView(E),this.write-=this.read,this.read=0}return this};util$7.DataBuffer.prototype.clear=function(){return this.data=new DataView(new ArrayBuffer(0)),this.read=this.write=0,this};util$7.DataBuffer.prototype.truncate=function(J){return this.write=Math.max(0,this.length()-J),this.read=Math.min(this.read,this.write),this};util$7.DataBuffer.prototype.toHex=function(){for(var J="",E=this.read;E<this.data.byteLength;++E){var ee=this.data.getUint8(E);ee<16&&(J+="0"),J+=ee.toString(16)}return J};util$7.DataBuffer.prototype.toString=function(J){var E=new Uint8Array(this.data,this.read,this.length());if(J=J||"utf8",J==="binary"||J==="raw")return util$7.binary.raw.encode(E);if(J==="hex")return util$7.binary.hex.encode(E);if(J==="base64")return util$7.binary.base64.encode(E);if(J==="utf8")return util$7.text.utf8.decode(E);if(J==="utf16")return util$7.text.utf16.decode(E);throw new Error("Invalid encoding: "+J)};util$7.createBuffer=function(J,E){return E=E||"raw",J!==void 0&&E==="utf8"&&(J=util$7.encodeUtf8(J)),new util$7.ByteBuffer(J)};util$7.fillString=function(J,E){for(var ee="";E>0;)E&1&&(ee+=J),E>>>=1,E>0&&(J+=J);return ee};util$7.xorBytes=function(J,E,ee){for(var te="",re="",ne="",ie=0,se=0;ee>0;--ee,++ie)re=J.charCodeAt(ie)^E.charCodeAt(ie),se>=10&&(te+=ne,ne="",se=0),ne+=String.fromCharCode(re),++se;return te+=ne,te};util$7.hexToBytes=function(J){var E="",ee=0;for(J.length&!0&&(ee=1,E+=String.fromCharCode(parseInt(J[0],16)));ee<J.length;ee+=2)E+=String.fromCharCode(parseInt(J.substr(ee,2),16));return E};util$7.bytesToHex=function(J){return util$7.createBuffer(J).toHex()};util$7.int32ToBytes=function(J){return String.fromCharCode(J>>24&255)+String.fromCharCode(J>>16&255)+String.fromCharCode(J>>8&255)+String.fromCharCode(J&255)};var _base64="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",_base64Idx=[62,-1,-1,-1,63,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,64,-1,-1,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,-1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51],_base58="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";util$7.encode64=function(J,E){for(var ee="",te="",re,ne,ie,se=0;se<J.length;)re=J.charCodeAt(se++),ne=J.charCodeAt(se++),ie=J.charCodeAt(se++),ee+=_base64.charAt(re>>2),ee+=_base64.charAt((re&3)<<4|ne>>4),isNaN(ne)?ee+="==":(ee+=_base64.charAt((ne&15)<<2|ie>>6),ee+=isNaN(ie)?"=":_base64.charAt(ie&63)),E&&ee.length>E&&(te+=ee.substr(0,E)+`\r
`,ee=ee.substr(E));return te+=ee,te};util$7.decode64=function(J){J=J.replace(/[^A-Za-z0-9\+\/\=]/g,"");for(var E="",ee,te,re,ne,ie=0;ie<J.length;)ee=_base64Idx[J.charCodeAt(ie++)-43],te=_base64Idx[J.charCodeAt(ie++)-43],re=_base64Idx[J.charCodeAt(ie++)-43],ne=_base64Idx[J.charCodeAt(ie++)-43],E+=String.fromCharCode(ee<<2|te>>4),re!==64&&(E+=String.fromCharCode((te&15)<<4|re>>2),ne!==64&&(E+=String.fromCharCode((re&3)<<6|ne)));return E};util$7.encodeUtf8=function(J){return unescape(encodeURIComponent(J))};util$7.decodeUtf8=function(J){return decodeURIComponent(escape(J))};util$7.binary={raw:{},hex:{},base64:{},base58:{},baseN:{encode:baseN.encode,decode:baseN.decode}};util$7.binary.raw.encode=function(J){return String.fromCharCode.apply(null,J)};util$7.binary.raw.decode=function(J,E,ee){var te=E;te||(te=new Uint8Array(J.length)),ee=ee||0;for(var re=ee,ne=0;ne<J.length;++ne)te[re++]=J.charCodeAt(ne);return E?re-ee:te};util$7.binary.hex.encode=util$7.bytesToHex;util$7.binary.hex.decode=function(J,E,ee){var te=E;te||(te=new Uint8Array(Math.ceil(J.length/2))),ee=ee||0;var re=0,ne=ee;for(J.length&1&&(re=1,te[ne++]=parseInt(J[0],16));re<J.length;re+=2)te[ne++]=parseInt(J.substr(re,2),16);return E?ne-ee:te};util$7.binary.base64.encode=function(J,E){for(var ee="",te="",re,ne,ie,se=0;se<J.byteLength;)re=J[se++],ne=J[se++],ie=J[se++],ee+=_base64.charAt(re>>2),ee+=_base64.charAt((re&3)<<4|ne>>4),isNaN(ne)?ee+="==":(ee+=_base64.charAt((ne&15)<<2|ie>>6),ee+=isNaN(ie)?"=":_base64.charAt(ie&63)),E&&ee.length>E&&(te+=ee.substr(0,E)+`\r
`,ee=ee.substr(E));return te+=ee,te};util$7.binary.base64.decode=function(J,E,ee){var te=E;te||(te=new Uint8Array(Math.ceil(J.length/4)*3)),J=J.replace(/[^A-Za-z0-9\+\/\=]/g,""),ee=ee||0;for(var re,ne,ie,se,oe=0,ce=ee;oe<J.length;)re=_base64Idx[J.charCodeAt(oe++)-43],ne=_base64Idx[J.charCodeAt(oe++)-43],ie=_base64Idx[J.charCodeAt(oe++)-43],se=_base64Idx[J.charCodeAt(oe++)-43],te[ce++]=re<<2|ne>>4,ie!==64&&(te[ce++]=(ne&15)<<4|ie>>2,se!==64&&(te[ce++]=(ie&3)<<6|se));return E?ce-ee:te.subarray(0,ce)};util$7.binary.base58.encode=function(J,E){return util$7.binary.baseN.encode(J,_base58,E)};util$7.binary.base58.decode=function(J,E){return util$7.binary.baseN.decode(J,_base58,E)};util$7.text={utf8:{},utf16:{}};util$7.text.utf8.encode=function(J,E,ee){J=util$7.encodeUtf8(J);var te=E;te||(te=new Uint8Array(J.length)),ee=ee||0;for(var re=ee,ne=0;ne<J.length;++ne)te[re++]=J.charCodeAt(ne);return E?re-ee:te};util$7.text.utf8.decode=function(J){return util$7.decodeUtf8(String.fromCharCode.apply(null,J))};util$7.text.utf16.encode=function(J,E,ee){var te=E;te||(te=new Uint8Array(J.length*2));var re=new Uint16Array(te.buffer);ee=ee||0;for(var ne=ee,ie=ee,se=0;se<J.length;++se)re[ie++]=J.charCodeAt(se),ne+=2;return E?ne-ee:te};util$7.text.utf16.decode=function(J){return String.fromCharCode.apply(null,new Uint16Array(J.buffer))};util$7.deflate=function(J,E,ee){if(E=util$7.decode64(J.deflate(util$7.encode64(E)).rval),ee){var te=2,re=E.charCodeAt(1);re&32&&(te=6),E=E.substring(te,E.length-4)}return E};util$7.inflate=function(J,E,ee){var te=J.inflate(util$7.encode64(E)).rval;return te===null?null:util$7.decode64(te)};var _setStorageObject=function(J,E,ee){if(!J)throw new Error("WebStorage not available.");var te;if(ee===null?te=J.removeItem(E):(ee=util$7.encode64(JSON.stringify(ee)),te=J.setItem(E,ee)),typeof te<"u"&&te.rval!==!0){var re=new Error(te.error.message);throw re.id=te.error.id,re.name=te.error.name,re}},_getStorageObject=function(J,E){if(!J)throw new Error("WebStorage not available.");var ee=J.getItem(E);if(J.init)if(ee.rval===null){if(ee.error){var te=new Error(ee.error.message);throw te.id=ee.error.id,te.name=ee.error.name,te}ee=null}else ee=ee.rval;return ee!==null&&(ee=JSON.parse(util$7.decode64(ee))),ee},_setItem=function(J,E,ee,te){var re=_getStorageObject(J,E);re===null&&(re={}),re[ee]=te,_setStorageObject(J,E,re)},_getItem=function(J,E,ee){var te=_getStorageObject(J,E);return te!==null&&(te=ee in te?te[ee]:null),te},_removeItem=function(J,E,ee){var te=_getStorageObject(J,E);if(te!==null&&ee in te){delete te[ee];var re=!0;for(var ne in te){re=!1;break}re&&(te=null),_setStorageObject(J,E,te)}},_clearItems=function(J,E){_setStorageObject(J,E,null)},_callStorageFunction=function(J,E,ee){var te=null;typeof ee>"u"&&(ee=["web","flash"]);var re,ne=!1,ie=null;for(var se in ee){re=ee[se];try{if(re==="flash"||re==="both"){if(E[0]===null)throw new Error("Flash local storage not available.");te=J.apply(this,E),ne=re==="flash"}(re==="web"||re==="both")&&(E[0]=localStorage,te=J.apply(this,E),ne=!0)}catch(oe){ie=oe}if(ne)break}if(!ne)throw ie;return te};util$7.setItem=function(J,E,ee,te,re){_callStorageFunction(_setItem,arguments,re)};util$7.getItem=function(J,E,ee,te){return _callStorageFunction(_getItem,arguments,te)};util$7.removeItem=function(J,E,ee,te){_callStorageFunction(_removeItem,arguments,te)};util$7.clearItems=function(J,E,ee){_callStorageFunction(_clearItems,arguments,ee)};util$7.isEmpty=function(J){for(var E in J)if(J.hasOwnProperty(E))return!1;return!0};util$7.format=function(J){for(var E=/%./g,ee,te,re=0,ne=[],ie=0;ee=E.exec(J);){te=J.substring(ie,E.lastIndex-2),te.length>0&&ne.push(te),ie=E.lastIndex;var se=ee[0][1];switch(se){case"s":case"o":re<arguments.length?ne.push(arguments[re+++1]):ne.push("<?>");break;case"%":ne.push("%");break;default:ne.push("<%"+se+"?>")}}return ne.push(J.substring(ie)),ne.join("")};util$7.formatNumber=function(J,E,ee,te){var re=J,ne=isNaN(E=Math.abs(E))?2:E,ie=ee===void 0?",":ee,se=te===void 0?".":te,oe=re<0?"-":"",ce=parseInt(re=Math.abs(+re||0).toFixed(ne),10)+"",ae=ce.length>3?ce.length%3:0;return oe+(ae?ce.substr(0,ae)+se:"")+ce.substr(ae).replace(/(\d{3})(?=\d)/g,"$1"+se)+(ne?ie+Math.abs(re-ce).toFixed(ne).slice(2):"")};util$7.formatSize=function(J){return J>=1073741824?J=util$7.formatNumber(J/1073741824,2,".","")+" GiB":J>=1048576?J=util$7.formatNumber(J/1048576,2,".","")+" MiB":J>=1024?J=util$7.formatNumber(J/1024,0)+" KiB":J=util$7.formatNumber(J,0)+" bytes",J};util$7.bytesFromIP=function(J){return J.indexOf(".")!==-1?util$7.bytesFromIPv4(J):J.indexOf(":")!==-1?util$7.bytesFromIPv6(J):null};util$7.bytesFromIPv4=function(J){if(J=J.split("."),J.length!==4)return null;for(var E=util$7.createBuffer(),ee=0;ee<J.length;++ee){var te=parseInt(J[ee],10);if(isNaN(te))return null;E.putByte(te)}return E.getBytes()};util$7.bytesFromIPv6=function(J){var E=0;J=J.split(":").filter(function(ie){return ie.length===0&&++E,!0});for(var ee=(8-J.length+E)*2,te=util$7.createBuffer(),re=0;re<8;++re){if(!J[re]||J[re].length===0){te.fillWithByte(0,ee),ee=0;continue}var ne=util$7.hexToBytes(J[re]);ne.length<2&&te.putByte(0),te.putBytes(ne)}return te.getBytes()};util$7.bytesToIP=function(J){return J.length===4?util$7.bytesToIPv4(J):J.length===16?util$7.bytesToIPv6(J):null};util$7.bytesToIPv4=function(J){if(J.length!==4)return null;for(var E=[],ee=0;ee<J.length;++ee)E.push(J.charCodeAt(ee));return E.join(".")};util$7.bytesToIPv6=function(J){if(J.length!==16)return null;for(var E=[],ee=[],te=0,re=0;re<J.length;re+=2){for(var ne=util$7.bytesToHex(J[re]+J[re+1]);ne[0]==="0"&&ne!=="0";)ne=ne.substr(1);if(ne==="0"){var ie=ee[ee.length-1],se=E.length;!ie||se!==ie.end+1?ee.push({start:se,end:se}):(ie.end=se,ie.end-ie.start>ee[te].end-ee[te].start&&(te=ee.length-1))}E.push(ne)}if(ee.length>0){var oe=ee[te];oe.end-oe.start>0&&(E.splice(oe.start,oe.end-oe.start+1,""),oe.start===0&&E.unshift(""),oe.end===7&&E.push(""))}return E.join(":")};util$7.estimateCores=function(J,E){if(typeof J=="function"&&(E=J,J={}),J=J||{},"cores"in util$7&&!J.update)return E(null,util$7.cores);if(typeof navigator<"u"&&"hardwareConcurrency"in navigator&&navigator.hardwareConcurrency>0)return util$7.cores=navigator.hardwareConcurrency,E(null,util$7.cores);if(typeof Worker>"u")return util$7.cores=1,E(null,util$7.cores);if(typeof Blob>"u")return util$7.cores=2,E(null,util$7.cores);var ee=URL.createObjectURL(new Blob(["(",function(){self.addEventListener("message",function(ie){var se=Date.now(),oe=se+4;self.postMessage({st:se,et:oe})})}.toString(),")()"],{type:"application/javascript"}));te([],5,16);function te(ie,se,oe){if(se===0){var ce=Math.floor(ie.reduce(function(ae,le){return ae+le},0)/ie.length);return util$7.cores=Math.max(1,ce),URL.revokeObjectURL(ee),E(null,util$7.cores)}re(oe,function(ae,le){ie.push(ne(oe,le)),te(ie,se-1,oe)})}function re(ie,se){for(var oe=[],ce=[],ae=0;ae<ie;++ae){var le=new Worker(ee);le.addEventListener("message",function(ue){if(ce.push(ue.data),ce.length===ie){for(var he=0;he<ie;++he)oe[he].terminate();se(null,ce)}}),oe.push(le)}for(var ae=0;ae<ie;++ae)oe[ae].postMessage(ae)}function ne(ie,se){for(var oe=[],ce=0;ce<ie;++ce)for(var ae=se[ce],le=oe[ce]=[],ue=0;ue<ie;++ue)if(ce!==ue){var he=se[ue];(ae.st>he.st&&ae.st<he.et||he.st>ae.st&&he.st<ae.et)&&le.push(ue)}return oe.reduce(function(pe,de){return Math.max(pe,de.length)},0)}};var utilExports=util$8.exports;const forgeUtil=getDefaultExportFromCjs(utilExports);var forge$k=forge$m;forge$k.pki=forge$k.pki||{};var oids$1=forge$k.pki.oids=forge$k.oids=forge$k.oids||{};function _IN(J,E){oids$1[J]=E,oids$1[E]=J}function _I_(J,E){oids$1[J]=E}_IN("1.2.840.113549.1.1.1","rsaEncryption");_IN("1.2.840.113549.1.1.4","md5WithRSAEncryption");_IN("1.2.840.113549.1.1.5","sha1WithRSAEncryption");_IN("1.2.840.113549.1.1.7","RSAES-OAEP");_IN("1.2.840.113549.1.1.8","mgf1");_IN("1.2.840.113549.1.1.9","pSpecified");_IN("1.2.840.113549.1.1.10","RSASSA-PSS");_IN("1.2.840.113549.1.1.11","sha256WithRSAEncryption");_IN("1.2.840.113549.1.1.12","sha384WithRSAEncryption");_IN("1.2.840.113549.1.1.13","sha512WithRSAEncryption");_IN("1.3.101.112","EdDSA25519");_IN("1.2.840.10040.4.3","dsa-with-sha1");_IN("1.3.14.3.2.7","desCBC");_IN("1.3.14.3.2.26","sha1");_IN("1.3.14.3.2.29","sha1WithRSASignature");_IN("2.16.840.1.101.3.4.2.1","sha256");_IN("2.16.840.1.101.3.4.2.2","sha384");_IN("2.16.840.1.101.3.4.2.3","sha512");_IN("2.16.840.1.101.3.4.2.4","sha224");_IN("2.16.840.1.101.3.4.2.5","sha512-224");_IN("2.16.840.1.101.3.4.2.6","sha512-256");_IN("1.2.840.113549.2.2","md2");_IN("1.2.840.113549.2.5","md5");_IN("1.2.840.113549.1.7.1","data");_IN("1.2.840.113549.1.7.2","signedData");_IN("1.2.840.113549.1.7.3","envelopedData");_IN("1.2.840.113549.1.7.4","signedAndEnvelopedData");_IN("1.2.840.113549.1.7.5","digestedData");_IN("1.2.840.113549.1.7.6","encryptedData");_IN("1.2.840.113549.1.9.1","emailAddress");_IN("1.2.840.113549.1.9.2","unstructuredName");_IN("1.2.840.113549.1.9.3","contentType");_IN("1.2.840.113549.1.9.4","messageDigest");_IN("1.2.840.113549.1.9.5","signingTime");_IN("1.2.840.113549.1.9.6","counterSignature");_IN("1.2.840.113549.1.9.7","challengePassword");_IN("1.2.840.113549.1.9.8","unstructuredAddress");_IN("1.2.840.113549.1.9.14","extensionRequest");_IN("1.2.840.113549.1.9.20","friendlyName");_IN("1.2.840.113549.1.9.21","localKeyId");_IN("1.2.840.113549.1.9.22.1","x509Certificate");_IN("1.2.840.113549.1.12.10.1.1","keyBag");_IN("1.2.840.113549.1.12.10.1.2","pkcs8ShroudedKeyBag");_IN("1.2.840.113549.1.12.10.1.3","certBag");_IN("1.2.840.113549.1.12.10.1.4","crlBag");_IN("1.2.840.113549.1.12.10.1.5","secretBag");_IN("1.2.840.113549.1.12.10.1.6","safeContentsBag");_IN("1.2.840.113549.1.5.13","pkcs5PBES2");_IN("1.2.840.113549.1.5.12","pkcs5PBKDF2");_IN("1.2.840.113549.1.12.1.1","pbeWithSHAAnd128BitRC4");_IN("1.2.840.113549.1.12.1.2","pbeWithSHAAnd40BitRC4");_IN("1.2.840.113549.1.12.1.3","pbeWithSHAAnd3-KeyTripleDES-CBC");_IN("1.2.840.113549.1.12.1.4","pbeWithSHAAnd2-KeyTripleDES-CBC");_IN("1.2.840.113549.1.12.1.5","pbeWithSHAAnd128BitRC2-CBC");_IN("1.2.840.113549.1.12.1.6","pbewithSHAAnd40BitRC2-CBC");_IN("1.2.840.113549.2.7","hmacWithSHA1");_IN("1.2.840.113549.2.8","hmacWithSHA224");_IN("1.2.840.113549.2.9","hmacWithSHA256");_IN("1.2.840.113549.2.10","hmacWithSHA384");_IN("1.2.840.113549.2.11","hmacWithSHA512");_IN("1.2.840.113549.3.7","des-EDE3-CBC");_IN("2.16.840.1.101.3.4.1.2","aes128-CBC");_IN("2.16.840.1.101.3.4.1.22","aes192-CBC");_IN("2.16.840.1.101.3.4.1.42","aes256-CBC");_IN("2.5.4.3","commonName");_IN("2.5.4.4","surname");_IN("2.5.4.5","serialNumber");_IN("2.5.4.6","countryName");_IN("2.5.4.7","localityName");_IN("2.5.4.8","stateOrProvinceName");_IN("2.5.4.9","streetAddress");_IN("2.5.4.10","organizationName");_IN("2.5.4.11","organizationalUnitName");_IN("2.5.4.12","title");_IN("2.5.4.13","description");_IN("2.5.4.15","businessCategory");_IN("2.5.4.17","postalCode");_IN("2.5.4.42","givenName");_IN("1.3.6.1.4.1.311.60.2.1.2","jurisdictionOfIncorporationStateOrProvinceName");_IN("1.3.6.1.4.1.311.60.2.1.3","jurisdictionOfIncorporationCountryName");_IN("2.16.840.1.113730.1.1","nsCertType");_IN("2.16.840.1.113730.1.13","nsComment");_I_("2.5.29.1","authorityKeyIdentifier");_I_("2.5.29.2","keyAttributes");_I_("2.5.29.3","certificatePolicies");_I_("2.5.29.4","keyUsageRestriction");_I_("2.5.29.5","policyMapping");_I_("2.5.29.6","subtreesConstraint");_I_("2.5.29.7","subjectAltName");_I_("2.5.29.8","issuerAltName");_I_("2.5.29.9","subjectDirectoryAttributes");_I_("2.5.29.10","basicConstraints");_I_("2.5.29.11","nameConstraints");_I_("2.5.29.12","policyConstraints");_I_("2.5.29.13","basicConstraints");_IN("2.5.29.14","subjectKeyIdentifier");_IN("2.5.29.15","keyUsage");_I_("2.5.29.16","privateKeyUsagePeriod");_IN("2.5.29.17","subjectAltName");_IN("2.5.29.18","issuerAltName");_IN("2.5.29.19","basicConstraints");_I_("2.5.29.20","cRLNumber");_I_("2.5.29.21","cRLReason");_I_("2.5.29.22","expirationDate");_I_("2.5.29.23","instructionCode");_I_("2.5.29.24","invalidityDate");_I_("2.5.29.25","cRLDistributionPoints");_I_("2.5.29.26","issuingDistributionPoint");_I_("2.5.29.27","deltaCRLIndicator");_I_("2.5.29.28","issuingDistributionPoint");_I_("2.5.29.29","certificateIssuer");_I_("2.5.29.30","nameConstraints");_IN("2.5.29.31","cRLDistributionPoints");_IN("2.5.29.32","certificatePolicies");_I_("2.5.29.33","policyMappings");_I_("2.5.29.34","policyConstraints");_IN("2.5.29.35","authorityKeyIdentifier");_I_("2.5.29.36","policyConstraints");_IN("2.5.29.37","extKeyUsage");_I_("2.5.29.46","freshestCRL");_I_("2.5.29.54","inhibitAnyPolicy");_IN("1.3.6.1.4.1.11129.2.4.2","timestampList");_IN("1.3.6.1.5.5.7.1.1","authorityInfoAccess");_IN("1.3.6.1.5.5.7.3.1","serverAuth");_IN("1.3.6.1.5.5.7.3.2","clientAuth");_IN("1.3.6.1.5.5.7.3.3","codeSigning");_IN("1.3.6.1.5.5.7.3.4","emailProtection");_IN("1.3.6.1.5.5.7.3.8","timeStamping");var forge$j=forge$m,asn1$2=forge$j.asn1=forge$j.asn1||{};asn1$2.Class={UNIVERSAL:0,APPLICATION:64,CONTEXT_SPECIFIC:128,PRIVATE:192};asn1$2.Type={NONE:0,BOOLEAN:1,INTEGER:2,BITSTRING:3,OCTETSTRING:4,NULL:5,OID:6,ODESC:7,EXTERNAL:8,REAL:9,ENUMERATED:10,EMBEDDED:11,UTF8:12,ROID:13,SEQUENCE:16,SET:17,PRINTABLESTRING:19,IA5STRING:22,UTCTIME:23,GENERALIZEDTIME:24,BMPSTRING:30};asn1$2.create=function(J,E,ee,te,re){if(forge$j.util.isArray(te)){for(var ne=[],ie=0;ie<te.length;++ie)te[ie]!==void 0&&ne.push(te[ie]);te=ne}var se={tagClass:J,type:E,constructed:ee,composed:ee||forge$j.util.isArray(te),value:te};return re&&"bitStringContents"in re&&(se.bitStringContents=re.bitStringContents,se.original=asn1$2.copy(se)),se};asn1$2.copy=function(J,E){var ee;if(forge$j.util.isArray(J)){ee=[];for(var te=0;te<J.length;++te)ee.push(asn1$2.copy(J[te],E));return ee}return typeof J=="string"?J:(ee={tagClass:J.tagClass,type:J.type,constructed:J.constructed,composed:J.composed,value:asn1$2.copy(J.value,E)},E&&!E.excludeBitStringContents&&(ee.bitStringContents=J.bitStringContents),ee)};asn1$2.equals=function(J,E,ee){if(forge$j.util.isArray(J)){if(!forge$j.util.isArray(E)||J.length!==E.length)return!1;for(var te=0;te<J.length;++te)if(!asn1$2.equals(J[te],E[te]))return!1;return!0}if(typeof J!=typeof E)return!1;if(typeof J=="string")return J===E;var re=J.tagClass===E.tagClass&&J.type===E.type&&J.constructed===E.constructed&&J.composed===E.composed&&asn1$2.equals(J.value,E.value);return ee&&ee.includeBitStringContents&&(re=re&&J.bitStringContents===E.bitStringContents),re};asn1$2.getBerValueLength=function(J){var E=J.getByte();if(E!==128){var ee,te=E&128;return te?ee=J.getInt((E&127)<<3):ee=E,ee}};function _checkBufferLength(J,E,ee){if(ee>E){var te=new Error("Too few bytes to parse DER.");throw te.available=J.length(),te.remaining=E,te.requested=ee,te}}var _getValueLength=function(J,E){var ee=J.getByte();if(E--,ee!==128){var te,re=ee&128;if(!re)te=ee;else{var ne=ee&127;_checkBufferLength(J,E,ne),te=J.getInt(ne<<3)}if(te<0)throw new Error("Negative length: "+te);return te}};asn1$2.fromDer=function(J,E){E===void 0&&(E={strict:!0,parseAllBytes:!0,decodeBitStrings:!0}),typeof E=="boolean"&&(E={strict:E,parseAllBytes:!0,decodeBitStrings:!0}),"strict"in E||(E.strict=!0),"parseAllBytes"in E||(E.parseAllBytes=!0),"decodeBitStrings"in E||(E.decodeBitStrings=!0),typeof J=="string"&&(J=forge$j.util.createBuffer(J));var ee=J.length(),te=_fromDer(J,J.length(),0,E);if(E.parseAllBytes&&J.length()!==0){var re=new Error("Unparsed DER bytes remain after ASN.1 parsing.");throw re.byteCount=ee,re.remaining=J.length(),re}return te};function _fromDer(J,E,ee,te){var re;_checkBufferLength(J,E,2);var ne=J.getByte();E--;var ie=ne&192,se=ne&31;re=J.length();var oe=_getValueLength(J,E);if(E-=re-J.length(),oe!==void 0&&oe>E){if(te.strict){var ce=new Error("Too few bytes to read ASN.1 value.");throw ce.available=J.length(),ce.remaining=E,ce.requested=oe,ce}oe=E}var ae,le,ue=(ne&32)===32;if(ue)if(ae=[],oe===void 0)for(;;){if(_checkBufferLength(J,E,2),J.bytes(2)===String.fromCharCode(0,0)){J.getBytes(2),E-=2;break}re=J.length(),ae.push(_fromDer(J,E,ee+1,te)),E-=re-J.length()}else for(;oe>0;)re=J.length(),ae.push(_fromDer(J,oe,ee+1,te)),E-=re-J.length(),oe-=re-J.length();if(ae===void 0&&ie===asn1$2.Class.UNIVERSAL&&se===asn1$2.Type.BITSTRING&&(le=J.bytes(oe)),ae===void 0&&te.decodeBitStrings&&ie===asn1$2.Class.UNIVERSAL&&se===asn1$2.Type.BITSTRING&&oe>1){var he=J.read,pe=E,de=0;if(se===asn1$2.Type.BITSTRING&&(_checkBufferLength(J,E,1),de=J.getByte(),E--),de===0)try{re=J.length();var fe={strict:!0,decodeBitStrings:!0},me=_fromDer(J,E,ee+1,fe),_e=re-J.length();E-=_e,se==asn1$2.Type.BITSTRING&&_e++;var be=me.tagClass;_e===oe&&(be===asn1$2.Class.UNIVERSAL||be===asn1$2.Class.CONTEXT_SPECIFIC)&&(ae=[me])}catch{}ae===void 0&&(J.read=he,E=pe)}if(ae===void 0){if(oe===void 0){if(te.strict)throw new Error("Non-constructed ASN.1 object of indefinite length.");oe=E}if(se===asn1$2.Type.BMPSTRING)for(ae="";oe>0;oe-=2)_checkBufferLength(J,E,2),ae+=String.fromCharCode(J.getInt16()),E-=2;else ae=J.getBytes(oe),E-=oe}var Ee=le===void 0?null:{bitStringContents:le};return asn1$2.create(ie,se,ue,ae,Ee)}asn1$2.toDer=function(J){var E=forge$j.util.createBuffer(),ee=J.tagClass|J.type,te=forge$j.util.createBuffer(),re=!1;if("bitStringContents"in J&&(re=!0,J.original&&(re=asn1$2.equals(J,J.original))),re)te.putBytes(J.bitStringContents);else if(J.composed){J.constructed?ee|=32:te.putByte(0);for(var ne=0;ne<J.value.length;++ne)J.value[ne]!==void 0&&te.putBuffer(asn1$2.toDer(J.value[ne]))}else if(J.type===asn1$2.Type.BMPSTRING)for(var ne=0;ne<J.value.length;++ne)te.putInt16(J.value.charCodeAt(ne));else J.type===asn1$2.Type.INTEGER&&J.value.length>1&&(J.value.charCodeAt(0)===0&&!(J.value.charCodeAt(1)&128)||J.value.charCodeAt(0)===255&&(J.value.charCodeAt(1)&128)===128)?te.putBytes(J.value.substr(1)):te.putBytes(J.value);if(E.putByte(ee),te.length()<=127)E.putByte(te.length()&127);else{var ie=te.length(),se="";do se+=String.fromCharCode(ie&255),ie=ie>>>8;while(ie>0);E.putByte(se.length|128);for(var ne=se.length-1;ne>=0;--ne)E.putByte(se.charCodeAt(ne))}return E.putBuffer(te),E};asn1$2.oidToDer=function(J){var E=J.split("."),ee=forge$j.util.createBuffer();ee.putByte(40*parseInt(E[0],10)+parseInt(E[1],10));for(var te,re,ne,ie,se=2;se<E.length;++se){te=!0,re=[],ne=parseInt(E[se],10);do ie=ne&127,ne=ne>>>7,te||(ie|=128),re.push(ie),te=!1;while(ne>0);for(var oe=re.length-1;oe>=0;--oe)ee.putByte(re[oe])}return ee};asn1$2.derToOid=function(J){var E;typeof J=="string"&&(J=forge$j.util.createBuffer(J));var ee=J.getByte();E=Math.floor(ee/40)+"."+ee%40;for(var te=0;J.length()>0;)ee=J.getByte(),te=te<<7,ee&128?te+=ee&127:(E+="."+(te+ee),te=0);return E};asn1$2.utcTimeToDate=function(J){var E=new Date,ee=parseInt(J.substr(0,2),10);ee=ee>=50?1900+ee:2e3+ee;var te=parseInt(J.substr(2,2),10)-1,re=parseInt(J.substr(4,2),10),ne=parseInt(J.substr(6,2),10),ie=parseInt(J.substr(8,2),10),se=0;if(J.length>11){var oe=J.charAt(10),ce=10;oe!=="+"&&oe!=="-"&&(se=parseInt(J.substr(10,2),10),ce+=2)}if(E.setUTCFullYear(ee,te,re),E.setUTCHours(ne,ie,se,0),ce&&(oe=J.charAt(ce),oe==="+"||oe==="-")){var ae=parseInt(J.substr(ce+1,2),10),le=parseInt(J.substr(ce+4,2),10),ue=ae*60+le;ue*=6e4,oe==="+"?E.setTime(+E-ue):E.setTime(+E+ue)}return E};asn1$2.generalizedTimeToDate=function(J){var E=new Date,ee=parseInt(J.substr(0,4),10),te=parseInt(J.substr(4,2),10)-1,re=parseInt(J.substr(6,2),10),ne=parseInt(J.substr(8,2),10),ie=parseInt(J.substr(10,2),10),se=parseInt(J.substr(12,2),10),oe=0,ce=0,ae=!1;J.charAt(J.length-1)==="Z"&&(ae=!0);var le=J.length-5,ue=J.charAt(le);if(ue==="+"||ue==="-"){var he=parseInt(J.substr(le+1,2),10),pe=parseInt(J.substr(le+4,2),10);ce=he*60+pe,ce*=6e4,ue==="+"&&(ce*=-1),ae=!0}return J.charAt(14)==="."&&(oe=parseFloat(J.substr(14),10)*1e3),ae?(E.setUTCFullYear(ee,te,re),E.setUTCHours(ne,ie,se,oe),E.setTime(+E+ce)):(E.setFullYear(ee,te,re),E.setHours(ne,ie,se,oe)),E};asn1$2.dateToUtcTime=function(J){if(typeof J=="string")return J;var E="",ee=[];ee.push((""+J.getUTCFullYear()).substr(2)),ee.push(""+(J.getUTCMonth()+1)),ee.push(""+J.getUTCDate()),ee.push(""+J.getUTCHours()),ee.push(""+J.getUTCMinutes()),ee.push(""+J.getUTCSeconds());for(var te=0;te<ee.length;++te)ee[te].length<2&&(E+="0"),E+=ee[te];return E+="Z",E};asn1$2.dateToGeneralizedTime=function(J){if(typeof J=="string")return J;var E="",ee=[];ee.push(""+J.getUTCFullYear()),ee.push(""+(J.getUTCMonth()+1)),ee.push(""+J.getUTCDate()),ee.push(""+J.getUTCHours()),ee.push(""+J.getUTCMinutes()),ee.push(""+J.getUTCSeconds());for(var te=0;te<ee.length;++te)ee[te].length<2&&(E+="0"),E+=ee[te];return E+="Z",E};asn1$2.integerToDer=function(J){var E=forge$j.util.createBuffer();if(J>=-128&&J<128)return E.putSignedInt(J,8);if(J>=-32768&&J<32768)return E.putSignedInt(J,16);if(J>=-8388608&&J<8388608)return E.putSignedInt(J,24);if(J>=-2147483648&&J<2147483648)return E.putSignedInt(J,32);var ee=new Error("Integer too large; max is 32-bits.");throw ee.integer=J,ee};asn1$2.derToInteger=function(J){typeof J=="string"&&(J=forge$j.util.createBuffer(J));var E=J.length()*8;if(E>32)throw new Error("Integer too large; max is 32-bits.");return J.getSignedInt(E)};asn1$2.validate=function(J,E,ee,te){var re=!1;if((J.tagClass===E.tagClass||typeof E.tagClass>"u")&&(J.type===E.type||typeof E.type>"u"))if(J.constructed===E.constructed||typeof E.constructed>"u"){if(re=!0,E.value&&forge$j.util.isArray(E.value))for(var ne=0,ie=0;re&&ie<E.value.length;++ie)re=E.value[ie].optional||!1,J.value[ne]&&(re=asn1$2.validate(J.value[ne],E.value[ie],ee,te),re?++ne:E.value[ie].optional&&(re=!0)),!re&&te&&te.push("["+E.name+'] Tag class "'+E.tagClass+'", type "'+E.type+'" expected value length "'+E.value.length+'", got "'+J.value.length+'"');if(re&&ee&&(E.capture&&(ee[E.capture]=J.value),E.captureAsn1&&(ee[E.captureAsn1]=J),E.captureBitStringContents&&"bitStringContents"in J&&(ee[E.captureBitStringContents]=J.bitStringContents),E.captureBitStringValue&&"bitStringContents"in J))if(J.bitStringContents.length<2)ee[E.captureBitStringValue]="";else{var se=J.bitStringContents.charCodeAt(0);if(se!==0)throw new Error("captureBitStringValue only supported for zero unused bits");ee[E.captureBitStringValue]=J.bitStringContents.slice(1)}}else te&&te.push("["+E.name+'] Expected constructed "'+E.constructed+'", got "'+J.constructed+'"');else te&&(J.tagClass!==E.tagClass&&te.push("["+E.name+'] Expected tag class "'+E.tagClass+'", got "'+J.tagClass+'"'),J.type!==E.type&&te.push("["+E.name+'] Expected type "'+E.type+'", got "'+J.type+'"'));return re};var _nonLatinRegex=/[^\\u0000-\\u00ff]/;asn1$2.prettyPrint=function(J,E,ee){var te="";E=E||0,ee=ee||2,E>0&&(te+=`
`);for(var re="",ne=0;ne<E*ee;++ne)re+=" ";switch(te+=re+"Tag: ",J.tagClass){case asn1$2.Class.UNIVERSAL:te+="Universal:";break;case asn1$2.Class.APPLICATION:te+="Application:";break;case asn1$2.Class.CONTEXT_SPECIFIC:te+="Context-Specific:";break;case asn1$2.Class.PRIVATE:te+="Private:";break}if(J.tagClass===asn1$2.Class.UNIVERSAL)switch(te+=J.type,J.type){case asn1$2.Type.NONE:te+=" (None)";break;case asn1$2.Type.BOOLEAN:te+=" (Boolean)";break;case asn1$2.Type.INTEGER:te+=" (Integer)";break;case asn1$2.Type.BITSTRING:te+=" (Bit string)";break;case asn1$2.Type.OCTETSTRING:te+=" (Octet string)";break;case asn1$2.Type.NULL:te+=" (Null)";break;case asn1$2.Type.OID:te+=" (Object Identifier)";break;case asn1$2.Type.ODESC:te+=" (Object Descriptor)";break;case asn1$2.Type.EXTERNAL:te+=" (External or Instance of)";break;case asn1$2.Type.REAL:te+=" (Real)";break;case asn1$2.Type.ENUMERATED:te+=" (Enumerated)";break;case asn1$2.Type.EMBEDDED:te+=" (Embedded PDV)";break;case asn1$2.Type.UTF8:te+=" (UTF8)";break;case asn1$2.Type.ROID:te+=" (Relative Object Identifier)";break;case asn1$2.Type.SEQUENCE:te+=" (Sequence)";break;case asn1$2.Type.SET:te+=" (Set)";break;case asn1$2.Type.PRINTABLESTRING:te+=" (Printable String)";break;case asn1$2.Type.IA5String:te+=" (IA5String (ASCII))";break;case asn1$2.Type.UTCTIME:te+=" (UTC time)";break;case asn1$2.Type.GENERALIZEDTIME:te+=" (Generalized time)";break;case asn1$2.Type.BMPSTRING:te+=" (BMP String)";break}else te+=J.type;if(te+=`
`,te+=re+"Constructed: "+J.constructed+`
`,J.composed){for(var ie=0,se="",ne=0;ne<J.value.length;++ne)J.value[ne]!==void 0&&(ie+=1,se+=asn1$2.prettyPrint(J.value[ne],E+1,ee),ne+1<J.value.length&&(se+=","));te+=re+"Sub values: "+ie+se}else{if(te+=re+"Value: ",J.type===asn1$2.Type.OID){var oe=asn1$2.derToOid(J.value);te+=oe,forge$j.pki&&forge$j.pki.oids&&oe in forge$j.pki.oids&&(te+=" ("+forge$j.pki.oids[oe]+") ")}if(J.type===asn1$2.Type.INTEGER)try{te+=asn1$2.derToInteger(J.value)}catch{te+="0x"+forge$j.util.bytesToHex(J.value)}else if(J.type===asn1$2.Type.BITSTRING){if(J.value.length>1?te+="0x"+forge$j.util.bytesToHex(J.value.slice(1)):te+="(none)",J.value.length>0){var ce=J.value.charCodeAt(0);ce==1?te+=" (1 unused bit shown)":ce>1&&(te+=" ("+ce+" unused bits shown)")}}else if(J.type===asn1$2.Type.OCTETSTRING)_nonLatinRegex.test(J.value)||(te+="("+J.value+") "),te+="0x"+forge$j.util.bytesToHex(J.value);else if(J.type===asn1$2.Type.UTF8)try{te+=forge$j.util.decodeUtf8(J.value)}catch(ae){if(ae.message==="URI malformed")te+="0x"+forge$j.util.bytesToHex(J.value)+" (malformed UTF8)";else throw ae}else J.type===asn1$2.Type.PRINTABLESTRING||J.type===asn1$2.Type.IA5String?te+=J.value:_nonLatinRegex.test(J.value)?te+="0x"+forge$j.util.bytesToHex(J.value):J.value.length===0?te+="[null]":te+=J.value}return te};var forge$i=forge$m;forge$i.cipher=forge$i.cipher||{};forge$i.cipher.algorithms=forge$i.cipher.algorithms||{};forge$i.cipher.createCipher=function(J,E){var ee=J;if(typeof ee=="string"&&(ee=forge$i.cipher.getAlgorithm(ee),ee&&(ee=ee())),!ee)throw new Error("Unsupported algorithm: "+J);return new forge$i.cipher.BlockCipher({algorithm:ee,key:E,decrypt:!1})};forge$i.cipher.createDecipher=function(J,E){var ee=J;if(typeof ee=="string"&&(ee=forge$i.cipher.getAlgorithm(ee),ee&&(ee=ee())),!ee)throw new Error("Unsupported algorithm: "+J);return new forge$i.cipher.BlockCipher({algorithm:ee,key:E,decrypt:!0})};forge$i.cipher.registerAlgorithm=function(J,E){J=J.toUpperCase(),forge$i.cipher.algorithms[J]=E};forge$i.cipher.getAlgorithm=function(J){return J=J.toUpperCase(),J in forge$i.cipher.algorithms?forge$i.cipher.algorithms[J]:null};var BlockCipher=forge$i.cipher.BlockCipher=function(J){this.algorithm=J.algorithm,this.mode=this.algorithm.mode,this.blockSize=this.mode.blockSize,this._finish=!1,this._input=null,this.output=null,this._op=J.decrypt?this.mode.decrypt:this.mode.encrypt,this._decrypt=J.decrypt,this.algorithm.initialize(J)};BlockCipher.prototype.start=function(J){J=J||{};var E={};for(var ee in J)E[ee]=J[ee];E.decrypt=this._decrypt,this._finish=!1,this._input=forge$i.util.createBuffer(),this.output=J.output||forge$i.util.createBuffer(),this.mode.start(E)};BlockCipher.prototype.update=function(J){for(J&&this._input.putBuffer(J);!this._op.call(this.mode,this._input,this.output,this._finish)&&!this._finish;);this._input.compact()};BlockCipher.prototype.finish=function(J){J&&(this.mode.name==="ECB"||this.mode.name==="CBC")&&(this.mode.pad=function(ee){return J(this.blockSize,ee,!1)},this.mode.unpad=function(ee){return J(this.blockSize,ee,!0)});var E={};return E.decrypt=this._decrypt,E.overflow=this._input.length()%this.blockSize,!(!this._decrypt&&this.mode.pad&&!this.mode.pad(this._input,E)||(this._finish=!0,this.update(),this._decrypt&&this.mode.unpad&&!this.mode.unpad(this.output,E))||this.mode.afterFinish&&!this.mode.afterFinish(this.output,E))};var forge$h=forge$m;forge$h.cipher=forge$h.cipher||{};var modes=forge$h.cipher.modes=forge$h.cipher.modes||{};modes.ecb=function(J){J=J||{},this.name="ECB",this.cipher=J.cipher,this.blockSize=J.blockSize||16,this._ints=this.blockSize/4,this._inBlock=new Array(this._ints),this._outBlock=new Array(this._ints)};modes.ecb.prototype.start=function(J){};modes.ecb.prototype.encrypt=function(J,E,ee){if(J.length()<this.blockSize&&!(ee&&J.length()>0))return!0;for(var te=0;te<this._ints;++te)this._inBlock[te]=J.getInt32();this.cipher.encrypt(this._inBlock,this._outBlock);for(var te=0;te<this._ints;++te)E.putInt32(this._outBlock[te])};modes.ecb.prototype.decrypt=function(J,E,ee){if(J.length()<this.blockSize&&!(ee&&J.length()>0))return!0;for(var te=0;te<this._ints;++te)this._inBlock[te]=J.getInt32();this.cipher.decrypt(this._inBlock,this._outBlock);for(var te=0;te<this._ints;++te)E.putInt32(this._outBlock[te])};modes.ecb.prototype.pad=function(J,E){var ee=J.length()===this.blockSize?this.blockSize:this.blockSize-J.length();return J.fillWithByte(ee,ee),!0};modes.ecb.prototype.unpad=function(J,E){if(E.overflow>0)return!1;var ee=J.length(),te=J.at(ee-1);return te>this.blockSize<<2?!1:(J.truncate(te),!0)};modes.cbc=function(J){J=J||{},this.name="CBC",this.cipher=J.cipher,this.blockSize=J.blockSize||16,this._ints=this.blockSize/4,this._inBlock=new Array(this._ints),this._outBlock=new Array(this._ints)};modes.cbc.prototype.start=function(J){if(J.iv===null){if(!this._prev)throw new Error("Invalid IV parameter.");this._iv=this._prev.slice(0)}else if("iv"in J)this._iv=transformIV(J.iv,this.blockSize),this._prev=this._iv.slice(0);else throw new Error("Invalid IV parameter.")};modes.cbc.prototype.encrypt=function(J,E,ee){if(J.length()<this.blockSize&&!(ee&&J.length()>0))return!0;for(var te=0;te<this._ints;++te)this._inBlock[te]=this._prev[te]^J.getInt32();this.cipher.encrypt(this._inBlock,this._outBlock);for(var te=0;te<this._ints;++te)E.putInt32(this._outBlock[te]);this._prev=this._outBlock};modes.cbc.prototype.decrypt=function(J,E,ee){if(J.length()<this.blockSize&&!(ee&&J.length()>0))return!0;for(var te=0;te<this._ints;++te)this._inBlock[te]=J.getInt32();this.cipher.decrypt(this._inBlock,this._outBlock);for(var te=0;te<this._ints;++te)E.putInt32(this._prev[te]^this._outBlock[te]);this._prev=this._inBlock.slice(0)};modes.cbc.prototype.pad=function(J,E){var ee=J.length()===this.blockSize?this.blockSize:this.blockSize-J.length();return J.fillWithByte(ee,ee),!0};modes.cbc.prototype.unpad=function(J,E){if(E.overflow>0)return!1;var ee=J.length(),te=J.at(ee-1);return te>this.blockSize<<2?!1:(J.truncate(te),!0)};modes.cfb=function(J){J=J||{},this.name="CFB",this.cipher=J.cipher,this.blockSize=J.blockSize||16,this._ints=this.blockSize/4,this._inBlock=null,this._outBlock=new Array(this._ints),this._partialBlock=new Array(this._ints),this._partialOutput=forge$h.util.createBuffer(),this._partialBytes=0};modes.cfb.prototype.start=function(J){if(!("iv"in J))throw new Error("Invalid IV parameter.");this._iv=transformIV(J.iv,this.blockSize),this._inBlock=this._iv.slice(0),this._partialBytes=0};modes.cfb.prototype.encrypt=function(J,E,ee){var te=J.length();if(te===0)return!0;if(this.cipher.encrypt(this._inBlock,this._outBlock),this._partialBytes===0&&te>=this.blockSize){for(var re=0;re<this._ints;++re)this._inBlock[re]=J.getInt32()^this._outBlock[re],E.putInt32(this._inBlock[re]);return}var ne=(this.blockSize-te)%this.blockSize;ne>0&&(ne=this.blockSize-ne),this._partialOutput.clear();for(var re=0;re<this._ints;++re)this._partialBlock[re]=J.getInt32()^this._outBlock[re],this._partialOutput.putInt32(this._partialBlock[re]);if(ne>0)J.read-=this.blockSize;else for(var re=0;re<this._ints;++re)this._inBlock[re]=this._partialBlock[re];if(this._partialBytes>0&&this._partialOutput.getBytes(this._partialBytes),ne>0&&!ee)return E.putBytes(this._partialOutput.getBytes(ne-this._partialBytes)),this._partialBytes=ne,!0;E.putBytes(this._partialOutput.getBytes(te-this._partialBytes)),this._partialBytes=0};modes.cfb.prototype.decrypt=function(J,E,ee){var te=J.length();if(te===0)return!0;if(this.cipher.encrypt(this._inBlock,this._outBlock),this._partialBytes===0&&te>=this.blockSize){for(var re=0;re<this._ints;++re)this._inBlock[re]=J.getInt32(),E.putInt32(this._inBlock[re]^this._outBlock[re]);return}var ne=(this.blockSize-te)%this.blockSize;ne>0&&(ne=this.blockSize-ne),this._partialOutput.clear();for(var re=0;re<this._ints;++re)this._partialBlock[re]=J.getInt32(),this._partialOutput.putInt32(this._partialBlock[re]^this._outBlock[re]);if(ne>0)J.read-=this.blockSize;else for(var re=0;re<this._ints;++re)this._inBlock[re]=this._partialBlock[re];if(this._partialBytes>0&&this._partialOutput.getBytes(this._partialBytes),ne>0&&!ee)return E.putBytes(this._partialOutput.getBytes(ne-this._partialBytes)),this._partialBytes=ne,!0;E.putBytes(this._partialOutput.getBytes(te-this._partialBytes)),this._partialBytes=0};modes.ofb=function(J){J=J||{},this.name="OFB",this.cipher=J.cipher,this.blockSize=J.blockSize||16,this._ints=this.blockSize/4,this._inBlock=null,this._outBlock=new Array(this._ints),this._partialOutput=forge$h.util.createBuffer(),this._partialBytes=0};modes.ofb.prototype.start=function(J){if(!("iv"in J))throw new Error("Invalid IV parameter.");this._iv=transformIV(J.iv,this.blockSize),this._inBlock=this._iv.slice(0),this._partialBytes=0};modes.ofb.prototype.encrypt=function(J,E,ee){var te=J.length();if(J.length()===0)return!0;if(this.cipher.encrypt(this._inBlock,this._outBlock),this._partialBytes===0&&te>=this.blockSize){for(var re=0;re<this._ints;++re)E.putInt32(J.getInt32()^this._outBlock[re]),this._inBlock[re]=this._outBlock[re];return}var ne=(this.blockSize-te)%this.blockSize;ne>0&&(ne=this.blockSize-ne),this._partialOutput.clear();for(var re=0;re<this._ints;++re)this._partialOutput.putInt32(J.getInt32()^this._outBlock[re]);if(ne>0)J.read-=this.blockSize;else for(var re=0;re<this._ints;++re)this._inBlock[re]=this._outBlock[re];if(this._partialBytes>0&&this._partialOutput.getBytes(this._partialBytes),ne>0&&!ee)return E.putBytes(this._partialOutput.getBytes(ne-this._partialBytes)),this._partialBytes=ne,!0;E.putBytes(this._partialOutput.getBytes(te-this._partialBytes)),this._partialBytes=0};modes.ofb.prototype.decrypt=modes.ofb.prototype.encrypt;modes.ctr=function(J){J=J||{},this.name="CTR",this.cipher=J.cipher,this.blockSize=J.blockSize||16,this._ints=this.blockSize/4,this._inBlock=null,this._outBlock=new Array(this._ints),this._partialOutput=forge$h.util.createBuffer(),this._partialBytes=0};modes.ctr.prototype.start=function(J){if(!("iv"in J))throw new Error("Invalid IV parameter.");this._iv=transformIV(J.iv,this.blockSize),this._inBlock=this._iv.slice(0),this._partialBytes=0};modes.ctr.prototype.encrypt=function(J,E,ee){var te=J.length();if(te===0)return!0;if(this.cipher.encrypt(this._inBlock,this._outBlock),this._partialBytes===0&&te>=this.blockSize)for(var re=0;re<this._ints;++re)E.putInt32(J.getInt32()^this._outBlock[re]);else{var ne=(this.blockSize-te)%this.blockSize;ne>0&&(ne=this.blockSize-ne),this._partialOutput.clear();for(var re=0;re<this._ints;++re)this._partialOutput.putInt32(J.getInt32()^this._outBlock[re]);if(ne>0&&(J.read-=this.blockSize),this._partialBytes>0&&this._partialOutput.getBytes(this._partialBytes),ne>0&&!ee)return E.putBytes(this._partialOutput.getBytes(ne-this._partialBytes)),this._partialBytes=ne,!0;E.putBytes(this._partialOutput.getBytes(te-this._partialBytes)),this._partialBytes=0}inc32(this._inBlock)};modes.ctr.prototype.decrypt=modes.ctr.prototype.encrypt;modes.gcm=function(J){J=J||{},this.name="GCM",this.cipher=J.cipher,this.blockSize=J.blockSize||16,this._ints=this.blockSize/4,this._inBlock=new Array(this._ints),this._outBlock=new Array(this._ints),this._partialOutput=forge$h.util.createBuffer(),this._partialBytes=0,this._R=3774873600};modes.gcm.prototype.start=function(J){if(!("iv"in J))throw new Error("Invalid IV parameter.");var E=forge$h.util.createBuffer(J.iv);this._cipherLength=0;var ee;if("additionalData"in J?ee=forge$h.util.createBuffer(J.additionalData):ee=forge$h.util.createBuffer(),"tagLength"in J?this._tagLength=J.tagLength:this._tagLength=128,this._tag=null,J.decrypt&&(this._tag=forge$h.util.createBuffer(J.tag).getBytes(),this._tag.length!==this._tagLength/8))throw new Error("Authentication tag does not match tag length.");this._hashBlock=new Array(this._ints),this.tag=null,this._hashSubkey=new Array(this._ints),this.cipher.encrypt([0,0,0,0],this._hashSubkey),this.componentBits=4,this._m=this.generateHashTable(this._hashSubkey,this.componentBits);var te=E.length();if(te===12)this._j0=[E.getInt32(),E.getInt32(),E.getInt32(),1];else{for(this._j0=[0,0,0,0];E.length()>0;)this._j0=this.ghash(this._hashSubkey,this._j0,[E.getInt32(),E.getInt32(),E.getInt32(),E.getInt32()]);this._j0=this.ghash(this._hashSubkey,this._j0,[0,0].concat(from64To32(te*8)))}this._inBlock=this._j0.slice(0),inc32(this._inBlock),this._partialBytes=0,ee=forge$h.util.createBuffer(ee),this._aDataLength=from64To32(ee.length()*8);var re=ee.length()%this.blockSize;for(re&&ee.fillWithByte(0,this.blockSize-re),this._s=[0,0,0,0];ee.length()>0;)this._s=this.ghash(this._hashSubkey,this._s,[ee.getInt32(),ee.getInt32(),ee.getInt32(),ee.getInt32()])};modes.gcm.prototype.encrypt=function(J,E,ee){var te=J.length();if(te===0)return!0;if(this.cipher.encrypt(this._inBlock,this._outBlock),this._partialBytes===0&&te>=this.blockSize){for(var re=0;re<this._ints;++re)E.putInt32(this._outBlock[re]^=J.getInt32());this._cipherLength+=this.blockSize}else{var ne=(this.blockSize-te)%this.blockSize;ne>0&&(ne=this.blockSize-ne),this._partialOutput.clear();for(var re=0;re<this._ints;++re)this._partialOutput.putInt32(J.getInt32()^this._outBlock[re]);if(ne<=0||ee){if(ee){var ie=te%this.blockSize;this._cipherLength+=ie,this._partialOutput.truncate(this.blockSize-ie)}else this._cipherLength+=this.blockSize;for(var re=0;re<this._ints;++re)this._outBlock[re]=this._partialOutput.getInt32();this._partialOutput.read-=this.blockSize}if(this._partialBytes>0&&this._partialOutput.getBytes(this._partialBytes),ne>0&&!ee)return J.read-=this.blockSize,E.putBytes(this._partialOutput.getBytes(ne-this._partialBytes)),this._partialBytes=ne,!0;E.putBytes(this._partialOutput.getBytes(te-this._partialBytes)),this._partialBytes=0}this._s=this.ghash(this._hashSubkey,this._s,this._outBlock),inc32(this._inBlock)};modes.gcm.prototype.decrypt=function(J,E,ee){var te=J.length();if(te<this.blockSize&&!(ee&&te>0))return!0;this.cipher.encrypt(this._inBlock,this._outBlock),inc32(this._inBlock),this._hashBlock[0]=J.getInt32(),this._hashBlock[1]=J.getInt32(),this._hashBlock[2]=J.getInt32(),this._hashBlock[3]=J.getInt32(),this._s=this.ghash(this._hashSubkey,this._s,this._hashBlock);for(var re=0;re<this._ints;++re)E.putInt32(this._outBlock[re]^this._hashBlock[re]);te<this.blockSize?this._cipherLength+=te%this.blockSize:this._cipherLength+=this.blockSize};modes.gcm.prototype.afterFinish=function(J,E){var ee=!0;E.decrypt&&E.overflow&&J.truncate(this.blockSize-E.overflow),this.tag=forge$h.util.createBuffer();var te=this._aDataLength.concat(from64To32(this._cipherLength*8));this._s=this.ghash(this._hashSubkey,this._s,te);var re=[];this.cipher.encrypt(this._j0,re);for(var ne=0;ne<this._ints;++ne)this.tag.putInt32(this._s[ne]^re[ne]);return this.tag.truncate(this.tag.length()%(this._tagLength/8)),E.decrypt&&this.tag.bytes()!==this._tag&&(ee=!1),ee};modes.gcm.prototype.multiply=function(J,E){for(var ee=[0,0,0,0],te=E.slice(0),re=0;re<128;++re){var ne=J[re/32|0]&1<<31-re%32;ne&&(ee[0]^=te[0],ee[1]^=te[1],ee[2]^=te[2],ee[3]^=te[3]),this.pow(te,te)}return ee};modes.gcm.prototype.pow=function(J,E){for(var ee=J[3]&1,te=3;te>0;--te)E[te]=J[te]>>>1|(J[te-1]&1)<<31;E[0]=J[0]>>>1,ee&&(E[0]^=this._R)};modes.gcm.prototype.tableMultiply=function(J){for(var E=[0,0,0,0],ee=0;ee<32;++ee){var te=ee/8|0,re=J[te]>>>(7-ee%8)*4&15,ne=this._m[ee][re];E[0]^=ne[0],E[1]^=ne[1],E[2]^=ne[2],E[3]^=ne[3]}return E};modes.gcm.prototype.ghash=function(J,E,ee){return E[0]^=ee[0],E[1]^=ee[1],E[2]^=ee[2],E[3]^=ee[3],this.tableMultiply(E)};modes.gcm.prototype.generateHashTable=function(J,E){for(var ee=8/E,te=4*ee,re=16*ee,ne=new Array(re),ie=0;ie<re;++ie){var se=[0,0,0,0],oe=ie/te|0,ce=(te-1-ie%te)*E;se[oe]=1<<E-1<<ce,ne[ie]=this.generateSubHashTable(this.multiply(se,J),E)}return ne};modes.gcm.prototype.generateSubHashTable=function(J,E){var ee=1<<E,te=ee>>>1,re=new Array(ee);re[te]=J.slice(0);for(var ne=te>>>1;ne>0;)this.pow(re[2*ne],re[ne]=[]),ne>>=1;for(ne=2;ne<te;){for(var ie=1;ie<ne;++ie){var se=re[ne],oe=re[ie];re[ne+ie]=[se[0]^oe[0],se[1]^oe[1],se[2]^oe[2],se[3]^oe[3]]}ne*=2}for(re[0]=[0,0,0,0],ne=te+1;ne<ee;++ne){var ce=re[ne^te];re[ne]=[J[0]^ce[0],J[1]^ce[1],J[2]^ce[2],J[3]^ce[3]]}return re};function transformIV(J,E){if(typeof J=="string"&&(J=forge$h.util.createBuffer(J)),forge$h.util.isArray(J)&&J.length>4){var ee=J;J=forge$h.util.createBuffer();for(var te=0;te<ee.length;++te)J.putByte(ee[te])}if(J.length()<E)throw new Error("Invalid IV length; got "+J.length()+" bytes and expected "+E+" bytes.");if(!forge$h.util.isArray(J)){for(var re=[],ne=E/4,te=0;te<ne;++te)re.push(J.getInt32());J=re}return J}function inc32(J){J[J.length-1]=J[J.length-1]+1&4294967295}function from64To32(J){return[J/4294967296|0,J&4294967295]}var forge$g=forge$m;forge$g.aes=forge$g.aes||{};forge$g.aes.startEncrypting=function(J,E,ee,te){var re=_createCipher$1({key:J,output:ee,decrypt:!1,mode:te});return re.start(E),re};forge$g.aes.createEncryptionCipher=function(J,E){return _createCipher$1({key:J,output:null,decrypt:!1,mode:E})};forge$g.aes.startDecrypting=function(J,E,ee,te){var re=_createCipher$1({key:J,output:ee,decrypt:!0,mode:te});return re.start(E),re};forge$g.aes.createDecryptionCipher=function(J,E){return _createCipher$1({key:J,output:null,decrypt:!0,mode:E})};forge$g.aes.Algorithm=function(J,E){init||initialize();var ee=this;ee.name=J,ee.mode=new E({blockSize:16,cipher:{encrypt:function(te,re){return _updateBlock$1(ee._w,te,re,!1)},decrypt:function(te,re){return _updateBlock$1(ee._w,te,re,!0)}}}),ee._init=!1};forge$g.aes.Algorithm.prototype.initialize=function(J){if(!this._init){var E=J.key,ee;if(typeof E=="string"&&(E.length===16||E.length===24||E.length===32))E=forge$g.util.createBuffer(E);else if(forge$g.util.isArray(E)&&(E.length===16||E.length===24||E.length===32)){ee=E,E=forge$g.util.createBuffer();for(var te=0;te<ee.length;++te)E.putByte(ee[te])}if(!forge$g.util.isArray(E)){ee=E,E=[];var re=ee.length();if(re===16||re===24||re===32){re=re>>>2;for(var te=0;te<re;++te)E.push(ee.getInt32())}}if(!forge$g.util.isArray(E)||!(E.length===4||E.length===6||E.length===8))throw new Error("Invalid key parameter.");var ne=this.mode.name,ie=["CFB","OFB","CTR","GCM"].indexOf(ne)!==-1;this._w=_expandKey(E,J.decrypt&&!ie),this._init=!0}};forge$g.aes._expandKey=function(J,E){return init||initialize(),_expandKey(J,E)};forge$g.aes._updateBlock=_updateBlock$1;registerAlgorithm$1("AES-ECB",forge$g.cipher.modes.ecb);registerAlgorithm$1("AES-CBC",forge$g.cipher.modes.cbc);registerAlgorithm$1("AES-CFB",forge$g.cipher.modes.cfb);registerAlgorithm$1("AES-OFB",forge$g.cipher.modes.ofb);registerAlgorithm$1("AES-CTR",forge$g.cipher.modes.ctr);registerAlgorithm$1("AES-GCM",forge$g.cipher.modes.gcm);function registerAlgorithm$1(J,E){var ee=function(){return new forge$g.aes.Algorithm(J,E)};forge$g.cipher.registerAlgorithm(J,ee)}var init=!1,Nb=4,sbox,isbox,rcon,mix,imix;function initialize(){init=!0,rcon=[0,1,2,4,8,16,32,64,128,27,54];for(var J=new Array(256),E=0;E<128;++E)J[E]=E<<1,J[E+128]=E+128<<1^283;sbox=new Array(256),isbox=new Array(256),mix=new Array(4),imix=new Array(4);for(var E=0;E<4;++E)mix[E]=new Array(256),imix[E]=new Array(256);for(var ee=0,te=0,re,ne,ie,se,oe,ce,ae,E=0;E<256;++E){se=te^te<<1^te<<2^te<<3^te<<4,se=se>>8^se&255^99,sbox[ee]=se,isbox[se]=ee,oe=J[se],re=J[ee],ne=J[re],ie=J[ne],ce=oe<<24^se<<16^se<<8^(se^oe),ae=(re^ne^ie)<<24^(ee^ie)<<16^(ee^ne^ie)<<8^(ee^re^ie);for(var le=0;le<4;++le)mix[le][ee]=ce,imix[le][se]=ae,ce=ce<<24|ce>>>8,ae=ae<<24|ae>>>8;ee===0?ee=te=1:(ee=re^J[J[J[re^ie]]],te^=J[J[te]])}}function _expandKey(J,E){for(var ee=J.slice(0),te,re=1,ne=ee.length,ie=ne+6+1,se=Nb*ie,oe=ne;oe<se;++oe)te=ee[oe-1],oe%ne===0?(te=sbox[te>>>16&255]<<24^sbox[te>>>8&255]<<16^sbox[te&255]<<8^sbox[te>>>24]^rcon[re]<<24,re++):ne>6&&oe%ne===4&&(te=sbox[te>>>24]<<24^sbox[te>>>16&255]<<16^sbox[te>>>8&255]<<8^sbox[te&255]),ee[oe]=ee[oe-ne]^te;if(E){var ce,ae=imix[0],le=imix[1],ue=imix[2],he=imix[3],pe=ee.slice(0);se=ee.length;for(var oe=0,de=se-Nb;oe<se;oe+=Nb,de-=Nb)if(oe===0||oe===se-Nb)pe[oe]=ee[de],pe[oe+1]=ee[de+3],pe[oe+2]=ee[de+2],pe[oe+3]=ee[de+1];else for(var fe=0;fe<Nb;++fe)ce=ee[de+fe],pe[oe+(3&-fe)]=ae[sbox[ce>>>24]]^le[sbox[ce>>>16&255]]^ue[sbox[ce>>>8&255]]^he[sbox[ce&255]];ee=pe}return ee}function _updateBlock$1(J,E,ee,te){var re=J.length/4-1,ne,ie,se,oe,ce;te?(ne=imix[0],ie=imix[1],se=imix[2],oe=imix[3],ce=isbox):(ne=mix[0],ie=mix[1],se=mix[2],oe=mix[3],ce=sbox);var ae,le,ue,he,pe,de,fe;ae=E[0]^J[0],le=E[te?3:1]^J[1],ue=E[2]^J[2],he=E[te?1:3]^J[3];for(var me=3,_e=1;_e<re;++_e)pe=ne[ae>>>24]^ie[le>>>16&255]^se[ue>>>8&255]^oe[he&255]^J[++me],de=ne[le>>>24]^ie[ue>>>16&255]^se[he>>>8&255]^oe[ae&255]^J[++me],fe=ne[ue>>>24]^ie[he>>>16&255]^se[ae>>>8&255]^oe[le&255]^J[++me],he=ne[he>>>24]^ie[ae>>>16&255]^se[le>>>8&255]^oe[ue&255]^J[++me],ae=pe,le=de,ue=fe;ee[0]=ce[ae>>>24]<<24^ce[le>>>16&255]<<16^ce[ue>>>8&255]<<8^ce[he&255]^J[++me],ee[te?3:1]=ce[le>>>24]<<24^ce[ue>>>16&255]<<16^ce[he>>>8&255]<<8^ce[ae&255]^J[++me],ee[2]=ce[ue>>>24]<<24^ce[he>>>16&255]<<16^ce[ae>>>8&255]<<8^ce[le&255]^J[++me],ee[te?1:3]=ce[he>>>24]<<24^ce[ae>>>16&255]<<16^ce[le>>>8&255]<<8^ce[ue&255]^J[++me]}function _createCipher$1(J){J=J||{};var E=(J.mode||"CBC").toUpperCase(),ee="AES-"+E,te;J.decrypt?te=forge$g.cipher.createDecipher(ee,J.key):te=forge$g.cipher.createCipher(ee,J.key);var re=te.start;return te.start=function(ne,ie){var se=null;ie instanceof forge$g.util.ByteBuffer&&(se=ie,ie={}),ie=ie||{},ie.output=se,ie.iv=ne,re.call(te,ie)},te}var forge$f=forge$m;forge$f.des=forge$f.des||{};forge$f.des.startEncrypting=function(J,E,ee,te){var re=_createCipher({key:J,output:ee,decrypt:!1,mode:te||(E===null?"ECB":"CBC")});return re.start(E),re};forge$f.des.createEncryptionCipher=function(J,E){return _createCipher({key:J,output:null,decrypt:!1,mode:E})};forge$f.des.startDecrypting=function(J,E,ee,te){var re=_createCipher({key:J,output:ee,decrypt:!0,mode:te||(E===null?"ECB":"CBC")});return re.start(E),re};forge$f.des.createDecryptionCipher=function(J,E){return _createCipher({key:J,output:null,decrypt:!0,mode:E})};forge$f.des.Algorithm=function(J,E){var ee=this;ee.name=J,ee.mode=new E({blockSize:8,cipher:{encrypt:function(te,re){return _updateBlock(ee._keys,te,re,!1)},decrypt:function(te,re){return _updateBlock(ee._keys,te,re,!0)}}}),ee._init=!1};forge$f.des.Algorithm.prototype.initialize=function(J){if(!this._init){var E=forge$f.util.createBuffer(J.key);if(this.name.indexOf("3DES")===0&&E.length()!==24)throw new Error("Invalid Triple-DES key size: "+E.length()*8);this._keys=_createKeys(E),this._init=!0}};registerAlgorithm("DES-ECB",forge$f.cipher.modes.ecb);registerAlgorithm("DES-CBC",forge$f.cipher.modes.cbc);registerAlgorithm("DES-CFB",forge$f.cipher.modes.cfb);registerAlgorithm("DES-OFB",forge$f.cipher.modes.ofb);registerAlgorithm("DES-CTR",forge$f.cipher.modes.ctr);registerAlgorithm("3DES-ECB",forge$f.cipher.modes.ecb);registerAlgorithm("3DES-CBC",forge$f.cipher.modes.cbc);registerAlgorithm("3DES-CFB",forge$f.cipher.modes.cfb);registerAlgorithm("3DES-OFB",forge$f.cipher.modes.ofb);registerAlgorithm("3DES-CTR",forge$f.cipher.modes.ctr);function registerAlgorithm(J,E){var ee=function(){return new forge$f.des.Algorithm(J,E)};forge$f.cipher.registerAlgorithm(J,ee)}var spfunction1=[16843776,0,65536,16843780,16842756,66564,4,65536,1024,16843776,16843780,1024,16778244,16842756,16777216,4,1028,16778240,16778240,66560,66560,16842752,16842752,16778244,65540,16777220,16777220,65540,0,1028,66564,16777216,65536,16843780,4,16842752,16843776,16777216,16777216,1024,16842756,65536,66560,16777220,1024,4,16778244,66564,16843780,65540,16842752,16778244,16777220,1028,66564,16843776,1028,16778240,16778240,0,65540,66560,0,16842756],spfunction2=[-2146402272,-2147450880,32768,1081376,1048576,32,-2146435040,-2147450848,-2147483616,-2146402272,-2146402304,-2147483648,-2147450880,1048576,32,-2146435040,1081344,1048608,-2147450848,0,-2147483648,32768,1081376,-2146435072,1048608,-2147483616,0,1081344,32800,-2146402304,-2146435072,32800,0,1081376,-2146435040,1048576,-2147450848,-2146435072,-2146402304,32768,-2146435072,-2147450880,32,-2146402272,1081376,32,32768,-2147483648,32800,-2146402304,1048576,-2147483616,1048608,-2147450848,-2147483616,1048608,1081344,0,-2147450880,32800,-2147483648,-2146435040,-2146402272,1081344],spfunction3=[520,134349312,0,134348808,134218240,0,131592,134218240,131080,134217736,134217736,131072,134349320,131080,134348800,520,134217728,8,134349312,512,131584,134348800,134348808,131592,134218248,131584,131072,134218248,8,134349320,512,134217728,134349312,134217728,131080,520,131072,134349312,134218240,0,512,131080,134349320,134218240,134217736,512,0,134348808,134218248,131072,134217728,134349320,8,131592,131584,134217736,134348800,134218248,520,134348800,131592,8,134348808,131584],spfunction4=[8396801,8321,8321,128,8396928,8388737,8388609,8193,0,8396800,8396800,8396929,129,0,8388736,8388609,1,8192,8388608,8396801,128,8388608,8193,8320,8388737,1,8320,8388736,8192,8396928,8396929,129,8388736,8388609,8396800,8396929,129,0,0,8396800,8320,8388736,8388737,1,8396801,8321,8321,128,8396929,129,1,8192,8388609,8193,8396928,8388737,8193,8320,8388608,8396801,128,8388608,8192,8396928],spfunction5=[256,34078976,34078720,1107296512,524288,256,1073741824,34078720,1074266368,524288,33554688,1074266368,1107296512,1107820544,524544,1073741824,33554432,1074266112,1074266112,0,1073742080,1107820800,1107820800,33554688,1107820544,1073742080,0,1107296256,34078976,33554432,1107296256,524544,524288,1107296512,256,33554432,1073741824,34078720,1107296512,1074266368,33554688,1073741824,1107820544,34078976,1074266368,256,33554432,1107820544,1107820800,524544,1107296256,1107820800,34078720,0,1074266112,1107296256,524544,33554688,1073742080,524288,0,1074266112,34078976,1073742080],spfunction6=[536870928,541065216,16384,541081616,541065216,16,541081616,4194304,536887296,4210704,4194304,536870928,4194320,536887296,536870912,16400,0,4194320,536887312,16384,4210688,536887312,16,541065232,541065232,0,4210704,541081600,16400,4210688,541081600,536870912,536887296,16,541065232,4210688,541081616,4194304,16400,536870928,4194304,536887296,536870912,16400,536870928,541081616,4210688,541065216,4210704,541081600,0,541065232,16,16384,541065216,4210704,16384,4194320,536887312,0,541081600,536870912,4194320,536887312],spfunction7=[2097152,69206018,67110914,0,2048,67110914,2099202,69208064,69208066,2097152,0,67108866,2,67108864,69206018,2050,67110912,2099202,2097154,67110912,67108866,69206016,69208064,2097154,69206016,2048,2050,69208066,2099200,2,67108864,2099200,67108864,2099200,2097152,67110914,67110914,69206018,69206018,2,2097154,67108864,67110912,2097152,69208064,2050,2099202,69208064,2050,67108866,69208066,69206016,2099200,0,2,69208066,0,2099202,69206016,2048,67108866,67110912,2048,2097154],spfunction8=[268439616,4096,262144,268701760,268435456,268439616,64,268435456,262208,268697600,268701760,266240,268701696,266304,4096,64,268697600,268435520,268439552,4160,266240,262208,268697664,268701696,4160,0,0,268697664,268435520,268439552,266304,262144,266304,262144,268701696,4096,64,268697664,4096,266304,268439552,64,268435520,268697600,268697664,268435456,262144,268439616,0,268701760,262208,268435520,268697600,268439552,268439616,0,268701760,266240,266240,4160,4160,262208,268435456,268701696];function _createKeys(J){for(var E=[0,4,536870912,536870916,65536,65540,536936448,536936452,512,516,536871424,536871428,66048,66052,536936960,536936964],ee=[0,1,1048576,1048577,67108864,67108865,68157440,68157441,256,257,1048832,1048833,67109120,67109121,68157696,68157697],te=[0,8,2048,2056,16777216,16777224,16779264,16779272,0,8,2048,2056,16777216,16777224,16779264,16779272],re=[0,2097152,134217728,136314880,8192,2105344,134225920,136323072,131072,2228224,134348800,136445952,139264,2236416,134356992,136454144],ne=[0,262144,16,262160,0,262144,16,262160,4096,266240,4112,266256,4096,266240,4112,266256],ie=[0,1024,32,1056,0,1024,32,1056,33554432,33555456,33554464,33555488,33554432,33555456,33554464,33555488],se=[0,268435456,524288,268959744,2,268435458,524290,268959746,0,268435456,524288,268959744,2,268435458,524290,268959746],oe=[0,65536,2048,67584,536870912,536936448,536872960,536938496,131072,196608,133120,198656,537001984,537067520,537004032,537069568],ce=[0,262144,0,262144,2,262146,2,262146,33554432,33816576,33554432,33816576,33554434,33816578,33554434,33816578],ae=[0,268435456,8,268435464,0,268435456,8,268435464,1024,268436480,1032,268436488,1024,268436480,1032,268436488],le=[0,32,0,32,1048576,1048608,1048576,1048608,8192,8224,8192,8224,1056768,1056800,1056768,1056800],ue=[0,16777216,512,16777728,2097152,18874368,2097664,18874880,67108864,83886080,67109376,83886592,69206016,85983232,69206528,85983744],he=[0,4096,134217728,134221824,524288,528384,134742016,134746112,16,4112,134217744,134221840,524304,528400,134742032,134746128],pe=[0,4,256,260,0,4,256,260,1,5,257,261,1,5,257,261],de=J.length()>8?3:1,fe=[],me=[0,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0],_e=0,be,Ee=0;Ee<de;Ee++){var ve=J.getInt32(),we=J.getInt32();be=(ve>>>4^we)&252645135,we^=be,ve^=be<<4,be=(we>>>-16^ve)&65535,ve^=be,we^=be<<-16,be=(ve>>>2^we)&858993459,we^=be,ve^=be<<2,be=(we>>>-16^ve)&65535,ve^=be,we^=be<<-16,be=(ve>>>1^we)&1431655765,we^=be,ve^=be<<1,be=(we>>>8^ve)&16711935,ve^=be,we^=be<<8,be=(ve>>>1^we)&1431655765,we^=be,ve^=be<<1,be=ve<<8|we>>>20&240,ve=we<<24|we<<8&16711680|we>>>8&65280|we>>>24&240,we=be;for(var ge=0;ge<me.length;++ge){me[ge]?(ve=ve<<2|ve>>>26,we=we<<2|we>>>26):(ve=ve<<1|ve>>>27,we=we<<1|we>>>27),ve&=-15,we&=-15;var Se=E[ve>>>28]|ee[ve>>>24&15]|te[ve>>>20&15]|re[ve>>>16&15]|ne[ve>>>12&15]|ie[ve>>>8&15]|se[ve>>>4&15],$e=oe[we>>>28]|ce[we>>>24&15]|ae[we>>>20&15]|le[we>>>16&15]|ue[we>>>12&15]|he[we>>>8&15]|pe[we>>>4&15];be=($e>>>16^Se)&65535,fe[_e++]=Se^be,fe[_e++]=$e^be<<16}}return fe}function _updateBlock(J,E,ee,te){var re=J.length===32?3:9,ne;re===3?ne=te?[30,-2,-2]:[0,32,2]:ne=te?[94,62,-2,32,64,2,30,-2,-2]:[0,32,2,62,30,-2,64,96,2];var ie,se=E[0],oe=E[1];ie=(se>>>4^oe)&252645135,oe^=ie,se^=ie<<4,ie=(se>>>16^oe)&65535,oe^=ie,se^=ie<<16,ie=(oe>>>2^se)&858993459,se^=ie,oe^=ie<<2,ie=(oe>>>8^se)&16711935,se^=ie,oe^=ie<<8,ie=(se>>>1^oe)&1431655765,oe^=ie,se^=ie<<1,se=se<<1|se>>>31,oe=oe<<1|oe>>>31;for(var ce=0;ce<re;ce+=3){for(var ae=ne[ce+1],le=ne[ce+2],ue=ne[ce];ue!=ae;ue+=le){var he=oe^J[ue],pe=(oe>>>4|oe<<28)^J[ue+1];ie=se,se=oe,oe=ie^(spfunction2[he>>>24&63]|spfunction4[he>>>16&63]|spfunction6[he>>>8&63]|spfunction8[he&63]|spfunction1[pe>>>24&63]|spfunction3[pe>>>16&63]|spfunction5[pe>>>8&63]|spfunction7[pe&63])}ie=se,se=oe,oe=ie}se=se>>>1|se<<31,oe=oe>>>1|oe<<31,ie=(se>>>1^oe)&1431655765,oe^=ie,se^=ie<<1,ie=(oe>>>8^se)&16711935,se^=ie,oe^=ie<<8,ie=(oe>>>2^se)&858993459,se^=ie,oe^=ie<<2,ie=(se>>>16^oe)&65535,oe^=ie,se^=ie<<16,ie=(se>>>4^oe)&252645135,oe^=ie,se^=ie<<4,ee[0]=se,ee[1]=oe}function _createCipher(J){J=J||{};var E=(J.mode||"CBC").toUpperCase(),ee="DES-"+E,te;J.decrypt?te=forge$f.cipher.createDecipher(ee,J.key):te=forge$f.cipher.createCipher(ee,J.key);var re=te.start;return te.start=function(ne,ie){var se=null;ie instanceof forge$f.util.ByteBuffer&&(se=ie,ie={}),ie=ie||{},ie.output=se,ie.iv=ne,re.call(te,ie)},te}var forge$e=forge$m;forge$e.md=forge$e.md||{};forge$e.md.algorithms=forge$e.md.algorithms||{};var forge$d=forge$m,hmac$3=forge$d.hmac=forge$d.hmac||{};hmac$3.create=function(){var J=null,E=null,ee=null,te=null,re={};return re.start=function(ne,ie){if(ne!==null)if(typeof ne=="string")if(ne=ne.toLowerCase(),ne in forge$d.md.algorithms)E=forge$d.md.algorithms[ne].create();else throw new Error('Unknown hash algorithm "'+ne+'"');else E=ne;if(ie===null)ie=J;else{if(typeof ie=="string")ie=forge$d.util.createBuffer(ie);else if(forge$d.util.isArray(ie)){var se=ie;ie=forge$d.util.createBuffer();for(var oe=0;oe<se.length;++oe)ie.putByte(se[oe])}var ce=ie.length();ce>E.blockLength&&(E.start(),E.update(ie.bytes()),ie=E.digest()),ee=forge$d.util.createBuffer(),te=forge$d.util.createBuffer(),ce=ie.length();for(var oe=0;oe<ce;++oe){var se=ie.at(oe);ee.putByte(54^se),te.putByte(92^se)}if(ce<E.blockLength)for(var se=E.blockLength-ce,oe=0;oe<se;++oe)ee.putByte(54),te.putByte(92);J=ie,ee=ee.bytes(),te=te.bytes()}E.start(),E.update(ee)},re.update=function(ne){E.update(ne)},re.getMac=function(){var ne=E.digest().bytes();return E.start(),E.update(te),E.update(ne),E.digest()},re.digest=re.getMac,re};var forge$c=forge$m,pkcs5=forge$c.pkcs5=forge$c.pkcs5||{},crypto$4;forge$c.util.isNodejs&&!forge$c.options.usePureJavaScript&&(crypto$4=require$$8);var pbkdf2$1=forge$c.pbkdf2=pkcs5.pbkdf2=function(J,E,ee,te,re,ne){if(typeof re=="function"&&(ne=re,re=null),forge$c.util.isNodejs&&!forge$c.options.usePureJavaScript&&crypto$4.pbkdf2&&(re===null||typeof re!="object")&&(crypto$4.pbkdf2Sync.length>4||!re||re==="sha1"))return typeof re!="string"&&(re="sha1"),J=Buffer.from(J,"binary"),E=Buffer.from(E,"binary"),ne?crypto$4.pbkdf2Sync.length===4?crypto$4.pbkdf2(J,E,ee,te,function(be,Ee){if(be)return ne(be);ne(null,Ee.toString("binary"))}):crypto$4.pbkdf2(J,E,ee,te,re,function(be,Ee){if(be)return ne(be);ne(null,Ee.toString("binary"))}):crypto$4.pbkdf2Sync.length===4?crypto$4.pbkdf2Sync(J,E,ee,te).toString("binary"):crypto$4.pbkdf2Sync(J,E,ee,te,re).toString("binary");if((typeof re>"u"||re===null)&&(re="sha1"),typeof re=="string"){if(!(re in forge$c.md.algorithms))throw new Error("Unknown hash algorithm: "+re);re=forge$c.md[re].create()}var ie=re.digestLength;if(te>4294967295*ie){var se=new Error("Derived key is too long.");if(ne)return ne(se);throw se}var oe=Math.ceil(te/ie),ce=te-(oe-1)*ie,ae=forge$c.hmac.create();ae.start(re,J);var le="",ue,he,pe;if(!ne){for(var de=1;de<=oe;++de){ae.start(null,null),ae.update(E),ae.update(forge$c.util.int32ToBytes(de)),ue=pe=ae.digest().getBytes();for(var fe=2;fe<=ee;++fe)ae.start(null,null),ae.update(pe),he=ae.digest().getBytes(),ue=forge$c.util.xorBytes(ue,he,ie),pe=he;le+=de<oe?ue:ue.substr(0,ce)}return le}var de=1,fe;function me(){if(de>oe)return ne(null,le);ae.start(null,null),ae.update(E),ae.update(forge$c.util.int32ToBytes(de)),ue=pe=ae.digest().getBytes(),fe=2,_e()}function _e(){if(fe<=ee)return ae.start(null,null),ae.update(pe),he=ae.digest().getBytes(),ue=forge$c.util.xorBytes(ue,he,ie),pe=he,++fe,forge$c.util.setImmediate(_e);le+=de<oe?ue:ue.substr(0,ce),++de,me()}me()};const forgePbkdf2=getDefaultExportFromCjs(pbkdf2$1);var forge$b=forge$m,pem=forge$b.pem=forge$b.pem||{};pem.encode=function(J,E){E=E||{};var ee="-----BEGIN "+J.type+`-----\r
`,te;if(J.procType&&(te={name:"Proc-Type",values:[String(J.procType.version),J.procType.type]},ee+=foldHeader(te)),J.contentDomain&&(te={name:"Content-Domain",values:[J.contentDomain]},ee+=foldHeader(te)),J.dekInfo&&(te={name:"DEK-Info",values:[J.dekInfo.algorithm]},J.dekInfo.parameters&&te.values.push(J.dekInfo.parameters),ee+=foldHeader(te)),J.headers)for(var re=0;re<J.headers.length;++re)ee+=foldHeader(J.headers[re]);return J.procType&&(ee+=`\r
`),ee+=forge$b.util.encode64(J.body,E.maxline||64)+`\r
`,ee+="-----END "+J.type+`-----\r
`,ee};pem.decode=function(J){for(var E=[],ee=/\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g,te=/([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/,re=/\r?\n/,ne;ne=ee.exec(J),!!ne;){var ie=ne[1];ie==="NEW CERTIFICATE REQUEST"&&(ie="CERTIFICATE REQUEST");var se={type:ie,procType:null,contentDomain:null,dekInfo:null,headers:[],body:forge$b.util.decode64(ne[3])};if(E.push(se),!!ne[2]){for(var oe=ne[2].split(re),ce=0;ne&&ce<oe.length;){for(var ae=oe[ce].replace(/\s+$/,""),le=ce+1;le<oe.length;++le){var ue=oe[le];if(!/\s/.test(ue[0]))break;ae+=ue,ce=le}if(ne=ae.match(te),ne){for(var he={name:ne[1],values:[]},pe=ne[2].split(","),de=0;de<pe.length;++de)he.values.push(ltrim(pe[de]));if(se.procType)if(!se.contentDomain&&he.name==="Content-Domain")se.contentDomain=pe[0]||"";else if(!se.dekInfo&&he.name==="DEK-Info"){if(he.values.length===0)throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');se.dekInfo={algorithm:pe[0],parameters:pe[1]||null}}else se.headers.push(he);else{if(he.name!=="Proc-Type")throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');if(he.values.length!==2)throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');se.procType={version:pe[0],type:pe[1]}}}++ce}if(se.procType==="ENCRYPTED"&&!se.dekInfo)throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".')}}if(E.length===0)throw new Error("Invalid PEM formatted message.");return E};function foldHeader(J){for(var E=J.name+": ",ee=[],te=function(oe,ce){return" "+ce},re=0;re<J.values.length;++re)ee.push(J.values[re].replace(/^(\S+\r\n)/,te));E+=ee.join(",")+`\r
`;for(var ne=0,ie=-1,re=0;re<E.length;++re,++ne)if(ne>65&&ie!==-1){var se=E[ie];se===","?(++ie,E=E.substr(0,ie)+`\r
 `+E.substr(ie)):E=E.substr(0,ie)+`\r
`+se+E.substr(ie+1),ne=re-ie-1,ie=-1,++re}else(E[re]===" "||E[re]==="	"||E[re]===",")&&(ie=re);return E}function ltrim(J){return J.replace(/^\s+/,"")}var forge$a=forge$m,sha256$2=forge$a.sha256=forge$a.sha256||{};forge$a.md.sha256=forge$a.md.algorithms.sha256=sha256$2;sha256$2.create=function(){_initialized$2||_init$2();var J=null,E=forge$a.util.createBuffer(),ee=new Array(64),te={algorithm:"sha256",blockLength:64,digestLength:32,messageLength:0,fullMessageLength:null,messageLengthSize:8};return te.start=function(){te.messageLength=0,te.fullMessageLength=te.messageLength64=[];for(var re=te.messageLengthSize/4,ne=0;ne<re;++ne)te.fullMessageLength.push(0);return E=forge$a.util.createBuffer(),J={h0:1779033703,h1:3144134277,h2:1013904242,h3:2773480762,h4:1359893119,h5:2600822924,h6:528734635,h7:1541459225},te},te.start(),te.update=function(re,ne){ne==="utf8"&&(re=forge$a.util.encodeUtf8(re));var ie=re.length;te.messageLength+=ie,ie=[ie/4294967296>>>0,ie>>>0];for(var se=te.fullMessageLength.length-1;se>=0;--se)te.fullMessageLength[se]+=ie[1],ie[1]=ie[0]+(te.fullMessageLength[se]/4294967296>>>0),te.fullMessageLength[se]=te.fullMessageLength[se]>>>0,ie[0]=ie[1]/4294967296>>>0;return E.putBytes(re),_update$2(J,ee,E),(E.read>2048||E.length()===0)&&E.compact(),te},te.digest=function(){var re=forge$a.util.createBuffer();re.putBytes(E.bytes());var ne=te.fullMessageLength[te.fullMessageLength.length-1]+te.messageLengthSize,ie=ne&te.blockLength-1;re.putBytes(_padding$2.substr(0,te.blockLength-ie));for(var se,oe,ce=te.fullMessageLength[0]*8,ae=0;ae<te.fullMessageLength.length-1;++ae)se=te.fullMessageLength[ae+1]*8,oe=se/4294967296>>>0,ce+=oe,re.putInt32(ce>>>0),ce=se>>>0;re.putInt32(ce);var le={h0:J.h0,h1:J.h1,h2:J.h2,h3:J.h3,h4:J.h4,h5:J.h5,h6:J.h6,h7:J.h7};_update$2(le,ee,re);var ue=forge$a.util.createBuffer();return ue.putInt32(le.h0),ue.putInt32(le.h1),ue.putInt32(le.h2),ue.putInt32(le.h3),ue.putInt32(le.h4),ue.putInt32(le.h5),ue.putInt32(le.h6),ue.putInt32(le.h7),ue},te};var _padding$2=null,_initialized$2=!1,_k$1=null;function _init$2(){_padding$2=String.fromCharCode(128),_padding$2+=forge$a.util.fillString(String.fromCharCode(0),64),_k$1=[1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298],_initialized$2=!0}function _update$2(J,E,ee){for(var te,re,ne,ie,se,oe,ce,ae,le,ue,he,pe,de,fe,me,_e=ee.length();_e>=64;){for(ce=0;ce<16;++ce)E[ce]=ee.getInt32();for(;ce<64;++ce)te=E[ce-2],te=(te>>>17|te<<15)^(te>>>19|te<<13)^te>>>10,re=E[ce-15],re=(re>>>7|re<<25)^(re>>>18|re<<14)^re>>>3,E[ce]=te+E[ce-7]+re+E[ce-16]|0;for(ae=J.h0,le=J.h1,ue=J.h2,he=J.h3,pe=J.h4,de=J.h5,fe=J.h6,me=J.h7,ce=0;ce<64;++ce)ie=(pe>>>6|pe<<26)^(pe>>>11|pe<<21)^(pe>>>25|pe<<7),se=fe^pe&(de^fe),ne=(ae>>>2|ae<<30)^(ae>>>13|ae<<19)^(ae>>>22|ae<<10),oe=ae&le|ue&(ae^le),te=me+ie+se+_k$1[ce]+E[ce],re=ne+oe,me=fe,fe=de,de=pe,pe=he+te>>>0,he=ue,ue=le,le=ae,ae=te+re>>>0;J.h0=J.h0+ae|0,J.h1=J.h1+le|0,J.h2=J.h2+ue|0,J.h3=J.h3+he|0,J.h4=J.h4+pe|0,J.h5=J.h5+de|0,J.h6=J.h6+fe|0,J.h7=J.h7+me|0,_e-=64}}var forge$9=forge$m,_crypto$1=null;forge$9.util.isNodejs&&!forge$9.options.usePureJavaScript&&!process.versions["node-webkit"]&&(_crypto$1=require$$8);var prng=forge$9.prng=forge$9.prng||{};prng.create=function(J){for(var E={plugin:J,key:null,seed:null,time:null,reseeds:0,generated:0,keyBytes:""},ee=J.md,te=new Array(32),re=0;re<32;++re)te[re]=ee.create();E.pools=te,E.pool=0,E.generate=function(ce,ae){if(!ae)return E.generateSync(ce);var le=E.plugin.cipher,ue=E.plugin.increment,he=E.plugin.formatKey,pe=E.plugin.formatSeed,de=forge$9.util.createBuffer();E.key=null,fe();function fe(me){if(me)return ae(me);if(de.length()>=ce)return ae(null,de.getBytes(ce));if(E.generated>1048575&&(E.key=null),E.key===null)return forge$9.util.nextTick(function(){ne(fe)});var _e=le(E.key,E.seed);E.generated+=_e.length,de.putBytes(_e),E.key=he(le(E.key,ue(E.seed))),E.seed=pe(le(E.key,E.seed)),forge$9.util.setImmediate(fe)}},E.generateSync=function(ce){var ae=E.plugin.cipher,le=E.plugin.increment,ue=E.plugin.formatKey,he=E.plugin.formatSeed;E.key=null;for(var pe=forge$9.util.createBuffer();pe.length()<ce;){E.generated>1048575&&(E.key=null),E.key===null&&ie();var de=ae(E.key,E.seed);E.generated+=de.length,pe.putBytes(de),E.key=ue(ae(E.key,le(E.seed))),E.seed=he(ae(E.key,E.seed))}return pe.getBytes(ce)};function ne(ce){if(E.pools[0].messageLength>=32)return se(),ce();var ae=32-E.pools[0].messageLength<<5;E.seedFile(ae,function(le,ue){if(le)return ce(le);E.collect(ue),se(),ce()})}function ie(){if(E.pools[0].messageLength>=32)return se();var ce=32-E.pools[0].messageLength<<5;E.collect(E.seedFileSync(ce)),se()}function se(){E.reseeds=E.reseeds===4294967295?0:E.reseeds+1;var ce=E.plugin.md.create();ce.update(E.keyBytes);for(var ae=1,le=0;le<32;++le)E.reseeds%ae===0&&(ce.update(E.pools[le].digest().getBytes()),E.pools[le].start()),ae=ae<<1;E.keyBytes=ce.digest().getBytes(),ce.start(),ce.update(E.keyBytes);var ue=ce.digest().getBytes();E.key=E.plugin.formatKey(E.keyBytes),E.seed=E.plugin.formatSeed(ue),E.generated=0}function oe(ce){var ae=null,le=forge$9.util.globalScope,ue=le.crypto||le.msCrypto;ue&&ue.getRandomValues&&(ae=function(ve){return ue.getRandomValues(ve)});var he=forge$9.util.createBuffer();if(ae)for(;he.length()<ce;){var pe=Math.max(1,Math.min(ce-he.length(),65536)/4),de=new Uint32Array(Math.floor(pe));try{ae(de);for(var fe=0;fe<de.length;++fe)he.putInt32(de[fe])}catch(ve){if(!(typeof QuotaExceededError<"u"&&ve instanceof QuotaExceededError))throw ve}}if(he.length()<ce)for(var me,_e,be,Ee=Math.floor(Math.random()*65536);he.length()<ce;){_e=16807*(Ee&65535),me=16807*(Ee>>16),_e+=(me&32767)<<16,_e+=me>>15,_e=(_e&2147483647)+(_e>>31),Ee=_e&4294967295;for(var fe=0;fe<3;++fe)be=Ee>>>(fe<<3),be^=Math.floor(Math.random()*256),he.putByte(be&255)}return he.getBytes(ce)}return _crypto$1?(E.seedFile=function(ce,ae){_crypto$1.randomBytes(ce,function(le,ue){if(le)return ae(le);ae(null,ue.toString())})},E.seedFileSync=function(ce){return _crypto$1.randomBytes(ce).toString()}):(E.seedFile=function(ce,ae){try{ae(null,oe(ce))}catch(le){ae(le)}},E.seedFileSync=oe),E.collect=function(ce){for(var ae=ce.length,le=0;le<ae;++le)E.pools[E.pool].update(ce.substr(le,1)),E.pool=E.pool===31?0:E.pool+1},E.collectInt=function(ce,ae){for(var le="",ue=0;ue<ae;ue+=8)le+=String.fromCharCode(ce>>ue&255);E.collect(le)},E.registerWorker=function(ce){if(ce===self)E.seedFile=function(le,ue){function he(pe){var de=pe.data;de.forge&&de.forge.prng&&(self.removeEventListener("message",he),ue(de.forge.prng.err,de.forge.prng.bytes))}self.addEventListener("message",he),self.postMessage({forge:{prng:{needed:le}}})};else{var ae=function(le){var ue=le.data;ue.forge&&ue.forge.prng&&E.seedFile(ue.forge.prng.needed,function(he,pe){ce.postMessage({forge:{prng:{err:he,bytes:pe}}})})};ce.addEventListener("message",ae)}},E};var forge$8=forge$m;(function(){if(forge$8.random&&forge$8.random.getBytes){forge$8.random;return}(function(J){var E={},ee=new Array(4),te=forge$8.util.createBuffer();E.formatKey=function(le){var ue=forge$8.util.createBuffer(le);return le=new Array(4),le[0]=ue.getInt32(),le[1]=ue.getInt32(),le[2]=ue.getInt32(),le[3]=ue.getInt32(),forge$8.aes._expandKey(le,!1)},E.formatSeed=function(le){var ue=forge$8.util.createBuffer(le);return le=new Array(4),le[0]=ue.getInt32(),le[1]=ue.getInt32(),le[2]=ue.getInt32(),le[3]=ue.getInt32(),le},E.cipher=function(le,ue){return forge$8.aes._updateBlock(le,ue,ee,!1),te.putInt32(ee[0]),te.putInt32(ee[1]),te.putInt32(ee[2]),te.putInt32(ee[3]),te.getBytes()},E.increment=function(le){return++le[3],le},E.md=forge$8.md.sha256;function re(){var le=forge$8.prng.create(E);return le.getBytes=function(ue,he){return le.generate(ue,he)},le.getBytesSync=function(ue){return le.generate(ue)},le}var ne=re(),ie=null,se=forge$8.util.globalScope,oe=se.crypto||se.msCrypto;if(oe&&oe.getRandomValues&&(ie=function(le){return oe.getRandomValues(le)}),forge$8.options.usePureJavaScript||!forge$8.util.isNodejs&&!ie){if(ne.collectInt(+new Date,32),typeof navigator<"u"){var ce="";for(var ae in navigator)try{typeof navigator[ae]=="string"&&(ce+=navigator[ae])}catch{}ne.collect(ce),ce=null}J&&(J().mousemove(function(le){ne.collectInt(le.clientX,16),ne.collectInt(le.clientY,16)}),J().keypress(function(le){ne.collectInt(le.charCode,8)}))}if(!forge$8.random)forge$8.random=ne;else for(var ae in ne)forge$8.random[ae]=ne[ae];forge$8.random.createInstance=re,forge$8.random})(typeof jQuery<"u"?jQuery:null)})();var forge$7=forge$m,piTable=[217,120,249,196,25,221,181,237,40,233,253,121,74,160,216,157,198,126,55,131,43,118,83,142,98,76,100,136,68,139,251,162,23,154,89,245,135,179,79,19,97,69,109,141,9,129,125,50,189,143,64,235,134,183,123,11,240,149,33,34,92,107,78,130,84,214,101,147,206,96,178,28,115,86,192,20,167,140,241,220,18,117,202,31,59,190,228,209,66,61,212,48,163,60,182,38,111,191,14,218,70,105,7,87,39,242,29,155,188,148,67,3,248,17,199,246,144,239,62,231,6,195,213,47,200,102,30,215,8,232,234,222,128,82,238,247,132,170,114,172,53,77,106,42,150,26,210,113,90,21,73,116,75,159,208,94,4,24,164,236,194,224,65,110,15,81,203,204,36,145,175,80,161,244,112,57,153,124,58,133,35,184,180,122,252,2,54,91,37,85,151,49,45,93,250,152,227,138,146,174,5,223,41,16,103,108,186,201,211,0,230,207,225,158,168,44,99,22,1,63,88,226,137,169,13,56,52,27,171,51,255,176,187,72,12,95,185,177,205,46,197,243,219,71,229,165,156,119,10,166,32,104,254,127,193,173],s=[1,2,3,5],rol=function(J,E){return J<<E&65535|(J&65535)>>16-E},ror=function(J,E){return(J&65535)>>E|J<<16-E&65535};forge$7.rc2=forge$7.rc2||{};forge$7.rc2.expandKey=function(J,E){typeof J=="string"&&(J=forge$7.util.createBuffer(J)),E=E||128;var ee=J,te=J.length(),re=E,ne=Math.ceil(re/8),ie=255>>(re&7),se;for(se=te;se<128;se++)ee.putByte(piTable[ee.at(se-1)+ee.at(se-te)&255]);for(ee.setAt(128-ne,piTable[ee.at(128-ne)&ie]),se=127-ne;se>=0;se--)ee.setAt(se,piTable[ee.at(se+1)^ee.at(se+ne)]);return ee};var createCipher=function(J,E,ee){var te=!1,re=null,ne=null,ie=null,se,oe,ce,ae,le=[];for(J=forge$7.rc2.expandKey(J,E),ce=0;ce<64;ce++)le.push(J.getInt16Le());ee?(se=function(pe){for(ce=0;ce<4;ce++)pe[ce]+=le[ae]+(pe[(ce+3)%4]&pe[(ce+2)%4])+(~pe[(ce+3)%4]&pe[(ce+1)%4]),pe[ce]=rol(pe[ce],s[ce]),ae++},oe=function(pe){for(ce=0;ce<4;ce++)pe[ce]+=le[pe[(ce+3)%4]&63]}):(se=function(pe){for(ce=3;ce>=0;ce--)pe[ce]=ror(pe[ce],s[ce]),pe[ce]-=le[ae]+(pe[(ce+3)%4]&pe[(ce+2)%4])+(~pe[(ce+3)%4]&pe[(ce+1)%4]),ae--},oe=function(pe){for(ce=3;ce>=0;ce--)pe[ce]-=le[pe[(ce+3)%4]&63]});var ue=function(pe){var de=[];for(ce=0;ce<4;ce++){var fe=re.getInt16Le();ie!==null&&(ee?fe^=ie.getInt16Le():ie.putInt16Le(fe)),de.push(fe&65535)}ae=ee?0:63;for(var me=0;me<pe.length;me++)for(var _e=0;_e<pe[me][0];_e++)pe[me][1](de);for(ce=0;ce<4;ce++)ie!==null&&(ee?ie.putInt16Le(de[ce]):de[ce]^=ie.getInt16Le()),ne.putInt16Le(de[ce])},he=null;return he={start:function(pe,de){pe&&typeof pe=="string"&&(pe=forge$7.util.createBuffer(pe)),te=!1,re=forge$7.util.createBuffer(),ne=de||new forge$7.util.createBuffer,ie=pe,he.output=ne},update:function(pe){for(te||re.putBuffer(pe);re.length()>=8;)ue([[5,se],[1,oe],[6,se],[1,oe],[5,se]])},finish:function(pe){var de=!0;if(ee)if(pe)de=pe(8,re,!ee);else{var fe=re.length()===8?8:8-re.length();re.fillWithByte(fe,fe)}if(de&&(te=!0,he.update()),!ee&&(de=re.length()===0,de))if(pe)de=pe(8,ne,!ee);else{var me=ne.length(),_e=ne.at(me-1);_e>me?de=!1:ne.truncate(_e)}return de}},he};forge$7.rc2.startEncrypting=function(J,E,ee){var te=forge$7.rc2.createEncryptionCipher(J,128);return te.start(E,ee),te};forge$7.rc2.createEncryptionCipher=function(J,E){return createCipher(J,E,!0)};forge$7.rc2.startDecrypting=function(J,E,ee){var te=forge$7.rc2.createDecryptionCipher(J,128);return te.start(E,ee),te};forge$7.rc2.createDecryptionCipher=function(J,E){return createCipher(J,E,!1)};var forge$6=forge$m;forge$6.jsbn=forge$6.jsbn||{};var dbits;function BigInteger$2(J,E,ee){this.data=[],J!=null&&(typeof J=="number"?this.fromNumber(J,E,ee):E==null&&typeof J!="string"?this.fromString(J,256):this.fromString(J,E))}forge$6.jsbn.BigInteger=BigInteger$2;function nbi(){return new BigInteger$2(null)}function am1(J,E,ee,te,re,ne){for(;--ne>=0;){var ie=E*this.data[J++]+ee.data[te]+re;re=Math.floor(ie/67108864),ee.data[te++]=ie&67108863}return re}function am2(J,E,ee,te,re,ne){for(var ie=E&32767,se=E>>15;--ne>=0;){var oe=this.data[J]&32767,ce=this.data[J++]>>15,ae=se*oe+ce*ie;oe=ie*oe+((ae&32767)<<15)+ee.data[te]+(re&1073741823),re=(oe>>>30)+(ae>>>15)+se*ce+(re>>>30),ee.data[te++]=oe&1073741823}return re}function am3(J,E,ee,te,re,ne){for(var ie=E&16383,se=E>>14;--ne>=0;){var oe=this.data[J]&16383,ce=this.data[J++]>>14,ae=se*oe+ce*ie;oe=ie*oe+((ae&16383)<<14)+ee.data[te]+re,re=(oe>>28)+(ae>>14)+se*ce,ee.data[te++]=oe&268435455}return re}typeof navigator>"u"?(BigInteger$2.prototype.am=am3,dbits=28):navigator.appName=="Microsoft Internet Explorer"?(BigInteger$2.prototype.am=am2,dbits=30):navigator.appName!="Netscape"?(BigInteger$2.prototype.am=am1,dbits=26):(BigInteger$2.prototype.am=am3,dbits=28);BigInteger$2.prototype.DB=dbits;BigInteger$2.prototype.DM=(1<<dbits)-1;BigInteger$2.prototype.DV=1<<dbits;var BI_FP=52;BigInteger$2.prototype.FV=Math.pow(2,BI_FP);BigInteger$2.prototype.F1=BI_FP-dbits;BigInteger$2.prototype.F2=2*dbits-BI_FP;var BI_RM="0123456789abcdefghijklmnopqrstuvwxyz",BI_RC=new Array,rr,vv;rr="0".charCodeAt(0);for(vv=0;vv<=9;++vv)BI_RC[rr++]=vv;rr="a".charCodeAt(0);for(vv=10;vv<36;++vv)BI_RC[rr++]=vv;rr="A".charCodeAt(0);for(vv=10;vv<36;++vv)BI_RC[rr++]=vv;function int2char(J){return BI_RM.charAt(J)}function intAt(J,E){var ee=BI_RC[J.charCodeAt(E)];return ee??-1}function bnpCopyTo(J){for(var E=this.t-1;E>=0;--E)J.data[E]=this.data[E];J.t=this.t,J.s=this.s}function bnpFromInt(J){this.t=1,this.s=J<0?-1:0,J>0?this.data[0]=J:J<-1?this.data[0]=J+this.DV:this.t=0}function nbv(J){var E=nbi();return E.fromInt(J),E}function bnpFromString(J,E){var ee;if(E==16)ee=4;else if(E==8)ee=3;else if(E==256)ee=8;else if(E==2)ee=1;else if(E==32)ee=5;else if(E==4)ee=2;else{this.fromRadix(J,E);return}this.t=0,this.s=0;for(var te=J.length,re=!1,ne=0;--te>=0;){var ie=ee==8?J[te]&255:intAt(J,te);if(ie<0){J.charAt(te)=="-"&&(re=!0);continue}re=!1,ne==0?this.data[this.t++]=ie:ne+ee>this.DB?(this.data[this.t-1]|=(ie&(1<<this.DB-ne)-1)<<ne,this.data[this.t++]=ie>>this.DB-ne):this.data[this.t-1]|=ie<<ne,ne+=ee,ne>=this.DB&&(ne-=this.DB)}ee==8&&J[0]&128&&(this.s=-1,ne>0&&(this.data[this.t-1]|=(1<<this.DB-ne)-1<<ne)),this.clamp(),re&&BigInteger$2.ZERO.subTo(this,this)}function bnpClamp(){for(var J=this.s&this.DM;this.t>0&&this.data[this.t-1]==J;)--this.t}function bnToString(J){if(this.s<0)return"-"+this.negate().toString(J);var E;if(J==16)E=4;else if(J==8)E=3;else if(J==2)E=1;else if(J==32)E=5;else if(J==4)E=2;else return this.toRadix(J);var ee=(1<<E)-1,te,re=!1,ne="",ie=this.t,se=this.DB-ie*this.DB%E;if(ie-- >0)for(se<this.DB&&(te=this.data[ie]>>se)>0&&(re=!0,ne=int2char(te));ie>=0;)se<E?(te=(this.data[ie]&(1<<se)-1)<<E-se,te|=this.data[--ie]>>(se+=this.DB-E)):(te=this.data[ie]>>(se-=E)&ee,se<=0&&(se+=this.DB,--ie)),te>0&&(re=!0),re&&(ne+=int2char(te));return re?ne:"0"}function bnNegate(){var J=nbi();return BigInteger$2.ZERO.subTo(this,J),J}function bnAbs(){return this.s<0?this.negate():this}function bnCompareTo(J){var E=this.s-J.s;if(E!=0)return E;var ee=this.t;if(E=ee-J.t,E!=0)return this.s<0?-E:E;for(;--ee>=0;)if((E=this.data[ee]-J.data[ee])!=0)return E;return 0}function nbits(J){var E=1,ee;return(ee=J>>>16)!=0&&(J=ee,E+=16),(ee=J>>8)!=0&&(J=ee,E+=8),(ee=J>>4)!=0&&(J=ee,E+=4),(ee=J>>2)!=0&&(J=ee,E+=2),(ee=J>>1)!=0&&(J=ee,E+=1),E}function bnBitLength(){return this.t<=0?0:this.DB*(this.t-1)+nbits(this.data[this.t-1]^this.s&this.DM)}function bnpDLShiftTo(J,E){var ee;for(ee=this.t-1;ee>=0;--ee)E.data[ee+J]=this.data[ee];for(ee=J-1;ee>=0;--ee)E.data[ee]=0;E.t=this.t+J,E.s=this.s}function bnpDRShiftTo(J,E){for(var ee=J;ee<this.t;++ee)E.data[ee-J]=this.data[ee];E.t=Math.max(this.t-J,0),E.s=this.s}function bnpLShiftTo(J,E){var ee=J%this.DB,te=this.DB-ee,re=(1<<te)-1,ne=Math.floor(J/this.DB),ie=this.s<<ee&this.DM,se;for(se=this.t-1;se>=0;--se)E.data[se+ne+1]=this.data[se]>>te|ie,ie=(this.data[se]&re)<<ee;for(se=ne-1;se>=0;--se)E.data[se]=0;E.data[ne]=ie,E.t=this.t+ne+1,E.s=this.s,E.clamp()}function bnpRShiftTo(J,E){E.s=this.s;var ee=Math.floor(J/this.DB);if(ee>=this.t){E.t=0;return}var te=J%this.DB,re=this.DB-te,ne=(1<<te)-1;E.data[0]=this.data[ee]>>te;for(var ie=ee+1;ie<this.t;++ie)E.data[ie-ee-1]|=(this.data[ie]&ne)<<re,E.data[ie-ee]=this.data[ie]>>te;te>0&&(E.data[this.t-ee-1]|=(this.s&ne)<<re),E.t=this.t-ee,E.clamp()}function bnpSubTo(J,E){for(var ee=0,te=0,re=Math.min(J.t,this.t);ee<re;)te+=this.data[ee]-J.data[ee],E.data[ee++]=te&this.DM,te>>=this.DB;if(J.t<this.t){for(te-=J.s;ee<this.t;)te+=this.data[ee],E.data[ee++]=te&this.DM,te>>=this.DB;te+=this.s}else{for(te+=this.s;ee<J.t;)te-=J.data[ee],E.data[ee++]=te&this.DM,te>>=this.DB;te-=J.s}E.s=te<0?-1:0,te<-1?E.data[ee++]=this.DV+te:te>0&&(E.data[ee++]=te),E.t=ee,E.clamp()}function bnpMultiplyTo(J,E){var ee=this.abs(),te=J.abs(),re=ee.t;for(E.t=re+te.t;--re>=0;)E.data[re]=0;for(re=0;re<te.t;++re)E.data[re+ee.t]=ee.am(0,te.data[re],E,re,0,ee.t);E.s=0,E.clamp(),this.s!=J.s&&BigInteger$2.ZERO.subTo(E,E)}function bnpSquareTo(J){for(var E=this.abs(),ee=J.t=2*E.t;--ee>=0;)J.data[ee]=0;for(ee=0;ee<E.t-1;++ee){var te=E.am(ee,E.data[ee],J,2*ee,0,1);(J.data[ee+E.t]+=E.am(ee+1,2*E.data[ee],J,2*ee+1,te,E.t-ee-1))>=E.DV&&(J.data[ee+E.t]-=E.DV,J.data[ee+E.t+1]=1)}J.t>0&&(J.data[J.t-1]+=E.am(ee,E.data[ee],J,2*ee,0,1)),J.s=0,J.clamp()}function bnpDivRemTo(J,E,ee){var te=J.abs();if(!(te.t<=0)){var re=this.abs();if(re.t<te.t){E?.fromInt(0),ee!=null&&this.copyTo(ee);return}ee==null&&(ee=nbi());var ne=nbi(),ie=this.s,se=J.s,oe=this.DB-nbits(te.data[te.t-1]);oe>0?(te.lShiftTo(oe,ne),re.lShiftTo(oe,ee)):(te.copyTo(ne),re.copyTo(ee));var ce=ne.t,ae=ne.data[ce-1];if(ae!=0){var le=ae*(1<<this.F1)+(ce>1?ne.data[ce-2]>>this.F2:0),ue=this.FV/le,he=(1<<this.F1)/le,pe=1<<this.F2,de=ee.t,fe=de-ce,me=E??nbi();for(ne.dlShiftTo(fe,me),ee.compareTo(me)>=0&&(ee.data[ee.t++]=1,ee.subTo(me,ee)),BigInteger$2.ONE.dlShiftTo(ce,me),me.subTo(ne,ne);ne.t<ce;)ne.data[ne.t++]=0;for(;--fe>=0;){var _e=ee.data[--de]==ae?this.DM:Math.floor(ee.data[de]*ue+(ee.data[de-1]+pe)*he);if((ee.data[de]+=ne.am(0,_e,ee,fe,0,ce))<_e)for(ne.dlShiftTo(fe,me),ee.subTo(me,ee);ee.data[de]<--_e;)ee.subTo(me,ee)}E!=null&&(ee.drShiftTo(ce,E),ie!=se&&BigInteger$2.ZERO.subTo(E,E)),ee.t=ce,ee.clamp(),oe>0&&ee.rShiftTo(oe,ee),ie<0&&BigInteger$2.ZERO.subTo(ee,ee)}}}function bnMod(J){var E=nbi();return this.abs().divRemTo(J,null,E),this.s<0&&E.compareTo(BigInteger$2.ZERO)>0&&J.subTo(E,E),E}function Classic(J){this.m=J}function cConvert(J){return J.s<0||J.compareTo(this.m)>=0?J.mod(this.m):J}function cRevert(J){return J}function cReduce(J){J.divRemTo(this.m,null,J)}function cMulTo(J,E,ee){J.multiplyTo(E,ee),this.reduce(ee)}function cSqrTo(J,E){J.squareTo(E),this.reduce(E)}Classic.prototype.convert=cConvert;Classic.prototype.revert=cRevert;Classic.prototype.reduce=cReduce;Classic.prototype.mulTo=cMulTo;Classic.prototype.sqrTo=cSqrTo;function bnpInvDigit(){if(this.t<1)return 0;var J=this.data[0];if(!(J&1))return 0;var E=J&3;return E=E*(2-(J&15)*E)&15,E=E*(2-(J&255)*E)&255,E=E*(2-((J&65535)*E&65535))&65535,E=E*(2-J*E%this.DV)%this.DV,E>0?this.DV-E:-E}function Montgomery(J){this.m=J,this.mp=J.invDigit(),this.mpl=this.mp&32767,this.mph=this.mp>>15,this.um=(1<<J.DB-15)-1,this.mt2=2*J.t}function montConvert(J){var E=nbi();return J.abs().dlShiftTo(this.m.t,E),E.divRemTo(this.m,null,E),J.s<0&&E.compareTo(BigInteger$2.ZERO)>0&&this.m.subTo(E,E),E}function montRevert(J){var E=nbi();return J.copyTo(E),this.reduce(E),E}function montReduce(J){for(;J.t<=this.mt2;)J.data[J.t++]=0;for(var E=0;E<this.m.t;++E){var ee=J.data[E]&32767,te=ee*this.mpl+((ee*this.mph+(J.data[E]>>15)*this.mpl&this.um)<<15)&J.DM;for(ee=E+this.m.t,J.data[ee]+=this.m.am(0,te,J,E,0,this.m.t);J.data[ee]>=J.DV;)J.data[ee]-=J.DV,J.data[++ee]++}J.clamp(),J.drShiftTo(this.m.t,J),J.compareTo(this.m)>=0&&J.subTo(this.m,J)}function montSqrTo(J,E){J.squareTo(E),this.reduce(E)}function montMulTo(J,E,ee){J.multiplyTo(E,ee),this.reduce(ee)}Montgomery.prototype.convert=montConvert;Montgomery.prototype.revert=montRevert;Montgomery.prototype.reduce=montReduce;Montgomery.prototype.mulTo=montMulTo;Montgomery.prototype.sqrTo=montSqrTo;function bnpIsEven(){return(this.t>0?this.data[0]&1:this.s)==0}function bnpExp(J,E){if(J>4294967295||J<1)return BigInteger$2.ONE;var ee=nbi(),te=nbi(),re=E.convert(this),ne=nbits(J)-1;for(re.copyTo(ee);--ne>=0;)if(E.sqrTo(ee,te),(J&1<<ne)>0)E.mulTo(te,re,ee);else{var ie=ee;ee=te,te=ie}return E.revert(ee)}function bnModPowInt(J,E){var ee;return J<256||E.isEven()?ee=new Classic(E):ee=new Montgomery(E),this.exp(J,ee)}BigInteger$2.prototype.copyTo=bnpCopyTo;BigInteger$2.prototype.fromInt=bnpFromInt;BigInteger$2.prototype.fromString=bnpFromString;BigInteger$2.prototype.clamp=bnpClamp;BigInteger$2.prototype.dlShiftTo=bnpDLShiftTo;BigInteger$2.prototype.drShiftTo=bnpDRShiftTo;BigInteger$2.prototype.lShiftTo=bnpLShiftTo;BigInteger$2.prototype.rShiftTo=bnpRShiftTo;BigInteger$2.prototype.subTo=bnpSubTo;BigInteger$2.prototype.multiplyTo=bnpMultiplyTo;BigInteger$2.prototype.squareTo=bnpSquareTo;BigInteger$2.prototype.divRemTo=bnpDivRemTo;BigInteger$2.prototype.invDigit=bnpInvDigit;BigInteger$2.prototype.isEven=bnpIsEven;BigInteger$2.prototype.exp=bnpExp;BigInteger$2.prototype.toString=bnToString;BigInteger$2.prototype.negate=bnNegate;BigInteger$2.prototype.abs=bnAbs;BigInteger$2.prototype.compareTo=bnCompareTo;BigInteger$2.prototype.bitLength=bnBitLength;BigInteger$2.prototype.mod=bnMod;BigInteger$2.prototype.modPowInt=bnModPowInt;BigInteger$2.ZERO=nbv(0);BigInteger$2.ONE=nbv(1);function bnClone(){var J=nbi();return this.copyTo(J),J}function bnIntValue(){if(this.s<0){if(this.t==1)return this.data[0]-this.DV;if(this.t==0)return-1}else{if(this.t==1)return this.data[0];if(this.t==0)return 0}return(this.data[1]&(1<<32-this.DB)-1)<<this.DB|this.data[0]}function bnByteValue(){return this.t==0?this.s:this.data[0]<<24>>24}function bnShortValue(){return this.t==0?this.s:this.data[0]<<16>>16}function bnpChunkSize(J){return Math.floor(Math.LN2*this.DB/Math.log(J))}function bnSigNum(){return this.s<0?-1:this.t<=0||this.t==1&&this.data[0]<=0?0:1}function bnpToRadix(J){if(J==null&&(J=10),this.signum()==0||J<2||J>36)return"0";var E=this.chunkSize(J),ee=Math.pow(J,E),te=nbv(ee),re=nbi(),ne=nbi(),ie="";for(this.divRemTo(te,re,ne);re.signum()>0;)ie=(ee+ne.intValue()).toString(J).substr(1)+ie,re.divRemTo(te,re,ne);return ne.intValue().toString(J)+ie}function bnpFromRadix(J,E){this.fromInt(0),E==null&&(E=10);for(var ee=this.chunkSize(E),te=Math.pow(E,ee),re=!1,ne=0,ie=0,se=0;se<J.length;++se){var oe=intAt(J,se);if(oe<0){J.charAt(se)=="-"&&this.signum()==0&&(re=!0);continue}ie=E*ie+oe,++ne>=ee&&(this.dMultiply(te),this.dAddOffset(ie,0),ne=0,ie=0)}ne>0&&(this.dMultiply(Math.pow(E,ne)),this.dAddOffset(ie,0)),re&&BigInteger$2.ZERO.subTo(this,this)}function bnpFromNumber(J,E,ee){if(typeof E=="number")if(J<2)this.fromInt(1);else for(this.fromNumber(J,ee),this.testBit(J-1)||this.bitwiseTo(BigInteger$2.ONE.shiftLeft(J-1),op_or,this),this.isEven()&&this.dAddOffset(1,0);!this.isProbablePrime(E);)this.dAddOffset(2,0),this.bitLength()>J&&this.subTo(BigInteger$2.ONE.shiftLeft(J-1),this);else{var te=new Array,re=J&7;te.length=(J>>3)+1,E.nextBytes(te),re>0?te[0]&=(1<<re)-1:te[0]=0,this.fromString(te,256)}}function bnToByteArray(){var J=this.t,E=new Array;E[0]=this.s;var ee=this.DB-J*this.DB%8,te,re=0;if(J-- >0)for(ee<this.DB&&(te=this.data[J]>>ee)!=(this.s&this.DM)>>ee&&(E[re++]=te|this.s<<this.DB-ee);J>=0;)ee<8?(te=(this.data[J]&(1<<ee)-1)<<8-ee,te|=this.data[--J]>>(ee+=this.DB-8)):(te=this.data[J]>>(ee-=8)&255,ee<=0&&(ee+=this.DB,--J)),te&128&&(te|=-256),re==0&&(this.s&128)!=(te&128)&&++re,(re>0||te!=this.s)&&(E[re++]=te);return E}function bnEquals(J){return this.compareTo(J)==0}function bnMin(J){return this.compareTo(J)<0?this:J}function bnMax(J){return this.compareTo(J)>0?this:J}function bnpBitwiseTo(J,E,ee){var te,re,ne=Math.min(J.t,this.t);for(te=0;te<ne;++te)ee.data[te]=E(this.data[te],J.data[te]);if(J.t<this.t){for(re=J.s&this.DM,te=ne;te<this.t;++te)ee.data[te]=E(this.data[te],re);ee.t=this.t}else{for(re=this.s&this.DM,te=ne;te<J.t;++te)ee.data[te]=E(re,J.data[te]);ee.t=J.t}ee.s=E(this.s,J.s),ee.clamp()}function op_and(J,E){return J&E}function bnAnd(J){var E=nbi();return this.bitwiseTo(J,op_and,E),E}function op_or(J,E){return J|E}function bnOr(J){var E=nbi();return this.bitwiseTo(J,op_or,E),E}function op_xor(J,E){return J^E}function bnXor(J){var E=nbi();return this.bitwiseTo(J,op_xor,E),E}function op_andnot(J,E){return J&~E}function bnAndNot(J){var E=nbi();return this.bitwiseTo(J,op_andnot,E),E}function bnNot(){for(var J=nbi(),E=0;E<this.t;++E)J.data[E]=this.DM&~this.data[E];return J.t=this.t,J.s=~this.s,J}function bnShiftLeft(J){var E=nbi();return J<0?this.rShiftTo(-J,E):this.lShiftTo(J,E),E}function bnShiftRight(J){var E=nbi();return J<0?this.lShiftTo(-J,E):this.rShiftTo(J,E),E}function lbit(J){if(J==0)return-1;var E=0;return J&65535||(J>>=16,E+=16),J&255||(J>>=8,E+=8),J&15||(J>>=4,E+=4),J&3||(J>>=2,E+=2),J&1||++E,E}function bnGetLowestSetBit(){for(var J=0;J<this.t;++J)if(this.data[J]!=0)return J*this.DB+lbit(this.data[J]);return this.s<0?this.t*this.DB:-1}function cbit(J){for(var E=0;J!=0;)J&=J-1,++E;return E}function bnBitCount(){for(var J=0,E=this.s&this.DM,ee=0;ee<this.t;++ee)J+=cbit(this.data[ee]^E);return J}function bnTestBit(J){var E=Math.floor(J/this.DB);return E>=this.t?this.s!=0:(this.data[E]&1<<J%this.DB)!=0}function bnpChangeBit(J,E){var ee=BigInteger$2.ONE.shiftLeft(J);return this.bitwiseTo(ee,E,ee),ee}function bnSetBit(J){return this.changeBit(J,op_or)}function bnClearBit(J){return this.changeBit(J,op_andnot)}function bnFlipBit(J){return this.changeBit(J,op_xor)}function bnpAddTo(J,E){for(var ee=0,te=0,re=Math.min(J.t,this.t);ee<re;)te+=this.data[ee]+J.data[ee],E.data[ee++]=te&this.DM,te>>=this.DB;if(J.t<this.t){for(te+=J.s;ee<this.t;)te+=this.data[ee],E.data[ee++]=te&this.DM,te>>=this.DB;te+=this.s}else{for(te+=this.s;ee<J.t;)te+=J.data[ee],E.data[ee++]=te&this.DM,te>>=this.DB;te+=J.s}E.s=te<0?-1:0,te>0?E.data[ee++]=te:te<-1&&(E.data[ee++]=this.DV+te),E.t=ee,E.clamp()}function bnAdd(J){var E=nbi();return this.addTo(J,E),E}function bnSubtract(J){var E=nbi();return this.subTo(J,E),E}function bnMultiply(J){var E=nbi();return this.multiplyTo(J,E),E}function bnDivide(J){var E=nbi();return this.divRemTo(J,E,null),E}function bnRemainder(J){var E=nbi();return this.divRemTo(J,null,E),E}function bnDivideAndRemainder(J){var E=nbi(),ee=nbi();return this.divRemTo(J,E,ee),new Array(E,ee)}function bnpDMultiply(J){this.data[this.t]=this.am(0,J-1,this,0,0,this.t),++this.t,this.clamp()}function bnpDAddOffset(J,E){if(J!=0){for(;this.t<=E;)this.data[this.t++]=0;for(this.data[E]+=J;this.data[E]>=this.DV;)this.data[E]-=this.DV,++E>=this.t&&(this.data[this.t++]=0),++this.data[E]}}function NullExp(){}function nNop(J){return J}function nMulTo(J,E,ee){J.multiplyTo(E,ee)}function nSqrTo(J,E){J.squareTo(E)}NullExp.prototype.convert=nNop;NullExp.prototype.revert=nNop;NullExp.prototype.mulTo=nMulTo;NullExp.prototype.sqrTo=nSqrTo;function bnPow(J){return this.exp(J,new NullExp)}function bnpMultiplyLowerTo(J,E,ee){var te=Math.min(this.t+J.t,E);for(ee.s=0,ee.t=te;te>0;)ee.data[--te]=0;var re;for(re=ee.t-this.t;te<re;++te)ee.data[te+this.t]=this.am(0,J.data[te],ee,te,0,this.t);for(re=Math.min(J.t,E);te<re;++te)this.am(0,J.data[te],ee,te,0,E-te);ee.clamp()}function bnpMultiplyUpperTo(J,E,ee){--E;var te=ee.t=this.t+J.t-E;for(ee.s=0;--te>=0;)ee.data[te]=0;for(te=Math.max(E-this.t,0);te<J.t;++te)ee.data[this.t+te-E]=this.am(E-te,J.data[te],ee,0,0,this.t+te-E);ee.clamp(),ee.drShiftTo(1,ee)}function Barrett(J){this.r2=nbi(),this.q3=nbi(),BigInteger$2.ONE.dlShiftTo(2*J.t,this.r2),this.mu=this.r2.divide(J),this.m=J}function barrettConvert(J){if(J.s<0||J.t>2*this.m.t)return J.mod(this.m);if(J.compareTo(this.m)<0)return J;var E=nbi();return J.copyTo(E),this.reduce(E),E}function barrettRevert(J){return J}function barrettReduce(J){for(J.drShiftTo(this.m.t-1,this.r2),J.t>this.m.t+1&&(J.t=this.m.t+1,J.clamp()),this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3),this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);J.compareTo(this.r2)<0;)J.dAddOffset(1,this.m.t+1);for(J.subTo(this.r2,J);J.compareTo(this.m)>=0;)J.subTo(this.m,J)}function barrettSqrTo(J,E){J.squareTo(E),this.reduce(E)}function barrettMulTo(J,E,ee){J.multiplyTo(E,ee),this.reduce(ee)}Barrett.prototype.convert=barrettConvert;Barrett.prototype.revert=barrettRevert;Barrett.prototype.reduce=barrettReduce;Barrett.prototype.mulTo=barrettMulTo;Barrett.prototype.sqrTo=barrettSqrTo;function bnModPow(J,E){var ee=J.bitLength(),te,re=nbv(1),ne;if(ee<=0)return re;ee<18?te=1:ee<48?te=3:ee<144?te=4:ee<768?te=5:te=6,ee<8?ne=new Classic(E):E.isEven()?ne=new Barrett(E):ne=new Montgomery(E);var ie=new Array,se=3,oe=te-1,ce=(1<<te)-1;if(ie[1]=ne.convert(this),te>1){var ae=nbi();for(ne.sqrTo(ie[1],ae);se<=ce;)ie[se]=nbi(),ne.mulTo(ae,ie[se-2],ie[se]),se+=2}var le=J.t-1,ue,he=!0,pe=nbi(),de;for(ee=nbits(J.data[le])-1;le>=0;){for(ee>=oe?ue=J.data[le]>>ee-oe&ce:(ue=(J.data[le]&(1<<ee+1)-1)<<oe-ee,le>0&&(ue|=J.data[le-1]>>this.DB+ee-oe)),se=te;!(ue&1);)ue>>=1,--se;if((ee-=se)<0&&(ee+=this.DB,--le),he)ie[ue].copyTo(re),he=!1;else{for(;se>1;)ne.sqrTo(re,pe),ne.sqrTo(pe,re),se-=2;se>0?ne.sqrTo(re,pe):(de=re,re=pe,pe=de),ne.mulTo(pe,ie[ue],re)}for(;le>=0&&!(J.data[le]&1<<ee);)ne.sqrTo(re,pe),de=re,re=pe,pe=de,--ee<0&&(ee=this.DB-1,--le)}return ne.revert(re)}function bnGCD(J){var E=this.s<0?this.negate():this.clone(),ee=J.s<0?J.negate():J.clone();if(E.compareTo(ee)<0){var te=E;E=ee,ee=te}var re=E.getLowestSetBit(),ne=ee.getLowestSetBit();if(ne<0)return E;for(re<ne&&(ne=re),ne>0&&(E.rShiftTo(ne,E),ee.rShiftTo(ne,ee));E.signum()>0;)(re=E.getLowestSetBit())>0&&E.rShiftTo(re,E),(re=ee.getLowestSetBit())>0&&ee.rShiftTo(re,ee),E.compareTo(ee)>=0?(E.subTo(ee,E),E.rShiftTo(1,E)):(ee.subTo(E,ee),ee.rShiftTo(1,ee));return ne>0&&ee.lShiftTo(ne,ee),ee}function bnpModInt(J){if(J<=0)return 0;var E=this.DV%J,ee=this.s<0?J-1:0;if(this.t>0)if(E==0)ee=this.data[0]%J;else for(var te=this.t-1;te>=0;--te)ee=(E*ee+this.data[te])%J;return ee}function bnModInverse(J){var E=J.isEven();if(this.isEven()&&E||J.signum()==0)return BigInteger$2.ZERO;for(var ee=J.clone(),te=this.clone(),re=nbv(1),ne=nbv(0),ie=nbv(0),se=nbv(1);ee.signum()!=0;){for(;ee.isEven();)ee.rShiftTo(1,ee),E?((!re.isEven()||!ne.isEven())&&(re.addTo(this,re),ne.subTo(J,ne)),re.rShiftTo(1,re)):ne.isEven()||ne.subTo(J,ne),ne.rShiftTo(1,ne);for(;te.isEven();)te.rShiftTo(1,te),E?((!ie.isEven()||!se.isEven())&&(ie.addTo(this,ie),se.subTo(J,se)),ie.rShiftTo(1,ie)):se.isEven()||se.subTo(J,se),se.rShiftTo(1,se);ee.compareTo(te)>=0?(ee.subTo(te,ee),E&&re.subTo(ie,re),ne.subTo(se,ne)):(te.subTo(ee,te),E&&ie.subTo(re,ie),se.subTo(ne,se))}if(te.compareTo(BigInteger$2.ONE)!=0)return BigInteger$2.ZERO;if(se.compareTo(J)>=0)return se.subtract(J);if(se.signum()<0)se.addTo(J,se);else return se;return se.signum()<0?se.add(J):se}var lowprimes=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509],lplim=(1<<26)/lowprimes[lowprimes.length-1];function bnIsProbablePrime(J){var E,ee=this.abs();if(ee.t==1&&ee.data[0]<=lowprimes[lowprimes.length-1]){for(E=0;E<lowprimes.length;++E)if(ee.data[0]==lowprimes[E])return!0;return!1}if(ee.isEven())return!1;for(E=1;E<lowprimes.length;){for(var te=lowprimes[E],re=E+1;re<lowprimes.length&&te<lplim;)te*=lowprimes[re++];for(te=ee.modInt(te);E<re;)if(te%lowprimes[E++]==0)return!1}return ee.millerRabin(J)}function bnpMillerRabin(J){var E=this.subtract(BigInteger$2.ONE),ee=E.getLowestSetBit();if(ee<=0)return!1;for(var te=E.shiftRight(ee),re=bnGetPrng(),ne,ie=0;ie<J;++ie){do ne=new BigInteger$2(this.bitLength(),re);while(ne.compareTo(BigInteger$2.ONE)<=0||ne.compareTo(E)>=0);var se=ne.modPow(te,this);if(se.compareTo(BigInteger$2.ONE)!=0&&se.compareTo(E)!=0){for(var oe=1;oe++<ee&&se.compareTo(E)!=0;)if(se=se.modPowInt(2,this),se.compareTo(BigInteger$2.ONE)==0)return!1;if(se.compareTo(E)!=0)return!1}}return!0}function bnGetPrng(){return{nextBytes:function(J){for(var E=0;E<J.length;++E)J[E]=Math.floor(Math.random()*256)}}}BigInteger$2.prototype.chunkSize=bnpChunkSize;BigInteger$2.prototype.toRadix=bnpToRadix;BigInteger$2.prototype.fromRadix=bnpFromRadix;BigInteger$2.prototype.fromNumber=bnpFromNumber;BigInteger$2.prototype.bitwiseTo=bnpBitwiseTo;BigInteger$2.prototype.changeBit=bnpChangeBit;BigInteger$2.prototype.addTo=bnpAddTo;BigInteger$2.prototype.dMultiply=bnpDMultiply;BigInteger$2.prototype.dAddOffset=bnpDAddOffset;BigInteger$2.prototype.multiplyLowerTo=bnpMultiplyLowerTo;BigInteger$2.prototype.multiplyUpperTo=bnpMultiplyUpperTo;BigInteger$2.prototype.modInt=bnpModInt;BigInteger$2.prototype.millerRabin=bnpMillerRabin;BigInteger$2.prototype.clone=bnClone;BigInteger$2.prototype.intValue=bnIntValue;BigInteger$2.prototype.byteValue=bnByteValue;BigInteger$2.prototype.shortValue=bnShortValue;BigInteger$2.prototype.signum=bnSigNum;BigInteger$2.prototype.toByteArray=bnToByteArray;BigInteger$2.prototype.equals=bnEquals;BigInteger$2.prototype.min=bnMin;BigInteger$2.prototype.max=bnMax;BigInteger$2.prototype.and=bnAnd;BigInteger$2.prototype.or=bnOr;BigInteger$2.prototype.xor=bnXor;BigInteger$2.prototype.andNot=bnAndNot;BigInteger$2.prototype.not=bnNot;BigInteger$2.prototype.shiftLeft=bnShiftLeft;BigInteger$2.prototype.shiftRight=bnShiftRight;BigInteger$2.prototype.getLowestSetBit=bnGetLowestSetBit;BigInteger$2.prototype.bitCount=bnBitCount;BigInteger$2.prototype.testBit=bnTestBit;BigInteger$2.prototype.setBit=bnSetBit;BigInteger$2.prototype.clearBit=bnClearBit;BigInteger$2.prototype.flipBit=bnFlipBit;BigInteger$2.prototype.add=bnAdd;BigInteger$2.prototype.subtract=bnSubtract;BigInteger$2.prototype.multiply=bnMultiply;BigInteger$2.prototype.divide=bnDivide;BigInteger$2.prototype.remainder=bnRemainder;BigInteger$2.prototype.divideAndRemainder=bnDivideAndRemainder;BigInteger$2.prototype.modPow=bnModPow;BigInteger$2.prototype.modInverse=bnModInverse;BigInteger$2.prototype.pow=bnPow;BigInteger$2.prototype.gcd=bnGCD;BigInteger$2.prototype.isProbablePrime=bnIsProbablePrime;var forge$5=forge$m,sha1=forge$5.sha1=forge$5.sha1||{};forge$5.md.sha1=forge$5.md.algorithms.sha1=sha1;sha1.create=function(){_initialized$1||_init$1();var J=null,E=forge$5.util.createBuffer(),ee=new Array(80),te={algorithm:"sha1",blockLength:64,digestLength:20,messageLength:0,fullMessageLength:null,messageLengthSize:8};return te.start=function(){te.messageLength=0,te.fullMessageLength=te.messageLength64=[];for(var re=te.messageLengthSize/4,ne=0;ne<re;++ne)te.fullMessageLength.push(0);return E=forge$5.util.createBuffer(),J={h0:1732584193,h1:4023233417,h2:2562383102,h3:271733878,h4:3285377520},te},te.start(),te.update=function(re,ne){ne==="utf8"&&(re=forge$5.util.encodeUtf8(re));var ie=re.length;te.messageLength+=ie,ie=[ie/4294967296>>>0,ie>>>0];for(var se=te.fullMessageLength.length-1;se>=0;--se)te.fullMessageLength[se]+=ie[1],ie[1]=ie[0]+(te.fullMessageLength[se]/4294967296>>>0),te.fullMessageLength[se]=te.fullMessageLength[se]>>>0,ie[0]=ie[1]/4294967296>>>0;return E.putBytes(re),_update$1(J,ee,E),(E.read>2048||E.length()===0)&&E.compact(),te},te.digest=function(){var re=forge$5.util.createBuffer();re.putBytes(E.bytes());var ne=te.fullMessageLength[te.fullMessageLength.length-1]+te.messageLengthSize,ie=ne&te.blockLength-1;re.putBytes(_padding$1.substr(0,te.blockLength-ie));for(var se,oe,ce=te.fullMessageLength[0]*8,ae=0;ae<te.fullMessageLength.length-1;++ae)se=te.fullMessageLength[ae+1]*8,oe=se/4294967296>>>0,ce+=oe,re.putInt32(ce>>>0),ce=se>>>0;re.putInt32(ce);var le={h0:J.h0,h1:J.h1,h2:J.h2,h3:J.h3,h4:J.h4};_update$1(le,ee,re);var ue=forge$5.util.createBuffer();return ue.putInt32(le.h0),ue.putInt32(le.h1),ue.putInt32(le.h2),ue.putInt32(le.h3),ue.putInt32(le.h4),ue},te};var _padding$1=null,_initialized$1=!1;function _init$1(){_padding$1=String.fromCharCode(128),_padding$1+=forge$5.util.fillString(String.fromCharCode(0),64),_initialized$1=!0}function _update$1(J,E,ee){for(var te,re,ne,ie,se,oe,ce,ae,le=ee.length();le>=64;){for(re=J.h0,ne=J.h1,ie=J.h2,se=J.h3,oe=J.h4,ae=0;ae<16;++ae)te=ee.getInt32(),E[ae]=te,ce=se^ne&(ie^se),te=(re<<5|re>>>27)+ce+oe+1518500249+te,oe=se,se=ie,ie=(ne<<30|ne>>>2)>>>0,ne=re,re=te;for(;ae<20;++ae)te=E[ae-3]^E[ae-8]^E[ae-14]^E[ae-16],te=te<<1|te>>>31,E[ae]=te,ce=se^ne&(ie^se),te=(re<<5|re>>>27)+ce+oe+1518500249+te,oe=se,se=ie,ie=(ne<<30|ne>>>2)>>>0,ne=re,re=te;for(;ae<32;++ae)te=E[ae-3]^E[ae-8]^E[ae-14]^E[ae-16],te=te<<1|te>>>31,E[ae]=te,ce=ne^ie^se,te=(re<<5|re>>>27)+ce+oe+1859775393+te,oe=se,se=ie,ie=(ne<<30|ne>>>2)>>>0,ne=re,re=te;for(;ae<40;++ae)te=E[ae-6]^E[ae-16]^E[ae-28]^E[ae-32],te=te<<2|te>>>30,E[ae]=te,ce=ne^ie^se,te=(re<<5|re>>>27)+ce+oe+1859775393+te,oe=se,se=ie,ie=(ne<<30|ne>>>2)>>>0,ne=re,re=te;for(;ae<60;++ae)te=E[ae-6]^E[ae-16]^E[ae-28]^E[ae-32],te=te<<2|te>>>30,E[ae]=te,ce=ne&ie|se&(ne^ie),te=(re<<5|re>>>27)+ce+oe+2400959708+te,oe=se,se=ie,ie=(ne<<30|ne>>>2)>>>0,ne=re,re=te;for(;ae<80;++ae)te=E[ae-6]^E[ae-16]^E[ae-28]^E[ae-32],te=te<<2|te>>>30,E[ae]=te,ce=ne^ie^se,te=(re<<5|re>>>27)+ce+oe+3395469782+te,oe=se,se=ie,ie=(ne<<30|ne>>>2)>>>0,ne=re,re=te;J.h0=J.h0+re|0,J.h1=J.h1+ne|0,J.h2=J.h2+ie|0,J.h3=J.h3+se|0,J.h4=J.h4+oe|0,le-=64}}var forge$4=forge$m,pkcs1=forge$4.pkcs1=forge$4.pkcs1||{};pkcs1.encode_rsa_oaep=function(J,E,ee){var te,re,ne,ie;typeof ee=="string"?(te=ee,re=arguments[3]||void 0,ne=arguments[4]||void 0):ee&&(te=ee.label||void 0,re=ee.seed||void 0,ne=ee.md||void 0,ee.mgf1&&ee.mgf1.md&&(ie=ee.mgf1.md)),ne?ne.start():ne=forge$4.md.sha1.create(),ie||(ie=ne);var se=Math.ceil(J.n.bitLength()/8),oe=se-2*ne.digestLength-2;if(E.length>oe){var ce=new Error("RSAES-OAEP input message length is too long.");throw ce.length=E.length,ce.maxLength=oe,ce}te||(te=""),ne.update(te,"raw");for(var ae=ne.digest(),le="",ue=oe-E.length,he=0;he<ue;he++)le+="\0";var pe=ae.getBytes()+le+""+E;if(!re)re=forge$4.random.getBytes(ne.digestLength);else if(re.length!==ne.digestLength){var ce=new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");throw ce.seedLength=re.length,ce.digestLength=ne.digestLength,ce}var de=rsa_mgf1(re,se-ne.digestLength-1,ie),fe=forge$4.util.xorBytes(pe,de,pe.length),me=rsa_mgf1(fe,ne.digestLength,ie),_e=forge$4.util.xorBytes(re,me,re.length);return"\0"+_e+fe};pkcs1.decode_rsa_oaep=function(J,E,ee){var te,re,ne;typeof ee=="string"?(te=ee,re=arguments[3]||void 0):ee&&(te=ee.label||void 0,re=ee.md||void 0,ee.mgf1&&ee.mgf1.md&&(ne=ee.mgf1.md));var ie=Math.ceil(J.n.bitLength()/8);if(E.length!==ie){var se=new Error("RSAES-OAEP encoded message length is invalid.");throw se.length=E.length,se.expectedLength=ie,se}if(re===void 0?re=forge$4.md.sha1.create():re.start(),ne||(ne=re),ie<2*re.digestLength+2)throw new Error("RSAES-OAEP key is too short for the hash function.");te||(te=""),re.update(te,"raw");for(var oe=re.digest().getBytes(),ce=E.charAt(0),ae=E.substring(1,re.digestLength+1),le=E.substring(1+re.digestLength),ue=rsa_mgf1(le,re.digestLength,ne),he=forge$4.util.xorBytes(ae,ue,ae.length),pe=rsa_mgf1(he,ie-re.digestLength-1,ne),de=forge$4.util.xorBytes(le,pe,le.length),fe=de.substring(0,re.digestLength),se=ce!=="\0",me=0;me<re.digestLength;++me)se|=oe.charAt(me)!==fe.charAt(me);for(var _e=1,be=re.digestLength,Ee=re.digestLength;Ee<de.length;Ee++){var ve=de.charCodeAt(Ee),we=ve&1^1,ge=_e?65534:0;se|=ve&ge,_e=_e&we,be+=_e}if(se||de.charCodeAt(be)!==1)throw new Error("Invalid RSAES-OAEP padding.");return de.substring(be+1)};function rsa_mgf1(J,E,ee){ee||(ee=forge$4.md.sha1.create());for(var te="",re=Math.ceil(E/ee.digestLength),ne=0;ne<re;++ne){var ie=String.fromCharCode(ne>>24&255,ne>>16&255,ne>>8&255,ne&255);ee.start(),ee.update(J+ie),te+=ee.digest().getBytes()}return te.substring(0,E)}var forge$3=forge$m;(function(){if(forge$3.prime){forge$3.prime;return}var J=forge$3.prime=forge$3.prime||{},E=forge$3.jsbn.BigInteger,ee=[6,4,2,4,2,4,6,2],te=new E(null);te.fromInt(30);var re=function(le,ue){return le|ue};J.generateProbablePrime=function(le,ue,he){typeof ue=="function"&&(he=ue,ue={}),ue=ue||{};var pe=ue.algorithm||"PRIMEINC";typeof pe=="string"&&(pe={name:pe}),pe.options=pe.options||{};var de=ue.prng||forge$3.random,fe={nextBytes:function(me){for(var _e=de.getBytesSync(me.length),be=0;be<me.length;++be)me[be]=_e.charCodeAt(be)}};if(pe.name==="PRIMEINC")return ne(le,fe,pe.options,he);throw new Error("Invalid prime generation algorithm: "+pe.name)};function ne(le,ue,he,pe){return"workers"in he?oe(le,ue,he,pe):ie(le,ue,he,pe)}function ie(le,ue,he,pe){var de=ce(le,ue),fe=0,me=ae(de.bitLength());"millerRabinTests"in he&&(me=he.millerRabinTests);var _e=10;"maxBlockTime"in he&&(_e=he.maxBlockTime),se(de,le,ue,fe,me,_e,pe)}function se(le,ue,he,pe,de,fe,me){var _e=+new Date;do{if(le.bitLength()>ue&&(le=ce(ue,he)),le.isProbablePrime(de))return me(null,le);le.dAddOffset(ee[pe++%8],0)}while(fe<0||+new Date-_e<fe);forge$3.util.setImmediate(function(){se(le,ue,he,pe,de,fe,me)})}function oe(le,ue,he,pe){if(typeof Worker>"u")return ie(le,ue,he,pe);var de=ce(le,ue),fe=he.workers,me=he.workLoad||100,_e=me*30/8,be=he.workerScript||"forge/prime.worker.js";if(fe===-1)return forge$3.util.estimateCores(function(ve,we){ve&&(we=2),fe=we-1,Ee()});Ee();function Ee(){fe=Math.max(1,fe);for(var ve=[],we=0;we<fe;++we)ve[we]=new Worker(be);for(var we=0;we<fe;++we)ve[we].addEventListener("message",Se);var ge=!1;function Se($e){if(!ge){var Pe=$e.data;if(Pe.found){for(var Me=0;Me<ve.length;++Me)ve[Me].terminate();return ge=!0,pe(null,new E(Pe.prime,16))}de.bitLength()>le&&(de=ce(le,ue));var xe=de.toString(16);$e.target.postMessage({hex:xe,workLoad:me}),de.dAddOffset(_e,0)}}}}function ce(le,ue){var he=new E(le,ue),pe=le-1;return he.testBit(pe)||he.bitwiseTo(E.ONE.shiftLeft(pe),re,he),he.dAddOffset(31-he.mod(te).byteValue(),0),he}function ae(le){return le<=100?27:le<=150?18:le<=200?15:le<=250?12:le<=300?9:le<=350?8:le<=400?7:le<=500?6:le<=600?5:le<=800?4:le<=1250?3:2}})();var forge$2=forge$m;if(typeof BigInteger$1>"u")var BigInteger$1=forge$2.jsbn.BigInteger;var _crypto=forge$2.util.isNodejs?require$$8:null,asn1$1=forge$2.asn1,util$6=forge$2.util;forge$2.pki=forge$2.pki||{};forge$2.pki.rsa=forge$2.rsa=forge$2.rsa||{};var pki$1=forge$2.pki,GCD_30_DELTA=[6,4,2,4,2,4,6,2],privateKeyValidator={name:"PrivateKeyInfo",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.SEQUENCE,constructed:!0,value:[{name:"PrivateKeyInfo.version",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.INTEGER,constructed:!1,capture:"privateKeyVersion"},{name:"PrivateKeyInfo.privateKeyAlgorithm",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.SEQUENCE,constructed:!0,value:[{name:"AlgorithmIdentifier.algorithm",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.OID,constructed:!1,capture:"privateKeyOid"}]},{name:"PrivateKeyInfo",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.OCTETSTRING,constructed:!1,capture:"privateKey"}]},rsaPrivateKeyValidator={name:"RSAPrivateKey",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.SEQUENCE,constructed:!0,value:[{name:"RSAPrivateKey.version",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.INTEGER,constructed:!1,capture:"privateKeyVersion"},{name:"RSAPrivateKey.modulus",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.INTEGER,constructed:!1,capture:"privateKeyModulus"},{name:"RSAPrivateKey.publicExponent",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.INTEGER,constructed:!1,capture:"privateKeyPublicExponent"},{name:"RSAPrivateKey.privateExponent",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.INTEGER,constructed:!1,capture:"privateKeyPrivateExponent"},{name:"RSAPrivateKey.prime1",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.INTEGER,constructed:!1,capture:"privateKeyPrime1"},{name:"RSAPrivateKey.prime2",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.INTEGER,constructed:!1,capture:"privateKeyPrime2"},{name:"RSAPrivateKey.exponent1",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.INTEGER,constructed:!1,capture:"privateKeyExponent1"},{name:"RSAPrivateKey.exponent2",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.INTEGER,constructed:!1,capture:"privateKeyExponent2"},{name:"RSAPrivateKey.coefficient",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.INTEGER,constructed:!1,capture:"privateKeyCoefficient"}]},rsaPublicKeyValidator={name:"RSAPublicKey",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.SEQUENCE,constructed:!0,value:[{name:"RSAPublicKey.modulus",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.INTEGER,constructed:!1,capture:"publicKeyModulus"},{name:"RSAPublicKey.exponent",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.INTEGER,constructed:!1,capture:"publicKeyExponent"}]},publicKeyValidator=forge$2.pki.rsa.publicKeyValidator={name:"SubjectPublicKeyInfo",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.SEQUENCE,constructed:!0,captureAsn1:"subjectPublicKeyInfo",value:[{name:"SubjectPublicKeyInfo.AlgorithmIdentifier",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.SEQUENCE,constructed:!0,value:[{name:"AlgorithmIdentifier.algorithm",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.OID,constructed:!1,capture:"publicKeyOid"}]},{name:"SubjectPublicKeyInfo.subjectPublicKey",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.BITSTRING,constructed:!1,value:[{name:"SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.SEQUENCE,constructed:!0,optional:!0,captureAsn1:"rsaPublicKey"}]}]},digestInfoValidator={name:"DigestInfo",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.SEQUENCE,constructed:!0,value:[{name:"DigestInfo.DigestAlgorithm",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.SEQUENCE,constructed:!0,value:[{name:"DigestInfo.DigestAlgorithm.algorithmIdentifier",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.OID,constructed:!1,capture:"algorithmIdentifier"},{name:"DigestInfo.DigestAlgorithm.parameters",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.NULL,capture:"parameters",optional:!0,constructed:!1}]},{name:"DigestInfo.digest",tagClass:asn1$1.Class.UNIVERSAL,type:asn1$1.Type.OCTETSTRING,constructed:!1,capture:"digest"}]},emsaPkcs1v15encode=function(J){var E;if(J.algorithm in pki$1.oids)E=pki$1.oids[J.algorithm];else{var ee=new Error("Unknown message digest algorithm.");throw ee.algorithm=J.algorithm,ee}var te=asn1$1.oidToDer(E).getBytes(),re=asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.SEQUENCE,!0,[]),ne=asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.SEQUENCE,!0,[]);ne.value.push(asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.OID,!1,te)),ne.value.push(asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.NULL,!1,""));var ie=asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.OCTETSTRING,!1,J.digest().getBytes());return re.value.push(ne),re.value.push(ie),asn1$1.toDer(re).getBytes()},_modPow=function(J,E,ee){if(ee)return J.modPow(E.e,E.n);if(!E.p||!E.q)return J.modPow(E.d,E.n);E.dP||(E.dP=E.d.mod(E.p.subtract(BigInteger$1.ONE))),E.dQ||(E.dQ=E.d.mod(E.q.subtract(BigInteger$1.ONE))),E.qInv||(E.qInv=E.q.modInverse(E.p));var te;do te=new BigInteger$1(forge$2.util.bytesToHex(forge$2.random.getBytes(E.n.bitLength()/8)),16);while(te.compareTo(E.n)>=0||!te.gcd(E.n).equals(BigInteger$1.ONE));J=J.multiply(te.modPow(E.e,E.n)).mod(E.n);for(var re=J.mod(E.p).modPow(E.dP,E.p),ne=J.mod(E.q).modPow(E.dQ,E.q);re.compareTo(ne)<0;)re=re.add(E.p);var ie=re.subtract(ne).multiply(E.qInv).mod(E.p).multiply(E.q).add(ne);return ie=ie.multiply(te.modInverse(E.n)).mod(E.n),ie};pki$1.rsa.encrypt=function(J,E,ee){var te=ee,re,ne=Math.ceil(E.n.bitLength()/8);ee!==!1&&ee!==!0?(te=ee===2,re=_encodePkcs1_v1_5(J,E,ee)):(re=forge$2.util.createBuffer(),re.putBytes(J));for(var ie=new BigInteger$1(re.toHex(),16),se=_modPow(ie,E,te),oe=se.toString(16),ce=forge$2.util.createBuffer(),ae=ne-Math.ceil(oe.length/2);ae>0;)ce.putByte(0),--ae;return ce.putBytes(forge$2.util.hexToBytes(oe)),ce.getBytes()};pki$1.rsa.decrypt=function(J,E,ee,te){var re=Math.ceil(E.n.bitLength()/8);if(J.length!==re){var ne=new Error("Encrypted message length is invalid.");throw ne.length=J.length,ne.expected=re,ne}var ie=new BigInteger$1(forge$2.util.createBuffer(J).toHex(),16);if(ie.compareTo(E.n)>=0)throw new Error("Encrypted message is invalid.");for(var se=_modPow(ie,E,ee),oe=se.toString(16),ce=forge$2.util.createBuffer(),ae=re-Math.ceil(oe.length/2);ae>0;)ce.putByte(0),--ae;return ce.putBytes(forge$2.util.hexToBytes(oe)),te!==!1?_decodePkcs1_v1_5(ce.getBytes(),E,ee):ce.getBytes()};pki$1.rsa.createKeyPairGenerationState=function(J,E,ee){typeof J=="string"&&(J=parseInt(J,10)),J=J||2048,ee=ee||{};var te=ee.prng||forge$2.random,re={nextBytes:function(se){for(var oe=te.getBytesSync(se.length),ce=0;ce<se.length;++ce)se[ce]=oe.charCodeAt(ce)}},ne=ee.algorithm||"PRIMEINC",ie;if(ne==="PRIMEINC")ie={algorithm:ne,state:0,bits:J,rng:re,eInt:E||65537,e:new BigInteger$1(null),p:null,q:null,qBits:J>>1,pBits:J-(J>>1),pqState:0,num:null,keys:null},ie.e.fromInt(ie.eInt);else throw new Error("Invalid key generation algorithm: "+ne);return ie};pki$1.rsa.stepKeyPairGenerationState=function(J,E){"algorithm"in J||(J.algorithm="PRIMEINC");var ee=new BigInteger$1(null);ee.fromInt(30);for(var te=0,re=function(le,ue){return le|ue},ne=+new Date,ie,se=0;J.keys===null&&(E<=0||se<E);){if(J.state===0){var oe=J.p===null?J.pBits:J.qBits,ce=oe-1;J.pqState===0?(J.num=new BigInteger$1(oe,J.rng),J.num.testBit(ce)||J.num.bitwiseTo(BigInteger$1.ONE.shiftLeft(ce),re,J.num),J.num.dAddOffset(31-J.num.mod(ee).byteValue(),0),te=0,++J.pqState):J.pqState===1?J.num.bitLength()>oe?J.pqState=0:J.num.isProbablePrime(_getMillerRabinTests(J.num.bitLength()))?++J.pqState:J.num.dAddOffset(GCD_30_DELTA[te++%8],0):J.pqState===2?J.pqState=J.num.subtract(BigInteger$1.ONE).gcd(J.e).compareTo(BigInteger$1.ONE)===0?3:0:J.pqState===3&&(J.pqState=0,J.p===null?J.p=J.num:J.q=J.num,J.p!==null&&J.q!==null&&++J.state,J.num=null)}else if(J.state===1)J.p.compareTo(J.q)<0&&(J.num=J.p,J.p=J.q,J.q=J.num),++J.state;else if(J.state===2)J.p1=J.p.subtract(BigInteger$1.ONE),J.q1=J.q.subtract(BigInteger$1.ONE),J.phi=J.p1.multiply(J.q1),++J.state;else if(J.state===3)J.phi.gcd(J.e).compareTo(BigInteger$1.ONE)===0?++J.state:(J.p=null,J.q=null,J.state=0);else if(J.state===4)J.n=J.p.multiply(J.q),J.n.bitLength()===J.bits?++J.state:(J.q=null,J.state=0);else if(J.state===5){var ae=J.e.modInverse(J.phi);J.keys={privateKey:pki$1.rsa.setPrivateKey(J.n,J.e,ae,J.p,J.q,ae.mod(J.p1),ae.mod(J.q1),J.q.modInverse(J.p)),publicKey:pki$1.rsa.setPublicKey(J.n,J.e)}}ie=+new Date,se+=ie-ne,ne=ie}return J.keys!==null};pki$1.rsa.generateKeyPair=function(J,E,ee,te){if(arguments.length===1?typeof J=="object"?(ee=J,J=void 0):typeof J=="function"&&(te=J,J=void 0):arguments.length===2?typeof J=="number"?typeof E=="function"?(te=E,E=void 0):typeof E!="number"&&(ee=E,E=void 0):(ee=J,te=E,J=void 0,E=void 0):arguments.length===3&&(typeof E=="number"?typeof ee=="function"&&(te=ee,ee=void 0):(te=ee,ee=E,E=void 0)),ee=ee||{},J===void 0&&(J=ee.bits||2048),E===void 0&&(E=ee.e||65537),!forge$2.options.usePureJavaScript&&!ee.prng&&J>=256&&J<=16384&&(E===65537||E===3)){if(te){if(_detectNodeCrypto("generateKeyPair"))return _crypto.generateKeyPair("rsa",{modulusLength:J,publicExponent:E,publicKeyEncoding:{type:"spki",format:"pem"},privateKeyEncoding:{type:"pkcs8",format:"pem"}},function(se,oe,ce){if(se)return te(se);te(null,{privateKey:pki$1.privateKeyFromPem(ce),publicKey:pki$1.publicKeyFromPem(oe)})});if(_detectSubtleCrypto("generateKey")&&_detectSubtleCrypto("exportKey"))return util$6.globalScope.crypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:J,publicExponent:_intToUint8Array(E),hash:{name:"SHA-256"}},!0,["sign","verify"]).then(function(se){return util$6.globalScope.crypto.subtle.exportKey("pkcs8",se.privateKey)}).then(void 0,function(se){te(se)}).then(function(se){if(se){var oe=pki$1.privateKeyFromAsn1(asn1$1.fromDer(forge$2.util.createBuffer(se)));te(null,{privateKey:oe,publicKey:pki$1.setRsaPublicKey(oe.n,oe.e)})}});if(_detectSubtleMsCrypto("generateKey")&&_detectSubtleMsCrypto("exportKey")){var re=util$6.globalScope.msCrypto.subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:J,publicExponent:_intToUint8Array(E),hash:{name:"SHA-256"}},!0,["sign","verify"]);re.oncomplete=function(se){var oe=se.target.result,ce=util$6.globalScope.msCrypto.subtle.exportKey("pkcs8",oe.privateKey);ce.oncomplete=function(ae){var le=ae.target.result,ue=pki$1.privateKeyFromAsn1(asn1$1.fromDer(forge$2.util.createBuffer(le)));te(null,{privateKey:ue,publicKey:pki$1.setRsaPublicKey(ue.n,ue.e)})},ce.onerror=function(ae){te(ae)}},re.onerror=function(se){te(se)};return}}else if(_detectNodeCrypto("generateKeyPairSync")){var ne=_crypto.generateKeyPairSync("rsa",{modulusLength:J,publicExponent:E,publicKeyEncoding:{type:"spki",format:"pem"},privateKeyEncoding:{type:"pkcs8",format:"pem"}});return{privateKey:pki$1.privateKeyFromPem(ne.privateKey),publicKey:pki$1.publicKeyFromPem(ne.publicKey)}}}var ie=pki$1.rsa.createKeyPairGenerationState(J,E,ee);if(!te)return pki$1.rsa.stepKeyPairGenerationState(ie,0),ie.keys;_generateKeyPair(ie,ee,te)};pki$1.setRsaPublicKey=pki$1.rsa.setPublicKey=function(J,E){var ee={n:J,e:E};return ee.encrypt=function(te,re,ne){if(typeof re=="string"?re=re.toUpperCase():re===void 0&&(re="RSAES-PKCS1-V1_5"),re==="RSAES-PKCS1-V1_5")re={encode:function(se,oe,ce){return _encodePkcs1_v1_5(se,oe,2).getBytes()}};else if(re==="RSA-OAEP"||re==="RSAES-OAEP")re={encode:function(se,oe){return forge$2.pkcs1.encode_rsa_oaep(oe,se,ne)}};else if(["RAW","NONE","NULL",null].indexOf(re)!==-1)re={encode:function(se){return se}};else if(typeof re=="string")throw new Error('Unsupported encryption scheme: "'+re+'".');var ie=re.encode(te,ee,!0);return pki$1.rsa.encrypt(ie,ee,!0)},ee.verify=function(te,re,ne,ie){typeof ne=="string"?ne=ne.toUpperCase():ne===void 0&&(ne="RSASSA-PKCS1-V1_5"),ie===void 0&&(ie={_parseAllDigestBytes:!0}),"_parseAllDigestBytes"in ie||(ie._parseAllDigestBytes=!0),ne==="RSASSA-PKCS1-V1_5"?ne={verify:function(oe,ce){ce=_decodePkcs1_v1_5(ce,ee,!0);var ae=asn1$1.fromDer(ce,{parseAllBytes:ie._parseAllDigestBytes}),le={},ue=[];if(!asn1$1.validate(ae,digestInfoValidator,le,ue)){var he=new Error("ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value.");throw he.errors=ue,he}var pe=asn1$1.derToOid(le.algorithmIdentifier);if(!(pe===forge$2.oids.md2||pe===forge$2.oids.md5||pe===forge$2.oids.sha1||pe===forge$2.oids.sha224||pe===forge$2.oids.sha256||pe===forge$2.oids.sha384||pe===forge$2.oids.sha512||pe===forge$2.oids["sha512-224"]||pe===forge$2.oids["sha512-256"])){var he=new Error("Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier.");throw he.oid=pe,he}if((pe===forge$2.oids.md2||pe===forge$2.oids.md5)&&!("parameters"in le))throw new Error("ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters.");return oe===le.digest}}:(ne==="NONE"||ne==="NULL"||ne===null)&&(ne={verify:function(oe,ce){return ce=_decodePkcs1_v1_5(ce,ee,!0),oe===ce}});var se=pki$1.rsa.decrypt(re,ee,!0,!1);return ne.verify(te,se,ee.n.bitLength())},ee};pki$1.setRsaPrivateKey=pki$1.rsa.setPrivateKey=function(J,E,ee,te,re,ne,ie,se){var oe={n:J,e:E,d:ee,p:te,q:re,dP:ne,dQ:ie,qInv:se};return oe.decrypt=function(ce,ae,le){typeof ae=="string"?ae=ae.toUpperCase():ae===void 0&&(ae="RSAES-PKCS1-V1_5");var ue=pki$1.rsa.decrypt(ce,oe,!1,!1);if(ae==="RSAES-PKCS1-V1_5")ae={decode:_decodePkcs1_v1_5};else if(ae==="RSA-OAEP"||ae==="RSAES-OAEP")ae={decode:function(he,pe){return forge$2.pkcs1.decode_rsa_oaep(pe,he,le)}};else if(["RAW","NONE","NULL",null].indexOf(ae)!==-1)ae={decode:function(he){return he}};else throw new Error('Unsupported encryption scheme: "'+ae+'".');return ae.decode(ue,oe,!1)},oe.sign=function(ce,ae){var le=!1;typeof ae=="string"&&(ae=ae.toUpperCase()),ae===void 0||ae==="RSASSA-PKCS1-V1_5"?(ae={encode:emsaPkcs1v15encode},le=1):(ae==="NONE"||ae==="NULL"||ae===null)&&(ae={encode:function(){return ce}},le=1);var ue=ae.encode(ce,oe.n.bitLength());return pki$1.rsa.encrypt(ue,oe,le)},oe};pki$1.wrapRsaPrivateKey=function(J){return asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.SEQUENCE,!0,[asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.INTEGER,!1,asn1$1.integerToDer(0).getBytes()),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.SEQUENCE,!0,[asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.OID,!1,asn1$1.oidToDer(pki$1.oids.rsaEncryption).getBytes()),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.NULL,!1,"")]),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.OCTETSTRING,!1,asn1$1.toDer(J).getBytes())])};pki$1.privateKeyFromAsn1=function(J){var E={},ee=[];if(asn1$1.validate(J,privateKeyValidator,E,ee)&&(J=asn1$1.fromDer(forge$2.util.createBuffer(E.privateKey))),E={},ee=[],!asn1$1.validate(J,rsaPrivateKeyValidator,E,ee)){var te=new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");throw te.errors=ee,te}var re,ne,ie,se,oe,ce,ae,le;return re=forge$2.util.createBuffer(E.privateKeyModulus).toHex(),ne=forge$2.util.createBuffer(E.privateKeyPublicExponent).toHex(),ie=forge$2.util.createBuffer(E.privateKeyPrivateExponent).toHex(),se=forge$2.util.createBuffer(E.privateKeyPrime1).toHex(),oe=forge$2.util.createBuffer(E.privateKeyPrime2).toHex(),ce=forge$2.util.createBuffer(E.privateKeyExponent1).toHex(),ae=forge$2.util.createBuffer(E.privateKeyExponent2).toHex(),le=forge$2.util.createBuffer(E.privateKeyCoefficient).toHex(),pki$1.setRsaPrivateKey(new BigInteger$1(re,16),new BigInteger$1(ne,16),new BigInteger$1(ie,16),new BigInteger$1(se,16),new BigInteger$1(oe,16),new BigInteger$1(ce,16),new BigInteger$1(ae,16),new BigInteger$1(le,16))};pki$1.privateKeyToAsn1=pki$1.privateKeyToRSAPrivateKey=function(J){return asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.SEQUENCE,!0,[asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.INTEGER,!1,asn1$1.integerToDer(0).getBytes()),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.INTEGER,!1,_bnToBytes(J.n)),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.INTEGER,!1,_bnToBytes(J.e)),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.INTEGER,!1,_bnToBytes(J.d)),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.INTEGER,!1,_bnToBytes(J.p)),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.INTEGER,!1,_bnToBytes(J.q)),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.INTEGER,!1,_bnToBytes(J.dP)),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.INTEGER,!1,_bnToBytes(J.dQ)),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.INTEGER,!1,_bnToBytes(J.qInv))])};pki$1.publicKeyFromAsn1=function(J){var E={},ee=[];if(asn1$1.validate(J,publicKeyValidator,E,ee)){var te=asn1$1.derToOid(E.publicKeyOid);if(te!==pki$1.oids.rsaEncryption){var re=new Error("Cannot read public key. Unknown OID.");throw re.oid=te,re}J=E.rsaPublicKey}if(ee=[],!asn1$1.validate(J,rsaPublicKeyValidator,E,ee)){var re=new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");throw re.errors=ee,re}var ne=forge$2.util.createBuffer(E.publicKeyModulus).toHex(),ie=forge$2.util.createBuffer(E.publicKeyExponent).toHex();return pki$1.setRsaPublicKey(new BigInteger$1(ne,16),new BigInteger$1(ie,16))};pki$1.publicKeyToAsn1=pki$1.publicKeyToSubjectPublicKeyInfo=function(J){return asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.SEQUENCE,!0,[asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.SEQUENCE,!0,[asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.OID,!1,asn1$1.oidToDer(pki$1.oids.rsaEncryption).getBytes()),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.NULL,!1,"")]),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.BITSTRING,!1,[pki$1.publicKeyToRSAPublicKey(J)])])};pki$1.publicKeyToRSAPublicKey=function(J){return asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.SEQUENCE,!0,[asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.INTEGER,!1,_bnToBytes(J.n)),asn1$1.create(asn1$1.Class.UNIVERSAL,asn1$1.Type.INTEGER,!1,_bnToBytes(J.e))])};function _encodePkcs1_v1_5(J,E,ee){var te=forge$2.util.createBuffer(),re=Math.ceil(E.n.bitLength()/8);if(J.length>re-11){var ne=new Error("Message is too long for PKCS#1 v1.5 padding.");throw ne.length=J.length,ne.max=re-11,ne}te.putByte(0),te.putByte(ee);var ie=re-3-J.length,se;if(ee===0||ee===1){se=ee===0?0:255;for(var oe=0;oe<ie;++oe)te.putByte(se)}else for(;ie>0;){for(var ce=0,ae=forge$2.random.getBytes(ie),oe=0;oe<ie;++oe)se=ae.charCodeAt(oe),se===0?++ce:te.putByte(se);ie=ce}return te.putByte(0),te.putBytes(J),te}function _decodePkcs1_v1_5(J,E,ee,te){var re=Math.ceil(E.n.bitLength()/8),ne=forge$2.util.createBuffer(J),ie=ne.getByte(),se=ne.getByte();if(ie!==0||ee&&se!==0&&se!==1||!ee&&se!=2||ee&&se===0&&typeof te>"u")throw new Error("Encryption block is invalid.");var oe=0;if(se===0){oe=re-3-te;for(var ce=0;ce<oe;++ce)if(ne.getByte()!==0)throw new Error("Encryption block is invalid.")}else if(se===1)for(oe=0;ne.length()>1;){if(ne.getByte()!==255){--ne.read;break}++oe}else if(se===2)for(oe=0;ne.length()>1;){if(ne.getByte()===0){--ne.read;break}++oe}var ae=ne.getByte();if(ae!==0||oe!==re-3-ne.length())throw new Error("Encryption block is invalid.");return ne.getBytes()}function _generateKeyPair(J,E,ee){typeof E=="function"&&(ee=E,E={}),E=E||{};var te={algorithm:{name:E.algorithm||"PRIMEINC",options:{workers:E.workers||2,workLoad:E.workLoad||100,workerScript:E.workerScript}}};"prng"in E&&(te.prng=E.prng),re();function re(){ne(J.pBits,function(se,oe){if(se)return ee(se);if(J.p=oe,J.q!==null)return ie(se,J.q);ne(J.qBits,ie)})}function ne(se,oe){forge$2.prime.generateProbablePrime(se,te,oe)}function ie(se,oe){if(se)return ee(se);if(J.q=oe,J.p.compareTo(J.q)<0){var ce=J.p;J.p=J.q,J.q=ce}if(J.p.subtract(BigInteger$1.ONE).gcd(J.e).compareTo(BigInteger$1.ONE)!==0){J.p=null,re();return}if(J.q.subtract(BigInteger$1.ONE).gcd(J.e).compareTo(BigInteger$1.ONE)!==0){J.q=null,ne(J.qBits,ie);return}if(J.p1=J.p.subtract(BigInteger$1.ONE),J.q1=J.q.subtract(BigInteger$1.ONE),J.phi=J.p1.multiply(J.q1),J.phi.gcd(J.e).compareTo(BigInteger$1.ONE)!==0){J.p=J.q=null,re();return}if(J.n=J.p.multiply(J.q),J.n.bitLength()!==J.bits){J.q=null,ne(J.qBits,ie);return}var ae=J.e.modInverse(J.phi);J.keys={privateKey:pki$1.rsa.setPrivateKey(J.n,J.e,ae,J.p,J.q,ae.mod(J.p1),ae.mod(J.q1),J.q.modInverse(J.p)),publicKey:pki$1.rsa.setPublicKey(J.n,J.e)},ee(null,J.keys)}}function _bnToBytes(J){var E=J.toString(16);E[0]>="8"&&(E="00"+E);var ee=forge$2.util.hexToBytes(E);return ee.length>1&&(ee.charCodeAt(0)===0&&!(ee.charCodeAt(1)&128)||ee.charCodeAt(0)===255&&(ee.charCodeAt(1)&128)===128)?ee.substr(1):ee}function _getMillerRabinTests(J){return J<=100?27:J<=150?18:J<=200?15:J<=250?12:J<=300?9:J<=350?8:J<=400?7:J<=500?6:J<=600?5:J<=800?4:J<=1250?3:2}function _detectNodeCrypto(J){return forge$2.util.isNodejs&&typeof _crypto[J]=="function"}function _detectSubtleCrypto(J){return typeof util$6.globalScope<"u"&&typeof util$6.globalScope.crypto=="object"&&typeof util$6.globalScope.crypto.subtle=="object"&&typeof util$6.globalScope.crypto.subtle[J]=="function"}function _detectSubtleMsCrypto(J){return typeof util$6.globalScope<"u"&&typeof util$6.globalScope.msCrypto=="object"&&typeof util$6.globalScope.msCrypto.subtle=="object"&&typeof util$6.globalScope.msCrypto.subtle[J]=="function"}function _intToUint8Array(J){for(var E=forge$2.util.hexToBytes(J.toString(16)),ee=new Uint8Array(E.length),te=0;te<E.length;++te)ee[te]=E.charCodeAt(te);return ee}var forge$1=forge$m;if(typeof BigInteger>"u")var BigInteger=forge$1.jsbn.BigInteger;var asn1=forge$1.asn1,pki=forge$1.pki=forge$1.pki||{};pki.pbe=forge$1.pbe=forge$1.pbe||{};var oids=pki.oids,encryptedPrivateKeyValidator={name:"EncryptedPrivateKeyInfo",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"EncryptedPrivateKeyInfo.encryptionAlgorithm",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"AlgorithmIdentifier.algorithm",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:!1,capture:"encryptionOid"},{name:"AlgorithmIdentifier.parameters",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,captureAsn1:"encryptionParams"}]},{name:"EncryptedPrivateKeyInfo.encryptedData",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:!1,capture:"encryptedData"}]},PBES2AlgorithmsValidator={name:"PBES2Algorithms",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.keyDerivationFunc",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.keyDerivationFunc.oid",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:!1,capture:"kdfOid"},{name:"PBES2Algorithms.params",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.params.salt",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:!1,capture:"kdfSalt"},{name:"PBES2Algorithms.params.iterationCount",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:!1,capture:"kdfIterationCount"},{name:"PBES2Algorithms.params.keyLength",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:!1,optional:!0,capture:"keyLength"},{name:"PBES2Algorithms.params.prf",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,optional:!0,value:[{name:"PBES2Algorithms.params.prf.algorithm",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:!1,capture:"prfOid"}]}]}]},{name:"PBES2Algorithms.encryptionScheme",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"PBES2Algorithms.encryptionScheme.oid",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OID,constructed:!1,capture:"encOid"},{name:"PBES2Algorithms.encryptionScheme.iv",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:!1,capture:"encIv"}]}]},pkcs12PbeParamsValidator={name:"pkcs-12PbeParams",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.SEQUENCE,constructed:!0,value:[{name:"pkcs-12PbeParams.salt",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.OCTETSTRING,constructed:!1,capture:"salt"},{name:"pkcs-12PbeParams.iterations",tagClass:asn1.Class.UNIVERSAL,type:asn1.Type.INTEGER,constructed:!1,capture:"iterations"}]};pki.encryptPrivateKeyInfo=function(J,E,ee){ee=ee||{},ee.saltSize=ee.saltSize||8,ee.count=ee.count||2048,ee.algorithm=ee.algorithm||"aes128",ee.prfAlgorithm=ee.prfAlgorithm||"sha1";var te=forge$1.random.getBytesSync(ee.saltSize),re=ee.count,ne=asn1.integerToDer(re),ie,se,oe;if(ee.algorithm.indexOf("aes")===0||ee.algorithm==="des"){var ce,ae,le;switch(ee.algorithm){case"aes128":ie=16,ce=16,ae=oids["aes128-CBC"],le=forge$1.aes.createEncryptionCipher;break;case"aes192":ie=24,ce=16,ae=oids["aes192-CBC"],le=forge$1.aes.createEncryptionCipher;break;case"aes256":ie=32,ce=16,ae=oids["aes256-CBC"],le=forge$1.aes.createEncryptionCipher;break;case"des":ie=8,ce=8,ae=oids.desCBC,le=forge$1.des.createEncryptionCipher;break;default:var ue=new Error("Cannot encrypt private key. Unknown encryption algorithm.");throw ue.algorithm=ee.algorithm,ue}var he="hmacWith"+ee.prfAlgorithm.toUpperCase(),pe=prfAlgorithmToMessageDigest(he),de=forge$1.pkcs5.pbkdf2(E,te,re,ie,pe),fe=forge$1.random.getBytesSync(ce),me=le(de);me.start(fe),me.update(asn1.toDer(J)),me.finish(),oe=me.output.getBytes();var _e=createPbkdf2Params(te,ne,ie,he);se=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,!1,asn1.oidToDer(oids.pkcs5PBES2).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,!1,asn1.oidToDer(oids.pkcs5PBKDF2).getBytes()),_e]),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,!1,asn1.oidToDer(ae).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,!1,fe)])])])}else if(ee.algorithm==="3des"){ie=24;var be=new forge$1.util.ByteBuffer(te),de=pki.pbe.generatePkcs12Key(E,be,1,re,ie),fe=pki.pbe.generatePkcs12Key(E,be,2,re,ie),me=forge$1.des.createEncryptionCipher(de);me.start(fe),me.update(asn1.toDer(J)),me.finish(),oe=me.output.getBytes(),se=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,!1,asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,!1,te),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,!1,ne.getBytes())])])}else{var ue=new Error("Cannot encrypt private key. Unknown encryption algorithm.");throw ue.algorithm=ee.algorithm,ue}var Ee=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[se,asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,!1,oe)]);return Ee};pki.decryptPrivateKeyInfo=function(J,E){var ee=null,te={},re=[];if(!asn1.validate(J,encryptedPrivateKeyValidator,te,re)){var ne=new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");throw ne.errors=re,ne}var ie=asn1.derToOid(te.encryptionOid),se=pki.pbe.getCipher(ie,te.encryptionParams,E),oe=forge$1.util.createBuffer(te.encryptedData);return se.update(oe),se.finish()&&(ee=asn1.fromDer(se.output)),ee};pki.encryptedPrivateKeyToPem=function(J,E){var ee={type:"ENCRYPTED PRIVATE KEY",body:asn1.toDer(J).getBytes()};return forge$1.pem.encode(ee,{maxline:E})};pki.encryptedPrivateKeyFromPem=function(J){var E=forge$1.pem.decode(J)[0];if(E.type!=="ENCRYPTED PRIVATE KEY"){var ee=new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');throw ee.headerType=E.type,ee}if(E.procType&&E.procType.type==="ENCRYPTED")throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");return asn1.fromDer(E.body)};pki.encryptRsaPrivateKey=function(J,E,ee){if(ee=ee||{},!ee.legacy){var te=pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(J));return te=pki.encryptPrivateKeyInfo(te,E,ee),pki.encryptedPrivateKeyToPem(te)}var re,ne,ie,se;switch(ee.algorithm){case"aes128":re="AES-128-CBC",ie=16,ne=forge$1.random.getBytesSync(16),se=forge$1.aes.createEncryptionCipher;break;case"aes192":re="AES-192-CBC",ie=24,ne=forge$1.random.getBytesSync(16),se=forge$1.aes.createEncryptionCipher;break;case"aes256":re="AES-256-CBC",ie=32,ne=forge$1.random.getBytesSync(16),se=forge$1.aes.createEncryptionCipher;break;case"3des":re="DES-EDE3-CBC",ie=24,ne=forge$1.random.getBytesSync(8),se=forge$1.des.createEncryptionCipher;break;case"des":re="DES-CBC",ie=8,ne=forge$1.random.getBytesSync(8),se=forge$1.des.createEncryptionCipher;break;default:var oe=new Error('Could not encrypt RSA private key; unsupported encryption algorithm "'+ee.algorithm+'".');throw oe.algorithm=ee.algorithm,oe}var ce=forge$1.pbe.opensslDeriveBytes(E,ne.substr(0,8),ie),ae=se(ce);ae.start(ne),ae.update(asn1.toDer(pki.privateKeyToAsn1(J))),ae.finish();var le={type:"RSA PRIVATE KEY",procType:{version:"4",type:"ENCRYPTED"},dekInfo:{algorithm:re,parameters:forge$1.util.bytesToHex(ne).toUpperCase()},body:ae.output.getBytes()};return forge$1.pem.encode(le)};pki.decryptRsaPrivateKey=function(J,E){var ee=null,te=forge$1.pem.decode(J)[0];if(te.type!=="ENCRYPTED PRIVATE KEY"&&te.type!=="PRIVATE KEY"&&te.type!=="RSA PRIVATE KEY"){var re=new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');throw re.headerType=re,re}if(te.procType&&te.procType.type==="ENCRYPTED"){var ne,ie;switch(te.dekInfo.algorithm){case"DES-CBC":ne=8,ie=forge$1.des.createDecryptionCipher;break;case"DES-EDE3-CBC":ne=24,ie=forge$1.des.createDecryptionCipher;break;case"AES-128-CBC":ne=16,ie=forge$1.aes.createDecryptionCipher;break;case"AES-192-CBC":ne=24,ie=forge$1.aes.createDecryptionCipher;break;case"AES-256-CBC":ne=32,ie=forge$1.aes.createDecryptionCipher;break;case"RC2-40-CBC":ne=5,ie=function(le){return forge$1.rc2.createDecryptionCipher(le,40)};break;case"RC2-64-CBC":ne=8,ie=function(le){return forge$1.rc2.createDecryptionCipher(le,64)};break;case"RC2-128-CBC":ne=16,ie=function(le){return forge$1.rc2.createDecryptionCipher(le,128)};break;default:var re=new Error('Could not decrypt private key; unsupported encryption algorithm "'+te.dekInfo.algorithm+'".');throw re.algorithm=te.dekInfo.algorithm,re}var se=forge$1.util.hexToBytes(te.dekInfo.parameters),oe=forge$1.pbe.opensslDeriveBytes(E,se.substr(0,8),ne),ce=ie(oe);if(ce.start(se),ce.update(forge$1.util.createBuffer(te.body)),ce.finish())ee=ce.output.getBytes();else return ee}else ee=te.body;return te.type==="ENCRYPTED PRIVATE KEY"?ee=pki.decryptPrivateKeyInfo(asn1.fromDer(ee),E):ee=asn1.fromDer(ee),ee!==null&&(ee=pki.privateKeyFromAsn1(ee)),ee};pki.pbe.generatePkcs12Key=function(J,E,ee,te,re,ne){var ie,se;if(typeof ne>"u"||ne===null){if(!("sha1"in forge$1.md))throw new Error('"sha1" hash algorithm unavailable.');ne=forge$1.md.sha1.create()}var oe=ne.digestLength,ce=ne.blockLength,ae=new forge$1.util.ByteBuffer,le=new forge$1.util.ByteBuffer;if(J!=null){for(se=0;se<J.length;se++)le.putInt16(J.charCodeAt(se));le.putInt16(0)}var ue=le.length(),he=E.length(),pe=new forge$1.util.ByteBuffer;pe.fillWithByte(ee,ce);var de=ce*Math.ceil(he/ce),fe=new forge$1.util.ByteBuffer;for(se=0;se<de;se++)fe.putByte(E.at(se%he));var me=ce*Math.ceil(ue/ce),_e=new forge$1.util.ByteBuffer;for(se=0;se<me;se++)_e.putByte(le.at(se%ue));var be=fe;be.putBuffer(_e);for(var Ee=Math.ceil(re/oe),ve=1;ve<=Ee;ve++){var we=new forge$1.util.ByteBuffer;we.putBytes(pe.bytes()),we.putBytes(be.bytes());for(var ge=0;ge<te;ge++)ne.start(),ne.update(we.getBytes()),we=ne.digest();var Se=new forge$1.util.ByteBuffer;for(se=0;se<ce;se++)Se.putByte(we.at(se%oe));var $e=Math.ceil(he/ce)+Math.ceil(ue/ce),Pe=new forge$1.util.ByteBuffer;for(ie=0;ie<$e;ie++){var Me=new forge$1.util.ByteBuffer(be.getBytes(ce)),xe=511;for(se=Se.length()-1;se>=0;se--)xe=xe>>8,xe+=Se.at(se)+Me.at(se),Me.setAt(se,xe&255);Pe.putBuffer(Me)}be=Pe,ae.putBuffer(we)}return ae.truncate(ae.length()-re),ae};pki.pbe.getCipher=function(J,E,ee){switch(J){case pki.oids.pkcs5PBES2:return pki.pbe.getCipherForPBES2(J,E,ee);case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:return pki.pbe.getCipherForPKCS12PBE(J,E,ee);default:var te=new Error("Cannot read encrypted PBE data block. Unsupported OID.");throw te.oid=J,te.supportedOids=["pkcs5PBES2","pbeWithSHAAnd3-KeyTripleDES-CBC","pbewithSHAAnd40BitRC2-CBC"],te}};pki.pbe.getCipherForPBES2=function(J,E,ee){var te={},re=[];if(!asn1.validate(E,PBES2AlgorithmsValidator,te,re)){var ne=new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");throw ne.errors=re,ne}if(J=asn1.derToOid(te.kdfOid),J!==pki.oids.pkcs5PBKDF2){var ne=new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");throw ne.oid=J,ne.supportedOids=["pkcs5PBKDF2"],ne}if(J=asn1.derToOid(te.encOid),J!==pki.oids["aes128-CBC"]&&J!==pki.oids["aes192-CBC"]&&J!==pki.oids["aes256-CBC"]&&J!==pki.oids["des-EDE3-CBC"]&&J!==pki.oids.desCBC){var ne=new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");throw ne.oid=J,ne.supportedOids=["aes128-CBC","aes192-CBC","aes256-CBC","des-EDE3-CBC","desCBC"],ne}var ie=te.kdfSalt,se=forge$1.util.createBuffer(te.kdfIterationCount);se=se.getInt(se.length()<<3);var oe,ce;switch(pki.oids[J]){case"aes128-CBC":oe=16,ce=forge$1.aes.createDecryptionCipher;break;case"aes192-CBC":oe=24,ce=forge$1.aes.createDecryptionCipher;break;case"aes256-CBC":oe=32,ce=forge$1.aes.createDecryptionCipher;break;case"des-EDE3-CBC":oe=24,ce=forge$1.des.createDecryptionCipher;break;case"desCBC":oe=8,ce=forge$1.des.createDecryptionCipher;break}var ae=prfOidToMessageDigest(te.prfOid),le=forge$1.pkcs5.pbkdf2(ee,ie,se,oe,ae),ue=te.encIv,he=ce(le);return he.start(ue),he};pki.pbe.getCipherForPKCS12PBE=function(J,E,ee){var te={},re=[];if(!asn1.validate(E,pkcs12PbeParamsValidator,te,re)){var ne=new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");throw ne.errors=re,ne}var ie=forge$1.util.createBuffer(te.salt),se=forge$1.util.createBuffer(te.iterations);se=se.getInt(se.length()<<3);var oe,ce,ae;switch(J){case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:oe=24,ce=8,ae=forge$1.des.startDecrypting;break;case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:oe=5,ce=8,ae=function(de,fe){var me=forge$1.rc2.createDecryptionCipher(de,40);return me.start(fe,null),me};break;default:var ne=new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");throw ne.oid=J,ne}var le=prfOidToMessageDigest(te.prfOid),ue=pki.pbe.generatePkcs12Key(ee,ie,1,se,oe,le);le.start();var he=pki.pbe.generatePkcs12Key(ee,ie,2,se,ce,le);return ae(ue,he)};pki.pbe.opensslDeriveBytes=function(J,E,ee,te){if(typeof te>"u"||te===null){if(!("md5"in forge$1.md))throw new Error('"md5" hash algorithm unavailable.');te=forge$1.md.md5.create()}E===null&&(E="");for(var re=[hash$2(te,J+E)],ne=16,ie=1;ne<ee;++ie,ne+=16)re.push(hash$2(te,re[ie-1]+J+E));return re.join("").substr(0,ee)};function hash$2(J,E){return J.start().update(E).digest().getBytes()}function prfOidToMessageDigest(J){var E;if(!J)E="hmacWithSHA1";else if(E=pki.oids[asn1.derToOid(J)],!E){var ee=new Error("Unsupported PRF OID.");throw ee.oid=J,ee.supported=["hmacWithSHA1","hmacWithSHA224","hmacWithSHA256","hmacWithSHA384","hmacWithSHA512"],ee}return prfAlgorithmToMessageDigest(E)}function prfAlgorithmToMessageDigest(J){var E=forge$1.md;switch(J){case"hmacWithSHA224":E=forge$1.md.sha512;case"hmacWithSHA1":case"hmacWithSHA256":case"hmacWithSHA384":case"hmacWithSHA512":J=J.substr(8).toLowerCase();break;default:var ee=new Error("Unsupported PRF algorithm.");throw ee.algorithm=J,ee.supported=["hmacWithSHA1","hmacWithSHA224","hmacWithSHA256","hmacWithSHA384","hmacWithSHA512"],ee}if(!E||!(J in E))throw new Error("Unknown hash algorithm: "+J);return E[J].create()}function createPbkdf2Params(J,E,ee,te){var re=asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OCTETSTRING,!1,J),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,!1,E.getBytes())]);return te!=="hmacWithSHA1"&&re.value.push(asn1.create(asn1.Class.UNIVERSAL,asn1.Type.INTEGER,!1,forge$1.util.hexToBytes(ee.toString(16))),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.SEQUENCE,!0,[asn1.create(asn1.Class.UNIVERSAL,asn1.Type.OID,!1,asn1.oidToDer(pki.oids[te]).getBytes()),asn1.create(asn1.Class.UNIVERSAL,asn1.Type.NULL,!1,"")])),re}/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */const _0n$1=BigInt(0),_1n$1=BigInt(1),_2n$1=BigInt(2),_8n$1=BigInt(8),CU_O=BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),CURVE$1=Object.freeze({a:BigInt(-1),d:BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),P:BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"),l:CU_O,n:CU_O,h:BigInt(8),Gx:BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),Gy:BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960")}),POW_2_256$1=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000"),SQRT_M1=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");BigInt("6853475219497561581579357271197624642482790079785650197046958215289687604742");const SQRT_AD_MINUS_ONE=BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),INVSQRT_A_MINUS_D=BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),ONE_MINUS_D_SQ=BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),D_MINUS_ONE_SQ=BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");class ExtendedPoint{constructor(E,ee,te,re){this.x=E,this.y=ee,this.z=te,this.t=re}static fromAffine(E){if(!(E instanceof Point$1))throw new TypeError("ExtendedPoint#fromAffine: expected Point");return E.equals(Point$1.ZERO)?ExtendedPoint.ZERO:new ExtendedPoint(E.x,E.y,_1n$1,mod$1(E.x*E.y))}static toAffineBatch(E){const ee=invertBatch$1(E.map(te=>te.z));return E.map((te,re)=>te.toAffine(ee[re]))}static normalizeZ(E){return this.toAffineBatch(E).map(this.fromAffine)}equals(E){assertExtPoint(E);const{x:ee,y:te,z:re}=this,{x:ne,y:ie,z:se}=E,oe=mod$1(ee*se),ce=mod$1(ne*re),ae=mod$1(te*se),le=mod$1(ie*re);return oe===ce&&ae===le}negate(){return new ExtendedPoint(mod$1(-this.x),this.y,this.z,mod$1(-this.t))}double(){const{x:E,y:ee,z:te}=this,{a:re}=CURVE$1,ne=mod$1(E*E),ie=mod$1(ee*ee),se=mod$1(_2n$1*mod$1(te*te)),oe=mod$1(re*ne),ce=E+ee,ae=mod$1(mod$1(ce*ce)-ne-ie),le=oe+ie,ue=le-se,he=oe-ie,pe=mod$1(ae*ue),de=mod$1(le*he),fe=mod$1(ae*he),me=mod$1(ue*le);return new ExtendedPoint(pe,de,me,fe)}add(E){assertExtPoint(E);const{x:ee,y:te,z:re,t:ne}=this,{x:ie,y:se,z:oe,t:ce}=E,ae=mod$1((te-ee)*(se+ie)),le=mod$1((te+ee)*(se-ie)),ue=mod$1(le-ae);if(ue===_0n$1)return this.double();const he=mod$1(re*_2n$1*ce),pe=mod$1(ne*_2n$1*oe),de=pe+he,fe=le+ae,me=pe-he,_e=mod$1(de*ue),be=mod$1(fe*me),Ee=mod$1(de*me),ve=mod$1(ue*fe);return new ExtendedPoint(_e,be,ve,Ee)}subtract(E){return this.add(E.negate())}precomputeWindow(E){const ee=1+256/E,te=[];let re=this,ne=re;for(let ie=0;ie<ee;ie++){ne=re,te.push(ne);for(let se=1;se<2**(E-1);se++)ne=ne.add(re),te.push(ne);re=ne.double()}return te}wNAF(E,ee){!ee&&this.equals(ExtendedPoint.BASE)&&(ee=Point$1.BASE);const te=ee&&ee._WINDOW_SIZE||1;if(256%te)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let re=ee&&pointPrecomputes$1.get(ee);re||(re=this.precomputeWindow(te),ee&&te!==1&&(re=ExtendedPoint.normalizeZ(re),pointPrecomputes$1.set(ee,re)));let ne=ExtendedPoint.ZERO,ie=ExtendedPoint.BASE;const se=1+256/te,oe=2**(te-1),ce=BigInt(2**te-1),ae=2**te,le=BigInt(te);for(let ue=0;ue<se;ue++){const he=ue*oe;let pe=Number(E&ce);E>>=le,pe>oe&&(pe-=ae,E+=_1n$1);const de=he,fe=he+Math.abs(pe)-1,me=ue%2!==0,_e=pe<0;pe===0?ie=ie.add(constTimeNegate$1(me,re[de])):ne=ne.add(constTimeNegate$1(_e,re[fe]))}return ExtendedPoint.normalizeZ([ne,ie])[0]}multiply(E,ee){return this.wNAF(normalizeScalar$1(E,CURVE$1.l),ee)}multiplyUnsafe(E){let ee=normalizeScalar$1(E,CURVE$1.l,!1);const te=ExtendedPoint.BASE,re=ExtendedPoint.ZERO;if(ee===_0n$1)return re;if(this.equals(re)||ee===_1n$1)return this;if(this.equals(te))return this.wNAF(ee);let ne=re,ie=this;for(;ee>_0n$1;)ee&_1n$1&&(ne=ne.add(ie)),ie=ie.double(),ee>>=_1n$1;return ne}isSmallOrder(){return this.multiplyUnsafe(CURVE$1.h).equals(ExtendedPoint.ZERO)}isTorsionFree(){let E=this.multiplyUnsafe(CURVE$1.l/_2n$1).double();return CURVE$1.l%_2n$1&&(E=E.add(this)),E.equals(ExtendedPoint.ZERO)}toAffine(E){const{x:ee,y:te,z:re}=this,ne=this.equals(ExtendedPoint.ZERO);E==null&&(E=ne?_8n$1:invert$1(re));const ie=mod$1(ee*E),se=mod$1(te*E),oe=mod$1(re*E);if(ne)return Point$1.ZERO;if(oe!==_1n$1)throw new Error("invZ was invalid");return new Point$1(ie,se)}fromRistrettoBytes(){legacyRist()}toRistrettoBytes(){legacyRist()}fromRistrettoHash(){legacyRist()}}ExtendedPoint.BASE=new ExtendedPoint(CURVE$1.Gx,CURVE$1.Gy,_1n$1,mod$1(CURVE$1.Gx*CURVE$1.Gy));ExtendedPoint.ZERO=new ExtendedPoint(_0n$1,_1n$1,_1n$1,_0n$1);function constTimeNegate$1(J,E){const ee=E.negate();return J?ee:E}function assertExtPoint(J){if(!(J instanceof ExtendedPoint))throw new TypeError("ExtendedPoint expected")}function assertRstPoint(J){if(!(J instanceof RistrettoPoint))throw new TypeError("RistrettoPoint expected")}function legacyRist(){throw new Error("Legacy method: switch to RistrettoPoint")}class RistrettoPoint{constructor(E){this.ep=E}static calcElligatorRistrettoMap(E){const{d:ee}=CURVE$1,te=mod$1(SQRT_M1*E*E),re=mod$1((te+_1n$1)*ONE_MINUS_D_SQ);let ne=BigInt(-1);const ie=mod$1((ne-ee*te)*mod$1(te+ee));let{isValid:se,value:oe}=uvRatio(re,ie),ce=mod$1(oe*E);edIsNegative(ce)||(ce=mod$1(-ce)),se||(oe=ce),se||(ne=te);const ae=mod$1(ne*(te-_1n$1)*D_MINUS_ONE_SQ-ie),le=oe*oe,ue=mod$1((oe+oe)*ie),he=mod$1(ae*SQRT_AD_MINUS_ONE),pe=mod$1(_1n$1-le),de=mod$1(_1n$1+le);return new ExtendedPoint(mod$1(ue*de),mod$1(pe*he),mod$1(he*de),mod$1(ue*pe))}static hashToCurve(E){E=ensureBytes$1(E,64);const ee=bytes255ToNumberLE(E.slice(0,32)),te=this.calcElligatorRistrettoMap(ee),re=bytes255ToNumberLE(E.slice(32,64)),ne=this.calcElligatorRistrettoMap(re);return new RistrettoPoint(te.add(ne))}static fromHex(E){E=ensureBytes$1(E,32);const{a:ee,d:te}=CURVE$1,re="RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint",ne=bytes255ToNumberLE(E);if(!equalBytes(numberTo32BytesLE(ne),E)||edIsNegative(ne))throw new Error(re);const ie=mod$1(ne*ne),se=mod$1(_1n$1+ee*ie),oe=mod$1(_1n$1-ee*ie),ce=mod$1(se*se),ae=mod$1(oe*oe),le=mod$1(ee*te*ce-ae),{isValid:ue,value:he}=invertSqrt(mod$1(le*ae)),pe=mod$1(he*oe),de=mod$1(he*pe*le);let fe=mod$1((ne+ne)*pe);edIsNegative(fe)&&(fe=mod$1(-fe));const me=mod$1(se*de),_e=mod$1(fe*me);if(!ue||edIsNegative(_e)||me===_0n$1)throw new Error(re);return new RistrettoPoint(new ExtendedPoint(fe,me,_1n$1,_e))}toRawBytes(){let{x:E,y:ee,z:te,t:re}=this.ep;const ne=mod$1(mod$1(te+ee)*mod$1(te-ee)),ie=mod$1(E*ee),se=mod$1(ie*ie),{value:oe}=invertSqrt(mod$1(ne*se)),ce=mod$1(oe*ne),ae=mod$1(oe*ie),le=mod$1(ce*ae*re);let ue;if(edIsNegative(re*le)){let pe=mod$1(ee*SQRT_M1),de=mod$1(E*SQRT_M1);E=pe,ee=de,ue=mod$1(ce*INVSQRT_A_MINUS_D)}else ue=ae;edIsNegative(E*le)&&(ee=mod$1(-ee));let he=mod$1((te-ee)*ue);return edIsNegative(he)&&(he=mod$1(-he)),numberTo32BytesLE(he)}toHex(){return bytesToHex$1(this.toRawBytes())}toString(){return this.toHex()}equals(E){assertRstPoint(E);const ee=this.ep,te=E.ep,re=mod$1(ee.x*te.y)===mod$1(ee.y*te.x),ne=mod$1(ee.y*te.y)===mod$1(ee.x*te.x);return re||ne}add(E){return assertRstPoint(E),new RistrettoPoint(this.ep.add(E.ep))}subtract(E){return assertRstPoint(E),new RistrettoPoint(this.ep.subtract(E.ep))}multiply(E){return new RistrettoPoint(this.ep.multiply(E))}multiplyUnsafe(E){return new RistrettoPoint(this.ep.multiplyUnsafe(E))}}RistrettoPoint.BASE=new RistrettoPoint(ExtendedPoint.BASE);RistrettoPoint.ZERO=new RistrettoPoint(ExtendedPoint.ZERO);const pointPrecomputes$1=new WeakMap;let Point$1=class Ut{constructor(E,ee){this.x=E,this.y=ee}_setWindowSize(E){this._WINDOW_SIZE=E,pointPrecomputes$1.delete(this)}static fromHex(E,ee=!0){const{d:te,P:re}=CURVE$1;E=ensureBytes$1(E,32);const ne=E.slice();ne[31]=E[31]&-129;const ie=bytesToNumberLE(ne);if(ee&&ie>=re)throw new Error("Expected 0 < hex < P");if(!ee&&ie>=POW_2_256$1)throw new Error("Expected 0 < hex < 2**256");const se=mod$1(ie*ie),oe=mod$1(se-_1n$1),ce=mod$1(te*se+_1n$1);let{isValid:ae,value:le}=uvRatio(oe,ce);if(!ae)throw new Error("Point.fromHex: invalid y coordinate");const ue=(le&_1n$1)===_1n$1;return(E[31]&128)!==0!==ue&&(le=mod$1(-le)),new Ut(le,ie)}static async fromPrivateKey(E){return(await getExtendedPublicKey(E)).point}toRawBytes(){const E=numberTo32BytesLE(this.y);return E[31]|=this.x&_1n$1?128:0,E}toHex(){return bytesToHex$1(this.toRawBytes())}toX25519(){const{y:E}=this,ee=mod$1((_1n$1+E)*invert$1(_1n$1-E));return numberTo32BytesLE(ee)}isTorsionFree(){return ExtendedPoint.fromAffine(this).isTorsionFree()}equals(E){return this.x===E.x&&this.y===E.y}negate(){return new Ut(mod$1(-this.x),this.y)}add(E){return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(E)).toAffine()}subtract(E){return this.add(E.negate())}multiply(E){return ExtendedPoint.fromAffine(this).multiply(E,this).toAffine()}};Point$1.BASE=new Point$1(CURVE$1.Gx,CURVE$1.Gy);Point$1.ZERO=new Point$1(_0n$1,_1n$1);let Signature$1=class Vt{constructor(E,ee){this.r=E,this.s=ee,this.assertValidity()}static fromHex(E){const ee=ensureBytes$1(E,64),te=Point$1.fromHex(ee.slice(0,32),!1),re=bytesToNumberLE(ee.slice(32,64));return new Vt(te,re)}assertValidity(){const{r:E,s:ee}=this;if(!(E instanceof Point$1))throw new Error("Expected Point instance");return normalizeScalar$1(ee,CURVE$1.l,!1),this}toRawBytes(){const E=new Uint8Array(64);return E.set(this.r.toRawBytes()),E.set(numberTo32BytesLE(this.s),32),E}toHex(){return bytesToHex$1(this.toRawBytes())}};function concatBytes$1(...J){if(!J.every(te=>te instanceof Uint8Array))throw new Error("Expected Uint8Array list");if(J.length===1)return J[0];const E=J.reduce((te,re)=>te+re.length,0),ee=new Uint8Array(E);for(let te=0,re=0;te<J.length;te++){const ne=J[te];ee.set(ne,re),re+=ne.length}return ee}const hexes$1=Array.from({length:256},(J,E)=>E.toString(16).padStart(2,"0"));function bytesToHex$1(J){if(!(J instanceof Uint8Array))throw new Error("Uint8Array expected");let E="";for(let ee=0;ee<J.length;ee++)E+=hexes$1[J[ee]];return E}function hexToBytes$1(J){if(typeof J!="string")throw new TypeError("hexToBytes: expected string, got "+typeof J);if(J.length%2)throw new Error("hexToBytes: received invalid unpadded hex");const E=new Uint8Array(J.length/2);for(let ee=0;ee<E.length;ee++){const te=ee*2,re=J.slice(te,te+2),ne=Number.parseInt(re,16);if(Number.isNaN(ne)||ne<0)throw new Error("Invalid byte sequence");E[ee]=ne}return E}function numberTo32BytesBE(J){const E=J.toString(16).padStart(64,"0");return hexToBytes$1(E)}function numberTo32BytesLE(J){return numberTo32BytesBE(J).reverse()}function edIsNegative(J){return(mod$1(J)&_1n$1)===_1n$1}function bytesToNumberLE(J){if(!(J instanceof Uint8Array))throw new Error("Expected Uint8Array");return BigInt("0x"+bytesToHex$1(Uint8Array.from(J).reverse()))}const MAX_255B=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");function bytes255ToNumberLE(J){return mod$1(bytesToNumberLE(J)&MAX_255B)}function mod$1(J,E=CURVE$1.P){const ee=J%E;return ee>=_0n$1?ee:E+ee}function invert$1(J,E=CURVE$1.P){if(J===_0n$1||E<=_0n$1)throw new Error(`invert: expected positive integers, got n=${J} mod=${E}`);let ee=mod$1(J,E),te=E,re=_0n$1,ne=_1n$1;for(;ee!==_0n$1;){const ie=te/ee,se=te%ee,oe=re-ne*ie;te=ee,ee=se,re=ne,ne=oe}if(te!==_1n$1)throw new Error("invert: does not exist");return mod$1(re,E)}function invertBatch$1(J,E=CURVE$1.P){const ee=new Array(J.length),te=J.reduce((ne,ie,se)=>ie===_0n$1?ne:(ee[se]=ne,mod$1(ne*ie,E)),_1n$1),re=invert$1(te,E);return J.reduceRight((ne,ie,se)=>ie===_0n$1?ne:(ee[se]=mod$1(ne*ee[se],E),mod$1(ne*ie,E)),re),ee}function pow2$1(J,E){const{P:ee}=CURVE$1;let te=J;for(;E-- >_0n$1;)te*=te,te%=ee;return te}function pow_2_252_3(J){const{P:E}=CURVE$1,ee=BigInt(5),te=BigInt(10),re=BigInt(20),ne=BigInt(40),ie=BigInt(80),se=J*J%E*J%E,oe=pow2$1(se,_2n$1)*se%E,ce=pow2$1(oe,_1n$1)*J%E,ae=pow2$1(ce,ee)*ce%E,le=pow2$1(ae,te)*ae%E,ue=pow2$1(le,re)*le%E,he=pow2$1(ue,ne)*ue%E,pe=pow2$1(he,ie)*he%E,de=pow2$1(pe,ie)*he%E,fe=pow2$1(de,te)*ae%E;return{pow_p_5_8:pow2$1(fe,_2n$1)*J%E,b2:se}}function uvRatio(J,E){const ee=mod$1(E*E*E),te=mod$1(ee*ee*E),re=pow_2_252_3(J*te).pow_p_5_8;let ne=mod$1(J*ee*re);const ie=mod$1(E*ne*ne),se=ne,oe=mod$1(ne*SQRT_M1),ce=ie===J,ae=ie===mod$1(-J),le=ie===mod$1(-J*SQRT_M1);return ce&&(ne=se),(ae||le)&&(ne=oe),edIsNegative(ne)&&(ne=mod$1(-ne)),{isValid:ce||ae,value:ne}}function invertSqrt(J){return uvRatio(_1n$1,J)}function modlLE(J){return mod$1(bytesToNumberLE(J),CURVE$1.l)}function equalBytes(J,E){if(J.length!==E.length)return!1;for(let ee=0;ee<J.length;ee++)if(J[ee]!==E[ee])return!1;return!0}function ensureBytes$1(J,E){const ee=J instanceof Uint8Array?Uint8Array.from(J):hexToBytes$1(J);if(typeof E=="number"&&ee.length!==E)throw new Error(`Expected ${E} bytes`);return ee}function normalizeScalar$1(J,E,ee=!0){if(!E)throw new TypeError("Specify max value");if(typeof J=="number"&&Number.isSafeInteger(J)&&(J=BigInt(J)),typeof J=="bigint"&&J<E){if(ee){if(_0n$1<J)return J}else if(_0n$1<=J)return J}throw new TypeError("Expected valid scalar: 0 < scalar < max")}function adjustBytes25519(J){return J[0]&=248,J[31]&=127,J[31]|=64,J}function checkPrivateKey(J){if(J=typeof J=="bigint"||typeof J=="number"?numberTo32BytesBE(normalizeScalar$1(J,POW_2_256$1)):ensureBytes$1(J),J.length!==32)throw new Error("Expected 32 bytes");return J}function getKeyFromHash(J){const E=adjustBytes25519(J.slice(0,32)),ee=J.slice(32,64),te=modlLE(E),re=Point$1.BASE.multiply(te),ne=re.toRawBytes();return{head:E,prefix:ee,scalar:te,point:re,pointBytes:ne}}let _sha512Sync;async function getExtendedPublicKey(J){return getKeyFromHash(await utils$1$1.sha512(checkPrivateKey(J)))}async function getPublicKey$1(J){return(await getExtendedPublicKey(J)).pointBytes}async function sign$1(J,E){J=ensureBytes$1(J);const{prefix:ee,scalar:te,pointBytes:re}=await getExtendedPublicKey(E),ne=modlLE(await utils$1$1.sha512(ee,J)),ie=Point$1.BASE.multiply(ne),se=modlLE(await utils$1$1.sha512(ie.toRawBytes(),re,J)),oe=mod$1(ne+se*te,CURVE$1.l);return new Signature$1(ie,oe).toRawBytes()}function prepareVerification(J,E,ee){E=ensureBytes$1(E),ee instanceof Point$1||(ee=Point$1.fromHex(ee,!1));const{r:te,s:re}=J instanceof Signature$1?J.assertValidity():Signature$1.fromHex(J),ne=ExtendedPoint.BASE.multiplyUnsafe(re);return{r:te,s:re,SB:ne,pub:ee,msg:E}}function finishVerification(J,E,ee,te){const re=modlLE(te),ne=ExtendedPoint.fromAffine(J).multiplyUnsafe(re);return ExtendedPoint.fromAffine(E).add(ne).subtract(ee).multiplyUnsafe(CURVE$1.h).equals(ExtendedPoint.ZERO)}async function verify$1(J,E,ee){const{r:te,SB:re,msg:ne,pub:ie}=prepareVerification(J,E,ee),se=await utils$1$1.sha512(te.toRawBytes(),ie.toRawBytes(),ne);return finishVerification(ie,te,re,se)}Point$1.BASE._setWindowSize(8);const crypto$3={node:nodeCrypto,web:typeof self=="object"&&"crypto"in self?self.crypto:void 0},utils$1$1={bytesToHex:bytesToHex$1,hexToBytes:hexToBytes$1,concatBytes:concatBytes$1,getExtendedPublicKey,mod:mod$1,invert:invert$1,TORSION_SUBGROUP:["0100000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a","0000000000000000000000000000000000000000000000000000000000000080","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05","ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85","0000000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"],hashToPrivateScalar:J=>{if(J=ensureBytes$1(J),J.length<40||J.length>1024)throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");return mod$1(bytesToNumberLE(J),CURVE$1.l-_1n$1)+_1n$1},randomBytes:(J=32)=>{if(crypto$3.web)return crypto$3.web.getRandomValues(new Uint8Array(J));if(crypto$3.node){const{randomBytes:E}=crypto$3.node;return new Uint8Array(E(J).buffer)}else throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>utils$1$1.randomBytes(32),sha512:async(...J)=>{const E=concatBytes$1(...J);if(crypto$3.web){const ee=await crypto$3.web.subtle.digest("SHA-512",E.buffer);return new Uint8Array(ee)}else{if(crypto$3.node)return Uint8Array.from(crypto$3.node.createHash("sha512").update(E).digest());throw new Error("The environment doesn't have sha512 function")}},precompute(J=8,E=Point$1.BASE){const ee=E.equals(Point$1.BASE)?E:new Point$1(E.x,E.y);return ee._setWindowSize(J),ee.multiply(_2n$1),ee},sha512Sync:void 0};Object.defineProperties(utils$1$1,{sha512Sync:{configurable:!1,get(){return _sha512Sync},set(J){_sha512Sync||(_sha512Sync=J)}}});const PUBLIC_KEY_BYTE_LENGTH=32,PRIVATE_KEY_BYTE_LENGTH=64,KEYS_BYTE_LENGTH=32;async function generateKey$2(){const J=utils$1$1.randomPrivateKey(),E=await getPublicKey$1(J);return{privateKey:concatKeys(J,E),publicKey:E}}async function generateKeyFromSeed(J){if(J.length!==KEYS_BYTE_LENGTH)throw new TypeError('"seed" must be 32 bytes in length.');if(!(J instanceof Uint8Array))throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');const E=J,ee=await getPublicKey$1(E);return{privateKey:concatKeys(E,ee),publicKey:ee}}async function hashAndSign$2(J,E){const ee=J.subarray(0,KEYS_BYTE_LENGTH);return sign$1(E,ee)}async function hashAndVerify$2(J,E,ee){return verify$1(E,ee,J)}function concatKeys(J,E){const ee=new Uint8Array(PRIVATE_KEY_BYTE_LENGTH);for(let te=0;te<KEYS_BYTE_LENGTH;te++)ee[te]=J[te],ee[KEYS_BYTE_LENGTH+te]=E[te];return ee}const webcrypto={get(J=globalThis){const E=J.crypto;if(E==null||E.subtle==null)throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"),{code:"ERR_MISSING_WEB_CRYPTO"});return E}},derivedEmptyPasswordKey={alg:"A128GCM",ext:!0,k:"scm9jmO_4BJAgdwWGVulLg",key_ops:["encrypt","decrypt"],kty:"oct"};function create$2(J){const E=J?.algorithm??"AES-GCM";let ee=J?.keyLength??16;const te=J?.nonceLength??12,re=J?.digest??"SHA-256",ne=J?.saltLength??16,ie=J?.iterations??32767,se=webcrypto.get();ee*=8;async function oe(ae,le){const ue=se.getRandomValues(new Uint8Array(ne)),he=se.getRandomValues(new Uint8Array(te)),pe={name:E,iv:he};typeof le=="string"&&(le=fromString$5(le));let de;if(le.length===0){de=await se.subtle.importKey("jwk",derivedEmptyPasswordKey,{name:"AES-GCM"},!0,["encrypt"]);try{const me={name:"PBKDF2",salt:ue,iterations:ie,hash:{name:re}},_e=await se.subtle.importKey("raw",le,{name:"PBKDF2"},!1,["deriveKey"]);de=await se.subtle.deriveKey(me,_e,{name:E,length:ee},!0,["encrypt"])}catch{de=await se.subtle.importKey("jwk",derivedEmptyPasswordKey,{name:"AES-GCM"},!0,["encrypt"])}}else{const me={name:"PBKDF2",salt:ue,iterations:ie,hash:{name:re}},_e=await se.subtle.importKey("raw",le,{name:"PBKDF2"},!1,["deriveKey"]);de=await se.subtle.deriveKey(me,_e,{name:E,length:ee},!0,["encrypt"])}const fe=await se.subtle.encrypt(pe,de,ae);return concat$4([ue,pe.iv,new Uint8Array(fe)])}async function ce(ae,le){const ue=ae.subarray(0,ne),he=ae.subarray(ne,ne+te),pe=ae.subarray(ne+te),de={name:E,iv:he};typeof le=="string"&&(le=fromString$5(le));let fe;if(le.length===0)try{const _e={name:"PBKDF2",salt:ue,iterations:ie,hash:{name:re}},be=await se.subtle.importKey("raw",le,{name:"PBKDF2"},!1,["deriveKey"]);fe=await se.subtle.deriveKey(_e,be,{name:E,length:ee},!0,["decrypt"])}catch{fe=await se.subtle.importKey("jwk",derivedEmptyPasswordKey,{name:"AES-GCM"},!0,["decrypt"])}else{const _e={name:"PBKDF2",salt:ue,iterations:ie,hash:{name:re}},be=await se.subtle.importKey("raw",le,{name:"PBKDF2"},!1,["deriveKey"]);fe=await se.subtle.deriveKey(_e,be,{name:E,length:ee},!0,["decrypt"])}const me=await se.subtle.decrypt(de,fe,pe);return new Uint8Array(me)}return{encrypt:oe,decrypt:ce}}async function exporter$1(J,E){const ee=await create$2().encrypt(J,E);return base64$4.encode(ee)}var minimal$2={},aspromise=asPromise;function asPromise(J,E){for(var ee=new Array(arguments.length-1),te=0,re=2,ne=!0;re<arguments.length;)ee[te++]=arguments[re++];return new Promise(function(ie,se){ee[te]=function(oe){if(ne)if(ne=!1,oe)se(oe);else{for(var ce=new Array(arguments.length-1),ae=0;ae<ce.length;)ce[ae++]=arguments[ae];ie.apply(null,ce)}};try{J.apply(E||null,ee)}catch(oe){ne&&(ne=!1,se(oe))}})}var base64$3={};(function(J){var E=J;E.length=function(ie){var se=ie.length;if(!se)return 0;for(var oe=0;--se%4>1&&ie.charAt(se)==="=";)++oe;return Math.ceil(ie.length*3)/4-oe};for(var ee=new Array(64),te=new Array(123),re=0;re<64;)te[ee[re]=re<26?re+65:re<52?re+71:re<62?re-4:re-59|43]=re++;E.encode=function(ie,se,oe){for(var ce=null,ae=[],le=0,ue=0,he;se<oe;){var pe=ie[se++];switch(ue){case 0:ae[le++]=ee[pe>>2],he=(pe&3)<<4,ue=1;break;case 1:ae[le++]=ee[he|pe>>4],he=(pe&15)<<2,ue=2;break;case 2:ae[le++]=ee[he|pe>>6],ae[le++]=ee[pe&63],ue=0;break}le>8191&&((ce||(ce=[])).push(String.fromCharCode.apply(String,ae)),le=0)}return ue&&(ae[le++]=ee[he],ae[le++]=61,ue===1&&(ae[le++]=61)),ce?(le&&ce.push(String.fromCharCode.apply(String,ae.slice(0,le))),ce.join("")):String.fromCharCode.apply(String,ae.slice(0,le))};var ne="invalid encoding";E.decode=function(ie,se,oe){for(var ce=oe,ae=0,le,ue=0;ue<ie.length;){var he=ie.charCodeAt(ue++);if(he===61&&ae>1)break;if((he=te[he])===void 0)throw Error(ne);switch(ae){case 0:le=he,ae=1;break;case 1:se[oe++]=le<<2|(he&48)>>4,le=he,ae=2;break;case 2:se[oe++]=(le&15)<<4|(he&60)>>2,le=he,ae=3;break;case 3:se[oe++]=(le&3)<<6|he,ae=0;break}}if(ae===1)throw Error(ne);return oe-ce},E.test=function(ie){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(ie)}})(base64$3);var eventemitter=EventEmitter;function EventEmitter(){this._listeners={}}EventEmitter.prototype.on=function(J,E,ee){return(this._listeners[J]||(this._listeners[J]=[])).push({fn:E,ctx:ee||this}),this};EventEmitter.prototype.off=function(J,E){if(J===void 0)this._listeners={};else if(E===void 0)this._listeners[J]=[];else for(var ee=this._listeners[J],te=0;te<ee.length;)ee[te].fn===E?ee.splice(te,1):++te;return this};EventEmitter.prototype.emit=function(J){var E=this._listeners[J];if(E){for(var ee=[],te=1;te<arguments.length;)ee.push(arguments[te++]);for(te=0;te<E.length;)E[te].fn.apply(E[te++].ctx,ee)}return this};var float=factory(factory);function factory(J){return typeof Float32Array<"u"?function(){var E=new Float32Array([-0]),ee=new Uint8Array(E.buffer),te=ee[3]===128;function re(oe,ce,ae){E[0]=oe,ce[ae]=ee[0],ce[ae+1]=ee[1],ce[ae+2]=ee[2],ce[ae+3]=ee[3]}function ne(oe,ce,ae){E[0]=oe,ce[ae]=ee[3],ce[ae+1]=ee[2],ce[ae+2]=ee[1],ce[ae+3]=ee[0]}J.writeFloatLE=te?re:ne,J.writeFloatBE=te?ne:re;function ie(oe,ce){return ee[0]=oe[ce],ee[1]=oe[ce+1],ee[2]=oe[ce+2],ee[3]=oe[ce+3],E[0]}function se(oe,ce){return ee[3]=oe[ce],ee[2]=oe[ce+1],ee[1]=oe[ce+2],ee[0]=oe[ce+3],E[0]}J.readFloatLE=te?ie:se,J.readFloatBE=te?se:ie}():function(){function E(te,re,ne,ie){var se=re<0?1:0;if(se&&(re=-re),re===0)te(1/re>0?0:2147483648,ne,ie);else if(isNaN(re))te(2143289344,ne,ie);else if(re>34028234663852886e22)te((se<<31|2139095040)>>>0,ne,ie);else if(re<11754943508222875e-54)te((se<<31|Math.round(re/1401298464324817e-60))>>>0,ne,ie);else{var oe=Math.floor(Math.log(re)/Math.LN2),ce=Math.round(re*Math.pow(2,-oe)*8388608)&8388607;te((se<<31|oe+127<<23|ce)>>>0,ne,ie)}}J.writeFloatLE=E.bind(null,writeUintLE),J.writeFloatBE=E.bind(null,writeUintBE);function ee(te,re,ne){var ie=te(re,ne),se=(ie>>31)*2+1,oe=ie>>>23&255,ce=ie&8388607;return oe===255?ce?NaN:se*(1/0):oe===0?se*1401298464324817e-60*ce:se*Math.pow(2,oe-150)*(ce+8388608)}J.readFloatLE=ee.bind(null,readUintLE),J.readFloatBE=ee.bind(null,readUintBE)}(),typeof Float64Array<"u"?function(){var E=new Float64Array([-0]),ee=new Uint8Array(E.buffer),te=ee[7]===128;function re(oe,ce,ae){E[0]=oe,ce[ae]=ee[0],ce[ae+1]=ee[1],ce[ae+2]=ee[2],ce[ae+3]=ee[3],ce[ae+4]=ee[4],ce[ae+5]=ee[5],ce[ae+6]=ee[6],ce[ae+7]=ee[7]}function ne(oe,ce,ae){E[0]=oe,ce[ae]=ee[7],ce[ae+1]=ee[6],ce[ae+2]=ee[5],ce[ae+3]=ee[4],ce[ae+4]=ee[3],ce[ae+5]=ee[2],ce[ae+6]=ee[1],ce[ae+7]=ee[0]}J.writeDoubleLE=te?re:ne,J.writeDoubleBE=te?ne:re;function ie(oe,ce){return ee[0]=oe[ce],ee[1]=oe[ce+1],ee[2]=oe[ce+2],ee[3]=oe[ce+3],ee[4]=oe[ce+4],ee[5]=oe[ce+5],ee[6]=oe[ce+6],ee[7]=oe[ce+7],E[0]}function se(oe,ce){return ee[7]=oe[ce],ee[6]=oe[ce+1],ee[5]=oe[ce+2],ee[4]=oe[ce+3],ee[3]=oe[ce+4],ee[2]=oe[ce+5],ee[1]=oe[ce+6],ee[0]=oe[ce+7],E[0]}J.readDoubleLE=te?ie:se,J.readDoubleBE=te?se:ie}():function(){function E(te,re,ne,ie,se,oe){var ce=ie<0?1:0;if(ce&&(ie=-ie),ie===0)te(0,se,oe+re),te(1/ie>0?0:2147483648,se,oe+ne);else if(isNaN(ie))te(0,se,oe+re),te(2146959360,se,oe+ne);else if(ie>17976931348623157e292)te(0,se,oe+re),te((ce<<31|2146435072)>>>0,se,oe+ne);else{var ae;if(ie<22250738585072014e-324)ae=ie/5e-324,te(ae>>>0,se,oe+re),te((ce<<31|ae/4294967296)>>>0,se,oe+ne);else{var le=Math.floor(Math.log(ie)/Math.LN2);le===1024&&(le=1023),ae=ie*Math.pow(2,-le),te(ae*4503599627370496>>>0,se,oe+re),te((ce<<31|le+1023<<20|ae*1048576&1048575)>>>0,se,oe+ne)}}}J.writeDoubleLE=E.bind(null,writeUintLE,0,4),J.writeDoubleBE=E.bind(null,writeUintBE,4,0);function ee(te,re,ne,ie,se){var oe=te(ie,se+re),ce=te(ie,se+ne),ae=(ce>>31)*2+1,le=ce>>>20&2047,ue=4294967296*(ce&1048575)+oe;return le===2047?ue?NaN:ae*(1/0):le===0?ae*5e-324*ue:ae*Math.pow(2,le-1075)*(ue+4503599627370496)}J.readDoubleLE=ee.bind(null,readUintLE,0,4),J.readDoubleBE=ee.bind(null,readUintBE,4,0)}(),J}function writeUintLE(J,E,ee){E[ee]=J&255,E[ee+1]=J>>>8&255,E[ee+2]=J>>>16&255,E[ee+3]=J>>>24}function writeUintBE(J,E,ee){E[ee]=J>>>24,E[ee+1]=J>>>16&255,E[ee+2]=J>>>8&255,E[ee+3]=J&255}function readUintLE(J,E){return(J[E]|J[E+1]<<8|J[E+2]<<16|J[E+3]<<24)>>>0}function readUintBE(J,E){return(J[E]<<24|J[E+1]<<16|J[E+2]<<8|J[E+3])>>>0}var inquire_1=inquire;function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(J){}return null}var utf8$2={};(function(J){var E=J;E.length=function(ee){for(var te=0,re=0,ne=0;ne<ee.length;++ne)re=ee.charCodeAt(ne),re<128?te+=1:re<2048?te+=2:(re&64512)===55296&&(ee.charCodeAt(ne+1)&64512)===56320?(++ne,te+=4):te+=3;return te},E.read=function(ee,te,re){var ne=re-te;if(ne<1)return"";for(var ie=null,se=[],oe=0,ce;te<re;)ce=ee[te++],ce<128?se[oe++]=ce:ce>191&&ce<224?se[oe++]=(ce&31)<<6|ee[te++]&63:ce>239&&ce<365?(ce=((ce&7)<<18|(ee[te++]&63)<<12|(ee[te++]&63)<<6|ee[te++]&63)-65536,se[oe++]=55296+(ce>>10),se[oe++]=56320+(ce&1023)):se[oe++]=(ce&15)<<12|(ee[te++]&63)<<6|ee[te++]&63,oe>8191&&((ie||(ie=[])).push(String.fromCharCode.apply(String,se)),oe=0);return ie?(oe&&ie.push(String.fromCharCode.apply(String,se.slice(0,oe))),ie.join("")):String.fromCharCode.apply(String,se.slice(0,oe))},E.write=function(ee,te,re){for(var ne=re,ie,se,oe=0;oe<ee.length;++oe)ie=ee.charCodeAt(oe),ie<128?te[re++]=ie:ie<2048?(te[re++]=ie>>6|192,te[re++]=ie&63|128):(ie&64512)===55296&&((se=ee.charCodeAt(oe+1))&64512)===56320?(ie=65536+((ie&1023)<<10)+(se&1023),++oe,te[re++]=ie>>18|240,te[re++]=ie>>12&63|128,te[re++]=ie>>6&63|128,te[re++]=ie&63|128):(te[re++]=ie>>12|224,te[re++]=ie>>6&63|128,te[re++]=ie&63|128);return re-ne}})(utf8$2);var pool_1=pool;function pool(J,E,ee){var te=ee||8192,re=te>>>1,ne=null,ie=te;return function(se){if(se<1||se>re)return J(se);ie+se>te&&(ne=J(te),ie=0);var oe=E.call(ne,ie,ie+=se);return ie&7&&(ie=(ie|7)+1),oe}}var longbits$1,hasRequiredLongbits$1;function requireLongbits$1(){if(hasRequiredLongbits$1)return longbits$1;hasRequiredLongbits$1=1,longbits$1=E;var J=requireMinimal$2();function E(ne,ie){this.lo=ne>>>0,this.hi=ie>>>0}var ee=E.zero=new E(0,0);ee.toNumber=function(){return 0},ee.zzEncode=ee.zzDecode=function(){return this},ee.length=function(){return 1};var te=E.zeroHash="\0\0\0\0\0\0\0\0";E.fromNumber=function(ne){if(ne===0)return ee;var ie=ne<0;ie&&(ne=-ne);var se=ne>>>0,oe=(ne-se)/4294967296>>>0;return ie&&(oe=~oe>>>0,se=~se>>>0,++se>4294967295&&(se=0,++oe>4294967295&&(oe=0))),new E(se,oe)},E.from=function(ne){if(typeof ne=="number")return E.fromNumber(ne);if(J.isString(ne))if(J.Long)ne=J.Long.fromString(ne);else return E.fromNumber(parseInt(ne,10));return ne.low||ne.high?new E(ne.low>>>0,ne.high>>>0):ee},E.prototype.toNumber=function(ne){if(!ne&&this.hi>>>31){var ie=~this.lo+1>>>0,se=~this.hi>>>0;return ie||(se=se+1>>>0),-(ie+se*4294967296)}return this.lo+this.hi*4294967296},E.prototype.toLong=function(ne){return J.Long?new J.Long(this.lo|0,this.hi|0,!!ne):{low:this.lo|0,high:this.hi|0,unsigned:!!ne}};var re=String.prototype.charCodeAt;return E.fromHash=function(ne){return ne===te?ee:new E((re.call(ne,0)|re.call(ne,1)<<8|re.call(ne,2)<<16|re.call(ne,3)<<24)>>>0,(re.call(ne,4)|re.call(ne,5)<<8|re.call(ne,6)<<16|re.call(ne,7)<<24)>>>0)},E.prototype.toHash=function(){return String.fromCharCode(this.lo&255,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,this.hi&255,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},E.prototype.zzEncode=function(){var ne=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^ne)>>>0,this.lo=(this.lo<<1^ne)>>>0,this},E.prototype.zzDecode=function(){var ne=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^ne)>>>0,this.hi=(this.hi>>>1^ne)>>>0,this},E.prototype.length=function(){var ne=this.lo,ie=(this.lo>>>28|this.hi<<4)>>>0,se=this.hi>>>24;return se===0?ie===0?ne<16384?ne<128?1:2:ne<2097152?3:4:ie<16384?ie<128?5:6:ie<2097152?7:8:se<128?9:10},longbits$1}var hasRequiredMinimal$2;function requireMinimal$2(){return hasRequiredMinimal$2||(hasRequiredMinimal$2=1,function(J){var E=J;E.asPromise=aspromise,E.base64=base64$3,E.EventEmitter=eventemitter,E.float=float,E.inquire=inquire_1,E.utf8=utf8$2,E.pool=pool_1,E.LongBits=requireLongbits$1(),E.isNode=!!(typeof commonjsGlobal<"u"&&commonjsGlobal&&commonjsGlobal.process&&commonjsGlobal.process.versions&&commonjsGlobal.process.versions.node),E.global=E.isNode&&commonjsGlobal||typeof window<"u"&&window||typeof self<"u"&&self||commonjsGlobal,E.emptyArray=Object.freeze?Object.freeze([]):[],E.emptyObject=Object.freeze?Object.freeze({}):{},E.isInteger=Number.isInteger||function(re){return typeof re=="number"&&isFinite(re)&&Math.floor(re)===re},E.isString=function(re){return typeof re=="string"||re instanceof String},E.isObject=function(re){return re&&typeof re=="object"},E.isset=E.isSet=function(re,ne){var ie=re[ne];return ie!=null&&re.hasOwnProperty(ne)?typeof ie!="object"||(Array.isArray(ie)?ie.length:Object.keys(ie).length)>0:!1},E.Buffer=function(){try{var re=E.inquire("buffer").Buffer;return re.prototype.utf8Write?re:null}catch{return null}}(),E._Buffer_from=null,E._Buffer_allocUnsafe=null,E.newBuffer=function(re){return typeof re=="number"?E.Buffer?E._Buffer_allocUnsafe(re):new E.Array(re):E.Buffer?E._Buffer_from(re):typeof Uint8Array>"u"?re:new Uint8Array(re)},E.Array=typeof Uint8Array<"u"?Uint8Array:Array,E.Long=E.global.dcodeIO&&E.global.dcodeIO.Long||E.global.Long||E.inquire("long"),E.key2Re=/^true|false|0|1$/,E.key32Re=/^-?(?:0|[1-9][0-9]*)$/,E.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,E.longToHash=function(re){return re?E.LongBits.from(re).toHash():E.LongBits.zeroHash},E.longFromHash=function(re,ne){var ie=E.LongBits.fromHash(re);return E.Long?E.Long.fromBits(ie.lo,ie.hi,ne):ie.toNumber(!!ne)};function ee(re,ne,ie){for(var se=Object.keys(ne),oe=0;oe<se.length;++oe)(re[se[oe]]===void 0||!ie)&&(re[se[oe]]=ne[se[oe]]);return re}E.merge=ee,E.lcFirst=function(re){return re.charAt(0).toLowerCase()+re.substring(1)};function te(re){function ne(ie,se){if(!(this instanceof ne))return new ne(ie,se);Object.defineProperty(this,"message",{get:function(){return ie}}),Error.captureStackTrace?Error.captureStackTrace(this,ne):Object.defineProperty(this,"stack",{value:new Error().stack||""}),se&&ee(this,se)}return ne.prototype=Object.create(Error.prototype,{constructor:{value:ne,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return re},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),ne}E.newError=te,E.ProtocolError=te("ProtocolError"),E.oneOfGetter=function(re){for(var ne={},ie=0;ie<re.length;++ie)ne[re[ie]]=1;return function(){for(var se=Object.keys(this),oe=se.length-1;oe>-1;--oe)if(ne[se[oe]]===1&&this[se[oe]]!==void 0&&this[se[oe]]!==null)return se[oe]}},E.oneOfSetter=function(re){return function(ne){for(var ie=0;ie<re.length;++ie)re[ie]!==ne&&delete this[re[ie]]}},E.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},E._configure=function(){var re=E.Buffer;if(!re){E._Buffer_from=E._Buffer_allocUnsafe=null;return}E._Buffer_from=re.from!==Uint8Array.from&&re.from||function(ne,ie){return new re(ne,ie)},E._Buffer_allocUnsafe=re.allocUnsafe||function(ne){return new re(ne)}}}(minimal$2)),minimal$2}var reader$3=Reader$1,util$5=requireMinimal$2(),BufferReader$1,LongBits$2=util$5.LongBits,utf8$1=util$5.utf8;function indexOutOfRange(J,E){return RangeError("index out of range: "+J.pos+" + "+(E||1)+" > "+J.len)}function Reader$1(J){this.buf=J,this.pos=0,this.len=J.length}var create_array=typeof Uint8Array<"u"?function J(E){if(E instanceof Uint8Array||Array.isArray(E))return new Reader$1(E);throw Error("illegal buffer")}:function J(E){if(Array.isArray(E))return new Reader$1(E);throw Error("illegal buffer")},create$1=function J(){return util$5.Buffer?function(E){return(Reader$1.create=function(ee){return util$5.Buffer.isBuffer(ee)?new BufferReader$1(ee):create_array(ee)})(E)}:create_array};Reader$1.create=create$1();Reader$1.prototype._slice=util$5.Array.prototype.subarray||util$5.Array.prototype.slice;Reader$1.prototype.uint32=function J(){var E=4294967295;return function(){if(E=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(E=(E|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(E=(E|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(E=(E|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(E=(E|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return E;if((this.pos+=5)>this.len)throw this.pos=this.len,indexOutOfRange(this,10);return E}}();Reader$1.prototype.int32=function J(){return this.uint32()|0};Reader$1.prototype.sint32=function J(){var E=this.uint32();return E>>>1^-(E&1)|0};function readLongVarint(){var J=new LongBits$2(0,0),E=0;if(this.len-this.pos>4){for(;E<4;++E)if(J.lo=(J.lo|(this.buf[this.pos]&127)<<E*7)>>>0,this.buf[this.pos++]<128)return J;if(J.lo=(J.lo|(this.buf[this.pos]&127)<<28)>>>0,J.hi=(J.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return J;E=0}else{for(;E<3;++E){if(this.pos>=this.len)throw indexOutOfRange(this);if(J.lo=(J.lo|(this.buf[this.pos]&127)<<E*7)>>>0,this.buf[this.pos++]<128)return J}return J.lo=(J.lo|(this.buf[this.pos++]&127)<<E*7)>>>0,J}if(this.len-this.pos>4){for(;E<5;++E)if(J.hi=(J.hi|(this.buf[this.pos]&127)<<E*7+3)>>>0,this.buf[this.pos++]<128)return J}else for(;E<5;++E){if(this.pos>=this.len)throw indexOutOfRange(this);if(J.hi=(J.hi|(this.buf[this.pos]&127)<<E*7+3)>>>0,this.buf[this.pos++]<128)return J}throw Error("invalid varint encoding")}Reader$1.prototype.bool=function J(){return this.uint32()!==0};function readFixed32_end(J,E){return(J[E-4]|J[E-3]<<8|J[E-2]<<16|J[E-1]<<24)>>>0}Reader$1.prototype.fixed32=function J(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);return readFixed32_end(this.buf,this.pos+=4)};Reader$1.prototype.sfixed32=function J(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);return readFixed32_end(this.buf,this.pos+=4)|0};function readFixed64(){if(this.pos+8>this.len)throw indexOutOfRange(this,8);return new LongBits$2(readFixed32_end(this.buf,this.pos+=4),readFixed32_end(this.buf,this.pos+=4))}Reader$1.prototype.float=function J(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);var E=util$5.float.readFloatLE(this.buf,this.pos);return this.pos+=4,E};Reader$1.prototype.double=function J(){if(this.pos+8>this.len)throw indexOutOfRange(this,4);var E=util$5.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,E};Reader$1.prototype.bytes=function J(){var E=this.uint32(),ee=this.pos,te=this.pos+E;if(te>this.len)throw indexOutOfRange(this,E);return this.pos+=E,Array.isArray(this.buf)?this.buf.slice(ee,te):ee===te?new this.buf.constructor(0):this._slice.call(this.buf,ee,te)};Reader$1.prototype.string=function J(){var E=this.bytes();return utf8$1.read(E,0,E.length)};Reader$1.prototype.skip=function J(E){if(typeof E=="number"){if(this.pos+E>this.len)throw indexOutOfRange(this,E);this.pos+=E}else do if(this.pos>=this.len)throw indexOutOfRange(this);while(this.buf[this.pos++]&128);return this};Reader$1.prototype.skipType=function(J){switch(J){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(J=this.uint32()&7)!==4;)this.skipType(J);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+J+" at offset "+this.pos)}return this};Reader$1._configure=function(J){BufferReader$1=J,Reader$1.create=create$1(),BufferReader$1._configure();var E=util$5.Long?"toLong":"toNumber";util$5.merge(Reader$1.prototype,{int64:function(){return readLongVarint.call(this)[E](!1)},uint64:function(){return readLongVarint.call(this)[E](!0)},sint64:function(){return readLongVarint.call(this).zzDecode()[E](!1)},fixed64:function(){return readFixed64.call(this)[E](!0)},sfixed64:function(){return readFixed64.call(this)[E](!1)}})};const ReaderClass=getDefaultExportFromCjs(reader$3);var reader_buffer$1=BufferReader,Reader=reader$3;(BufferReader.prototype=Object.create(Reader.prototype)).constructor=BufferReader;var util$4=requireMinimal$2();function BufferReader(J){Reader.call(this,J)}BufferReader._configure=function(){util$4.Buffer&&(BufferReader.prototype._slice=util$4.Buffer.prototype.slice)};BufferReader.prototype.string=function J(){var E=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+E,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+E,this.len))};BufferReader._configure();const ReaderBufferClass=getDefaultExportFromCjs(reader_buffer$1);var minimalExports$1=requireMinimal$2();const util$3=getDefaultExportFromCjs(minimalExports$1);var writer$2=Writer$1,util$2=requireMinimal$2(),BufferWriter$1,LongBits$1=util$2.LongBits,base64$2=util$2.base64,utf8=util$2.utf8;function Op(J,E,ee){this.fn=J,this.len=E,this.next=void 0,this.val=ee}function noop$1(){}function State(J){this.head=J.head,this.tail=J.tail,this.len=J.len,this.next=J.states}function Writer$1(){this.len=0,this.head=new Op(noop$1,0,0),this.tail=this.head,this.states=null}var create=function J(){return util$2.Buffer?function(){return(Writer$1.create=function(){return new BufferWriter$1})()}:function(){return new Writer$1}};Writer$1.create=create();Writer$1.alloc=function J(E){return new util$2.Array(E)};util$2.Array!==Array&&(Writer$1.alloc=util$2.pool(Writer$1.alloc,util$2.Array.prototype.subarray));Writer$1.prototype._push=function J(E,ee,te){return this.tail=this.tail.next=new Op(E,ee,te),this.len+=ee,this};function writeByte(J,E,ee){E[ee]=J&255}function writeVarint32(J,E,ee){for(;J>127;)E[ee++]=J&127|128,J>>>=7;E[ee]=J}function VarintOp(J,E){this.len=J,this.next=void 0,this.val=E}VarintOp.prototype=Object.create(Op.prototype);VarintOp.prototype.fn=writeVarint32;Writer$1.prototype.uint32=function J(E){return this.len+=(this.tail=this.tail.next=new VarintOp((E=E>>>0)<128?1:E<16384?2:E<2097152?3:E<268435456?4:5,E)).len,this};Writer$1.prototype.int32=function J(E){return E<0?this._push(writeVarint64,10,LongBits$1.fromNumber(E)):this.uint32(E)};Writer$1.prototype.sint32=function J(E){return this.uint32((E<<1^E>>31)>>>0)};function writeVarint64(J,E,ee){for(;J.hi;)E[ee++]=J.lo&127|128,J.lo=(J.lo>>>7|J.hi<<25)>>>0,J.hi>>>=7;for(;J.lo>127;)E[ee++]=J.lo&127|128,J.lo=J.lo>>>7;E[ee++]=J.lo}Writer$1.prototype.uint64=function J(E){var ee=LongBits$1.from(E);return this._push(writeVarint64,ee.length(),ee)};Writer$1.prototype.int64=Writer$1.prototype.uint64;Writer$1.prototype.sint64=function J(E){var ee=LongBits$1.from(E).zzEncode();return this._push(writeVarint64,ee.length(),ee)};Writer$1.prototype.bool=function J(E){return this._push(writeByte,1,E?1:0)};function writeFixed32(J,E,ee){E[ee]=J&255,E[ee+1]=J>>>8&255,E[ee+2]=J>>>16&255,E[ee+3]=J>>>24}Writer$1.prototype.fixed32=function J(E){return this._push(writeFixed32,4,E>>>0)};Writer$1.prototype.sfixed32=Writer$1.prototype.fixed32;Writer$1.prototype.fixed64=function J(E){var ee=LongBits$1.from(E);return this._push(writeFixed32,4,ee.lo)._push(writeFixed32,4,ee.hi)};Writer$1.prototype.sfixed64=Writer$1.prototype.fixed64;Writer$1.prototype.float=function J(E){return this._push(util$2.float.writeFloatLE,4,E)};Writer$1.prototype.double=function J(E){return this._push(util$2.float.writeDoubleLE,8,E)};var writeBytes=util$2.Array.prototype.set?function J(E,ee,te){ee.set(E,te)}:function J(E,ee,te){for(var re=0;re<E.length;++re)ee[te+re]=E[re]};Writer$1.prototype.bytes=function J(E){var ee=E.length>>>0;if(!ee)return this._push(writeByte,1,0);if(util$2.isString(E)){var te=Writer$1.alloc(ee=base64$2.length(E));base64$2.decode(E,te,0),E=te}return this.uint32(ee)._push(writeBytes,ee,E)};Writer$1.prototype.string=function J(E){var ee=utf8.length(E);return ee?this.uint32(ee)._push(utf8.write,ee,E):this._push(writeByte,1,0)};Writer$1.prototype.fork=function J(){return this.states=new State(this),this.head=this.tail=new Op(noop$1,0,0),this.len=0,this};Writer$1.prototype.reset=function J(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Op(noop$1,0,0),this.len=0),this};Writer$1.prototype.ldelim=function J(){var E=this.head,ee=this.tail,te=this.len;return this.reset().uint32(te),te&&(this.tail.next=E.next,this.tail=ee,this.len+=te),this};Writer$1.prototype.finish=function J(){for(var E=this.head.next,ee=this.constructor.alloc(this.len),te=0;E;)E.fn(E.val,ee,te),te+=E.len,E=E.next;return ee};Writer$1._configure=function(J){BufferWriter$1=J,Writer$1.create=create(),BufferWriter$1._configure()};const WriterClass=getDefaultExportFromCjs(writer$2);var writer_buffer$1=BufferWriter,Writer=writer$2;(BufferWriter.prototype=Object.create(Writer.prototype)).constructor=BufferWriter;var util$1=requireMinimal$2();function BufferWriter(){Writer.call(this)}BufferWriter._configure=function(){BufferWriter.alloc=util$1._Buffer_allocUnsafe,BufferWriter.writeBytesBuffer=util$1.Buffer&&util$1.Buffer.prototype instanceof Uint8Array&&util$1.Buffer.prototype.set.name==="set"?function(J,E,ee){E.set(J,ee)}:function(J,E,ee){if(J.copy)J.copy(E,ee,0,J.length);else for(var te=0;te<J.length;)E[ee++]=J[te++]}};BufferWriter.prototype.bytes=function J(E){util$1.isString(E)&&(E=util$1._Buffer_from(E,"base64"));var ee=E.length>>>0;return this.uint32(ee),ee&&this._push(BufferWriter.writeBytesBuffer,ee,E),this};function writeStringBuffer(J,E,ee){J.length<40?util$1.utf8.write(J,E,ee):E.utf8Write?E.utf8Write(J,ee):E.write(J,ee)}BufferWriter.prototype.string=function J(E){var ee=util$1.Buffer.byteLength(E);return this.uint32(ee),ee&&this._push(writeStringBuffer,ee,E),this};BufferWriter._configure();const WriterBufferClass=getDefaultExportFromCjs(writer_buffer$1);function configure(){util$3._configure(),ReaderClass._configure(ReaderBufferClass),WriterClass._configure(WriterBufferClass)}configure();const methods=["uint64","int64","sint64","fixed64","sfixed64"];function patchReader(J){for(const E of methods){if(J[E]==null)continue;const ee=J[E];J[E]=function(){return BigInt(ee.call(this).toString())}}return J}function reader$2(J){return patchReader(new ReaderClass(J))}function patchWriter(J){for(const E of methods){if(J[E]==null)continue;const ee=J[E];J[E]=function(te){return ee.call(this,te.toString())}}return J}function writer$1(){return patchWriter(WriterClass.create())}function decodeMessage$1(J,E){const ee=reader$2(J instanceof Uint8Array?J:J.subarray());return E.decode(ee)}function encodeMessage(J,E){const ee=writer$1();return E.encode(J,ee,{lengthDelimited:!1}),ee.finish()}var CODEC_TYPES;(function(J){J[J.VARINT=0]="VARINT",J[J.BIT64=1]="BIT64",J[J.LENGTH_DELIMITED=2]="LENGTH_DELIMITED",J[J.START_GROUP=3]="START_GROUP",J[J.END_GROUP=4]="END_GROUP",J[J.BIT32=5]="BIT32"})(CODEC_TYPES||(CODEC_TYPES={}));function createCodec$1(J,E,ee,te){return{name:J,type:E,encode:ee,decode:te}}function enumeration(J){function E(re){if(J[re.toString()]==null)throw new Error("Invalid enum value");return J[re]}const ee=function(re,ne){const ie=E(re);ne.int32(ie)},te=function(re){const ne=re.int32();return E(ne)};return createCodec$1("enum",CODEC_TYPES.VARINT,ee,te)}function message(J,E){return createCodec$1("message",CODEC_TYPES.LENGTH_DELIMITED,J,E)}var KeyType;(function(J){J.RSA="RSA",J.Ed25519="Ed25519",J.Secp256k1="Secp256k1"})(KeyType||(KeyType={}));var __KeyTypeValues;(function(J){J[J.RSA=0]="RSA",J[J.Ed25519=1]="Ed25519",J[J.Secp256k1=2]="Secp256k1"})(__KeyTypeValues||(__KeyTypeValues={}));(function(J){J.codec=()=>enumeration(__KeyTypeValues)})(KeyType||(KeyType={}));var PublicKey;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{re.lengthDelimited!==!1&&te.fork(),ee.Type!=null&&(te.uint32(8),KeyType.codec().encode(ee.Type,te)),ee.Data!=null&&(te.uint32(18),te.bytes(ee.Data)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.Type=KeyType.codec().decode(ee);break;case 2:re.Data=ee.bytes();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage$1(ee,J.codec())})(PublicKey||(PublicKey={}));var PrivateKey;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{re.lengthDelimited!==!1&&te.fork(),ee.Type!=null&&(te.uint32(8),KeyType.codec().encode(ee.Type,te)),ee.Data!=null&&(te.uint32(18),te.bytes(ee.Data)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.Type=KeyType.codec().decode(ee);break;case 2:re.Data=ee.bytes();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage$1(ee,J.codec())})(PrivateKey||(PrivateKey={}));class Ed25519PublicKey{_key;constructor(E){this._key=ensureKey(E,PUBLIC_KEY_BYTE_LENGTH)}async verify(E,ee){return hashAndVerify$2(this._key,ee,E)}marshal(){return this._key}get bytes(){return PublicKey.encode({Type:KeyType.Ed25519,Data:this.marshal()}).subarray()}equals(E){return equals(this.bytes,E.bytes)}async hash(){const{bytes:E}=await sha256$3.digest(this.bytes);return E}}class Ed25519PrivateKey{_key;_publicKey;constructor(E,ee){this._key=ensureKey(E,PRIVATE_KEY_BYTE_LENGTH),this._publicKey=ensureKey(ee,PUBLIC_KEY_BYTE_LENGTH)}async sign(E){return hashAndSign$2(this._key,E)}get public(){return new Ed25519PublicKey(this._publicKey)}marshal(){return this._key}get bytes(){return PrivateKey.encode({Type:KeyType.Ed25519,Data:this.marshal()}).subarray()}equals(E){return equals(this.bytes,E.bytes)}async hash(){const{bytes:E}=await sha256$3.digest(this.bytes);return E}async id(){const E=identity$2.digest(this.public.bytes);return base58btc$1.encode(E.bytes).substring(1)}async export(E,ee="libp2p-key"){if(ee==="libp2p-key")return exporter$1(this.bytes,E);throw new CodeError(`export format '${ee}' is not supported`,"ERR_INVALID_EXPORT_FORMAT")}}function unmarshalEd25519PrivateKey(J){if(J.length>PRIVATE_KEY_BYTE_LENGTH){J=ensureKey(J,PRIVATE_KEY_BYTE_LENGTH+PUBLIC_KEY_BYTE_LENGTH);const te=J.subarray(0,PRIVATE_KEY_BYTE_LENGTH),re=J.subarray(PRIVATE_KEY_BYTE_LENGTH,J.length);return new Ed25519PrivateKey(te,re)}J=ensureKey(J,PRIVATE_KEY_BYTE_LENGTH);const E=J.subarray(0,PRIVATE_KEY_BYTE_LENGTH),ee=J.subarray(PUBLIC_KEY_BYTE_LENGTH);return new Ed25519PrivateKey(E,ee)}function unmarshalEd25519PublicKey(J){return J=ensureKey(J,PUBLIC_KEY_BYTE_LENGTH),new Ed25519PublicKey(J)}async function generateKeyPair$3(){const{privateKey:J,publicKey:E}=await generateKey$2();return new Ed25519PrivateKey(J,E)}async function generateKeyPairFromSeed(J){const{privateKey:E,publicKey:ee}=await generateKeyFromSeed(J);return new Ed25519PrivateKey(E,ee)}function ensureKey(J,E){if(J=Uint8Array.from(J??[]),J.length!==E)throw new CodeError(`Key must be a Uint8Array of length ${E}, got ${J.length}`,"ERR_INVALID_KEY_TYPE");return J}const Ed25519=Object.freeze(Object.defineProperty({__proto__:null,Ed25519PrivateKey,Ed25519PublicKey,generateKeyPair:generateKeyPair$3,generateKeyPairFromSeed,unmarshalEd25519PrivateKey,unmarshalEd25519PublicKey},Symbol.toStringTag,{value:"Module"}));function bigIntegerToUintBase64url(J,E){let ee=Uint8Array.from(J.abs().toByteArray());if(ee=ee[0]===0?ee.subarray(1):ee,E!=null){if(ee.length>E)throw new Error("byte array longer than desired length");ee=concat$4([new Uint8Array(E-ee.length),ee])}return toString$5(ee,"base64url")}function base64urlToBigInteger(J){const E=base64urlToBuffer(J);return new forge$n.jsbn.BigInteger(toString$5(E,"base16"),16)}function base64urlToBuffer(J,E){let ee=fromString$5(J,"base64urlpad");if(E!=null){if(ee.length>E)throw new Error("byte array longer than desired length");ee=concat$4([new Uint8Array(E-ee.length),ee])}return ee}const bits={"P-256":256,"P-384":384,"P-521":521},curveTypes=Object.keys(bits);curveTypes.join(" / ");async function importer$1(J,E){const ee=base64$4.decode(J);return create$2().decrypt(ee,E)}var forge=forge$m,sha512=forge.sha512=forge.sha512||{};forge.md.sha512=forge.md.algorithms.sha512=sha512;var sha384=forge.sha384=forge.sha512.sha384=forge.sha512.sha384||{};sha384.create=function(){return sha512.create("SHA-384")};forge.md.sha384=forge.md.algorithms.sha384=sha384;forge.sha512.sha256=forge.sha512.sha256||{create:function(){return sha512.create("SHA-512/256")}};forge.md["sha512/256"]=forge.md.algorithms["sha512/256"]=forge.sha512.sha256;forge.sha512.sha224=forge.sha512.sha224||{create:function(){return sha512.create("SHA-512/224")}};forge.md["sha512/224"]=forge.md.algorithms["sha512/224"]=forge.sha512.sha224;sha512.create=function(J){if(_initialized||_init(),typeof J>"u"&&(J="SHA-512"),!(J in _states))throw new Error("Invalid SHA-512 algorithm: "+J);for(var E=_states[J],ee=null,te=forge.util.createBuffer(),re=new Array(80),ne=0;ne<80;++ne)re[ne]=new Array(2);var ie=64;switch(J){case"SHA-384":ie=48;break;case"SHA-512/256":ie=32;break;case"SHA-512/224":ie=28;break}var se={algorithm:J.replace("-","").toLowerCase(),blockLength:128,digestLength:ie,messageLength:0,fullMessageLength:null,messageLengthSize:16};return se.start=function(){se.messageLength=0,se.fullMessageLength=se.messageLength128=[];for(var oe=se.messageLengthSize/4,ce=0;ce<oe;++ce)se.fullMessageLength.push(0);te=forge.util.createBuffer(),ee=new Array(E.length);for(var ce=0;ce<E.length;++ce)ee[ce]=E[ce].slice(0);return se},se.start(),se.update=function(oe,ce){ce==="utf8"&&(oe=forge.util.encodeUtf8(oe));var ae=oe.length;se.messageLength+=ae,ae=[ae/4294967296>>>0,ae>>>0];for(var le=se.fullMessageLength.length-1;le>=0;--le)se.fullMessageLength[le]+=ae[1],ae[1]=ae[0]+(se.fullMessageLength[le]/4294967296>>>0),se.fullMessageLength[le]=se.fullMessageLength[le]>>>0,ae[0]=ae[1]/4294967296>>>0;return te.putBytes(oe),_update(ee,re,te),(te.read>2048||te.length()===0)&&te.compact(),se},se.digest=function(){var oe=forge.util.createBuffer();oe.putBytes(te.bytes());var ce=se.fullMessageLength[se.fullMessageLength.length-1]+se.messageLengthSize,ae=ce&se.blockLength-1;oe.putBytes(_padding.substr(0,se.blockLength-ae));for(var le,ue,he=se.fullMessageLength[0]*8,pe=0;pe<se.fullMessageLength.length-1;++pe)le=se.fullMessageLength[pe+1]*8,ue=le/4294967296>>>0,he+=ue,oe.putInt32(he>>>0),he=le>>>0;oe.putInt32(he);for(var de=new Array(ee.length),pe=0;pe<ee.length;++pe)de[pe]=ee[pe].slice(0);_update(de,re,oe);var fe=forge.util.createBuffer(),me;J==="SHA-512"?me=de.length:J==="SHA-384"?me=de.length-2:me=de.length-4;for(var pe=0;pe<me;++pe)fe.putInt32(de[pe][0]),(pe!==me-1||J!=="SHA-512/224")&&fe.putInt32(de[pe][1]);return fe},se};var _padding=null,_initialized=!1,_k=null,_states=null;function _init(){_padding=String.fromCharCode(128),_padding+=forge.util.fillString(String.fromCharCode(0),128),_k=[[1116352408,3609767458],[1899447441,602891725],[3049323471,3964484399],[3921009573,2173295548],[961987163,4081628472],[1508970993,3053834265],[2453635748,2937671579],[2870763221,3664609560],[3624381080,2734883394],[310598401,1164996542],[607225278,1323610764],[1426881987,3590304994],[1925078388,4068182383],[2162078206,991336113],[2614888103,633803317],[3248222580,3479774868],[3835390401,2666613458],[4022224774,944711139],[264347078,2341262773],[604807628,2007800933],[770255983,1495990901],[1249150122,1856431235],[1555081692,3175218132],[1996064986,2198950837],[2554220882,3999719339],[2821834349,766784016],[2952996808,2566594879],[3210313671,3203337956],[3336571891,1034457026],[3584528711,2466948901],[113926993,3758326383],[338241895,168717936],[666307205,1188179964],[773529912,1546045734],[1294757372,1522805485],[1396182291,2643833823],[1695183700,2343527390],[1986661051,1014477480],[2177026350,1206759142],[2456956037,344077627],[2730485921,1290863460],[2820302411,3158454273],[3259730800,3505952657],[3345764771,106217008],[3516065817,3606008344],[3600352804,1432725776],[4094571909,1467031594],[275423344,851169720],[430227734,3100823752],[506948616,1363258195],[659060556,3750685593],[883997877,3785050280],[958139571,3318307427],[1322822218,3812723403],[1537002063,2003034995],[1747873779,3602036899],[1955562222,1575990012],[2024104815,1125592928],[2227730452,2716904306],[2361852424,442776044],[2428436474,593698344],[2756734187,3733110249],[3204031479,2999351573],[3329325298,3815920427],[3391569614,3928383900],[3515267271,566280711],[3940187606,3454069534],[4118630271,4000239992],[116418474,1914138554],[174292421,2731055270],[289380356,3203993006],[460393269,320620315],[685471733,587496836],[852142971,1086792851],[1017036298,365543100],[1126000580,2618297676],[1288033470,3409855158],[1501505948,4234509866],[1607167915,987167468],[1816402316,1246189591]],_states={},_states["SHA-512"]=[[1779033703,4089235720],[3144134277,2227873595],[1013904242,4271175723],[2773480762,1595750129],[1359893119,2917565137],[2600822924,725511199],[528734635,4215389547],[1541459225,327033209]],_states["SHA-384"]=[[3418070365,3238371032],[1654270250,914150663],[2438529370,812702999],[355462360,4144912697],[1731405415,4290775857],[2394180231,1750603025],[3675008525,1694076839],[1203062813,3204075428]],_states["SHA-512/256"]=[[573645204,4230739756],[2673172387,3360449730],[596883563,1867755857],[2520282905,1497426621],[2519219938,2827943907],[3193839141,1401305490],[721525244,746961066],[246885852,2177182882]],_states["SHA-512/224"]=[[2352822216,424955298],[1944164710,2312950998],[502970286,855612546],[1738396948,1479516111],[258812777,2077511080],[2011393907,79989058],[1067287976,1780299464],[286451373,2446758561]],_initialized=!0}function _update(J,E,ee){for(var te,re,ne,ie,se,oe,ce,ae,le,ue,he,pe,de,fe,me,_e,be,Ee,ve,we,ge,Se,$e,Pe,Me,xe,Fe,ke,Te,Ve,Ce,Ne,Oe,Le,Be,ze=ee.length();ze>=128;){for(Te=0;Te<16;++Te)E[Te][0]=ee.getInt32()>>>0,E[Te][1]=ee.getInt32()>>>0;for(;Te<80;++Te)Ne=E[Te-2],Ve=Ne[0],Ce=Ne[1],te=((Ve>>>19|Ce<<13)^(Ce>>>29|Ve<<3)^Ve>>>6)>>>0,re=((Ve<<13|Ce>>>19)^(Ce<<3|Ve>>>29)^(Ve<<26|Ce>>>6))>>>0,Le=E[Te-15],Ve=Le[0],Ce=Le[1],ne=((Ve>>>1|Ce<<31)^(Ve>>>8|Ce<<24)^Ve>>>7)>>>0,ie=((Ve<<31|Ce>>>1)^(Ve<<24|Ce>>>8)^(Ve<<25|Ce>>>7))>>>0,Oe=E[Te-7],Be=E[Te-16],Ce=re+Oe[1]+ie+Be[1],E[Te][0]=te+Oe[0]+ne+Be[0]+(Ce/4294967296>>>0)>>>0,E[Te][1]=Ce>>>0;for(de=J[0][0],fe=J[0][1],me=J[1][0],_e=J[1][1],be=J[2][0],Ee=J[2][1],ve=J[3][0],we=J[3][1],ge=J[4][0],Se=J[4][1],$e=J[5][0],Pe=J[5][1],Me=J[6][0],xe=J[6][1],Fe=J[7][0],ke=J[7][1],Te=0;Te<80;++Te)ce=((ge>>>14|Se<<18)^(ge>>>18|Se<<14)^(Se>>>9|ge<<23))>>>0,ae=((ge<<18|Se>>>14)^(ge<<14|Se>>>18)^(Se<<23|ge>>>9))>>>0,le=(Me^ge&($e^Me))>>>0,ue=(xe^Se&(Pe^xe))>>>0,se=((de>>>28|fe<<4)^(fe>>>2|de<<30)^(fe>>>7|de<<25))>>>0,oe=((de<<4|fe>>>28)^(fe<<30|de>>>2)^(fe<<25|de>>>7))>>>0,he=(de&me|be&(de^me))>>>0,pe=(fe&_e|Ee&(fe^_e))>>>0,Ce=ke+ae+ue+_k[Te][1]+E[Te][1],te=Fe+ce+le+_k[Te][0]+E[Te][0]+(Ce/4294967296>>>0)>>>0,re=Ce>>>0,Ce=oe+pe,ne=se+he+(Ce/4294967296>>>0)>>>0,ie=Ce>>>0,Fe=Me,ke=xe,Me=$e,xe=Pe,$e=ge,Pe=Se,Ce=we+re,ge=ve+te+(Ce/4294967296>>>0)>>>0,Se=Ce>>>0,ve=be,we=Ee,be=me,Ee=_e,me=de,_e=fe,Ce=re+ie,de=te+ne+(Ce/4294967296>>>0)>>>0,fe=Ce>>>0;Ce=J[0][1]+fe,J[0][0]=J[0][0]+de+(Ce/4294967296>>>0)>>>0,J[0][1]=Ce>>>0,Ce=J[1][1]+_e,J[1][0]=J[1][0]+me+(Ce/4294967296>>>0)>>>0,J[1][1]=Ce>>>0,Ce=J[2][1]+Ee,J[2][0]=J[2][0]+be+(Ce/4294967296>>>0)>>>0,J[2][1]=Ce>>>0,Ce=J[3][1]+we,J[3][0]=J[3][0]+ve+(Ce/4294967296>>>0)>>>0,J[3][1]=Ce>>>0,Ce=J[4][1]+Se,J[4][0]=J[4][0]+ge+(Ce/4294967296>>>0)>>>0,J[4][1]=Ce>>>0,Ce=J[5][1]+Pe,J[5][0]=J[5][0]+$e+(Ce/4294967296>>>0)>>>0,J[5][1]=Ce>>>0,Ce=J[6][1]+xe,J[6][0]=J[6][0]+Me+(Ce/4294967296>>>0)>>>0,J[6][1]=Ce>>>0,Ce=J[7][1]+ke,J[7][0]=J[7][0]+Fe+(Ce/4294967296>>>0)>>>0,J[7][1]=Ce>>>0,ze-=128}}/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */const _0n=BigInt(0),_1n=BigInt(1),_2n=BigInt(2),_3n=BigInt(3),_8n=BigInt(8),CURVE=Object.freeze({a:_0n,b:BigInt(7),P:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:_1n,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")}),divNearest=(J,E)=>(J+E/_2n)/E,endo={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar(J){const{n:E}=CURVE,ee=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),te=-_1n*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),re=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),ne=ee,ie=BigInt("0x100000000000000000000000000000000"),se=divNearest(ne*J,E),oe=divNearest(-te*J,E);let ce=mod(J-se*ee-oe*re,E),ae=mod(-se*te-oe*ne,E);const le=ce>ie,ue=ae>ie;if(le&&(ce=E-ce),ue&&(ae=E-ae),ce>ie||ae>ie)throw new Error("splitScalarEndo: Endomorphism failed, k="+J);return{k1neg:le,k1:ce,k2neg:ue,k2:ae}}},fieldLen=32,groupLen=32,hashLen=32,compressedLen=fieldLen+1,uncompressedLen=2*fieldLen+1;function weierstrass(J){const{a:E,b:ee}=CURVE,te=mod(J*J),re=mod(te*J);return mod(re+E*J+ee)}const USE_ENDOMORPHISM=CURVE.a===_0n;class ShaError extends Error{constructor(E){super(E)}}function assertJacPoint(J){if(!(J instanceof JacobianPoint))throw new TypeError("JacobianPoint expected")}class JacobianPoint{constructor(E,ee,te){this.x=E,this.y=ee,this.z=te}static fromAffine(E){if(!(E instanceof Point))throw new TypeError("JacobianPoint#fromAffine: expected Point");return E.equals(Point.ZERO)?JacobianPoint.ZERO:new JacobianPoint(E.x,E.y,_1n)}static toAffineBatch(E){const ee=invertBatch(E.map(te=>te.z));return E.map((te,re)=>te.toAffine(ee[re]))}static normalizeZ(E){return JacobianPoint.toAffineBatch(E).map(JacobianPoint.fromAffine)}equals(E){assertJacPoint(E);const{x:ee,y:te,z:re}=this,{x:ne,y:ie,z:se}=E,oe=mod(re*re),ce=mod(se*se),ae=mod(ee*ce),le=mod(ne*oe),ue=mod(mod(te*se)*ce),he=mod(mod(ie*re)*oe);return ae===le&&ue===he}negate(){return new JacobianPoint(this.x,mod(-this.y),this.z)}double(){const{x:E,y:ee,z:te}=this,re=mod(E*E),ne=mod(ee*ee),ie=mod(ne*ne),se=E+ne,oe=mod(_2n*(mod(se*se)-re-ie)),ce=mod(_3n*re),ae=mod(ce*ce),le=mod(ae-_2n*oe),ue=mod(ce*(oe-le)-_8n*ie),he=mod(_2n*ee*te);return new JacobianPoint(le,ue,he)}add(E){assertJacPoint(E);const{x:ee,y:te,z:re}=this,{x:ne,y:ie,z:se}=E;if(ne===_0n||ie===_0n)return this;if(ee===_0n||te===_0n)return E;const oe=mod(re*re),ce=mod(se*se),ae=mod(ee*ce),le=mod(ne*oe),ue=mod(mod(te*se)*ce),he=mod(mod(ie*re)*oe),pe=mod(le-ae),de=mod(he-ue);if(pe===_0n)return de===_0n?this.double():JacobianPoint.ZERO;const fe=mod(pe*pe),me=mod(pe*fe),_e=mod(ae*fe),be=mod(de*de-me-_2n*_e),Ee=mod(de*(_e-be)-ue*me),ve=mod(re*se*pe);return new JacobianPoint(be,Ee,ve)}subtract(E){return this.add(E.negate())}multiplyUnsafe(E){const ee=JacobianPoint.ZERO;if(typeof E=="bigint"&&E===_0n)return ee;let te=normalizeScalar(E);if(te===_1n)return this;if(!USE_ENDOMORPHISM){let le=ee,ue=this;for(;te>_0n;)te&_1n&&(le=le.add(ue)),ue=ue.double(),te>>=_1n;return le}let{k1neg:re,k1:ne,k2neg:ie,k2:se}=endo.splitScalar(te),oe=ee,ce=ee,ae=this;for(;ne>_0n||se>_0n;)ne&_1n&&(oe=oe.add(ae)),se&_1n&&(ce=ce.add(ae)),ae=ae.double(),ne>>=_1n,se>>=_1n;return re&&(oe=oe.negate()),ie&&(ce=ce.negate()),ce=new JacobianPoint(mod(ce.x*endo.beta),ce.y,ce.z),oe.add(ce)}precomputeWindow(E){const ee=USE_ENDOMORPHISM?128/E+1:256/E+1,te=[];let re=this,ne=re;for(let ie=0;ie<ee;ie++){ne=re,te.push(ne);for(let se=1;se<2**(E-1);se++)ne=ne.add(re),te.push(ne);re=ne.double()}return te}wNAF(E,ee){!ee&&this.equals(JacobianPoint.BASE)&&(ee=Point.BASE);const te=ee&&ee._WINDOW_SIZE||1;if(256%te)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let re=ee&&pointPrecomputes.get(ee);re||(re=this.precomputeWindow(te),ee&&te!==1&&(re=JacobianPoint.normalizeZ(re),pointPrecomputes.set(ee,re)));let ne=JacobianPoint.ZERO,ie=JacobianPoint.BASE;const se=1+(USE_ENDOMORPHISM?128/te:256/te),oe=2**(te-1),ce=BigInt(2**te-1),ae=2**te,le=BigInt(te);for(let ue=0;ue<se;ue++){const he=ue*oe;let pe=Number(E&ce);E>>=le,pe>oe&&(pe-=ae,E+=_1n);const de=he,fe=he+Math.abs(pe)-1,me=ue%2!==0,_e=pe<0;pe===0?ie=ie.add(constTimeNegate(me,re[de])):ne=ne.add(constTimeNegate(_e,re[fe]))}return{p:ne,f:ie}}multiply(E,ee){let te=normalizeScalar(E),re,ne;if(USE_ENDOMORPHISM){const{k1neg:ie,k1:se,k2neg:oe,k2:ce}=endo.splitScalar(te);let{p:ae,f:le}=this.wNAF(se,ee),{p:ue,f:he}=this.wNAF(ce,ee);ae=constTimeNegate(ie,ae),ue=constTimeNegate(oe,ue),ue=new JacobianPoint(mod(ue.x*endo.beta),ue.y,ue.z),re=ae.add(ue),ne=le.add(he)}else{const{p:ie,f:se}=this.wNAF(te,ee);re=ie,ne=se}return JacobianPoint.normalizeZ([re,ne])[0]}toAffine(E){const{x:ee,y:te,z:re}=this,ne=this.equals(JacobianPoint.ZERO);E==null&&(E=ne?_8n:invert(re));const ie=E,se=mod(ie*ie),oe=mod(se*ie),ce=mod(ee*se),ae=mod(te*oe),le=mod(re*ie);if(ne)return Point.ZERO;if(le!==_1n)throw new Error("invZ was invalid");return new Point(ce,ae)}}JacobianPoint.BASE=new JacobianPoint(CURVE.Gx,CURVE.Gy,_1n);JacobianPoint.ZERO=new JacobianPoint(_0n,_1n,_0n);function constTimeNegate(J,E){const ee=E.negate();return J?ee:E}const pointPrecomputes=new WeakMap;class Point{constructor(E,ee){this.x=E,this.y=ee}_setWindowSize(E){this._WINDOW_SIZE=E,pointPrecomputes.delete(this)}hasEvenY(){return this.y%_2n===_0n}static fromCompressedHex(E){const ee=E.length===32,te=bytesToNumber(ee?E:E.subarray(1));if(!isValidFieldElement(te))throw new Error("Point is not on curve");const re=weierstrass(te);let ne=sqrtMod(re);const ie=(ne&_1n)===_1n;ee?ie&&(ne=mod(-ne)):(E[0]&1)===1!==ie&&(ne=mod(-ne));const se=new Point(te,ne);return se.assertValidity(),se}static fromUncompressedHex(E){const ee=bytesToNumber(E.subarray(1,fieldLen+1)),te=bytesToNumber(E.subarray(fieldLen+1,fieldLen*2+1)),re=new Point(ee,te);return re.assertValidity(),re}static fromHex(E){const ee=ensureBytes(E),te=ee.length,re=ee[0];if(te===fieldLen)return this.fromCompressedHex(ee);if(te===compressedLen&&(re===2||re===3))return this.fromCompressedHex(ee);if(te===uncompressedLen&&re===4)return this.fromUncompressedHex(ee);throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${te}`)}static fromPrivateKey(E){return Point.BASE.multiply(normalizePrivateKey(E))}static fromSignature(E,ee,te){const{r:re,s:ne}=normalizeSignature(ee);if(![0,1,2,3].includes(te))throw new Error("Cannot recover: invalid recovery bit");const ie=truncateHash(ensureBytes(E)),{n:se}=CURVE,oe=te===2||te===3?re+se:re,ce=invert(oe,se),ae=mod(-ie*ce,se),le=mod(ne*ce,se),ue=te&1?"03":"02",he=Point.fromHex(ue+numTo32bStr(oe)),pe=Point.BASE.multiplyAndAddUnsafe(he,ae,le);if(!pe)throw new Error("Cannot recover signature: point at infinify");return pe.assertValidity(),pe}toRawBytes(E=!1){return hexToBytes(this.toHex(E))}toHex(E=!1){const ee=numTo32bStr(this.x);return E?`${this.hasEvenY()?"02":"03"}${ee}`:`04${ee}${numTo32bStr(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const E="Point is not on elliptic curve",{x:ee,y:te}=this;if(!isValidFieldElement(ee)||!isValidFieldElement(te))throw new Error(E);const re=mod(te*te),ne=weierstrass(ee);if(mod(re-ne)!==_0n)throw new Error(E)}equals(E){return this.x===E.x&&this.y===E.y}negate(){return new Point(this.x,mod(-this.y))}double(){return JacobianPoint.fromAffine(this).double().toAffine()}add(E){return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(E)).toAffine()}subtract(E){return this.add(E.negate())}multiply(E){return JacobianPoint.fromAffine(this).multiply(E,this).toAffine()}multiplyAndAddUnsafe(E,ee,te){const re=JacobianPoint.fromAffine(this),ne=ee===_0n||ee===_1n||this!==Point.BASE?re.multiplyUnsafe(ee):re.multiply(ee),ie=JacobianPoint.fromAffine(E).multiplyUnsafe(te),se=ne.add(ie);return se.equals(JacobianPoint.ZERO)?void 0:se.toAffine()}}Point.BASE=new Point(CURVE.Gx,CURVE.Gy);Point.ZERO=new Point(_0n,_0n);function sliceDER(J){return Number.parseInt(J[0],16)>=8?"00"+J:J}function parseDERInt(J){if(J.length<2||J[0]!==2)throw new Error(`Invalid signature integer tag: ${bytesToHex(J)}`);const E=J[1],ee=J.subarray(2,E+2);if(!E||ee.length!==E)throw new Error("Invalid signature integer: wrong length");if(ee[0]===0&&ee[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:bytesToNumber(ee),left:J.subarray(E+2)}}function parseDERSignature(J){if(J.length<2||J[0]!=48)throw new Error(`Invalid signature tag: ${bytesToHex(J)}`);if(J[1]!==J.length-2)throw new Error("Invalid signature: incorrect length");const{data:E,left:ee}=parseDERInt(J.subarray(2)),{data:te,left:re}=parseDERInt(ee);if(re.length)throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex(re)}`);return{r:E,s:te}}class Signature{constructor(E,ee){this.r=E,this.s=ee,this.assertValidity()}static fromCompact(E){const ee=E instanceof Uint8Array,te="Signature.fromCompact";if(typeof E!="string"&&!ee)throw new TypeError(`${te}: Expected string or Uint8Array`);const re=ee?bytesToHex(E):E;if(re.length!==128)throw new Error(`${te}: Expected 64-byte hex`);return new Signature(hexToNumber(re.slice(0,64)),hexToNumber(re.slice(64,128)))}static fromDER(E){const ee=E instanceof Uint8Array;if(typeof E!="string"&&!ee)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r:te,s:re}=parseDERSignature(ee?E:hexToBytes(E));return new Signature(te,re)}static fromHex(E){return this.fromDER(E)}assertValidity(){const{r:E,s:ee}=this;if(!isWithinCurveOrder(E))throw new Error("Invalid Signature: r must be 0 < r < n");if(!isWithinCurveOrder(ee))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){const E=CURVE.n>>_1n;return this.s>E}normalizeS(){return this.hasHighS()?new Signature(this.r,mod(-this.s,CURVE.n)):this}toDERRawBytes(){return hexToBytes(this.toDERHex())}toDERHex(){const E=sliceDER(numberToHexUnpadded(this.s)),ee=sliceDER(numberToHexUnpadded(this.r)),te=E.length/2,re=ee.length/2,ne=numberToHexUnpadded(te),ie=numberToHexUnpadded(re);return`30${numberToHexUnpadded(re+te+4)}02${ie}${ee}02${ne}${E}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return hexToBytes(this.toCompactHex())}toCompactHex(){return numTo32bStr(this.r)+numTo32bStr(this.s)}}function concatBytes(...J){if(!J.every(te=>te instanceof Uint8Array))throw new Error("Uint8Array list expected");if(J.length===1)return J[0];const E=J.reduce((te,re)=>te+re.length,0),ee=new Uint8Array(E);for(let te=0,re=0;te<J.length;te++){const ne=J[te];ee.set(ne,re),re+=ne.length}return ee}const hexes=Array.from({length:256},(J,E)=>E.toString(16).padStart(2,"0"));function bytesToHex(J){if(!(J instanceof Uint8Array))throw new Error("Expected Uint8Array");let E="";for(let ee=0;ee<J.length;ee++)E+=hexes[J[ee]];return E}const POW_2_256=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");function numTo32bStr(J){if(typeof J!="bigint")throw new Error("Expected bigint");if(!(_0n<=J&&J<POW_2_256))throw new Error("Expected number 0 <= n < 2^256");return J.toString(16).padStart(64,"0")}function numTo32b(J){const E=hexToBytes(numTo32bStr(J));if(E.length!==32)throw new Error("Error: expected 32 bytes");return E}function numberToHexUnpadded(J){const E=J.toString(16);return E.length&1?`0${E}`:E}function hexToNumber(J){if(typeof J!="string")throw new TypeError("hexToNumber: expected string, got "+typeof J);return BigInt(`0x${J}`)}function hexToBytes(J){if(typeof J!="string")throw new TypeError("hexToBytes: expected string, got "+typeof J);if(J.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+J.length);const E=new Uint8Array(J.length/2);for(let ee=0;ee<E.length;ee++){const te=ee*2,re=J.slice(te,te+2),ne=Number.parseInt(re,16);if(Number.isNaN(ne)||ne<0)throw new Error("Invalid byte sequence");E[ee]=ne}return E}function bytesToNumber(J){return hexToNumber(bytesToHex(J))}function ensureBytes(J){return J instanceof Uint8Array?Uint8Array.from(J):hexToBytes(J)}function normalizeScalar(J){if(typeof J=="number"&&Number.isSafeInteger(J)&&J>0)return BigInt(J);if(typeof J=="bigint"&&isWithinCurveOrder(J))return J;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function mod(J,E=CURVE.P){const ee=J%E;return ee>=_0n?ee:E+ee}function pow2(J,E){const{P:ee}=CURVE;let te=J;for(;E-- >_0n;)te*=te,te%=ee;return te}function sqrtMod(J){const{P:E}=CURVE,ee=BigInt(6),te=BigInt(11),re=BigInt(22),ne=BigInt(23),ie=BigInt(44),se=BigInt(88),oe=J*J*J%E,ce=oe*oe*J%E,ae=pow2(ce,_3n)*ce%E,le=pow2(ae,_3n)*ce%E,ue=pow2(le,_2n)*oe%E,he=pow2(ue,te)*ue%E,pe=pow2(he,re)*he%E,de=pow2(pe,ie)*pe%E,fe=pow2(de,se)*de%E,me=pow2(fe,ie)*pe%E,_e=pow2(me,_3n)*ce%E,be=pow2(_e,ne)*he%E,Ee=pow2(be,ee)*oe%E,ve=pow2(Ee,_2n);if(ve*ve%E!==J)throw new Error("Cannot find square root");return ve}function invert(J,E=CURVE.P){if(J===_0n||E<=_0n)throw new Error(`invert: expected positive integers, got n=${J} mod=${E}`);let ee=mod(J,E),te=E,re=_0n,ne=_1n;for(;ee!==_0n;){const ie=te/ee,se=te%ee,oe=re-ne*ie;te=ee,ee=se,re=ne,ne=oe}if(te!==_1n)throw new Error("invert: does not exist");return mod(re,E)}function invertBatch(J,E=CURVE.P){const ee=new Array(J.length),te=J.reduce((ne,ie,se)=>ie===_0n?ne:(ee[se]=ne,mod(ne*ie,E)),_1n),re=invert(te,E);return J.reduceRight((ne,ie,se)=>ie===_0n?ne:(ee[se]=mod(ne*ee[se],E),mod(ne*ie,E)),re),ee}function bits2int_2(J){const E=J.length*8-groupLen*8,ee=bytesToNumber(J);return E>0?ee>>BigInt(E):ee}function truncateHash(J,E=!1){const ee=bits2int_2(J);if(E)return ee;const{n:te}=CURVE;return ee>=te?ee-te:ee}let _sha256Sync,_hmacSha256Sync;class HmacDrbg{constructor(E,ee){if(this.hashLen=E,this.qByteLen=ee,typeof E!="number"||E<2)throw new Error("hashLen must be a number");if(typeof ee!="number"||ee<2)throw new Error("qByteLen must be a number");this.v=new Uint8Array(E).fill(1),this.k=new Uint8Array(E).fill(0),this.counter=0}hmac(...E){return utils$2.hmacSha256(this.k,...E)}hmacSync(...E){return _hmacSha256Sync(this.k,...E)}checkSync(){if(typeof _hmacSha256Sync!="function")throw new ShaError("hmacSha256Sync needs to be set")}incr(){if(this.counter>=1e3)throw new Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(E=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),E),this.v=await this.hmac(this.v),E.length!==0&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),E),this.v=await this.hmac(this.v))}reseedSync(E=new Uint8Array){this.checkSync(),this.k=this.hmacSync(this.v,Uint8Array.from([0]),E),this.v=this.hmacSync(this.v),E.length!==0&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),E),this.v=this.hmacSync(this.v))}async generate(){this.incr();let E=0;const ee=[];for(;E<this.qByteLen;){this.v=await this.hmac(this.v);const te=this.v.slice();ee.push(te),E+=this.v.length}return concatBytes(...ee)}generateSync(){this.checkSync(),this.incr();let E=0;const ee=[];for(;E<this.qByteLen;){this.v=this.hmacSync(this.v);const te=this.v.slice();ee.push(te),E+=this.v.length}return concatBytes(...ee)}}function isWithinCurveOrder(J){return _0n<J&&J<CURVE.n}function isValidFieldElement(J){return _0n<J&&J<CURVE.P}function kmdToSig(J,E,ee,te=!0){const{n:re}=CURVE,ne=truncateHash(J,!0);if(!isWithinCurveOrder(ne))return;const ie=invert(ne,re),se=Point.BASE.multiply(ne),oe=mod(se.x,re);if(oe===_0n)return;const ce=mod(ie*mod(E+ee*oe,re),re);if(ce===_0n)return;let ae=new Signature(oe,ce),le=(se.x===ae.r?0:2)|Number(se.y&_1n);return te&&ae.hasHighS()&&(ae=ae.normalizeS(),le^=1),{sig:ae,recovery:le}}function normalizePrivateKey(J){let E;if(typeof J=="bigint")E=J;else if(typeof J=="number"&&Number.isSafeInteger(J)&&J>0)E=BigInt(J);else if(typeof J=="string"){if(J.length!==2*groupLen)throw new Error("Expected 32 bytes of private key");E=hexToNumber(J)}else if(J instanceof Uint8Array){if(J.length!==groupLen)throw new Error("Expected 32 bytes of private key");E=bytesToNumber(J)}else throw new TypeError("Expected valid private key");if(!isWithinCurveOrder(E))throw new Error("Expected private key: 0 < key < n");return E}function normalizePublicKey(J){return J instanceof Point?(J.assertValidity(),J):Point.fromHex(J)}function normalizeSignature(J){if(J instanceof Signature)return J.assertValidity(),J;try{return Signature.fromDER(J)}catch{return Signature.fromCompact(J)}}function getPublicKey(J,E=!1){return Point.fromPrivateKey(J).toRawBytes(E)}function bits2int(J){const E=J.length>fieldLen?J.slice(0,fieldLen):J;return bytesToNumber(E)}function bits2octets(J){const E=bits2int(J),ee=mod(E,CURVE.n);return int2octets(ee<_0n?E:ee)}function int2octets(J){return numTo32b(J)}function initSigArgs(J,E,ee){if(J==null)throw new Error(`sign: expected valid message hash, not "${J}"`);const te=ensureBytes(J),re=normalizePrivateKey(E),ne=[int2octets(re),bits2octets(te)];if(ee!=null){ee===!0&&(ee=utils$2.randomBytes(fieldLen));const oe=ensureBytes(ee);if(oe.length!==fieldLen)throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);ne.push(oe)}const ie=concatBytes(...ne),se=bits2int(te);return{seed:ie,m:se,d:re}}function finalizeSig(J,E){const{sig:ee,recovery:te}=J,{der:re,recovered:ne}=Object.assign({canonical:!0,der:!0},E),ie=re?ee.toDERRawBytes():ee.toCompactRawBytes();return ne?[ie,te]:ie}async function sign(J,E,ee={}){const{seed:te,m:re,d:ne}=initSigArgs(J,E,ee.extraEntropy),ie=new HmacDrbg(hashLen,groupLen);await ie.reseed(te);let se;for(;!(se=kmdToSig(await ie.generate(),re,ne,ee.canonical));)await ie.reseed();return finalizeSig(se,ee)}const vopts={strict:!0};function verify(J,E,ee,te=vopts){let re;try{re=normalizeSignature(J),E=ensureBytes(E)}catch{return!1}const{r:ne,s:ie}=re;if(te.strict&&re.hasHighS())return!1;const se=truncateHash(E);let oe;try{oe=normalizePublicKey(ee)}catch{return!1}const{n:ce}=CURVE,ae=invert(ie,ce),le=mod(se*ae,ce),ue=mod(ne*ae,ce),he=Point.BASE.multiplyAndAddUnsafe(oe,le,ue);return he?mod(he.x,ce)===ne:!1}Point.BASE._setWindowSize(8);const crypto$2={node:nodeCrypto,web:typeof self=="object"&&"crypto"in self?self.crypto:void 0},TAGGED_HASH_PREFIXES={},utils$2={bytesToHex,hexToBytes,concatBytes,mod,invert,isValidPrivateKey(J){try{return normalizePrivateKey(J),!0}catch{return!1}},_bigintTo32Bytes:numTo32b,_normalizePrivateKey:normalizePrivateKey,hashToPrivateKey:J=>{J=ensureBytes(J);const E=groupLen+8;if(J.length<E||J.length>1024)throw new Error("Expected valid bytes of private key as per FIPS 186");const ee=mod(bytesToNumber(J),CURVE.n-_1n)+_1n;return numTo32b(ee)},randomBytes:(J=32)=>{if(crypto$2.web)return crypto$2.web.getRandomValues(new Uint8Array(J));if(crypto$2.node){const{randomBytes:E}=crypto$2.node;return Uint8Array.from(E(J))}else throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>utils$2.hashToPrivateKey(utils$2.randomBytes(groupLen+8)),precompute(J=8,E=Point.BASE){const ee=E===Point.BASE?E:new Point(E.x,E.y);return ee._setWindowSize(J),ee.multiply(_3n),ee},sha256:async(...J)=>{if(crypto$2.web){const E=await crypto$2.web.subtle.digest("SHA-256",concatBytes(...J));return new Uint8Array(E)}else if(crypto$2.node){const{createHash:E}=crypto$2.node,ee=E("sha256");return J.forEach(te=>ee.update(te)),Uint8Array.from(ee.digest())}else throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(J,...E)=>{if(crypto$2.web){const ee=await crypto$2.web.subtle.importKey("raw",J,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),te=concatBytes(...E),re=await crypto$2.web.subtle.sign("HMAC",ee,te);return new Uint8Array(re)}else if(crypto$2.node){const{createHmac:ee}=crypto$2.node,te=ee("sha256",J);return E.forEach(re=>te.update(re)),Uint8Array.from(te.digest())}else throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(J,...E)=>{let ee=TAGGED_HASH_PREFIXES[J];if(ee===void 0){const te=await utils$2.sha256(Uint8Array.from(J,re=>re.charCodeAt(0)));ee=concatBytes(te,te),TAGGED_HASH_PREFIXES[J]=ee}return utils$2.sha256(ee,...E)},taggedHashSync:(J,...E)=>{if(typeof _sha256Sync!="function")throw new ShaError("sha256Sync is undefined, you need to set it");let ee=TAGGED_HASH_PREFIXES[J];if(ee===void 0){const te=_sha256Sync(Uint8Array.from(J,re=>re.charCodeAt(0)));ee=concatBytes(te,te),TAGGED_HASH_PREFIXES[J]=ee}return _sha256Sync(ee,...E)},_JacobianPoint:JacobianPoint};Object.defineProperties(utils$2,{sha256Sync:{configurable:!1,get(){return _sha256Sync},set(J){_sha256Sync||(_sha256Sync=J)}},hmacSha256Sync:{configurable:!1,get(){return _hmacSha256Sync},set(J){_hmacSha256Sync||(_hmacSha256Sync=J)}}});function randomBytes(J){if(isNaN(J)||J<=0)throw new CodeError("random bytes length must be a Number bigger than 0","ERR_INVALID_LENGTH");return utils$2.randomBytes(J)}function convert(J,E){return E.map(ee=>base64urlToBigInteger(J[ee]))}function jwk2priv(J){return forge$n.pki.setRsaPrivateKey(...convert(J,["n","e","d","p","q","dp","dq","qi"]))}function jwk2pub(J){return forge$n.pki.setRsaPublicKey(...convert(J,["n","e"]))}function pkcs1ToJwk(J){const E=forge$n.asn1.fromDer(toString$5(J,"ascii")),ee=forge$n.pki.privateKeyFromAsn1(E);return{kty:"RSA",n:bigIntegerToUintBase64url(ee.n),e:bigIntegerToUintBase64url(ee.e),d:bigIntegerToUintBase64url(ee.d),p:bigIntegerToUintBase64url(ee.p),q:bigIntegerToUintBase64url(ee.q),dp:bigIntegerToUintBase64url(ee.dP),dq:bigIntegerToUintBase64url(ee.dQ),qi:bigIntegerToUintBase64url(ee.qInv),alg:"RS256"}}function jwkToPkcs1(J){if(J.n==null||J.e==null||J.d==null||J.p==null||J.q==null||J.dp==null||J.dq==null||J.qi==null)throw new CodeError("JWK was missing components","ERR_INVALID_PARAMETERS");const E=forge$n.pki.privateKeyToAsn1({n:base64urlToBigInteger(J.n),e:base64urlToBigInteger(J.e),d:base64urlToBigInteger(J.d),p:base64urlToBigInteger(J.p),q:base64urlToBigInteger(J.q),dP:base64urlToBigInteger(J.dp),dQ:base64urlToBigInteger(J.dq),qInv:base64urlToBigInteger(J.qi)});return fromString$5(forge$n.asn1.toDer(E).getBytes(),"ascii")}function pkixToJwk(J){const E=forge$n.asn1.fromDer(toString$5(J,"ascii")),ee=forge$n.pki.publicKeyFromAsn1(E);return{kty:"RSA",n:bigIntegerToUintBase64url(ee.n),e:bigIntegerToUintBase64url(ee.e)}}function jwkToPkix(J){if(J.n==null||J.e==null)throw new CodeError("JWK was missing components","ERR_INVALID_PARAMETERS");const E=forge$n.pki.publicKeyToAsn1({n:base64urlToBigInteger(J.n),e:base64urlToBigInteger(J.e)});return fromString$5(forge$n.asn1.toDer(E).getBytes(),"ascii")}async function generateKey$1(J){const E=await webcrypto.get().subtle.generateKey({name:"RSASSA-PKCS1-v1_5",modulusLength:J,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},!0,["sign","verify"]),ee=await exportKey(E);return{privateKey:ee[0],publicKey:ee[1]}}async function unmarshalPrivateKey$1(J){const E=[await webcrypto.get().subtle.importKey("jwk",J,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["sign"]),await derivePublicFromPrivate(J)],ee=await exportKey({privateKey:E[0],publicKey:E[1]});return{privateKey:ee[0],publicKey:ee[1]}}async function hashAndSign$1(J,E){const ee=await webcrypto.get().subtle.importKey("jwk",J,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["sign"]),te=await webcrypto.get().subtle.sign({name:"RSASSA-PKCS1-v1_5"},ee,Uint8Array.from(E));return new Uint8Array(te,0,te.byteLength)}async function hashAndVerify$1(J,E,ee){const te=await webcrypto.get().subtle.importKey("jwk",J,{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!1,["verify"]);return webcrypto.get().subtle.verify({name:"RSASSA-PKCS1-v1_5"},te,E,ee)}async function exportKey(J){if(J.privateKey==null||J.publicKey==null)throw new CodeError("Private and public key are required","ERR_INVALID_PARAMETERS");return Promise.all([webcrypto.get().subtle.exportKey("jwk",J.privateKey),webcrypto.get().subtle.exportKey("jwk",J.publicKey)])}async function derivePublicFromPrivate(J){return webcrypto.get().subtle.importKey("jwk",{kty:J.kty,n:J.n,e:J.e},{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},!0,["verify"])}function convertKey(J,E,ee,te){const re=E?jwk2pub(J):jwk2priv(J),ne=toString$5(Uint8Array.from(ee),"ascii"),ie=te(ne,re);return fromString$5(ie,"ascii")}function encrypt(J,E){return convertKey(J,!0,E,(ee,te)=>te.encrypt(ee))}function decrypt(J,E){return convertKey(J,!1,E,(ee,te)=>te.decrypt(ee))}class RsaPublicKey{_key;constructor(E){this._key=E}async verify(E,ee){return hashAndVerify$1(this._key,ee,E)}marshal(){return jwkToPkix(this._key)}get bytes(){return PublicKey.encode({Type:KeyType.RSA,Data:this.marshal()}).subarray()}encrypt(E){return encrypt(this._key,E)}equals(E){return equals(this.bytes,E.bytes)}async hash(){const{bytes:E}=await sha256$3.digest(this.bytes);return E}}class RsaPrivateKey{_key;_publicKey;constructor(E,ee){this._key=E,this._publicKey=ee}genSecret(){return randomBytes(16)}async sign(E){return hashAndSign$1(this._key,E)}get public(){if(this._publicKey==null)throw new CodeError("public key not provided","ERR_PUBKEY_NOT_PROVIDED");return new RsaPublicKey(this._publicKey)}decrypt(E){return decrypt(this._key,E)}marshal(){return jwkToPkcs1(this._key)}get bytes(){return PrivateKey.encode({Type:KeyType.RSA,Data:this.marshal()}).subarray()}equals(E){return equals(this.bytes,E.bytes)}async hash(){const{bytes:E}=await sha256$3.digest(this.bytes);return E}async id(){const E=await this.public.hash();return toString$5(E,"base58btc")}async export(E,ee="pkcs-8"){if(ee==="pkcs-8"){const te=new forge$n.util.ByteBuffer(this.marshal()),re=forge$n.asn1.fromDer(te),ne=forge$n.pki.privateKeyFromAsn1(re),ie={algorithm:"aes256",count:1e4,saltSize:128/8,prfAlgorithm:"sha512"};return forge$n.pki.encryptRsaPrivateKey(ne,E,ie)}else{if(ee==="libp2p-key")return exporter$1(this.bytes,E);throw new CodeError(`export format '${ee}' is not supported`,"ERR_INVALID_EXPORT_FORMAT")}}}async function unmarshalRsaPrivateKey(J){const E=pkcs1ToJwk(J),ee=await unmarshalPrivateKey$1(E);return new RsaPrivateKey(ee.privateKey,ee.publicKey)}function unmarshalRsaPublicKey(J){const E=pkixToJwk(J);return new RsaPublicKey(E)}async function fromJwk(J){const E=await unmarshalPrivateKey$1(J);return new RsaPrivateKey(E.privateKey,E.publicKey)}async function generateKeyPair$2(J){const E=await generateKey$1(J);return new RsaPrivateKey(E.privateKey,E.publicKey)}const RSA=Object.freeze(Object.defineProperty({__proto__:null,RsaPrivateKey,RsaPublicKey,fromJwk,generateKeyPair:generateKeyPair$2,unmarshalRsaPrivateKey,unmarshalRsaPublicKey},Symbol.toStringTag,{value:"Module"}));function generateKey(){return utils$2.randomPrivateKey()}async function hashAndSign(J,E){const{digest:ee}=await sha256$3.digest(E);try{return await sign(ee,J)}catch(te){throw new CodeError(String(te),"ERR_INVALID_INPUT")}}async function hashAndVerify(J,E,ee){try{const{digest:te}=await sha256$3.digest(ee);return verify(E,te,J)}catch(te){throw new CodeError(String(te),"ERR_INVALID_INPUT")}}function compressPublicKey(J){return Point.fromHex(J).toRawBytes(!0)}function validatePrivateKey(J){try{getPublicKey(J,!0)}catch(E){throw new CodeError(String(E),"ERR_INVALID_PRIVATE_KEY")}}function validatePublicKey(J){try{Point.fromHex(J)}catch(E){throw new CodeError(String(E),"ERR_INVALID_PUBLIC_KEY")}}function computePublicKey(J){try{return getPublicKey(J,!0)}catch(E){throw new CodeError(String(E),"ERR_INVALID_PRIVATE_KEY")}}class Secp256k1PublicKey{_key;constructor(E){validatePublicKey(E),this._key=E}async verify(E,ee){return hashAndVerify(this._key,ee,E)}marshal(){return compressPublicKey(this._key)}get bytes(){return PublicKey.encode({Type:KeyType.Secp256k1,Data:this.marshal()}).subarray()}equals(E){return equals(this.bytes,E.bytes)}async hash(){const{bytes:E}=await sha256$3.digest(this.bytes);return E}}class Secp256k1PrivateKey{_key;_publicKey;constructor(E,ee){this._key=E,this._publicKey=ee??computePublicKey(E),validatePrivateKey(this._key),validatePublicKey(this._publicKey)}async sign(E){return hashAndSign(this._key,E)}get public(){return new Secp256k1PublicKey(this._publicKey)}marshal(){return this._key}get bytes(){return PrivateKey.encode({Type:KeyType.Secp256k1,Data:this.marshal()}).subarray()}equals(E){return equals(this.bytes,E.bytes)}async hash(){const{bytes:E}=await sha256$3.digest(this.bytes);return E}async id(){const E=await this.public.hash();return toString$5(E,"base58btc")}async export(E,ee="libp2p-key"){if(ee==="libp2p-key")return exporter$1(this.bytes,E);throw new CodeError(`export format '${ee}' is not supported`,"ERR_INVALID_EXPORT_FORMAT")}}function unmarshalSecp256k1PrivateKey(J){return new Secp256k1PrivateKey(J)}function unmarshalSecp256k1PublicKey(J){return new Secp256k1PublicKey(J)}async function generateKeyPair$1(){const J=generateKey();return new Secp256k1PrivateKey(J)}const Secp256k1=Object.freeze(Object.defineProperty({__proto__:null,Secp256k1PrivateKey,Secp256k1PublicKey,generateKeyPair:generateKeyPair$1,unmarshalSecp256k1PrivateKey,unmarshalSecp256k1PublicKey},Symbol.toStringTag,{value:"Module"})),supportedKeys={rsa:RSA,ed25519:Ed25519,secp256k1:Secp256k1};function unsupportedKey(J){const E=Object.keys(supportedKeys).join(" / ");return new CodeError(`invalid or unsupported key type ${J}. Must be ${E}`,"ERR_UNSUPPORTED_KEY_TYPE")}function typeToKey(J){if(J=J.toLowerCase(),J==="rsa"||J==="ed25519"||J==="secp256k1")return supportedKeys[J];throw unsupportedKey(J)}async function generateKeyPair(J,E){return typeToKey(J).generateKeyPair(E??2048)}function unmarshalPublicKey(J){const E=PublicKey.decode(J),ee=E.Data??new Uint8Array;switch(E.Type){case KeyType.RSA:return supportedKeys.rsa.unmarshalRsaPublicKey(ee);case KeyType.Ed25519:return supportedKeys.ed25519.unmarshalEd25519PublicKey(ee);case KeyType.Secp256k1:return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(ee);default:throw unsupportedKey(E.Type??"RSA")}}function marshalPublicKey(J,E){return E=(E??"rsa").toLowerCase(),typeToKey(E),J.bytes}async function unmarshalPrivateKey(J){const E=PrivateKey.decode(J),ee=E.Data??new Uint8Array;switch(E.Type){case KeyType.RSA:return supportedKeys.rsa.unmarshalRsaPrivateKey(ee);case KeyType.Ed25519:return supportedKeys.ed25519.unmarshalEd25519PrivateKey(ee);case KeyType.Secp256k1:return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(ee);default:throw unsupportedKey(E.Type??"RSA")}}function marshalPrivateKey(J,E){return E=(E??"rsa").toLowerCase(),typeToKey(E),J.bytes}async function importKey(J,E){try{const re=await importer$1(J,E);return await unmarshalPrivateKey(re)}catch{}const ee=forge$n.pki.decryptRsaPrivateKey(J,E);if(ee===null)throw new CodeError("Cannot read the key, most likely the password is wrong or not a RSA key","ERR_CANNOT_DECRYPT_PEM");let te=forge$n.asn1.toDer(forge$n.pki.privateKeyToAsn1(ee));return te=fromString$5(te.getBytes(),"ascii"),supportedKeys.rsa.unmarshalRsaPrivateKey(te)}const hashName={sha1:"sha1","sha2-256":"sha256","sha2-512":"sha512"};function pbkdf2(J,E,ee,te,re){if(re!=="sha1"&&re!=="sha2-256"&&re!=="sha2-512"){const se=Object.keys(hashName).join(" / ");throw new CodeError(`Hash '${re}' is unknown or not supported. Must be ${se}`,"ERR_UNSUPPORTED_HASH_TYPE")}const ne=hashName[re],ie=forgePbkdf2(J,E,ee,te,ne);return forgeUtil.encode64(ie,null)}const log$1h=logger$1("libp2p:keychain"),keyPrefix="/pkcs8/",infoPrefix="/info/",privates=new WeakMap,NIST={minKeyLength:112/8,minSaltLength:128/8,minIterationCount:1e3},defaultOptions$g={dek:{keyLength:512/8,iterationCount:1e4,salt:"you should override this value with a crypto secure random number",hash:"sha2-512"}};function validateKeyName(J){return J==null||typeof J!="string"?!1:J===sanitize$1(J.trim())&&J.length>0}async function randomDelay(){const J=Math.random()*800+200;await new Promise(E=>setTimeout(E,J))}function DsName(J){return new Key(keyPrefix+J)}function DsInfoName(J){return new Key(infoPrefix+J)}class DefaultKeyChain{constructor(E,ee){if(this.components=E,this.init=mergeOptions$9(defaultOptions$g,ee),this.init.pass!=null&&this.init.pass?.length<20)throw new Error("pass must be least 20 characters");if(this.init.dek?.keyLength!=null&&this.init.dek.keyLength<NIST.minKeyLength)throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`);if(this.init.dek?.salt?.length!=null&&this.init.dek.salt.length<NIST.minSaltLength)throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`);if(this.init.dek?.iterationCount!=null&&this.init.dek.iterationCount<NIST.minIterationCount)throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`);const te=this.init.pass!=null&&this.init.dek?.salt!=null?pbkdf2(this.init.pass,this.init.dek?.salt,this.init.dek?.iterationCount,this.init.dek?.keyLength,this.init.dek?.hash):"";privates.set(this,{dek:te})}static generateOptions(){const E=Object.assign({},defaultOptions$g),ee=Math.ceil(NIST.minSaltLength/3)*3;return E.dek.salt=toString$5(randomBytes(ee),"base64"),E}static get options(){return defaultOptions$g}async createKey(E,ee,te=2048){if(!validateKeyName(E)||E==="self")throw await randomDelay(),new CodeError("Invalid key name",codes$7.ERR_INVALID_KEY_NAME);if(typeof ee!="string")throw await randomDelay(),new CodeError("Invalid key type",codes$7.ERR_INVALID_KEY_TYPE);const re=DsName(E);if(await this.components.datastore.has(re))throw await randomDelay(),new CodeError("Key name already exists",codes$7.ERR_KEY_ALREADY_EXISTS);switch(ee.toLowerCase()){case"rsa":if(!Number.isSafeInteger(te)||te<2048)throw await randomDelay(),new CodeError("Invalid RSA key size",codes$7.ERR_INVALID_KEY_SIZE);break}let ne;try{const ie=await generateKeyPair(ee,te),se=await ie.id(),oe=privates.get(this);if(oe==null)throw new CodeError("dek missing",codes$7.ERR_INVALID_PARAMETERS);const ce=oe.dek,ae=await ie.export(ce);ne={name:E,id:se};const le=this.components.datastore.batch();le.put(re,fromString$5(ae)),le.put(DsInfoName(E),fromString$5(JSON.stringify(ne))),await le.commit()}catch(ie){throw await randomDelay(),ie}return ne}async listKeys(){const E={prefix:infoPrefix},ee=[];for await(const te of this.components.datastore.query(E))ee.push(JSON.parse(toString$5(te.value)));return ee}async findKeyById(E){try{const ee=(await this.listKeys()).find(te=>te.id===E);if(ee==null)throw new CodeError(`Key with id '${E}' does not exist.`,codes$7.ERR_KEY_NOT_FOUND);return ee}catch(ee){throw await randomDelay(),ee}}async findKeyByName(E){if(!validateKeyName(E))throw await randomDelay(),new CodeError(`Invalid key name '${E}'`,codes$7.ERR_INVALID_KEY_NAME);const ee=DsInfoName(E);try{const te=await this.components.datastore.get(ee);return JSON.parse(toString$5(te))}catch(te){throw await randomDelay(),log$1h.error(te),new CodeError(`Key '${E}' does not exist.`,codes$7.ERR_KEY_NOT_FOUND)}}async removeKey(E){if(!validateKeyName(E)||E==="self")throw await randomDelay(),new CodeError(`Invalid key name '${E}'`,codes$7.ERR_INVALID_KEY_NAME);const ee=DsName(E),te=await this.findKeyByName(E),re=this.components.datastore.batch();return re.delete(ee),re.delete(DsInfoName(E)),await re.commit(),te}async renameKey(E,ee){if(!validateKeyName(E)||E==="self")throw await randomDelay(),new CodeError(`Invalid old key name '${E}'`,codes$7.ERR_OLD_KEY_NAME_INVALID);if(!validateKeyName(ee)||ee==="self")throw await randomDelay(),new CodeError(`Invalid new key name '${ee}'`,codes$7.ERR_NEW_KEY_NAME_INVALID);const te=DsName(E),re=DsName(ee),ne=DsInfoName(E),ie=DsInfoName(ee);if(await this.components.datastore.has(re))throw await randomDelay(),new CodeError(`Key '${ee}' already exists`,codes$7.ERR_KEY_ALREADY_EXISTS);try{const se=await this.components.datastore.get(te),oe=await this.components.datastore.get(ne),ce=JSON.parse(toString$5(oe));ce.name=ee;const ae=this.components.datastore.batch();return ae.put(re,se),ae.put(ie,fromString$5(JSON.stringify(ce))),ae.delete(te),ae.delete(ne),await ae.commit(),ce}catch(se){throw await randomDelay(),se}}async exportKey(E,ee){if(!validateKeyName(E))throw await randomDelay(),new CodeError(`Invalid key name '${E}'`,codes$7.ERR_INVALID_KEY_NAME);if(ee==null)throw await randomDelay(),new CodeError("Password is required",codes$7.ERR_PASSWORD_REQUIRED);const te=DsName(E);try{const re=await this.components.datastore.get(te),ne=toString$5(re),ie=privates.get(this);if(ie==null)throw new CodeError("dek missing",codes$7.ERR_INVALID_PARAMETERS);const se=ie.dek;return await(await importKey(ne,se)).export(ee)}catch(re){throw await randomDelay(),re}}async exportPeerId(E){const ee="temporary-password",te=await this.exportKey(E,ee),re=await importKey(te,ee);return await peerIdFromKeys(re.public.bytes,re.bytes)}async importKey(E,ee,te){if(!validateKeyName(E)||E==="self")throw await randomDelay(),new CodeError(`Invalid key name '${E}'`,codes$7.ERR_INVALID_KEY_NAME);if(ee==null)throw await randomDelay(),new CodeError("PEM encoded key is required",codes$7.ERR_PEM_REQUIRED);const re=DsName(E);if(await this.components.datastore.has(re))throw await randomDelay(),new CodeError(`Key '${E}' already exists`,codes$7.ERR_KEY_ALREADY_EXISTS);let ne;try{ne=await importKey(ee,te)}catch{throw await randomDelay(),new CodeError("Cannot read the key, most likely the password is wrong",codes$7.ERR_CANNOT_READ_KEY)}let ie;try{ie=await ne.id();const ce=privates.get(this);if(ce==null)throw new CodeError("dek missing",codes$7.ERR_INVALID_PARAMETERS);const ae=ce.dek;ee=await ne.export(ae)}catch(ce){throw await randomDelay(),ce}const se={name:E,id:ie},oe=this.components.datastore.batch();return oe.put(re,fromString$5(ee)),oe.put(DsInfoName(E),fromString$5(JSON.stringify(se))),await oe.commit(),se}async importPeer(E,ee){try{if(!validateKeyName(E))throw new CodeError(`Invalid key name '${E}'`,codes$7.ERR_INVALID_KEY_NAME);if(ee==null)throw new CodeError("PeerId is required",codes$7.ERR_MISSING_PRIVATE_KEY);if(ee.privateKey==null)throw new CodeError("PeerId.privKey is required",codes$7.ERR_MISSING_PRIVATE_KEY);const te=await unmarshalPrivateKey(ee.privateKey),re=DsName(E);if(await this.components.datastore.has(re))throw await randomDelay(),new CodeError(`Key '${E}' already exists`,codes$7.ERR_KEY_ALREADY_EXISTS);const ne=privates.get(this);if(ne==null)throw new CodeError("dek missing",codes$7.ERR_INVALID_PARAMETERS);const ie=ne.dek,se=await te.export(ie),oe={name:E,id:ee.toString()},ce=this.components.datastore.batch();return ce.put(re,fromString$5(se)),ce.put(DsInfoName(E),fromString$5(JSON.stringify(oe))),await ce.commit(),oe}catch(te){throw await randomDelay(),te}}async getPrivateKey(E){if(!validateKeyName(E))throw await randomDelay(),new CodeError(`Invalid key name '${E}'`,codes$7.ERR_INVALID_KEY_NAME);try{const ee=DsName(E),te=await this.components.datastore.get(ee);return toString$5(te)}catch(ee){throw await randomDelay(),log$1h.error(ee),new CodeError(`Key '${E}' does not exist.`,codes$7.ERR_KEY_NOT_FOUND)}}async rotateKeychainPass(E,ee){if(typeof E!="string")throw await randomDelay(),new CodeError(`Invalid old pass type '${typeof E}'`,codes$7.ERR_INVALID_OLD_PASS_TYPE);if(typeof ee!="string")throw await randomDelay(),new CodeError(`Invalid new pass type '${typeof ee}'`,codes$7.ERR_INVALID_NEW_PASS_TYPE);if(ee.length<20)throw await randomDelay(),new CodeError(`Invalid pass length ${ee.length}`,codes$7.ERR_INVALID_PASS_LENGTH);log$1h("recreating keychain");const te=privates.get(this);if(te==null)throw new CodeError("dek missing",codes$7.ERR_INVALID_PARAMETERS);const re=te.dek;this.init.pass=ee;const ne=ee!=null&&this.init.dek?.salt!=null?pbkdf2(ee,this.init.dek.salt,this.init.dek?.iterationCount,this.init.dek?.keyLength,this.init.dek?.hash):"";privates.set(this,{dek:ne});const ie=await this.listKeys();for(const se of ie){const oe=await this.components.datastore.get(DsName(se.name)),ce=toString$5(oe),ae=await importKey(ce,re),le=ne.toString(),ue=await ae.export(le),he=this.components.datastore.batch(),pe={name:se.name,id:se.id};he.put(DsName(se.name),fromString$5(ue)),he.put(DsInfoName(se.name),fromString$5(JSON.stringify(pe))),await he.commit()}log$1h("keychain reconstructed")}}const symbol$2=Symbol.for("@libp2p/transport");var FaultTolerance;(function(J){J[J.FATAL_ALL=0]="FATAL_ALL",J[J.NO_FATAL=1]="NO_FATAL"})(FaultTolerance||(FaultTolerance={}));class TrackedMap extends Map{constructor(E){super();const{name:ee,metrics:te}=E;this.metric=te.registerMetric(ee),this.updateComponentMetric()}set(E,ee){return super.set(E,ee),this.updateComponentMetric(),this}delete(E){const ee=super.delete(E);return this.updateComponentMetric(),ee}clear(){super.clear(),this.updateComponentMetric()}updateComponentMetric(){this.metric.update(this.size)}}function trackedMap(J){const{name:E,metrics:ee}=J;let te;return ee!=null?te=new TrackedMap({name:E,metrics:ee}):te=new Map,te}const log$1g=logger$1("libp2p:transports");let DefaultTransportManager$1=class{constructor(J,E={}){this.components=J,this.started=!1,this.transports=new Map,this.listeners=trackedMap({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=E.faultTolerance??FaultTolerance.FATAL_ALL}add(J){const E=J[Symbol.toStringTag];if(E==null)throw new CodeError("Transport must have a valid tag",codes$8.ERR_INVALID_KEY);if(this.transports.has(E))throw new CodeError(`There is already a transport with the tag ${E}`,codes$8.ERR_DUPLICATE_TRANSPORT);log$1g("adding transport %s",E),this.transports.set(E,J),this.listeners.has(E)||this.listeners.set(E,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const J=this.components.addressManager.getListenAddrs();await this.listen(J)}async stop(){const J=[];for(const[E,ee]of this.listeners)for(log$1g("closing listeners for %s",E);ee.length>0;){const te=ee.pop();te!=null&&J.push(te.close())}await Promise.all(J),log$1g("all listeners closed");for(const E of this.listeners.keys())this.listeners.set(E,[]);this.started=!1}async dial(J,E){const ee=this.transportForMultiaddr(J);if(ee==null)throw new CodeError(`No transport available for address ${String(J)}`,codes$8.ERR_TRANSPORT_UNAVAILABLE);try{return await ee.dial(J,{...E,upgrader:this.components.upgrader})}catch(te){throw te.code==null&&(te.code=codes$8.ERR_TRANSPORT_DIAL_FAILED),te}}getAddrs(){let J=[];for(const E of this.listeners.values())for(const ee of E)J=[...J,...ee.getAddrs()];return J}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}transportForMultiaddr(J){for(const E of this.transports.values())if(E.filter([J]).length>0)return E}async listen(J){if(J==null||J.length===0){log$1g("no addresses were provided for listening, this node is dial only");return}const E=[];for(const[ee,te]of this.transports.entries()){const re=te.filter(J),ne=[];for(const ie of re){log$1g("creating listener for %s on %s",ee,ie);const se=te.createListener({upgrader:this.components.upgrader});let oe=this.listeners.get(ee)??[];oe==null&&(oe=[],this.listeners.set(ee,oe)),oe.push(se),se.addEventListener("listening",()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:se})}),se.addEventListener("close",()=>{const ce=oe.findIndex(ae=>ae===se);oe.splice(ce,1),this.components.events.safeDispatchEvent("transport:close",{detail:se})}),ne.push(se.listen(ie))}if(ne.length===0){E.push(ee);continue}if((await Promise.allSettled(ne)).find(ie=>ie.status==="fulfilled")==null&&this.faultTolerance!==FaultTolerance.NO_FATAL)throw new CodeError(`Transport (${ee}) could not listen on any available address`,codes$8.ERR_NO_VALID_ADDRESSES)}if(E.length===this.transports.size){const ee=`no valid addresses were provided for transports [${E.join(", ")}]`;if(this.faultTolerance===FaultTolerance.FATAL_ALL)throw new CodeError(ee,codes$8.ERR_NO_VALID_ADDRESSES);log$1g(`libp2p in dial mode only: ${ee}`)}}async remove(J){log$1g("removing %s",J);for(const E of this.listeners.get(J)??[])await E.close();this.transports.delete(J),this.listeners.delete(J)}async removeAll(){const J=[];for(const E of this.transports.keys())J.push(this.remove(E));await Promise.all(J)}};const PROTOCOL_ID="/multistream/1.0.0",MAX_PROTOCOL_LENGTH=1024,symbol$1=Symbol.for("@achingbrain/uint8arraylist");function findBufAndOffset(J,E){if(E==null||E<0)throw new RangeError("index is out of bounds");let ee=0;for(const te of J){const re=ee+te.byteLength;if(E<re)return{buf:te,index:E-ee};ee=re}throw new RangeError("index is out of bounds")}function isUint8ArrayList(J){return!!J?.[symbol$1]}class Uint8ArrayList{constructor(...E){Object.defineProperty(this,symbol$1,{value:!0}),this.bufs=[],this.length=0,E.length>0&&this.appendAll(E)}*[Symbol.iterator](){yield*this.bufs}get byteLength(){return this.length}append(...E){this.appendAll(E)}appendAll(E){let ee=0;for(const te of E)if(te instanceof Uint8Array)ee+=te.byteLength,this.bufs.push(te);else if(isUint8ArrayList(te))ee+=te.byteLength,this.bufs.push(...te.bufs);else throw new Error("Could not append value, must be an Uint8Array or a Uint8ArrayList");this.length+=ee}prepend(...E){this.prependAll(E)}prependAll(E){let ee=0;for(const te of E.reverse())if(te instanceof Uint8Array)ee+=te.byteLength,this.bufs.unshift(te);else if(isUint8ArrayList(te))ee+=te.byteLength,this.bufs.unshift(...te.bufs);else throw new Error("Could not prepend value, must be an Uint8Array or a Uint8ArrayList");this.length+=ee}get(E){const ee=findBufAndOffset(this.bufs,E);return ee.buf[ee.index]}set(E,ee){const te=findBufAndOffset(this.bufs,E);te.buf[te.index]=ee}write(E,ee=0){if(E instanceof Uint8Array)for(let te=0;te<E.length;te++)this.set(ee+te,E[te]);else if(isUint8ArrayList(E))for(let te=0;te<E.length;te++)this.set(ee+te,E.get(te));else throw new Error("Could not write value, must be an Uint8Array or a Uint8ArrayList")}consume(E){if(E=Math.trunc(E),!(Number.isNaN(E)||E<=0)){if(E===this.byteLength){this.bufs=[],this.length=0;return}for(;this.bufs.length>0;)if(E>=this.bufs[0].byteLength)E-=this.bufs[0].byteLength,this.length-=this.bufs[0].byteLength,this.bufs.shift();else{this.bufs[0]=this.bufs[0].subarray(E),this.length-=E;break}}}slice(E,ee){const{bufs:te,length:re}=this._subList(E,ee);return concat$4(te,re)}subarray(E,ee){const{bufs:te,length:re}=this._subList(E,ee);return te.length===1?te[0]:concat$4(te,re)}sublist(E,ee){const{bufs:te,length:re}=this._subList(E,ee),ne=new Uint8ArrayList;return ne.length=re,ne.bufs=te,ne}_subList(E,ee){if(E=E??0,ee=ee??this.length,E<0&&(E=this.length+E),ee<0&&(ee=this.length+ee),E<0||ee>this.length)throw new RangeError("index is out of bounds");if(E===ee)return{bufs:[],length:0};if(E===0&&ee===this.length)return{bufs:[...this.bufs],length:this.length};const te=[];let re=0;for(let ne=0;ne<this.bufs.length;ne++){const ie=this.bufs[ne],se=re,oe=se+ie.byteLength;if(re=oe,E>=oe)continue;const ce=E>=se&&E<oe,ae=ee>se&&ee<=oe;if(ce&&ae){if(E===se&&ee===oe){te.push(ie);break}const le=E-se;te.push(ie.subarray(le,le+(ee-E)));break}if(ce){if(E===0){te.push(ie);continue}te.push(ie.subarray(E-se));continue}if(ae){if(ee===oe){te.push(ie);break}te.push(ie.subarray(0,ee-se));break}te.push(ie)}return{bufs:te,length:ee-E}}indexOf(E,ee=0){if(!isUint8ArrayList(E)&&!(E instanceof Uint8Array))throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');const te=E instanceof Uint8Array?E:E.subarray();if(ee=Number(ee??0),isNaN(ee)&&(ee=0),ee<0&&(ee=this.length+ee),ee<0&&(ee=0),E.length===0)return ee>this.length?this.length:ee;const re=te.byteLength;if(re===0)throw new TypeError("search must be at least 1 byte long");const ne=256,ie=new Int32Array(ne);for(let le=0;le<ne;le++)ie[le]=-1;for(let le=0;le<re;le++)ie[te[le]]=le;const se=ie,oe=this.byteLength-te.byteLength,ce=te.byteLength-1;let ae;for(let le=ee;le<=oe;le+=ae){ae=0;for(let ue=ce;ue>=0;ue--){const he=this.get(le+ue);if(te[ue]!==he){ae=Math.max(1,ue-se[he]);break}}if(ae===0)return le}return-1}getInt8(E){const ee=this.subarray(E,E+1);return new DataView(ee.buffer,ee.byteOffset,ee.byteLength).getInt8(0)}setInt8(E,ee){const te=allocUnsafe$5(1);new DataView(te.buffer,te.byteOffset,te.byteLength).setInt8(0,ee),this.write(te,E)}getInt16(E,ee){const te=this.subarray(E,E+2);return new DataView(te.buffer,te.byteOffset,te.byteLength).getInt16(0,ee)}setInt16(E,ee,te){const re=alloc$1(2);new DataView(re.buffer,re.byteOffset,re.byteLength).setInt16(0,ee,te),this.write(re,E)}getInt32(E,ee){const te=this.subarray(E,E+4);return new DataView(te.buffer,te.byteOffset,te.byteLength).getInt32(0,ee)}setInt32(E,ee,te){const re=alloc$1(4);new DataView(re.buffer,re.byteOffset,re.byteLength).setInt32(0,ee,te),this.write(re,E)}getBigInt64(E,ee){const te=this.subarray(E,E+8);return new DataView(te.buffer,te.byteOffset,te.byteLength).getBigInt64(0,ee)}setBigInt64(E,ee,te){const re=alloc$1(8);new DataView(re.buffer,re.byteOffset,re.byteLength).setBigInt64(0,ee,te),this.write(re,E)}getUint8(E){const ee=this.subarray(E,E+1);return new DataView(ee.buffer,ee.byteOffset,ee.byteLength).getUint8(0)}setUint8(E,ee){const te=allocUnsafe$5(1);new DataView(te.buffer,te.byteOffset,te.byteLength).setUint8(0,ee),this.write(te,E)}getUint16(E,ee){const te=this.subarray(E,E+2);return new DataView(te.buffer,te.byteOffset,te.byteLength).getUint16(0,ee)}setUint16(E,ee,te){const re=alloc$1(2);new DataView(re.buffer,re.byteOffset,re.byteLength).setUint16(0,ee,te),this.write(re,E)}getUint32(E,ee){const te=this.subarray(E,E+4);return new DataView(te.buffer,te.byteOffset,te.byteLength).getUint32(0,ee)}setUint32(E,ee,te){const re=alloc$1(4);new DataView(re.buffer,re.byteOffset,re.byteLength).setUint32(0,ee,te),this.write(re,E)}getBigUint64(E,ee){const te=this.subarray(E,E+8);return new DataView(te.buffer,te.byteOffset,te.byteLength).getBigUint64(0,ee)}setBigUint64(E,ee,te){const re=alloc$1(8);new DataView(re.buffer,re.byteOffset,re.byteLength).setBigUint64(0,ee,te),this.write(re,E)}getFloat32(E,ee){const te=this.subarray(E,E+4);return new DataView(te.buffer,te.byteOffset,te.byteLength).getFloat32(0,ee)}setFloat32(E,ee,te){const re=alloc$1(4);new DataView(re.buffer,re.byteOffset,re.byteLength).setFloat32(0,ee,te),this.write(re,E)}getFloat64(E,ee){const te=this.subarray(E,E+8);return new DataView(te.buffer,te.byteOffset,te.byteLength).getFloat64(0,ee)}setFloat64(E,ee,te){const re=alloc$1(8);new DataView(re.buffer,re.byteOffset,re.byteLength).setFloat64(0,ee,te),this.write(re,E)}equals(E){if(E==null||!(E instanceof Uint8ArrayList)||E.bufs.length!==this.bufs.length)return!1;for(let ee=0;ee<this.bufs.length;ee++)if(!equals(this.bufs[ee],E.bufs[ee]))return!1;return!0}static fromUint8Arrays(E,ee){const te=new Uint8ArrayList;return te.bufs=E,ee==null&&(ee=E.reduce((re,ne)=>re+ne.byteLength,0)),te.length=ee,te}}function accessor(J){return J instanceof Uint8Array?{get(E){return J[E]},set(E,ee){J[E]=ee}}:{get(E){return J.get(E)},set(E,ee){J.set(E,ee)}}}const TWO_32=4294967296;class LongBits{constructor(E=0,ee=0){this.hi=E,this.lo=ee}toBigInt(E){if(E===!0)return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n);if(this.hi>>>31){const ee=~this.lo+1>>>0;let te=~this.hi>>>0;return ee===0&&(te=te+1>>>0),-(BigInt(ee)+(BigInt(te)<<32n))}return BigInt(this.lo>>>0)+(BigInt(this.hi>>>0)<<32n)}toNumber(E){return Number(this.toBigInt(E))}zzDecode(){const E=-(this.lo&1),ee=((this.lo>>>1|this.hi<<31)^E)>>>0,te=(this.hi>>>1^E)>>>0;return new LongBits(te,ee)}zzEncode(){const E=this.hi>>31,ee=((this.hi<<1|this.lo>>>31)^E)>>>0,te=(this.lo<<1^E)>>>0;return new LongBits(ee,te)}toBytes(E,ee=0){const te=accessor(E);for(;this.hi>0;)te.set(ee++,this.lo&127|128),this.lo=(this.lo>>>7|this.hi<<25)>>>0,this.hi>>>=7;for(;this.lo>127;)te.set(ee++,this.lo&127|128),this.lo=this.lo>>>7;te.set(ee++,this.lo)}static fromBigInt(E){if(E===0n)return new LongBits;const ee=E<0;ee&&(E=-E);let te=Number(E>>32n)|0,re=Number(E-(BigInt(te)<<32n))|0;return ee&&(te=~te>>>0,re=~re>>>0,++re>TWO_32&&(re=0,++te>TWO_32&&(te=0))),new LongBits(te,re)}static fromNumber(E){if(E===0)return new LongBits;const ee=E<0;ee&&(E=-E);let te=E>>>0,re=(E-te)/4294967296>>>0;return ee&&(re=~re>>>0,te=~te>>>0,++te>4294967295&&(te=0,++re>4294967295&&(re=0))),new LongBits(re,te)}static fromBytes(E,ee=0){const te=accessor(E),re=new LongBits;let ne=0;if(E.length-ee>4){for(;ne<4;++ne)if(re.lo=(re.lo|(te.get(ee)&127)<<ne*7)>>>0,te.get(ee++)<128)return re;if(re.lo=(re.lo|(te.get(ee)&127)<<28)>>>0,re.hi=(re.hi|(te.get(ee)&127)>>4)>>>0,te.get(ee++)<128)return re;ne=0}else for(;ne<4;++ne){if(ee>=E.length)throw RangeError(`index out of range: ${ee} > ${E.length}`);if(re.lo=(re.lo|(te.get(ee)&127)<<ne*7)>>>0,te.get(ee++)<128)return re}if(E.length-ee>4){for(;ne<5;++ne)if(re.hi=(re.hi|(te.get(ee)&127)<<ne*7+3)>>>0,te.get(ee++)<128)return re}else if(ee<E.byteLength)for(;ne<5;++ne){if(ee>=E.length)throw RangeError(`index out of range: ${ee} > ${E.length}`);if(re.hi=(re.hi|(te.get(ee)&127)<<ne*7+3)>>>0,te.get(ee++)<128)return re}throw RangeError("invalid varint encoding")}}const N1$1=Math.pow(2,7),N2$1=Math.pow(2,14),N3$1=Math.pow(2,21),N4$1=Math.pow(2,28),N5$1=Math.pow(2,35),N6$1=Math.pow(2,42),N7$1=Math.pow(2,49),N8$1=Math.pow(2,56),N9$1=Math.pow(2,63),unsigned={encodingLength(J){return J<N1$1?1:J<N2$1?2:J<N3$1?3:J<N4$1?4:J<N5$1?5:J<N6$1?6:J<N7$1?7:J<N8$1?8:J<N9$1?9:10},encode(J,E,ee=0){if(Number.MAX_SAFE_INTEGER!=null&&J>Number.MAX_SAFE_INTEGER)throw new RangeError("Could not encode varint");return E==null&&(E=allocUnsafe$5(unsigned.encodingLength(J))),LongBits.fromNumber(J).toBytes(E,ee),E},decode(J,E=0){return LongBits.fromBytes(J,E).toNumber(!0)}};function isAsyncIterable$6(J){return J[Symbol.asyncIterator]!=null}const defaultEncoder=J=>{const E=unsigned.encodingLength(J),ee=allocUnsafe$5(E);return unsigned.encode(J,ee),defaultEncoder.bytes=E,ee};defaultEncoder.bytes=0;function encode$b(J,E){E=E??{};const ee=E.lengthEncoder??defaultEncoder;function*te(re){const ne=ee(re.byteLength);ne instanceof Uint8Array?yield ne:yield*ne,re instanceof Uint8Array?yield re:yield*re}return isAsyncIterable$6(J)?async function*(){for await(const re of J)yield*te(re)}():function*(){for(const re of J)yield*te(re)}()}encode$b.single=(J,E)=>{E=E??{};const ee=E.lengthEncoder??defaultEncoder;return new Uint8ArrayList(ee(J.byteLength),J)};const MAX_LENGTH_LENGTH$1=8,MAX_DATA_LENGTH$1=1024*1024*4;var ReadMode$1;(function(J){J[J.LENGTH=0]="LENGTH",J[J.DATA=1]="DATA"})(ReadMode$1||(ReadMode$1={}));const defaultDecoder$1=J=>{const E=unsigned.decode(J);return defaultDecoder$1.bytes=unsigned.encodingLength(E),E};defaultDecoder$1.bytes=0;function decode$b(J,E){const ee=new Uint8ArrayList;let te=ReadMode$1.LENGTH,re=-1;const ne=E?.lengthDecoder??defaultDecoder$1,ie=E?.maxLengthLength??MAX_LENGTH_LENGTH$1,se=E?.maxDataLength??MAX_DATA_LENGTH$1;function*oe(){for(;ee.byteLength>0;){if(te===ReadMode$1.LENGTH)try{if(re=ne(ee),re<0)throw errCode$1(new Error("invalid message length"),"ERR_INVALID_MSG_LENGTH");if(re>se)throw errCode$1(new Error("message length too long"),"ERR_MSG_DATA_TOO_LONG");const ce=ne.bytes;ee.consume(ce),E?.onLength!=null&&E.onLength(re),te=ReadMode$1.DATA}catch(ce){if(ce instanceof RangeError){if(ee.byteLength>ie)throw errCode$1(new Error("message length length too long"),"ERR_MSG_LENGTH_TOO_LONG");break}throw ce}if(te===ReadMode$1.DATA){if(ee.byteLength<re)break;const ce=ee.sublist(0,re);ee.consume(re),E?.onData!=null&&E.onData(ce),yield ce,te=ReadMode$1.LENGTH}}}return isAsyncIterable$6(J)?async function*(){for await(const ce of J)ee.append(ce),yield*oe();if(ee.byteLength>0)throw errCode$1(new Error("unexpected end of input"),"ERR_UNEXPECTED_EOF")}():function*(){for(const ce of J)ee.append(ce),yield*oe();if(ee.byteLength>0)throw errCode$1(new Error("unexpected end of input"),"ERR_UNEXPECTED_EOF")}()}decode$b.fromReader=(J,E)=>{let ee=1;const te=async function*(){for(;;)try{const{done:re,value:ne}=await J.next(ee);if(re===!0)return;ne!=null&&(yield ne)}catch(re){if(re.code==="ERR_UNDER_READ")return{done:!0,value:null};throw re}finally{ee=1}}();return decode$b(te,{...E??{},onLength:re=>{ee=re}})};let AbortError$2=class extends Error{constructor(J,E){super(J??"The operation was aborted"),this.type="aborted",this.code=E??"ABORT_ERR"}};function getIterator(J){if(J!=null){if(typeof J[Symbol.iterator]=="function")return J[Symbol.iterator]();if(typeof J[Symbol.asyncIterator]=="function")return J[Symbol.asyncIterator]();if(typeof J.next=="function")return J}throw new Error("argument is not an iterator or iterable")}function abortableSource$1(J,E,ee){const te=ee??{},re=getIterator(J);async function*ne(){let ie;const se=()=>{ie?.()};for(E.addEventListener("abort",se);;){let oe;try{if(E.aborted){const{abortMessage:ae,abortCode:le}=te;throw new AbortError$2(ae,le)}const ce=new Promise((ae,le)=>{ie=()=>{const{abortMessage:ue,abortCode:he}=te;le(new AbortError$2(ue,he))}});oe=await Promise.race([ce,re.next()]),ie=null}catch(ce){E.removeEventListener("abort",se);const ae=ce.type==="aborted"&&E.aborted;if(ae&&te.onAbort!=null&&te.onAbort(J),typeof re.return=="function")try{const le=re.return();le instanceof Promise&&le.catch(ue=>{te.onReturnError!=null&&te.onReturnError(ue)})}catch(le){te.onReturnError!=null&&te.onReturnError(le)}if(ae&&te.returnOnAbort===!0)return;throw ce}if(oe.done===!0)break;yield oe.value}E.removeEventListener("abort",se)}return ne()}function abortableSink(J,E,ee){return te=>J(abortableSource$1(te,E,ee))}function abortableDuplex(J,E,ee){return{sink:abortableSink(J.sink,E,{...ee,onAbort:void 0}),source:abortableSource$1(J.source,E,ee)}}const log$1f=logger$1("libp2p:mss"),NewLine=fromString$5(`
`);function encode$a(J){const E=new Uint8ArrayList(J,NewLine);return encode$b.single(E)}function write(J,E,ee={}){const te=encode$a(E);ee.writeBytes===!0?J.push(te.subarray()):J.push(te)}function writeAll(J,E,ee={}){const te=new Uint8ArrayList;for(const re of E)te.append(encode$a(re));ee.writeBytes===!0?J.push(te.subarray()):J.push(te)}async function read$1(J,E){let ee=1;const te={[Symbol.asyncIterator]:()=>te,next:async()=>await J.next(ee)};let re=te;E?.signal!=null&&(re=abortableSource$1(te,E.signal));const ne=se=>{ee=se},ie=await pipe$1(re,se=>decode$b(se,{onLength:ne,maxDataLength:MAX_PROTOCOL_LENGTH}),async se=>await first(se));if(ie==null||ie.length===0)throw new CodeError("no buffer returned","ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");if(ie.get(ie.byteLength-1)!==NewLine[0])throw log$1f.error("Invalid mss message - missing newline - %s",ie.subarray()),new CodeError("missing newline","ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");return ie.sublist(0,-1)}async function readString(J,E){const ee=await read$1(J,E);return toString$5(ee.subarray())}function reader$1(J){const E=async function*(){let ee=yield,te=new Uint8ArrayList;for await(const re of J){if(ee==null){te.append(re),ee=yield te,te=new Uint8ArrayList;continue}for(te.append(re);te.length>=ee;){const ne=te.sublist(0,ee);if(te.consume(ee),ee=yield ne,ee==null){te.length>0&&(ee=yield te,te=new Uint8ArrayList);break}}}if(ee!=null)throw Object.assign(new Error(`stream ended before ${ee} bytes became available`),{code:"ERR_UNDER_READ",buffer:te})}();return E.next(),E}function handshake(J){const E=pushable(),ee=reader$1(J.source),te=pDefer();let re;const ne=J.sink(async function*(){yield*E,yield*await te.promise}());return ne.catch(ie=>{re=ie}),{reader:ee,writer:E,stream:{sink:async ie=>{if(re!=null){await Promise.reject(re);return}te.resolve(ie),await ne},source:ee},rest:()=>E.end(),write:E.push,read:async()=>{const ie=await ee.next();if(ie.value!=null)return ie.value}}}const log$1e=logger$1("libp2p:mss:select");async function select$1(J,E,ee={}){E=Array.isArray(E)?[...E]:[E];const{reader:te,writer:re,rest:ne,stream:ie}=handshake(J),se=E.shift();if(se==null)throw new Error("At least one protocol must be specified");log$1e.trace('select: write ["%s", "%s"]',PROTOCOL_ID,se);const oe=fromString$5(PROTOCOL_ID),ce=fromString$5(se);writeAll(re,[oe,ce],ee);let ae=await readString(te,ee);if(log$1e.trace('select: read "%s"',ae),ae===PROTOCOL_ID&&(ae=await readString(te,ee),log$1e.trace('select: read "%s"',ae)),ae===se)return ne(),{stream:ie,protocol:se};for(const le of E){log$1e.trace('select: write "%s"',le),write(re,fromString$5(le),ee);const ue=await readString(te,ee);if(log$1e.trace('select: read "%s" for "%s"',ue,le),ue===le)return ne(),{stream:ie,protocol:le}}throw ne(),new CodeError("protocol selection failed","ERR_UNSUPPORTED_PROTOCOL")}const log$1d=logger$1("libp2p:mss:handle");async function handle(J,E,ee){E=Array.isArray(E)?E:[E];const{writer:te,reader:re,rest:ne,stream:ie}=handshake(J);for(;;){const se=await readString(re,ee);if(log$1d.trace('read "%s"',se),se===PROTOCOL_ID){log$1d.trace('respond with "%s" for "%s"',PROTOCOL_ID,se),write(te,fromString$5(PROTOCOL_ID),ee);continue}if(E.includes(se))return write(te,fromString$5(se),ee),log$1d.trace('respond with "%s" for "%s"',se,se),ne(),{stream:ie,protocol:se};if(se==="ls"){write(te,new Uint8ArrayList(...E.map(oe=>encode$a(fromString$5(oe)))),ee),log$1d.trace('respond with "%s" for %s',E,se);continue}write(te,fromString$5("na"),ee),log$1d('respond with "na" for "%s"',se)}}const OPEN="OPEN",CLOSING="CLOSING",CLOSED="CLOSED",symbol=Symbol.for("@libp2p/connection"),log$1c=logger$1("libp2p:connection");let ConnectionImpl$1=class{constructor(J){const{remoteAddr:E,remotePeer:ee,newStream:te,close:re,getStreams:ne,stat:ie}=J;this.id=`${parseInt(String(Math.random()*1e9)).toString(36)}${Date.now()}`,this.remoteAddr=E,this.remotePeer=ee,this.stat={...ie,status:OPEN},this._newStream=te,this._close=re,this._getStreams=ne,this.tags=[],this._closing=!1}get[Symbol.toStringTag](){return"Connection"}get[symbol](){return!0}get streams(){return this._getStreams()}async newStream(J,E){if(this.stat.status===CLOSING)throw new CodeError("the connection is being closed","ERR_CONNECTION_BEING_CLOSED");if(this.stat.status===CLOSED)throw new CodeError("the connection is closed","ERR_CONNECTION_CLOSED");Array.isArray(J)||(J=[J]);const ee=await this._newStream(J,E);return ee.stat.direction="outbound",ee}addStream(J){J.stat.direction="inbound"}removeStream(J){}async close(){if(!(this.stat.status===CLOSED||this._closing)){this.stat.status=CLOSING;try{this.streams.forEach(J=>{J.close()})}catch(J){log$1c.error(J)}this._closing=!0,await this._close(),this._closing=!1,this.stat.timeline.close=Date.now(),this.stat.status=CLOSED}}};function createConnection$1(J){return new ConnectionImpl$1(J)}const topologySymbol=Symbol.for("@libp2p/topology");function isTopology(J){return J!=null&&!!J[topologySymbol]}const log$1b=logger$1("libp2p:registrar"),DEFAULT_MAX_INBOUND_STREAMS$3=32,DEFAULT_MAX_OUTBOUND_STREAMS$3=64;let DefaultRegistrar$1=class{constructor(J){this.topologies=new Map,this.handlers=new Map,this.components=J,this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onConnect=this._onConnect.bind(this),this.components.events.addEventListener("connection:close",this._onDisconnect),this.components.events.addEventListener("connection:open",this._onConnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate)}getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(J){const E=this.handlers.get(J);if(E==null)throw new CodeError(`No handler registered for protocol ${J}`,codes$8.ERR_NO_HANDLER_FOR_PROTOCOL);return E}getTopologies(J){const E=this.topologies.get(J);return E==null?[]:[...E.values()]}async handle(J,E,ee){if(this.handlers.has(J))throw new CodeError(`Handler already registered for protocol ${J}`,codes$8.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED);const te=mergeOptions$9.bind({ignoreUndefined:!0})({maxInboundStreams:DEFAULT_MAX_INBOUND_STREAMS$3,maxOutboundStreams:DEFAULT_MAX_OUTBOUND_STREAMS$3},ee);this.handlers.set(J,{handler:E,options:te}),await this.components.peerStore.merge(this.components.peerId,{protocols:[J]})}async unhandle(J){const E=Array.isArray(J)?J:[J];E.forEach(ee=>{this.handlers.delete(ee)}),await this.components.peerStore.patch(this.components.peerId,{protocols:E})}async register(J,E){if(!isTopology(E))throw log$1b.error("topology must be an instance of interfaces/topology"),new CodeError("topology must be an instance of interfaces/topology",codes$8.ERR_INVALID_PARAMETERS);const ee=`${(Math.random()*1e9).toString(36)}${Date.now()}`;let te=this.topologies.get(J);return te==null&&(te=new Map,this.topologies.set(J,te)),te.set(ee,E),await E.setRegistrar(this),ee}unregister(J){for(const[E,ee]of this.topologies.entries())ee.has(J)&&(ee.delete(J),ee.size===0&&this.topologies.delete(E))}_onDisconnect(J){const E=J.detail;this.components.peerStore.get(E.remotePeer).then(ee=>{for(const te of ee.protocols){const re=this.topologies.get(te);if(re!=null)for(const ne of re.values())ne.onDisconnect(E.remotePeer)}}).catch(ee=>{log$1b.error("could not inform topologies of disconnecting peer %p",E.remotePeer,ee)})}_onConnect(J){const E=J.detail;this.components.peerStore.get(E.remotePeer).then(ee=>{for(const te of ee.protocols){const re=this.topologies.get(te);if(re!=null)for(const ne of re.values())ne.onConnect(E.remotePeer,E)}}).catch(ee=>{log$1b.error("could not inform topologies of connecting peer %p",E.remotePeer,ee)})}_onPeerUpdate(J){const{peer:E,previous:ee}=J.detail,te=(ee?.protocols??[]).filter(ne=>!E.protocols.includes(ne)),re=E.protocols.filter(ne=>!(ee?.protocols??[]).includes(ne));for(const ne of te){const ie=this.topologies.get(ne);if(ie!=null)for(const se of ie.values())se.onDisconnect(E.id)}for(const ne of re){const ie=this.topologies.get(ne);if(ie!=null)for(const se of ie.values()){const oe=this.components.connectionManager.getConnections(E.id)[0];oe!=null&&se.onConnect(E.id,oe)}}}};const log$1a=logger$1("libp2p:upgrader");function findIncomingStreamLimit$1(J,E){try{const{options:ee}=E.getHandler(J);return ee.maxInboundStreams}catch(ee){if(ee.code!==codes$8.ERR_NO_HANDLER_FOR_PROTOCOL)throw ee}return DEFAULT_MAX_INBOUND_STREAMS$3}function findOutgoingStreamLimit$1(J,E){try{const{options:ee}=E.getHandler(J);return ee.maxOutboundStreams}catch(ee){if(ee.code!==codes$8.ERR_NO_HANDLER_FOR_PROTOCOL)throw ee}return DEFAULT_MAX_OUTBOUND_STREAMS$3}function countStreams$1(J,E,ee){let te=0;return ee.streams.forEach(re=>{re.stat.direction===E&&re.stat.protocol===J&&te++}),te}let DefaultUpgrader$1=class{constructor(J,E){this.components=J,this.connectionEncryption=new Map,E.connectionEncryption.forEach(ee=>{this.connectionEncryption.set(ee.protocol,ee)}),this.muxers=new Map,E.muxers.forEach(ee=>{this.muxers.set(ee.protocol,ee)}),this.inboundUpgradeTimeout=E.inboundUpgradeTimeout??INBOUND_UPGRADE_TIMEOUT$1,this.events=J.events}async shouldBlockConnection(J,E,ee){const te=this.components.connectionGater[ee];if(te!==void 0&&await te(J,E))throw new CodeError(`The multiaddr connection is blocked by gater.${ee}`,codes$8.ERR_CONNECTION_INTERCEPTED)}async upgradeInbound(J,E){if(!await this.components.connectionManager.acceptIncomingConnection(J))throw new CodeError("connection denied",codes$8.ERR_CONNECTION_DENIED);let ee,te,re,ne,ie;const se=anySignal([AbortSignal.timeout(this.inboundUpgradeTimeout)]);try{setMaxListeners?.(1/0,se)}catch{}try{const oe=abortableDuplex(J,se);if(J.source=oe.source,J.sink=oe.sink,await this.components.connectionGater.denyInboundConnection?.(J)===!0)throw new CodeError("The multiaddr connection is blocked by gater.acceptConnection",codes$8.ERR_CONNECTION_INTERCEPTED);this.components.metrics?.trackMultiaddrConnection(J),log$1a("starting the inbound connection upgrade");let ce=J;if(E?.skipProtection!==!0){const ae=this.components.connectionProtector;ae!=null&&(log$1a("protecting the inbound connection"),ce=await ae.protect(J))}try{if(ee=ce,E?.skipEncryption!==!0){({conn:ee,remotePeer:te,protocol:ie}=await this._encryptInbound(ce));const ae={...ce,...ee};await this.shouldBlockConnection(te,ae,"denyInboundEncryptedConnection")}else{const ae=J.remoteAddr.getPeerId();if(ae==null)throw new CodeError("inbound connection that skipped encryption must have a peer id",codes$8.ERR_INVALID_MULTIADDR);const le=peerIdFromString(ae);ie="native",te=le}if(re=ee,E?.muxerFactory!=null)ne=E.muxerFactory;else if(this.muxers.size>0){const ae=await this._multiplexInbound({...ce,...ee},this.muxers);ne=ae.muxerFactory,re=ae.stream}}catch(ae){throw log$1a.error("Failed to upgrade inbound connection",ae),ae}return await this.shouldBlockConnection(te,J,"denyInboundUpgradedConnection"),log$1a("Successfully upgraded inbound connection"),this._createConnection({cryptoProtocol:ie,direction:"inbound",maConn:J,upgradedConn:re,muxerFactory:ne,remotePeer:te})}finally{this.components.connectionManager.afterUpgradeInbound(),se.clear()}}async upgradeOutbound(J,E){const ee=J.remoteAddr.getPeerId();let te;ee!=null&&(te=peerIdFromString(ee),await this.shouldBlockConnection(te,J,"denyOutboundConnection"));let re,ne,ie,se,oe;this.components.metrics?.trackMultiaddrConnection(J),log$1a("Starting the outbound connection upgrade");let ce=J;if(E?.skipProtection!==!0){const ae=this.components.connectionProtector;ae!=null&&(ce=await ae.protect(J))}try{if(re=ce,E?.skipEncryption!==!0){({conn:re,remotePeer:ne,protocol:se}=await this._encryptOutbound(ce,te));const ae={...ce,...re};await this.shouldBlockConnection(ne,ae,"denyOutboundEncryptedConnection")}else{if(te==null)throw new CodeError("Encryption was skipped but no peer id was passed",codes$8.ERR_INVALID_PEER);se="native",ne=te}if(ie=re,E?.muxerFactory!=null)oe=E.muxerFactory;else if(this.muxers.size>0){const ae=await this._multiplexOutbound({...ce,...re},this.muxers);oe=ae.muxerFactory,ie=ae.stream}}catch(ae){throw log$1a.error("Failed to upgrade outbound connection",ae),await J.close(ae),ae}return await this.shouldBlockConnection(ne,J,"denyOutboundUpgradedConnection"),log$1a("Successfully upgraded outbound connection"),this._createConnection({cryptoProtocol:se,direction:"outbound",maConn:J,upgradedConn:ie,muxerFactory:oe,remotePeer:ne})}_createConnection(J){const{cryptoProtocol:E,direction:ee,maConn:te,upgradedConn:re,remotePeer:ne,muxerFactory:ie}=J;let se,oe,ce;ie!=null&&(se=ie.createStreamMuxer({direction:ee,onIncomingStream:ue=>{ce!=null&&Promise.resolve().then(async()=>{const he=this.components.registrar.getProtocols(),{stream:pe,protocol:de}=await handle(ue,he);if(log$1a("%s: incoming stream opened on %s",ee,de),ce==null)return;const fe=findIncomingStreamLimit$1(de,this.components.registrar);if(countStreams$1(de,"inbound",ce)===fe){const me=new CodeError(`Too many inbound protocol streams for protocol "${de}" - limit ${fe}`,codes$8.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS);throw ue.abort(me),me}ue.source=pe.source,ue.sink=pe.sink,ue.stat.protocol=de,await this.components.peerStore.merge(ne,{protocols:[de]}),ce.addStream(ue),this.components.metrics?.trackProtocolStream(ue,ce),this._onStream({connection:ce,stream:ue,protocol:de})}).catch(he=>{log$1a.error(he),ue.stat.timeline.close==null&&ue.close()})},onStreamEnd:ue=>{ce?.removeStream(ue.id)}}),oe=async(ue,he={})=>{if(se==null)throw new CodeError("Stream is not multiplexed",codes$8.ERR_MUXER_UNAVAILABLE);log$1a("%s: starting new stream on %s",ee,ue);const pe=await se.newStream();try{if(he.signal==null){log$1a("No abort signal was passed while trying to negotiate protocols %s falling back to default timeout",ue),he.signal=AbortSignal.timeout(3e4);try{setMaxListeners?.(1/0,he.signal)}catch{}}const{stream:de,protocol:fe}=await select$1(pe,ue,he),me=findOutgoingStreamLimit$1(fe,this.components.registrar);if(countStreams$1(fe,"outbound",ce)===me){const _e=new CodeError(`Too many outbound protocol streams for protocol "${fe}" - limit ${me}`,codes$8.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS);throw pe.abort(_e),_e}return await this.components.peerStore.merge(ne,{protocols:[fe]}),pe.source=de.source,pe.sink=de.sink,pe.stat.protocol=fe,this.components.metrics?.trackProtocolStream(pe,ce),pe}catch(de){throw log$1a.error("could not create new stream",de),pe.stat.timeline.close==null&&pe.close(),de.code!=null?de:new CodeError(String(de),codes$8.ERR_UNSUPPORTED_PROTOCOL)}},Promise.all([se.sink(re.source),re.sink(se.source)]).catch(ue=>{log$1a.error(ue)}));const ae=te.timeline;te.timeline=new Proxy(ae,{set:(...ue)=>(ce!=null&&ue[1]==="close"&&ue[2]!=null&&ae.close==null&&(async()=>{try{ce.stat.status==="OPEN"&&await ce.close()}catch(he){log$1a.error(he)}finally{this.events.safeDispatchEvent("connection:close",{detail:ce})}})().catch(he=>{log$1a.error(he)}),Reflect.set(...ue))}),te.timeline.upgraded=Date.now();const le=()=>{throw new CodeError("connection is not multiplexed",codes$8.ERR_CONNECTION_NOT_MULTIPLEXED)};return ce=createConnection$1({remoteAddr:te.remoteAddr,remotePeer:ne,stat:{status:"OPEN",direction:ee,timeline:te.timeline,multiplexer:se?.protocol,encryption:E},newStream:oe??le,getStreams:()=>se!=null?se.streams:le(),close:async()=>{await te.close(),se?.close()}}),this.events.safeDispatchEvent("connection:open",{detail:ce}),ce}_onStream(J){const{connection:E,stream:ee,protocol:te}=J,{handler:re}=this.components.registrar.getHandler(te);re({connection:E,stream:ee})}async _encryptInbound(J){const E=Array.from(this.connectionEncryption.keys());log$1a("handling inbound crypto protocol selection",E);try{const{stream:ee,protocol:te}=await handle(J,E,{writeBytes:!0}),re=this.connectionEncryption.get(te);if(re==null)throw new Error(`no crypto module found for ${te}`);return log$1a("encrypting inbound connection..."),{...await re.secureInbound(this.components.peerId,ee),protocol:te}}catch(ee){throw new CodeError(String(ee),codes$8.ERR_ENCRYPTION_FAILED)}}async _encryptOutbound(J,E){const ee=Array.from(this.connectionEncryption.keys());log$1a("selecting outbound crypto protocol",ee);try{const{stream:te,protocol:re}=await select$1(J,ee,{writeBytes:!0}),ne=this.connectionEncryption.get(re);if(ne==null)throw new Error(`no crypto module found for ${re}`);return log$1a("encrypting outbound connection to %p",E),{...await ne.secureOutbound(this.components.peerId,te,E),protocol:re}}catch(te){throw new CodeError(String(te),codes$8.ERR_ENCRYPTION_FAILED)}}async _multiplexOutbound(J,E){const ee=Array.from(E.keys());log$1a("outbound selecting muxer %s",ee);try{const{stream:te,protocol:re}=await select$1(J,ee,{writeBytes:!0});log$1a("%s selected as muxer protocol",re);const ne=E.get(re);return{stream:te,muxerFactory:ne}}catch(te){throw log$1a.error("error multiplexing outbound stream",te),new CodeError(String(te),codes$8.ERR_MUXER_UNAVAILABLE)}}async _multiplexInbound(J,E){const ee=Array.from(E.keys());log$1a("inbound handling muxers %s",ee);try{const{stream:te,protocol:re}=await handle(J,ee,{writeBytes:!0}),ne=E.get(re);return{stream:te,muxerFactory:ne}}catch(te){throw log$1a.error("error multiplexing inbound stream",te),new CodeError(String(te),codes$8.ERR_MUXER_UNAVAILABLE)}}};const codes$6={ERR_SIGNATURE_NOT_VALID:"ERR_SIGNATURE_NOT_VALID"};var Envelope;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{re.lengthDelimited!==!1&&te.fork(),ee.publicKey!=null&&ee.publicKey.byteLength>0&&(te.uint32(10),te.bytes(ee.publicKey)),ee.payloadType!=null&&ee.payloadType.byteLength>0&&(te.uint32(18),te.bytes(ee.payloadType)),ee.payload!=null&&ee.payload.byteLength>0&&(te.uint32(26),te.bytes(ee.payload)),ee.signature!=null&&ee.signature.byteLength>0&&(te.uint32(42),te.bytes(ee.signature)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={publicKey:new Uint8Array(0),payloadType:new Uint8Array(0),payload:new Uint8Array(0),signature:new Uint8Array(0)},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.publicKey=ee.bytes();break;case 2:re.payloadType=ee.bytes();break;case 3:re.payload=ee.bytes();break;case 5:re.signature=ee.bytes();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage$1(ee,J.codec())})(Envelope||(Envelope={}));class RecordEnvelope{constructor(E){const{peerId:ee,payloadType:te,payload:re,signature:ne}=E;this.peerId=ee,this.payloadType=te,this.payload=re,this.signature=ne}marshal(){if(this.peerId.publicKey==null)throw new Error("Missing public key");return this.marshaled==null&&(this.marshaled=Envelope.encode({publicKey:this.peerId.publicKey,payloadType:this.payloadType,payload:this.payload.subarray(),signature:this.signature})),this.marshaled}equals(E){return equals(this.marshal(),E.marshal())}async validate(E){const ee=formatSignaturePayload(E,this.payloadType,this.payload);if(this.peerId.publicKey==null)throw new Error("Missing public key");return await unmarshalPublicKey(this.peerId.publicKey).verify(ee.subarray(),this.signature)}}RecordEnvelope.createFromProtobuf=async J=>{const E=Envelope.decode(J),ee=await peerIdFromKeys(E.publicKey);return new RecordEnvelope({peerId:ee,payloadType:E.payloadType,payload:E.payload,signature:E.signature})};RecordEnvelope.seal=async(J,E)=>{if(E.privateKey==null)throw new Error("Missing private key");const ee=J.domain,te=J.codec,re=J.marshal(),ne=formatSignaturePayload(ee,te,re),ie=await(await unmarshalPrivateKey(E.privateKey)).sign(ne.subarray());return new RecordEnvelope({peerId:E,payloadType:te,payload:re,signature:ie})};RecordEnvelope.openAndCertify=async(J,E)=>{const ee=await RecordEnvelope.createFromProtobuf(J);if(!await ee.validate(E))throw new CodeError("envelope signature is not valid for the given domain",codes$6.ERR_SIGNATURE_NOT_VALID);return ee};const formatSignaturePayload=(J,E,ee)=>{const te=fromString$5(J),re=unsigned.encode(te.byteLength),ne=unsigned.encode(E.length),ie=unsigned.encode(ee.length);return new Uint8ArrayList(re,te,ne,E,ie,ee)};function arrayEquals$1(J,E){const ee=(te,re)=>te.toString().localeCompare(re.toString());return J.length!==E.length?!1:(E.sort(ee),J.sort(ee).every((te,re)=>E[re].equals(te)))}var PeerRecord$1;(function(J){(function(ee){let te;ee.codec=()=>(te==null&&(te=message((re,ne,ie={})=>{ie.lengthDelimited!==!1&&ne.fork(),re.multiaddr!=null&&re.multiaddr.byteLength>0&&(ne.uint32(10),ne.bytes(re.multiaddr)),ie.lengthDelimited!==!1&&ne.ldelim()},(re,ne)=>{const ie={multiaddr:new Uint8Array(0)},se=ne==null?re.len:re.pos+ne;for(;re.pos<se;){const oe=re.uint32();switch(oe>>>3){case 1:ie.multiaddr=re.bytes();break;default:re.skipType(oe&7);break}}return ie})),te),ee.encode=re=>encodeMessage(re,ee.codec()),ee.decode=re=>decodeMessage$1(re,ee.codec())})(J.AddressInfo||(J.AddressInfo={}));let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{if(re.lengthDelimited!==!1&&te.fork(),ee.peerId!=null&&ee.peerId.byteLength>0&&(te.uint32(10),te.bytes(ee.peerId)),ee.seq!=null&&ee.seq!==0n&&(te.uint32(16),te.uint64(ee.seq)),ee.addresses!=null)for(const ne of ee.addresses)te.uint32(26),J.AddressInfo.codec().encode(ne,te);re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={peerId:new Uint8Array(0),seq:0n,addresses:[]},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.peerId=ee.bytes();break;case 2:re.seq=ee.uint64();break;case 3:re.addresses.push(J.AddressInfo.codec().decode(ee,ee.uint32()));break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage$1(ee,J.codec())})(PeerRecord$1||(PeerRecord$1={}));const ENVELOPE_DOMAIN_PEER_RECORD="libp2p-peer-record",ENVELOPE_PAYLOAD_TYPE_PEER_RECORD=Uint8Array.from([3,1]);class PeerRecord{constructor(E){this.domain=PeerRecord.DOMAIN,this.codec=PeerRecord.CODEC;const{peerId:ee,multiaddrs:te,seqNumber:re}=E;this.peerId=ee,this.multiaddrs=te??[],this.seqNumber=re??BigInt(Date.now())}marshal(){return this.marshaled==null&&(this.marshaled=PeerRecord$1.encode({peerId:this.peerId.toBytes(),seq:BigInt(this.seqNumber),addresses:this.multiaddrs.map(E=>({multiaddr:E.bytes}))})),this.marshaled}equals(E){return!(!(E instanceof PeerRecord)||!this.peerId.equals(E.peerId)||this.seqNumber!==E.seqNumber||!arrayEquals$1(this.multiaddrs,E.multiaddrs))}}PeerRecord.createFromProtobuf=J=>{const E=PeerRecord$1.decode(J),ee=peerIdFromBytes(E.peerId),te=(E.addresses??[]).map(ne=>multiaddr(ne.multiaddr)),re=E.seq;return new PeerRecord({peerId:ee,multiaddrs:te,seqNumber:re})};PeerRecord.DOMAIN=ENVELOPE_DOMAIN_PEER_RECORD;PeerRecord.CODEC=ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;class TimeoutError extends Error{constructor(E){super(E),this.name="TimeoutError"}}let AbortError$1=class extends Error{constructor(J){super(),this.name="AbortError",this.message=J}};const getDOMException=J=>globalThis.DOMException===void 0?new AbortError$1(J):new DOMException(J),getAbortedReason=J=>{const E=J.reason===void 0?getDOMException("This operation was aborted."):J.reason;return E instanceof Error?E:getDOMException(E)};function pTimeout(J,E){const{milliseconds:ee,fallback:te,message:re,customTimers:ne={setTimeout,clearTimeout}}=E;let ie;const se=new Promise((oe,ce)=>{if(typeof ee!="number"||Math.sign(ee)!==1)throw new TypeError(`Expected \`milliseconds\` to be a positive number, got \`${ee}\``);if(ee===Number.POSITIVE_INFINITY){oe(J);return}if(E.signal){const{signal:le}=E;le.aborted&&ce(getAbortedReason(le)),le.addEventListener("abort",()=>{ce(getAbortedReason(le))})}const ae=new TimeoutError;ie=ne.setTimeout.call(void 0,()=>{if(te){try{oe(te())}catch(le){ce(le)}return}typeof J.cancel=="function"&&J.cancel(),re===!1?oe():re instanceof Error?ce(re):(ae.message=re??`Promise timed out after ${ee} milliseconds`,ce(ae))},ee),(async()=>{try{oe(await J)}catch(le){ce(le)}finally{ne.clearTimeout.call(void 0,ie)}})()});return se.clear=()=>{ne.clearTimeout.call(void 0,ie),ie=void 0},se}const WORKER_REQUEST_READ_LOCK="lock:worker:request-read",WORKER_RELEASE_READ_LOCK="lock:worker:release-read",MASTER_GRANT_READ_LOCK="lock:master:grant-read",WORKER_REQUEST_WRITE_LOCK="lock:worker:request-write",WORKER_RELEASE_WRITE_LOCK="lock:worker:release-write",MASTER_GRANT_WRITE_LOCK="lock:master:grant-write",events={},observable=J=>{J.addEventListener("message",E=>{observable.dispatchEvent("message",J,E)}),J.port!=null&&J.port.addEventListener("message",E=>{observable.dispatchEvent("message",J,E)})};observable.addEventListener=(J,E)=>{events[J]==null&&(events[J]=[]),events[J].push(E)};observable.removeEventListener=(J,E)=>{events[J]!=null&&(events[J]=events[J].filter(ee=>ee===E))};observable.dispatchEvent=function(J,E,ee){events[J]!=null&&events[J].forEach(te=>te(E,ee))};const handleWorkerLockRequest=(J,E,ee,te,re)=>(ne,ie)=>{if(ie.data.type!==ee)return;const se={type:ie.data.type,name:ie.data.name,identifier:ie.data.identifier};J.dispatchEvent(new MessageEvent(E,{data:{name:se.name,handler:async()=>(ne.postMessage({type:re,name:se.name,identifier:se.identifier}),await new Promise(oe=>{const ce=ae=>{if(ae==null||ae.data==null)return;const le={type:ae.data.type,name:ae.data.name,identifier:ae.data.identifier};le.type===te&&le.identifier===se.identifier&&(ne.removeEventListener("message",ce),oe())};ne.addEventListener("message",ce)}))}}))},makeWorkerLockRequest=(J,E,ee,te)=>async()=>{const re=nanoid();return globalThis.postMessage({type:E,identifier:re,name:J}),await new Promise(ne=>{const ie=se=>{if(se==null||se.data==null)return;const oe={type:se.data.type,identifier:se.data.identifier};oe.type===ee&&oe.identifier===re&&(globalThis.removeEventListener("message",ie),ne(()=>{globalThis.postMessage({type:te,identifier:re,name:J})}))};globalThis.addEventListener("message",ie)})},defaultOptions$f={singleProcess:!1},impl=J=>{if(J=Object.assign({},defaultOptions$f,J),!!globalThis.document||J.singleProcess){const E=new EventTarget;return observable.addEventListener("message",handleWorkerLockRequest(E,"requestReadLock",WORKER_REQUEST_READ_LOCK,WORKER_RELEASE_READ_LOCK,MASTER_GRANT_READ_LOCK)),observable.addEventListener("message",handleWorkerLockRequest(E,"requestWriteLock",WORKER_REQUEST_WRITE_LOCK,WORKER_RELEASE_WRITE_LOCK,MASTER_GRANT_WRITE_LOCK)),E}return{isWorker:!0,readLock:E=>makeWorkerLockRequest(E,WORKER_REQUEST_READ_LOCK,MASTER_GRANT_READ_LOCK,WORKER_RELEASE_READ_LOCK),writeLock:E=>makeWorkerLockRequest(E,WORKER_REQUEST_WRITE_LOCK,MASTER_GRANT_WRITE_LOCK,WORKER_RELEASE_WRITE_LOCK)}},mutexes={};let implementation;async function createReleaseable(J,E){let ee;const te=new Promise(re=>{ee=re});return J.add(async()=>await pTimeout((async()=>await new Promise(re=>{ee(()=>{re()})}))(),{milliseconds:E.timeout})),await te}const createMutex=(J,E)=>{if(implementation.isWorker===!0)return{readLock:implementation.readLock(J,E),writeLock:implementation.writeLock(J,E)};const ee=new PQueue({concurrency:1});let te;return{async readLock(){if(te!=null)return await createReleaseable(te,E);te=new PQueue({concurrency:E.concurrency,autoStart:!1});const re=te,ne=createReleaseable(te,E);return ee.add(async()=>(re.start(),await re.onIdle().then(()=>{te===re&&(te=null)}))),await ne},async writeLock(){return te=null,await createReleaseable(ee,E)}}},defaultOptions$e={name:"lock",concurrency:1/0,timeout:846e5,singleProcess:!1};function createMortice(J){const E=Object.assign({},defaultOptions$e,J);return implementation==null&&(implementation=impl(E),implementation.isWorker!==!0&&(implementation.addEventListener("requestReadLock",ee=>{mutexes[ee.data.name]!=null&&mutexes[ee.data.name].readLock().then(async te=>await ee.data.handler().finally(()=>te()))}),implementation.addEventListener("requestWriteLock",async ee=>{mutexes[ee.data.name]!=null&&mutexes[ee.data.name].writeLock().then(async te=>await ee.data.handler().finally(()=>te()))}))),mutexes[E.name]==null&&(mutexes[E.name]=createMutex(E.name,E)),mutexes[E.name]}const codes$5={ERR_INVALID_PARAMETERS:"ERR_INVALID_PARAMETERS"};var Peer$2;(function(J){(function(ee){let te;ee.codec=()=>(te==null&&(te=message((re,ne,ie={})=>{ie.lengthDelimited!==!1&&ne.fork(),re.key!=null&&re.key!==""&&(ne.uint32(10),ne.string(re.key)),re.value!=null&&re.value.byteLength>0&&(ne.uint32(18),ne.bytes(re.value)),ie.lengthDelimited!==!1&&ne.ldelim()},(re,ne)=>{const ie={key:"",value:new Uint8Array(0)},se=ne==null?re.len:re.pos+ne;for(;re.pos<se;){const oe=re.uint32();switch(oe>>>3){case 1:ie.key=re.string();break;case 2:ie.value=re.bytes();break;default:re.skipType(oe&7);break}}return ie})),te),ee.encode=re=>encodeMessage(re,ee.codec()),ee.decode=re=>decodeMessage$1(re,ee.codec())})(J.Peer$metadataEntry||(J.Peer$metadataEntry={})),function(ee){let te;ee.codec=()=>(te==null&&(te=message((re,ne,ie={})=>{ie.lengthDelimited!==!1&&ne.fork(),re.key!=null&&re.key!==""&&(ne.uint32(10),ne.string(re.key)),re.value!=null&&(ne.uint32(18),Tag.codec().encode(re.value,ne)),ie.lengthDelimited!==!1&&ne.ldelim()},(re,ne)=>{const ie={key:""},se=ne==null?re.len:re.pos+ne;for(;re.pos<se;){const oe=re.uint32();switch(oe>>>3){case 1:ie.key=re.string();break;case 2:ie.value=Tag.codec().decode(re,re.uint32());break;default:re.skipType(oe&7);break}}return ie})),te),ee.encode=re=>encodeMessage(re,ee.codec()),ee.decode=re=>decodeMessage$1(re,ee.codec())}(J.Peer$tagsEntry||(J.Peer$tagsEntry={}));let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{if(re.lengthDelimited!==!1&&te.fork(),ee.addresses!=null)for(const ne of ee.addresses)te.uint32(10),Address.codec().encode(ne,te);if(ee.protocols!=null)for(const ne of ee.protocols)te.uint32(18),te.string(ne);if(ee.publicKey!=null&&(te.uint32(34),te.bytes(ee.publicKey)),ee.peerRecordEnvelope!=null&&(te.uint32(42),te.bytes(ee.peerRecordEnvelope)),ee.metadata!=null&&ee.metadata.size!==0)for(const[ne,ie]of ee.metadata.entries())te.uint32(50),J.Peer$metadataEntry.codec().encode({key:ne,value:ie},te);if(ee.tags!=null&&ee.tags.size!==0)for(const[ne,ie]of ee.tags.entries())te.uint32(58),J.Peer$tagsEntry.codec().encode({key:ne,value:ie},te);re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={addresses:[],protocols:[],metadata:new Map,tags:new Map},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.addresses.push(Address.codec().decode(ee,ee.uint32()));break;case 2:re.protocols.push(ee.string());break;case 4:re.publicKey=ee.bytes();break;case 5:re.peerRecordEnvelope=ee.bytes();break;case 6:{const se=J.Peer$metadataEntry.codec().decode(ee,ee.uint32());re.metadata.set(se.key,se.value);break}case 7:{const se=J.Peer$tagsEntry.codec().decode(ee,ee.uint32());re.tags.set(se.key,se.value);break}default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage$1(ee,J.codec())})(Peer$2||(Peer$2={}));var Address;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{re.lengthDelimited!==!1&&te.fork(),ee.multiaddr!=null&&ee.multiaddr.byteLength>0&&(te.uint32(10),te.bytes(ee.multiaddr)),ee.isCertified!=null&&(te.uint32(16),te.bool(ee.isCertified)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={multiaddr:new Uint8Array(0)},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.multiaddr=ee.bytes();break;case 2:re.isCertified=ee.bool();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage$1(ee,J.codec())})(Address||(Address={}));var Tag;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{re.lengthDelimited!==!1&&te.fork(),ee.value!=null&&ee.value!==0&&(te.uint32(8),te.uint32(ee.value)),ee.expiry!=null&&(te.uint32(16),te.uint64(ee.expiry)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={value:0},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.value=ee.uint32();break;case 2:re.expiry=ee.uint64();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage$1(ee,J.codec())})(Tag||(Tag={}));var PeerIdProto;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{re.lengthDelimited!==!1&&te.fork(),ee.id!=null&&(te.uint32(10),te.bytes(ee.id)),ee.pubKey!=null&&(te.uint32(18),te.bytes(ee.pubKey)),ee.privKey!=null&&(te.uint32(26),te.bytes(ee.privKey)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.id=ee.bytes();break;case 2:re.pubKey=ee.bytes();break;case 3:re.privKey=ee.bytes();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage$1(ee,J.codec())})(PeerIdProto||(PeerIdProto={}));const createEd25519PeerId=async()=>{const J=await generateKeyPair("Ed25519"),E=await createFromPrivKey(J);if(E.type==="Ed25519")return E;throw new Error(`Generated unexpected PeerId type "${E.type}"`)};async function createFromPubKey(J){return await peerIdFromKeys(marshalPublicKey(J))}async function createFromPrivKey(J){return await peerIdFromKeys(marshalPublicKey(J.public),marshalPrivateKey(J))}async function bytesToPeer(J,E){const ee=Peer$2.decode(E);ee.publicKey!=null&&J.publicKey==null&&(J=await createFromPubKey(unmarshalPublicKey(ee.publicKey)));const te=new Map,re=BigInt(Date.now());for(const[ne,ie]of ee.tags.entries())ie.expiry!=null&&ie.expiry<re||te.set(ne,ie);return{...ee,id:J,addresses:ee.addresses.map(({multiaddr:ne,isCertified:ie})=>({multiaddr:multiaddr(ne),isCertified:ie??!1})),metadata:ee.metadata,peerRecordEnvelope:ee.peerRecordEnvelope??void 0,tags:te}}const NAMESPACE_COMMON="/peers/";function peerIdToDatastoreKey(J){if(!isPeerId(J)||J.type==null)throw new CodeError("Invalid PeerId",codes$5.ERR_INVALID_PARAMETERS);const E=J.toCID().toString();return new Key(`${NAMESPACE_COMMON}${E}`)}async function dedupeFilterAndSortAddresses(J,E,ee){const te=new Map;for(const re of ee){if(re==null)continue;if(re.multiaddr instanceof Uint8Array&&(re.multiaddr=multiaddr(re.multiaddr)),!isMultiaddr(re.multiaddr))throw new CodeError("Multiaddr was invalid",codes$5.ERR_INVALID_PARAMETERS);if(!await E(J,re.multiaddr))continue;const ne=re.isCertified??!1,ie=re.multiaddr.toString(),se=te.get(ie);se!=null?re.isCertified=se.isCertified||ne:te.set(ie,{multiaddr:re.multiaddr,isCertified:ne})}return[...te.values()].sort((re,ne)=>re.multiaddr.toString().localeCompare(ne.multiaddr.toString())).map(({isCertified:re,multiaddr:ne})=>({isCertified:re,multiaddr:ne.bytes}))}async function toPeerPB(J,E,ee,te){if(E==null)throw new CodeError("Invalid PeerData",codes$5.ERR_INVALID_PARAMETERS);if(E.publicKey!=null&&J.publicKey!=null&&!equals(E.publicKey,J.publicKey))throw new CodeError("publicKey bytes do not match peer id publicKey bytes",codes$5.ERR_INVALID_PARAMETERS);const re=te.existingPeer;if(re!=null&&!J.equals(re.id))throw new CodeError("peer id did not match existing peer id",codes$5.ERR_INVALID_PARAMETERS);let ne=re?.addresses??[],ie=new Set(re?.protocols??[]),se=re?.metadata??new Map,oe=re?.tags??new Map,ce=re?.peerRecordEnvelope;if(ee==="patch"){if((E.multiaddrs!=null||E.addresses!=null)&&(ne=[],E.multiaddrs!=null&&ne.push(...E.multiaddrs.map(le=>({isCertified:!1,multiaddr:le}))),E.addresses!=null&&ne.push(...E.addresses)),E.protocols!=null&&(ie=new Set(E.protocols)),E.metadata!=null){const le=E.metadata instanceof Map?[...E.metadata.entries()]:Object.entries(E.metadata);se=createSortedMap(le,{validate:validateMetadata})}if(E.tags!=null){const le=E.tags instanceof Map?[...E.tags.entries()]:Object.entries(E.tags);oe=createSortedMap(le,{validate:validateTag,map:mapTag})}E.peerRecordEnvelope!=null&&(ce=E.peerRecordEnvelope)}if(ee==="merge"){if(E.multiaddrs!=null&&ne.push(...E.multiaddrs.map(le=>({isCertified:!1,multiaddr:le}))),E.addresses!=null&&ne.push(...E.addresses),E.protocols!=null&&(ie=new Set([...ie,...E.protocols])),E.metadata!=null){const le=E.metadata instanceof Map?[...E.metadata.entries()]:Object.entries(E.metadata);for(const[ue,he]of le)he==null?se.delete(ue):se.set(ue,he);se=createSortedMap([...se.entries()],{validate:validateMetadata})}if(E.tags!=null){const le=E.tags instanceof Map?[...E.tags.entries()]:Object.entries(E.tags),ue=new Map(oe);for(const[he,pe]of le)pe==null?ue.delete(he):ue.set(he,pe);oe=createSortedMap([...ue.entries()],{validate:validateTag,map:mapTag})}E.peerRecordEnvelope!=null&&(ce=E.peerRecordEnvelope)}const ae={addresses:await dedupeFilterAndSortAddresses(J,te.addressFilter??(async()=>!0),ne),protocols:[...ie.values()].sort((le,ue)=>le.localeCompare(ue)),metadata:se,tags:oe,publicKey:re?.id.publicKey??E.publicKey??J.publicKey,peerRecordEnvelope:ce};return J.type!=="RSA"&&delete ae.publicKey,ae}function createSortedMap(J,E){const ee=new Map;for(const[te,re]of J)re!=null&&E.validate(te,re);for(const[te,re]of J.sort(([ne],[ie])=>ne.localeCompare(ie)))re!=null&&ee.set(te,E.map?.(te,re)??re);return ee}function validateMetadata(J,E){if(typeof J!="string")throw new CodeError("Metadata key must be a string",codes$5.ERR_INVALID_PARAMETERS);if(!(E instanceof Uint8Array))throw new CodeError("Metadata value must be a Uint8Array",codes$5.ERR_INVALID_PARAMETERS)}function validateTag(J,E){if(typeof J!="string")throw new CodeError("Tag name must be a string",codes$5.ERR_INVALID_PARAMETERS);if(E.value!=null){if(parseInt(`${E.value}`,10)!==E.value)throw new CodeError("Tag value must be an integer",codes$5.ERR_INVALID_PARAMETERS);if(E.value<0||E.value>100)throw new CodeError("Tag value must be between 0-100",codes$5.ERR_INVALID_PARAMETERS)}if(E.ttl!=null){if(parseInt(`${E.ttl}`,10)!==E.ttl)throw new CodeError("Tag ttl must be an integer",codes$5.ERR_INVALID_PARAMETERS);if(E.ttl<0)throw new CodeError("Tag ttl must be between greater than 0",codes$5.ERR_INVALID_PARAMETERS)}}function mapTag(J,E){let ee;return E.expiry!=null&&(ee=E.expiry),E.ttl!=null&&(ee=BigInt(Date.now()+Number(E.ttl))),{value:E.value??0,expiry:ee}}class PersistentStore{peerId;datastore;lock;addressFilter;constructor(E,ee={}){this.peerId=E.peerId,this.datastore=E.datastore,this.addressFilter=ee.addressFilter,this.lock=createMortice({name:"peer-store",singleProcess:!0})}async has(E){return this.datastore.has(peerIdToDatastoreKey(E))}async delete(E){if(this.peerId.equals(E))throw new CodeError("Cannot delete self peer",codes$5.ERR_INVALID_PARAMETERS);await this.datastore.delete(peerIdToDatastoreKey(E))}async load(E){const ee=await this.datastore.get(peerIdToDatastoreKey(E));return bytesToPeer(E,ee)}async save(E,ee){const{existingBuf:te,existingPeer:re}=await this.#e(E),ne=await toPeerPB(E,ee,"patch",{addressFilter:this.addressFilter});return this.#t(E,ne,te,re)}async patch(E,ee){const{existingBuf:te,existingPeer:re}=await this.#e(E),ne=await toPeerPB(E,ee,"patch",{addressFilter:this.addressFilter,existingPeer:re});return this.#t(E,ne,te,re)}async merge(E,ee){const{existingBuf:te,existingPeer:re}=await this.#e(E),ne=await toPeerPB(E,ee,"merge",{addressFilter:this.addressFilter,existingPeer:re});return this.#t(E,ne,te,re)}async*all(){for await(const{key:E,value:ee}of this.datastore.query({prefix:NAMESPACE_COMMON})){const te=E.toString().split("/")[2],re=base32$2.decode(te),ne=peerIdFromBytes(re);ne.equals(this.peerId)||(yield bytesToPeer(ne,ee))}}async#e(E){try{const ee=await this.datastore.get(peerIdToDatastoreKey(E)),te=await bytesToPeer(E,ee);return{existingBuf:ee,existingPeer:te}}catch(ee){if(ee.code!=="ERR_NOT_FOUND")throw ee}return{}}async#t(E,ee,te,re){const ne=Peer$2.encode(ee);return te!=null&&equals(ne,te)?{peer:await bytesToPeer(E,ne),previous:re,updated:!1}:(await this.datastore.put(peerIdToDatastoreKey(E),ne),{peer:await bytesToPeer(E,ne),previous:re,updated:!0})}}const log$19=logger$1("libp2p:peer-store");class PersistentPeerStore{store;events;peerId;constructor(E,ee={}){this.events=E.events,this.peerId=E.peerId,this.store=new PersistentStore(E,ee)}async forEach(E){log$19.trace("forEach await read lock");const ee=await this.store.lock.readLock();log$19.trace("forEach got read lock");try{for await(const te of this.store.all())E(te)}finally{log$19.trace("forEach release read lock"),ee()}}async all(){log$19.trace("all await read lock");const E=await this.store.lock.readLock();log$19.trace("all got read lock");try{const ee=[];for await(const te of this.store.all())ee.push(te);return ee}finally{log$19.trace("all release read lock"),E()}}async delete(E){log$19.trace("delete await write lock");const ee=await this.store.lock.writeLock();log$19.trace("delete got write lock");try{await this.store.delete(E)}finally{log$19.trace("delete release write lock"),ee()}}async has(E){log$19.trace("has await read lock");const ee=await this.store.lock.readLock();log$19.trace("has got read lock");try{return await this.store.has(E)}finally{log$19.trace("has release read lock"),ee()}}async get(E){log$19.trace("get await read lock");const ee=await this.store.lock.readLock();log$19.trace("get got read lock");try{return await this.store.load(E)}finally{log$19.trace("get release read lock"),ee()}}async save(E,ee){log$19.trace("save await write lock");const te=await this.store.lock.writeLock();log$19.trace("save got write lock");try{const re=await this.store.save(E,ee);return this.#e(E,re),re.peer}finally{log$19.trace("save release write lock"),te()}}async patch(E,ee){log$19.trace("patch await write lock");const te=await this.store.lock.writeLock();log$19.trace("patch got write lock");try{const re=await this.store.patch(E,ee);return this.#e(E,re),re.peer}finally{log$19.trace("patch release write lock"),te()}}async merge(E,ee){log$19.trace("merge await write lock");const te=await this.store.lock.writeLock();log$19.trace("merge got write lock");try{const re=await this.store.merge(E,ee);return this.#e(E,re),re.peer}finally{log$19.trace("merge release write lock"),te()}}async consumePeerRecord(E,ee){const te=await RecordEnvelope.openAndCertify(E,PeerRecord.DOMAIN);if(ee?.equals(te.peerId)===!1)return log$19("envelope peer id was not the expected peer id - expected: %p received: %p",ee,te.peerId),!1;const re=PeerRecord.createFromProtobuf(te.payload);let ne;try{ne=await this.get(te.peerId)}catch(ie){if(ie.code!=="ERR_NOT_FOUND")throw ie}if(ne?.peerRecordEnvelope!=null){const ie=await RecordEnvelope.createFromProtobuf(ne.peerRecordEnvelope),se=PeerRecord.createFromProtobuf(ie.payload);if(se.seqNumber>=re.seqNumber)return log$19("sequence number was lower or equal to existing sequence number - stored: %d received: %d",se.seqNumber,re.seqNumber),!1}return await this.patch(re.peerId,{peerRecordEnvelope:E,addresses:re.multiaddrs.map(ie=>({isCertified:!0,multiaddr:ie}))}),!0}#e(E,ee){ee.updated&&(this.peerId.equals(E)?this.events.safeDispatchEvent("self:peer:update",{detail:ee}):this.events.safeDispatchEvent("peer:update",{detail:ee}))}}function isStartable(J){return J!=null&&typeof J.start=="function"&&typeof J.stop=="function"}let DefaultComponents$1=class{constructor(J={}){this.components={},this._started=!1,this.components={};for(const[E,ee]of Object.entries(J))this.components[E]=ee}isStarted(){return this._started}async _invokeStartableMethod(J){await Promise.all(Object.values(this.components).filter(E=>isStartable(E)).map(async E=>{await E[J]?.()}))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}};const OPTIONAL_SERVICES$1=["metrics","connectionProtector"],NON_SERVICE_PROPERTIES$1=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function defaultComponents$1(J={}){const E=new DefaultComponents$1(J);return new Proxy(E,{get(ee,te,re){if(typeof te=="string"&&!NON_SERVICE_PROPERTIES$1.includes(te)){const ne=E.components[te];if(ne==null&&!OPTIONAL_SERVICES$1.includes(te))throw new CodeError(`${te} not set`,"ERR_SERVICE_MISSING");return ne}return Reflect.get(ee,te,re)},set(ee,te,re){return typeof te=="string"?E.components[te]=re:Reflect.set(ee,te,re),!0}})}const DefaultConfig$1={addresses:{listen:[],announce:[],noAnnounce:[],announceFilter:J=>J},connectionManager:{resolvers:{dnsaddr:dnsaddrResolver},addressSorter:publicAddressesFirst},transportManager:{faultTolerance:FaultTolerance.FATAL_ALL}};function validateConfig$1(J){const E=mergeOptions$9(DefaultConfig$1,J);if(E.transports==null||E.transports.length<1)throw new CodeError(messages$1.ERR_TRANSPORTS_REQUIRED,codes$8.ERR_TRANSPORTS_REQUIRED);if(E.connectionEncryption==null||E.connectionEncryption.length===0)throw new CodeError(messages$1.CONN_ENCRYPTION_REQUIRED,codes$8.CONN_ENCRYPTION_REQUIRED);if(E.connectionProtector===null&&globalThis.process?.env?.LIBP2P_FORCE_PNET!=null)throw new CodeError(messages$1.ERR_PROTECTOR_REQUIRED,codes$8.ERR_PROTECTOR_REQUIRED);return E}const contentRouting=Symbol.for("@libp2p/content-routing"),peerRouting=Symbol.for("@libp2p/peer-routing"),peerDiscovery=Symbol.for("@libp2p/peer-discovery");function connectionGater$1(J={}){return{denyDialPeer:async()=>!1,denyDialMultiaddr:async E=>{const ee=E.stringTuples();return ee[0][0]===4||ee[0][0]===41?!!is_ip_private(`${ee[0][1]}`):!1},denyInboundConnection:async()=>!1,denyOutboundConnection:async()=>!1,denyInboundEncryptedConnection:async()=>!1,denyOutboundEncryptedConnection:async()=>!1,denyInboundUpgradedConnection:async()=>!1,denyOutboundUpgradedConnection:async()=>!1,filterMultiaddrForPeer:async()=>!0,...J}}var __classPrivateFieldSet=globalThis&&globalThis.__classPrivateFieldSet||function(J,E,ee,te,re){if(te==="m")throw new TypeError("Private method is not writable");if(te==="a"&&!re)throw new TypeError("Private accessor was defined without a setter");if(typeof E=="function"?J!==E||!re:!E.has(J))throw new TypeError("Cannot write private member to an object whose class did not declare it");return te==="a"?re.call(J,ee):re?re.value=ee:E.set(J,ee),ee},__classPrivateFieldGet$3=globalThis&&globalThis.__classPrivateFieldGet||function(J,E,ee,te){if(ee==="a"&&!te)throw new TypeError("Private accessor was defined without a getter");if(typeof E=="function"?J!==E||!te:!E.has(J))throw new TypeError("Cannot read private member from an object whose class did not declare it");return ee==="m"?te:ee==="a"?te.call(J):te?te.value:E.get(J)},_Libp2pNode_instances,_Libp2pNode_started,_Libp2pNode_onDiscoveryPeer;const log$18=logger$1("libp2p");let Libp2pNode$1=class extends EventEmitter$3{constructor(J){super(),_Libp2pNode_instances.add(this),_Libp2pNode_started.set(this,void 0);const E=new EventEmitter$3,ee=E.dispatchEvent.bind(E);E.dispatchEvent=se=>{const oe=ee(se),ce=this.dispatchEvent(new CustomEvent$2(se.type,{detail:se.detail}));return oe||ce};try{setMaxListeners?.(1/0,E)}catch{}__classPrivateFieldSet(this,_Libp2pNode_started,!1,"f"),this.peerId=J.peerId,this.services={};const te=this.components=defaultComponents$1({peerId:J.peerId,events:E,datastore:J.datastore??new MemoryDatastore,connectionGater:connectionGater$1(J.connectionGater)});this.peerStore=this.configureComponent("peerStore",new PersistentPeerStore(te,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...J.peerStore})),J.metrics!=null&&(this.metrics=this.configureComponent("metrics",J.metrics(this.components))),te.events.addEventListener("peer:update",se=>{se.detail.previous==null&&this.safeDispatchEvent("peer:discovery",{detail:se.detail.peer})}),J.connectionProtector!=null&&this.configureComponent("connectionProtector",J.connectionProtector(te)),this.components.upgrader=new DefaultUpgrader$1(this.components,{connectionEncryption:(J.connectionEncryption??[]).map((se,oe)=>this.configureComponent(`connection-encryption-${oe}`,se(this.components))),muxers:(J.streamMuxers??[]).map((se,oe)=>this.configureComponent(`stream-muxers-${oe}`,se(this.components))),inboundUpgradeTimeout:J.connectionManager.inboundUpgradeTimeout}),this.configureComponent("transportManager",new DefaultTransportManager$1(this.components,J.transportManager)),this.configureComponent("connectionManager",new DefaultConnectionManager$1(this.components,J.connectionManager)),this.configureComponent("registrar",new DefaultRegistrar$1(this.components)),this.configureComponent("addressManager",new DefaultAddressManager$1(this.components,J.addresses));const re=DefaultKeyChain.generateOptions();this.keychain=this.configureComponent("keyChain",new DefaultKeyChain(this.components,{...re,...J.keychain}));const ne=(J.peerRouters??[]).map((se,oe)=>this.configureComponent(`peer-router-${oe}`,se(this.components)));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new DefaultPeerRouting$1(this.components,{routers:ne}));const ie=(J.contentRouters??[]).map((se,oe)=>this.configureComponent(`content-router-${oe}`,se(this.components)));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new CompoundContentRouting$1(this.components,{routers:ie})),(J.peerDiscovery??[]).forEach((se,oe)=>{this.configureComponent(`peer-discovery-${oe}`,se(this.components)).addEventListener("peer",ce=>{__classPrivateFieldGet$3(this,_Libp2pNode_instances,"m",_Libp2pNode_onDiscoveryPeer).call(this,ce)})}),J.transports.forEach((se,oe)=>{this.components.transportManager.add(this.configureComponent(`transport-${oe}`,se(this.components)))}),J.services!=null)for(const se of Object.keys(J.services)){const oe=J.services[se],ce=oe(this.components);if(ce==null){log$18.error("service factory %s returned null or undefined instance",se);continue}this.services[se]=ce,this.configureComponent(se,ce),ce[contentRouting]!=null&&(log$18("registering service %s for content routing",se),ie.push(ce[contentRouting])),ce[peerRouting]!=null&&(log$18("registering service %s for peer routing",se),ne.push(ce[peerRouting])),ce[peerDiscovery]!=null&&(log$18("registering service %s for peer discovery",se),ce[peerDiscovery].addEventListener("peer",ae=>{__classPrivateFieldGet$3(this,_Libp2pNode_instances,"m",_Libp2pNode_onDiscoveryPeer).call(this,ae)}))}}configureComponent(J,E){return E==null&&log$18.error("component %s was null or undefined",J),this.components[J]=E,E}async start(){if(!__classPrivateFieldGet$3(this,_Libp2pNode_started,"f")){__classPrivateFieldSet(this,_Libp2pNode_started,!0,"f"),log$18("libp2p is starting"),(await this.keychain.listKeys()).find(J=>J.name==="self")==null&&(log$18("importing self key into keychain"),await this.keychain.importPeer("self",this.components.peerId));try{await this.components.beforeStart?.(),await this.components.start(),await this.components.afterStart?.(),log$18("libp2p has started")}catch(J){throw log$18.error("An error occurred starting libp2p",J),await this.stop(),J}}}async stop(){__classPrivateFieldGet$3(this,_Libp2pNode_started,"f")&&(log$18("libp2p is stopping"),__classPrivateFieldSet(this,_Libp2pNode_started,!1,"f"),await this.components.beforeStop?.(),await this.components.stop(),await this.components.afterStop?.(),log$18("libp2p has stopped"))}isStarted(){return __classPrivateFieldGet$3(this,_Libp2pNode_started,"f")}getConnections(J){return this.components.connectionManager.getConnections(J)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const J=new PeerSet;for(const E of this.components.connectionManager.getConnections())J.add(E.remotePeer);return Array.from(J)}async dial(J,E={}){return await this.components.connectionManager.openConnection(J,E)}async dialProtocol(J,E,ee={}){if(E==null)throw new CodeError("no protocols were provided to open a stream",codes$8.ERR_INVALID_PROTOCOLS_FOR_STREAM);if(E=Array.isArray(E)?E:[E],E.length===0)throw new CodeError("no protocols were provided to open a stream",codes$8.ERR_INVALID_PROTOCOLS_FOR_STREAM);return await(await this.dial(J,ee)).newStream(E,ee)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(J){isMultiaddr(J)&&(J=peerIdFromString(J.getPeerId()??"")),await this.components.connectionManager.closeConnections(J)}async getPublicKey(J,E={}){if(log$18("getPublicKey %p",J),J.publicKey!=null)return J.publicKey;const ee=await this.peerStore.get(J);if(ee.id.publicKey!=null)return ee.id.publicKey;const te=concat$4([fromString$5("/pk/"),J.multihash.digest]),re=await this.contentRouting.get(te,E);return unmarshalPublicKey(re),await this.peerStore.patch(J,{publicKey:re}),re}async handle(J,E,ee){Array.isArray(J)||(J=[J]),await Promise.all(J.map(async te=>{await this.components.registrar.handle(te,E,ee)}))}async unhandle(J){Array.isArray(J)||(J=[J]),await Promise.all(J.map(async E=>{await this.components.registrar.unhandle(E)}))}async register(J,E){return await this.components.registrar.register(J,E)}unregister(J){this.components.registrar.unregister(J)}};_Libp2pNode_started=new WeakMap,_Libp2pNode_instances=new WeakSet,_Libp2pNode_onDiscoveryPeer=function J(E){const{detail:ee}=E;if(ee.id.toString()===this.peerId.toString()){log$18.error(new Error(codes$8.ERR_DISCOVERED_SELF));return}this.components.peerStore.merge(ee.id,{multiaddrs:ee.multiaddrs,protocols:ee.protocols}).catch(te=>{log$18.error(te)})};async function createLibp2pNode$1(J){if(J.peerId==null){const E=J.datastore;if(E!=null)try{const ee=new DefaultKeyChain({datastore:E},mergeOptions$9(DefaultKeyChain.generateOptions(),J.keychain));J.peerId=await ee.exportPeerId("self")}catch(ee){if(ee.code!=="ERR_NOT_FOUND")throw ee}}return J.peerId==null&&(J.peerId=await createEd25519PeerId()),new Libp2pNode$1(validateConfig$1(J))}async function createLibp2p$2(J){const E=await createLibp2pNode$1(J);return J.start!==!1&&await E.start(),E}const DNS4=base$3("dns4"),DNS6=base$3("dns6"),DNSADDR=base$3("dnsaddr"),DNS=or$1(base$3("dns"),DNSADDR,DNS4,DNS6),IP=or$1(base$3("ip4"),base$3("ip6")),TCP$1=or$1(and(IP,base$3("tcp")),and(DNS,base$3("tcp"))),UDP=and(IP,base$3("udp")),UTP=and(UDP,base$3("utp")),QUIC=and(UDP,base$3("quic")),QUICV1=and(UDP,base$3("quic-v1")),WebSockets$1=or$1(and(TCP$1,base$3("ws")),and(DNS,base$3("ws"))),WebSocketsSecure=or$1(and(TCP$1,base$3("wss")),and(DNS,base$3("wss")),and(TCP$1,base$3("tls"),base$3("ws")),and(DNS,base$3("tls"),base$3("ws"))),HTTP=or$1(and(TCP$1,base$3("http")),and(IP,base$3("http")),and(DNS,base$3("http"))),HTTPS=or$1(and(TCP$1,base$3("https")),and(IP,base$3("https")),and(DNS,base$3("https"))),_WebRTCDirect=and(UDP,base$3("webrtc-direct"),base$3("certhash")),WebRTCDirect=or$1(and(_WebRTCDirect,base$3("p2p")),_WebRTCDirect),_WebTransport=and(QUICV1,base$3("webtransport"),base$3("certhash"),base$3("certhash")),WebTransport$1=or$1(and(_WebTransport,base$3("p2p")),_WebTransport),P2PWebRTCStar=or$1(and(WebSockets$1,base$3("p2p-webrtc-star"),base$3("p2p")),and(WebSocketsSecure,base$3("p2p-webrtc-star"),base$3("p2p")),and(WebSockets$1,base$3("p2p-webrtc-star")),and(WebSocketsSecure,base$3("p2p-webrtc-star"))),P2PWebRTCDirect=or$1(and(HTTP,base$3("p2p-webrtc-direct"),base$3("p2p")),and(HTTPS,base$3("p2p-webrtc-direct"),base$3("p2p")),and(HTTP,base$3("p2p-webrtc-direct")),and(HTTPS,base$3("p2p-webrtc-direct"))),Reliable=or$1(WebSockets$1,WebSocketsSecure,HTTP,HTTPS,P2PWebRTCStar,P2PWebRTCDirect,TCP$1,UTP,QUIC,DNS,WebRTCDirect,WebTransport$1),_P2P=or$1(and(Reliable,base$3("p2p")),P2PWebRTCStar,P2PWebRTCDirect,WebRTCDirect,WebTransport$1,base$3("p2p")),_Circuit=or$1(and(_P2P,base$3("p2p-circuit"),_P2P),and(_P2P,base$3("p2p-circuit")),and(base$3("p2p-circuit"),_P2P),and(Reliable,base$3("p2p-circuit")),and(base$3("p2p-circuit"),Reliable),base$3("p2p-circuit")),CircuitRecursive=()=>or$1(and(_Circuit,CircuitRecursive),_Circuit),Circuit=CircuitRecursive(),P2P=or$1(and(Circuit,_P2P,Circuit),and(_P2P,Circuit),and(Circuit,_P2P),Circuit,_P2P);function makeMatchesFunction(J){function E(ee){let te;try{te=multiaddr(ee)}catch{return!1}const re=J(te.protoNames());return re===null?!1:re===!0||re===!1?re:re.length===0}return E}function and(...J){function E(ee){if(ee.length<J.length)return null;let te=ee;return J.some(re=>(te=typeof re=="function"?re().partialMatch(ee):re.partialMatch(ee),Array.isArray(te)&&(ee=te),te===null)),te}return{toString:function(){return"{ "+J.join(" ")+" }"},input:J,matches:makeMatchesFunction(E),partialMatch:E}}function or$1(...J){function E(ee){let te=null;return J.some(re=>{const ne=typeof re=="function"?re().partialMatch(ee):re.partialMatch(ee);return ne!=null?(te=ne,!0):!1}),te}return{toString:function(){return"{ "+J.join(" ")+" }"},input:J,matches:makeMatchesFunction(E),partialMatch:E}}function base$3(J){const E=J;function ee(re){let ne;try{ne=multiaddr(re)}catch{return!1}const ie=ne.protoNames();return ie.length===1&&ie[0]===E}function te(re){return re.length===0?null:re[0]===E?re.slice(1):null}return{toString:function(){return E},matches:ee,partialMatch:te}}const log$17=logger$1("libp2p:bootstrap"),DEFAULT_BOOTSTRAP_TAG_NAME="bootstrap",DEFAULT_BOOTSTRAP_TAG_VALUE=50,DEFAULT_BOOTSTRAP_TAG_TTL=12e4,DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT=1e3;class Bootstrap extends EventEmitter$3{static tag="bootstrap";timer;list;timeout;components;_init;constructor(E,ee={list:[]}){if(ee.list==null||ee.list.length===0)throw new Error("Bootstrap requires a list of peer addresses");super(),this.components=E,this.timeout=ee.timeout??DEFAULT_BOOTSTRAP_DISCOVERY_TIMEOUT,this.list=[];for(const te of ee.list){if(!P2P.matches(te)){log$17.error("Invalid multiaddr");continue}const re=multiaddr(te),ne=re.getPeerId();if(ne==null){log$17.error("Invalid bootstrap multiaddr without peer id");continue}const ie={id:peerIdFromString(ne),multiaddrs:[re],protocols:[]};this.list.push(ie)}this._init=ee}[peerDiscovery]=this;[Symbol.toStringTag]="@libp2p/bootstrap";isStarted(){return!!this.timer}start(){this.isStarted()||(log$17("Starting bootstrap node discovery, discovering peers after %s ms",this.timeout),this.timer=setTimeout(()=>{this._discoverBootstrapPeers().catch(E=>{log$17.error(E)})},this.timeout))}async _discoverBootstrapPeers(){if(this.timer!=null)for(const E of this.list){if(await this.components.peerStore.merge(E.id,{tags:{[this._init.tagName??DEFAULT_BOOTSTRAP_TAG_NAME]:{value:this._init.tagValue??DEFAULT_BOOTSTRAP_TAG_VALUE,ttl:this._init.tagTTL??DEFAULT_BOOTSTRAP_TAG_TTL}}}),this.timer==null)return;this.safeDispatchEvent("peer",{detail:E})}}stop(){this.timer!=null&&clearTimeout(this.timer),this.timer=void 0}}function bootstrap(J){return E=>new Bootstrap(E,J)}class AbortError extends Error{constructor(E,ee){super(E??"The operation was aborted"),this.type="aborted",this.code=ee??"ABORT_ERR"}}function abortableSource(J,E,ee){const te=ee??{},re=getIterator(J);async function*ne(){let ie;const se=()=>{ie?.()};for(E.addEventListener("abort",se);;){let oe;try{if(E.aborted){const{abortMessage:ae,abortCode:le}=te;throw new AbortError(ae,le)}const ce=new Promise((ae,le)=>{ie=()=>{const{abortMessage:ue,abortCode:he}=te;le(new AbortError(ue,he))}});oe=await Promise.race([ce,re.next()]),ie=null}catch(ce){E.removeEventListener("abort",se);const ae=ce.type==="aborted"&&E.aborted;if(ae&&te.onAbort!=null&&await te.onAbort(J),typeof re.return=="function")try{const le=re.return();le instanceof Promise&&le.catch(ue=>{te.onReturnError!=null&&te.onReturnError(ue)})}catch(le){te.onReturnError!=null&&te.onReturnError(le)}if(ae&&te.returnOnAbort===!0)return;throw ce}if(oe.done===!0)break;yield oe.value}E.removeEventListener("abort",se)}return ne()}var FrameType$1;(function(J){J[J.Data=0]="Data",J[J.WindowUpdate=1]="WindowUpdate",J[J.Ping=2]="Ping",J[J.GoAway=3]="GoAway"})(FrameType$1||(FrameType$1={}));var Flag$1;(function(J){J[J.SYN=1]="SYN",J[J.ACK=2]="ACK",J[J.FIN=4]="FIN",J[J.RST=8]="RST"})(Flag$1||(Flag$1={}));const flagCodes$1=Object.values(Flag$1).filter(J=>typeof J!="string"),YAMUX_VERSION$1=0;var GoAwayCode$1;(function(J){J[J.NormalTermination=0]="NormalTermination",J[J.ProtocolError=1]="ProtocolError",J[J.InternalError=2]="InternalError"})(GoAwayCode$1||(GoAwayCode$1={}));const HEADER_LENGTH$1=12;function stringifyHeader$1(J){const E=flagCodes$1.filter(ee=>(J.flag&ee)===ee).map(ee=>Flag$1[ee]).join("|");return`streamID=${J.streamID} type=${FrameType$1[J.type]} flag=${E} length=${J.length}`}const ERR_INVALID_FRAME$1="ERR_INVALID_FRAME",ERR_UNREQUESTED_PING$1="ERR_UNREQUESTED_PING",ERR_NOT_MATCHING_PING$1="ERR_NOT_MATCHING_PING",ERR_STREAM_ALREADY_EXISTS$1="ERR_STREAM_ALREADY_EXISTS",ERR_DECODE_INVALID_VERSION$1="ERR_DECODE_INVALID_VERSION",ERR_BOTH_CLIENTS$1="ERR_BOTH_CLIENTS",ERR_RECV_WINDOW_EXCEEDED$1="ERR_RECV_WINDOW_EXCEEDED",PROTOCOL_ERRORS$1=new Set([ERR_INVALID_FRAME$1,ERR_UNREQUESTED_PING$1,ERR_NOT_MATCHING_PING$1,ERR_STREAM_ALREADY_EXISTS$1,ERR_DECODE_INVALID_VERSION$1,ERR_BOTH_CLIENTS$1,ERR_RECV_WINDOW_EXCEEDED$1]),ERR_INVALID_CONFIG$1="ERR_INVALID_CONFIG",ERR_MUXER_LOCAL_CLOSED$1="ERR_MUXER_LOCAL_CLOSED",ERR_MUXER_REMOTE_CLOSED$1="ERR_MUXER_REMOTE_CLOSED",ERR_STREAM_RESET$3="ERR_STREAM_RESET",ERR_STREAM_ABORT$3="ERR_STREAM_ABORT",ERR_MAX_OUTBOUND_STREAMS_EXCEEDED$1="ERROR_MAX_OUTBOUND_STREAMS_EXCEEDED",ERR_DECODE_IN_PROGRESS$1="ERR_DECODE_IN_PROGRESS",INITIAL_STREAM_WINDOW$1=256*1024,MAX_STREAM_WINDOW$1=16*1024*1024;var StreamState$2;(function(J){J[J.Init=0]="Init",J[J.SYNSent=1]="SYNSent",J[J.SYNReceived=2]="SYNReceived",J[J.Established=3]="Established",J[J.Finished=4]="Finished"})(StreamState$2||(StreamState$2={}));var HalfStreamState$1;(function(J){J[J.Open=0]="Open",J[J.Closed=1]="Closed",J[J.Reset=2]="Reset"})(HalfStreamState$1||(HalfStreamState$1={}));let YamuxStream$1=class{constructor(J){this.config=J.config,this.log=J.log,this._id=J.id,this.id=String(J.id),this.name=J.name,this.stat={direction:J.direction,timeline:{open:Date.now()}},this.metadata={},this.state=J.state,this.readState=HalfStreamState$1.Open,this.writeState=HalfStreamState$1.Open,this.sendWindowCapacity=INITIAL_STREAM_WINDOW$1,this.recvWindow=this.config.initialStreamWindowSize,this.recvWindowCapacity=this.recvWindow,this.epochStart=Date.now(),this.getRTT=J.getRTT,this.abortController=new AbortController,this.sendFrame=J.sendFrame,this.onStreamEnd=J.onStreamEnd,this.sourceInput=pushable({onEnd:E=>{E!=null?this.log?.error("stream source ended id=%s",this._id,E):this.log?.trace("stream source ended id=%s",this._id),this.closeRead()}}),this.source=this.createSource(),this.sink=async E=>{if(this.writeState!==HalfStreamState$1.Open)throw new Error("stream closed for writing");E=abortableSource(E,this.abortController.signal,{returnOnAbort:!0});try{for await(let ee of E)for(;ee.length!==0;){this.sendWindowCapacity===0&&await this.waitForSendWindowCapacity();const te=Math.min(this.sendWindowCapacity,this.config.maxMessageSize-HEADER_LENGTH$1,ee.length);this.sendData(ee.subarray(0,te)),this.sendWindowCapacity-=te,ee=ee.subarray(te)}}catch(ee){this.log?.error("stream sink error id=%s",this._id,ee)}finally{this.log?.trace("stream sink ended id=%s",this._id),this.closeWrite()}}}async*createSource(){try{for await(const J of this.sourceInput)this.sendWindowUpdate(),yield J}catch(J){if(J.code!==ERR_STREAM_ABORT$3)throw this.log?.error("stream source error id=%s",this._id,J),J}}close(){this.log?.trace("stream close id=%s",this._id),this.closeRead(),this.closeWrite()}closeRead(){this.state!==StreamState$2.Finished&&this.readState===HalfStreamState$1.Open&&(this.log?.trace("stream close read id=%s",this._id),this.readState=HalfStreamState$1.Closed,this.sourceInput.end(),this.writeState!==HalfStreamState$1.Open&&this.finish())}closeWrite(){this.state!==StreamState$2.Finished&&this.writeState===HalfStreamState$1.Open&&(this.log?.trace("stream close write id=%s",this._id),this.writeState=HalfStreamState$1.Closed,this.sendClose(),this.abortController.abort(),this.readState!==HalfStreamState$1.Open&&this.finish())}abort(J){switch(this.state){case StreamState$2.Finished:return;case StreamState$2.Init:break;case StreamState$2.SYNSent:case StreamState$2.SYNReceived:case StreamState$2.Established:this.sendReset();break;default:throw new Error("unreachable")}J!=null?this.log?.error("stream abort id=%s error=%s",this._id,J):this.log?.trace("stream abort id=%s",this._id),this.onReset(new CodeError(String(J)??"stream aborted",ERR_STREAM_ABORT$3))}reset(){this.state!==StreamState$2.Finished&&(this.log?.trace("stream reset id=%s",this._id),this.onReset(new CodeError("stream reset",ERR_STREAM_RESET$3)))}onReset(J){this.writeState===HalfStreamState$1.Open&&(this.writeState=HalfStreamState$1.Reset),this.readState===HalfStreamState$1.Open&&(this.readState=HalfStreamState$1.Reset),this.state=StreamState$2.Finished,this.sourceInput.end(J),this.abortController.abort(),this.finish()}async waitForSendWindowCapacity(){if(this.abortController.signal.aborted)throw new CodeError("stream aborted",ERR_STREAM_ABORT$3);if(this.sendWindowCapacity>0)return;let J;const E=()=>{J(new CodeError("stream aborted",ERR_STREAM_ABORT$3))};this.abortController.signal.addEventListener("abort",E),await new Promise((ee,te)=>{this.sendWindowCapacityUpdate=()=>{this.abortController.signal.removeEventListener("abort",E),ee(void 0)},J=te})}handleWindowUpdate(J){this.log?.trace("stream received window update id=%s",this._id),this.processFlags(J.flag);const E=this.sendWindowCapacity;this.sendWindowCapacity+=J.length,E===0&&J.length>0&&this.sendWindowCapacityUpdate?.()}async handleData(J,E){if(this.log?.trace("stream received data id=%s",this._id),this.processFlags(J.flag),this.recvWindowCapacity<J.length)throw new CodeError("receive window exceeded",ERR_RECV_WINDOW_EXCEEDED$1,{available:this.recvWindowCapacity,recv:J.length});const ee=await E();this.recvWindowCapacity-=J.length,this.sourceInput.push(ee)}processFlags(J){(J&Flag$1.ACK)===Flag$1.ACK&&this.state===StreamState$2.SYNSent&&(this.state=StreamState$2.Established),(J&Flag$1.FIN)===Flag$1.FIN&&this.closeRead(),(J&Flag$1.RST)===Flag$1.RST&&this.reset()}finish(){this.log?.trace("stream finished id=%s",this._id),this.state=StreamState$2.Finished,this.stat.timeline.close=Date.now(),this.onStreamEnd()}getSendFlags(){switch(this.state){case StreamState$2.Init:return this.state=StreamState$2.SYNSent,Flag$1.SYN;case StreamState$2.SYNReceived:return this.state=StreamState$2.Established,Flag$1.ACK;default:return 0}}sendWindowUpdate(){const J=this.getSendFlags(),E=Date.now(),ee=this.getRTT();if(J===0&&ee>0&&E-this.epochStart<ee*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.config.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&J===0)return;const te=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=E,this.sendFrame({type:FrameType$1.WindowUpdate,flag:J,streamID:this._id,length:te})}sendData(J){const E=this.getSendFlags();this.sendFrame({type:FrameType$1.Data,flag:E,streamID:this._id,length:J.length},J)}sendClose(){const J=this.getSendFlags()|Flag$1.FIN;this.sendFrame({type:FrameType$1.WindowUpdate,flag:J,streamID:this._id,length:0})}sendReset(){this.sendFrame({type:FrameType$1.WindowUpdate,flag:Flag$1.RST,streamID:this._id,length:0})}};function encodeHeader$1(J){const E=new Uint8Array(HEADER_LENGTH$1);return E[1]=J.type,E[2]=J.flag>>>8,E[3]=J.flag,E[4]=J.streamID>>>24,E[5]=J.streamID>>>16,E[6]=J.streamID>>>8,E[7]=J.streamID,E[8]=J.length>>>24,E[9]=J.length>>>16,E[10]=J.length>>>8,E[11]=J.length,E}const defaultConfig$1={log:logger$1("libp2p:yamux"),enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3,initialStreamWindowSize:INITIAL_STREAM_WINDOW$1,maxStreamWindowSize:MAX_STREAM_WINDOW$1,maxMessageSize:64*1024};function verifyConfig$1(J){if(J.keepAliveInterval<=0)throw new CodeError("keep-alive interval must be positive",ERR_INVALID_CONFIG$1);if(J.maxInboundStreams<0)throw new CodeError("max inbound streams must be larger or equal 0",ERR_INVALID_CONFIG$1);if(J.maxOutboundStreams<0)throw new CodeError("max outbound streams must be larger or equal 0",ERR_INVALID_CONFIG$1);if(J.initialStreamWindowSize<INITIAL_STREAM_WINDOW$1)throw new CodeError("InitialStreamWindowSize must be larger or equal 256 kB",ERR_INVALID_CONFIG$1);if(J.maxStreamWindowSize<J.initialStreamWindowSize)throw new CodeError("MaxStreamWindowSize must be larger than the InitialStreamWindowSize",ERR_INVALID_CONFIG$1);if(J.maxStreamWindowSize>2**32-1)throw new CodeError("MaxStreamWindowSize must be less than equal MAX_UINT32",ERR_INVALID_CONFIG$1);if(J.maxMessageSize<1024)throw new CodeError("MaxMessageSize must be greater than a kilobyte",ERR_INVALID_CONFIG$1)}const twoPow24$1=2**24;function decodeHeader$1(J){if(J[0]!==YAMUX_VERSION$1)throw new CodeError("Invalid frame version",ERR_DECODE_INVALID_VERSION$1);return{type:J[1],flag:(J[2]<<8)+J[3],streamID:J[4]*twoPow24$1+(J[5]<<16)+(J[6]<<8)+J[7],length:J[8]*twoPow24$1+(J[9]<<16)+(J[10]<<8)+J[11]}}let Decoder$4=class{constructor(J){this.source=returnlessSource$1(J),this.buffer=new Uint8ArrayList,this.frameInProgress=!1}async*emitFrames(){for await(const J of this.source)for(this.buffer.append(J);;){const E=this.readHeader();if(E===void 0)break;const{type:ee,length:te}=E;ee===FrameType$1.Data?(this.frameInProgress=!0,yield{header:E,readData:this.readBytes.bind(this,te)}):yield{header:E}}}readHeader(){if(this.frameInProgress)throw new CodeError("decoding frame already in progress",ERR_DECODE_IN_PROGRESS$1);if(this.buffer.length<HEADER_LENGTH$1)return;const J=decodeHeader$1(this.buffer.slice(0,HEADER_LENGTH$1));return this.buffer.consume(HEADER_LENGTH$1),J}async readBytes(J){if(this.buffer.length<J){for await(const ee of this.source)if(this.buffer.append(ee),this.buffer.length>=J)break}const E=this.buffer.sublist(0,J);return this.buffer.consume(J),this.frameInProgress=!1,E}};function returnlessSource$1(J){if(J[Symbol.iterator]!==void 0){const E=J[Symbol.iterator]();return E.return=void 0,{[Symbol.iterator](){return E}}}else if(J[Symbol.asyncIterator]!==void 0){const E=J[Symbol.asyncIterator]();return E.return=void 0,{[Symbol.asyncIterator](){return E}}}else throw new Error("a source must be either an iterable or an async iterable")}const YAMUX_PROTOCOL_ID$1="/yamux/1.0.0";let Yamux$1=class{constructor(J={}){this.protocol=YAMUX_PROTOCOL_ID$1,this._init=J}createStreamMuxer(J){return new YamuxMuxer$1({...this._init,...J})}},YamuxMuxer$1=class{constructor(J){this.protocol=YAMUX_PROTOCOL_ID$1,this._init=J,this.client=J.direction==="outbound",this.config={...defaultConfig$1,...J},this.log=this.config.log,verifyConfig$1(this.config),this.closeController=new AbortController,this.onIncomingStream=J.onIncomingStream,this.onStreamEnd=J.onStreamEnd,this._streams=new Map,this.source=pushable({onEnd:E=>{this.log?.trace("muxer source ended"),this.close(E)}}),this.sink=async E=>{let ee;this._init.signal!=null&&(ee=anySignal([this.closeController.signal,this._init.signal])),E=abortableSource(E,ee??this.closeController.signal,{returnOnAbort:!0});let te,re;try{const ne=new Decoder$4(E);await pipe$1(ne.emitFrames.bind(ne),async ie=>{for await(const{header:se,readData:oe}of ie)await this.handleFrame(se,oe)}),te=GoAwayCode$1.NormalTermination}catch(ne){const ie=ne.code;PROTOCOL_ERRORS$1.has(ie)?(this.log?.error("protocol error in sink",ne),te=GoAwayCode$1.ProtocolError):(this.log?.error("internal error in sink",ne),te=GoAwayCode$1.InternalError),re=ne}finally{ee?.clear()}this.log?.trace("muxer sink ended"),this.close(re,te)},this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=0,this.log?.trace("muxer created"),this.config.enableKeepAlive&&this.keepAliveLoop().catch(E=>this.log?.error("keepalive error: %s",E))}get streams(){return Array.from(this._streams.values())}newStream(J){if(this.remoteGoAway!==void 0)throw new CodeError("muxer closed remotely",ERR_MUXER_REMOTE_CLOSED$1);if(this.localGoAway!==void 0)throw new CodeError("muxer closed locally",ERR_MUXER_LOCAL_CLOSED$1);const E=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.config.maxOutboundStreams)throw new CodeError("max outbound streams exceeded",ERR_MAX_OUTBOUND_STREAMS_EXCEEDED$1);this.log?.trace("new outgoing stream id=%s",E);const ee=this._newStream(E,J,StreamState$2.Init,"outbound");return this._streams.set(E,ee),this.numOutboundStreams++,ee.sendWindowUpdate(),ee}async ping(){if(this.remoteGoAway!==void 0)throw new CodeError("muxer closed remotely",ERR_MUXER_REMOTE_CLOSED$1);if(this.localGoAway!==void 0)throw new CodeError("muxer closed locally",ERR_MUXER_LOCAL_CLOSED$1);if(this.activePing===void 0){let J=()=>{};this.activePing={id:this.nextPingID++,promise:new Promise((te,re)=>{const ne=()=>{re(new CodeError("muxer closed locally",ERR_MUXER_LOCAL_CLOSED$1))};this.closeController.signal.addEventListener("abort",ne,{once:!0}),J=()=>{this.closeController.signal.removeEventListener("abort",ne),te()}}),resolve:J};const E=Date.now();this.sendPing(this.activePing.id);try{await this.activePing.promise}finally{delete this.activePing}const ee=Date.now();this.rtt=ee-E}else await this.activePing.promise;return this.rtt}getRTT(){return this.rtt}close(J,E){if(!this.closeController.signal.aborted){if(E=E??(J===void 0?GoAwayCode$1.InternalError:GoAwayCode$1.NormalTermination),J!=null?this.log?.error("muxer close reason=%s error=%s",GoAwayCode$1[E],J):this.log?.trace("muxer close reason=%s",GoAwayCode$1[E]),J===void 0)for(const ee of this._streams.values())ee.close();else for(const ee of this._streams.values())ee.abort(J);this.sendGoAway(E),this._closeMuxer()}}isClosed(){return this.closeController.signal.aborted}_closeMuxer(){this.closeController.abort(),this.source.end()}_newStream(J,E,ee,te){if(this._streams.get(J)!=null)throw new CodeError("Stream already exists",ERR_STREAM_ALREADY_EXISTS$1,{id:J});const re=new YamuxStream$1({id:J,name:E,state:ee,direction:te,sendFrame:this.sendFrame.bind(this),onStreamEnd:()=>{this.closeStream(J),this.onStreamEnd?.(re)},log:this.log,config:this.config,getRTT:this.getRTT.bind(this)});return re}closeStream(J){this.client===(J%2===0)?this.numInboundStreams--:this.numOutboundStreams--,this._streams.delete(J)}async keepAliveLoop(){const J=new Promise((E,ee)=>{this.closeController.signal.addEventListener("abort",ee,{once:!0})});for(this.log?.trace("muxer keepalive enabled interval=%s",this.config.keepAliveInterval);;){let E;try{await Promise.race([J,new Promise(ee=>{E=setTimeout(ee,this.config.keepAliveInterval)})]),this.ping().catch(ee=>this.log?.error("ping error: %s",ee))}catch{clearInterval(E);return}}}async handleFrame(J,E){const{streamID:ee,type:te,length:re}=J;if(this.log?.trace("received frame %s",stringifyHeader$1(J)),ee===0)switch(te){case FrameType$1.Ping:{this.handlePing(J);return}case FrameType$1.GoAway:{this.handleGoAway(re);return}default:throw new CodeError("Invalid frame type",ERR_INVALID_FRAME$1,{header:J})}else switch(J.type){case FrameType$1.Data:case FrameType$1.WindowUpdate:{await this.handleStreamMessage(J,E);return}default:throw new CodeError("Invalid frame type",ERR_INVALID_FRAME$1,{header:J})}}handlePing(J){if(J.flag===Flag$1.SYN)this.log?.trace("received ping request pingId=%s",J.length),this.sendPing(J.length,Flag$1.ACK);else if(J.flag===Flag$1.ACK)this.log?.trace("received ping response pingId=%s",J.length),this.handlePingResponse(J.length);else throw new CodeError("Invalid frame flag",ERR_INVALID_FRAME$1,{header:J})}handlePingResponse(J){if(this.activePing===void 0)throw new CodeError("ping not requested",ERR_UNREQUESTED_PING$1);if(this.activePing.id!==J)throw new CodeError("ping doesn't match our id",ERR_NOT_MATCHING_PING$1);this.activePing.resolve()}handleGoAway(J){this.log?.trace("received GoAway reason=%s",GoAwayCode$1[J]??"unknown"),this.remoteGoAway=J;for(const E of this._streams.values())E.reset();this._closeMuxer()}async handleStreamMessage(J,E){const{streamID:ee,flag:te,type:re}=J;(te&Flag$1.SYN)===Flag$1.SYN&&this.incomingStream(ee);const ne=this._streams.get(ee);if(ne===void 0){if(re===FrameType$1.Data){if(this.log?.("discarding data for stream id=%s",ee),E===void 0)throw new Error("unreachable");await E()}else this.log?.("frame for missing stream id=%s",ee);return}switch(re){case FrameType$1.WindowUpdate:{ne.handleWindowUpdate(J);return}case FrameType$1.Data:{if(E===void 0)throw new Error("unreachable");await ne.handleData(J,E);return}default:throw new Error("unreachable")}}incomingStream(J){if(this.client!==(J%2===0))throw new CodeError("both endpoints are clients",ERR_BOTH_CLIENTS$1);if(this._streams.has(J))return;if(this.log?.trace("new incoming stream id=%s",J),this.localGoAway!==void 0){this.sendFrame({type:FrameType$1.WindowUpdate,flag:Flag$1.RST,streamID:J,length:0});return}if(this.numInboundStreams>=this.config.maxInboundStreams){this.log?.("maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:FrameType$1.WindowUpdate,flag:Flag$1.RST,streamID:J,length:0});return}const E=this._newStream(J,void 0,StreamState$2.SYNReceived,"inbound");this.numInboundStreams++,this._streams.set(J,E),this.onIncomingStream?.(E)}sendFrame(J,E){if(this.log?.trace("sending frame %s",stringifyHeader$1(J)),J.type===FrameType$1.Data){if(E===void 0)throw new CodeError("invalid frame",ERR_INVALID_FRAME$1);this.source.push(encodeHeader$1(J)),this.source.push(E)}else this.source.push(encodeHeader$1(J))}sendPing(J,E=Flag$1.SYN){E===Flag$1.SYN?this.log?.trace("sending ping request pingId=%s",J):this.log?.trace("sending ping response pingId=%s",J),this.sendFrame({type:FrameType$1.Ping,flag:E,streamID:0,length:J})}sendGoAway(J=GoAwayCode$1.NormalTermination){this.log?.("sending GoAway reason=%s",GoAwayCode$1[J]),this.localGoAway=J,this.sendFrame({type:FrameType$1.GoAway,flag:0,streamID:0,length:J})}};function yamux$1(J={}){return()=>new Yamux$1(J)}var codes$4;(function(J){J.ERR_ALREADY_ABORTED="ERR_ALREADY_ABORTED",J.ERR_DATA_CHANNEL="ERR_DATA_CHANNEL",J.ERR_CONNECTION_CLOSED="ERR_CONNECTION_CLOSED",J.ERR_HASH_NOT_SUPPORTED="ERR_HASH_NOT_SUPPORTED",J.ERR_INVALID_MULTIADDR="ERR_INVALID_MULTIADDR",J.ERR_INVALID_FINGERPRINT="ERR_INVALID_FINGERPRINT",J.ERR_INVALID_PARAMETERS="ERR_INVALID_PARAMETERS",J.ERR_NOT_IMPLEMENTED="ERR_NOT_IMPLEMENTED",J.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS="ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS",J.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS="ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS"})(codes$4||(codes$4={}));let WebRTCTransportError$1=class extends CodeError{constructor(J,E){super(`WebRTC transport error: ${J}`,E??""),this.name="WebRTCTransportError"}},DataChannelError$1=class extends WebRTCTransportError$1{constructor(J,E){super(`[stream: ${J}] data channel error: ${E}`,codes$4.ERR_DATA_CHANNEL),this.name="WebRTC/DataChannelError"}};function dataChannelError$1(J,E){return new DataChannelError$1(J,E)}let InappropriateMultiaddrError$1=class extends WebRTCTransportError$1{constructor(J){super(`There was a problem with the Multiaddr which was passed in: ${J}`,codes$4.ERR_INVALID_MULTIADDR),this.name="WebRTC/InappropriateMultiaddrError"}};function inappropriateMultiaddr$1(J){return new InappropriateMultiaddrError$1(J)}let InvalidArgumentError$1=class extends WebRTCTransportError$1{constructor(J){super(`There was a problem with a provided argument: ${J}`,codes$4.ERR_INVALID_PARAMETERS),this.name="WebRTC/InvalidArgumentError"}};function invalidArgument$1(J){return new InvalidArgumentError$1(J)}let InvalidFingerprintError$1=class extends WebRTCTransportError$1{constructor(J,E){super(`Invalid fingerprint "${J}" within ${E}`,codes$4.ERR_INVALID_FINGERPRINT),this.name="WebRTC/InvalidFingerprintError"}};function invalidFingerprint$1(J,E){return new InvalidFingerprintError$1(J,E)}let UnimplementedError$1=class extends WebRTCTransportError$1{constructor(J){super(`A method (${J}) was called though it has been intentionally left unimplemented.`,codes$4.ERR_NOT_IMPLEMENTED),this.name="WebRTC/UnimplementedError"}};function unimplemented$1(J){return new UnimplementedError$1(J)}let UnsupportedHashAlgorithmError$1=class extends WebRTCTransportError$1{constructor(J){super(`unsupported hash algorithm: ${J}`,codes$4.ERR_HASH_NOT_SUPPORTED),this.name="WebRTC/UnsupportedHashAlgorithmError"}};function unsupportedHashAlgorithm$1(J){return new UnsupportedHashAlgorithmError$1(J)}var __spreadArray=globalThis&&globalThis.__spreadArray||function(J,E,ee){if(ee||arguments.length===2)for(var te=0,re=E.length,ne;te<re;te++)(ne||!(te in E))&&(ne||(ne=Array.prototype.slice.call(E,0,te)),ne[te]=E[te]);return J.concat(ne||Array.prototype.slice.call(E))},BrowserInfo=function(){function J(E,ee,te){this.name=E,this.version=ee,this.os=te,this.type="browser"}return J}(),NodeInfo=function(){function J(E){this.version=E,this.type="node",this.name="node",this.os=process.platform}return J}(),SearchBotDeviceInfo=function(){function J(E,ee,te,re){this.name=E,this.version=ee,this.os=te,this.bot=re,this.type="bot-device"}return J}(),BotInfo=function(){function J(){this.type="bot",this.bot=!0,this.name="bot",this.version=null,this.os=null}return J}(),ReactNativeInfo=function(){function J(){this.type="react-native",this.name="react-native",this.version=null,this.os=null}return J}(),SEARCHBOX_UA_REGEX=/alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/,SEARCHBOT_OS_REGEX=/(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/,REQUIRED_VERSION_PARTS=3,userAgentRules=[["aol",/AOLShield\/([0-9\._]+)/],["edge",/Edge\/([0-9\._]+)/],["edge-ios",/EdgiOS\/([0-9\._]+)/],["yandexbrowser",/YaBrowser\/([0-9\._]+)/],["kakaotalk",/KAKAOTALK\s([0-9\.]+)/],["samsung",/SamsungBrowser\/([0-9\.]+)/],["silk",/\bSilk\/([0-9._-]+)\b/],["miui",/MiuiBrowser\/([0-9\.]+)$/],["beaker",/BeakerBrowser\/([0-9\.]+)/],["edge-chromium",/EdgA?\/([0-9\.]+)/],["chromium-webview",/(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["chrome",/(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],["phantomjs",/PhantomJS\/([0-9\.]+)(:?\s|$)/],["crios",/CriOS\/([0-9\.]+)(:?\s|$)/],["firefox",/Firefox\/([0-9\.]+)(?:\s|$)/],["fxios",/FxiOS\/([0-9\.]+)/],["opera-mini",/Opera Mini.*Version\/([0-9\.]+)/],["opera",/Opera\/([0-9\.]+)(?:\s|$)/],["opera",/OPR\/([0-9\.]+)(:?\s|$)/],["pie",/^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],["pie",/^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],["netfront",/^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],["ie",/Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],["ie",/MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],["ie",/MSIE\s(7\.0)/],["bb10",/BB10;\sTouch.*Version\/([0-9\.]+)/],["android",/Android\s([0-9\.]+)/],["ios",/Version\/([0-9\._]+).*Mobile.*Safari.*/],["safari",/Version\/([0-9\._]+).*Safari/],["facebook",/FB[AS]V\/([0-9\.]+)/],["instagram",/Instagram\s([0-9\.]+)/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Mobile/],["ios-webview",/AppleWebKit\/([0-9\.]+).*Gecko\)$/],["curl",/^curl\/([0-9\.]+)$/],["searchbot",SEARCHBOX_UA_REGEX]],operatingSystemRules=[["iOS",/iP(hone|od|ad)/],["Android OS",/Android/],["BlackBerry OS",/BlackBerry|BB10/],["Windows Mobile",/IEMobile/],["Amazon OS",/Kindle/],["Windows 3.11",/Win16/],["Windows 95",/(Windows 95)|(Win95)|(Windows_95)/],["Windows 98",/(Windows 98)|(Win98)/],["Windows 2000",/(Windows NT 5.0)|(Windows 2000)/],["Windows XP",/(Windows NT 5.1)|(Windows XP)/],["Windows Server 2003",/(Windows NT 5.2)/],["Windows Vista",/(Windows NT 6.0)/],["Windows 7",/(Windows NT 6.1)/],["Windows 8",/(Windows NT 6.2)/],["Windows 8.1",/(Windows NT 6.3)/],["Windows 10",/(Windows NT 10.0)/],["Windows ME",/Windows ME/],["Windows CE",/Windows CE|WinCE|Microsoft Pocket Internet Explorer/],["Open BSD",/OpenBSD/],["Sun OS",/SunOS/],["Chrome OS",/CrOS/],["Linux",/(Linux)|(X11)/],["Mac OS",/(Mac_PowerPC)|(Macintosh)/],["QNX",/QNX/],["BeOS",/BeOS/],["OS/2",/OS\/2/]];function detect(J){return J?parseUserAgent(J):typeof document>"u"&&typeof navigator<"u"&&navigator.product==="ReactNative"?new ReactNativeInfo:typeof navigator<"u"?parseUserAgent(navigator.userAgent):getNodeVersion()}function matchUserAgent(J){return J!==""&&userAgentRules.reduce(function(E,ee){var te=ee[0],re=ee[1];if(E)return E;var ne=re.exec(J);return!!ne&&[te,ne]},!1)}function parseUserAgent(J){var E=matchUserAgent(J);if(!E)return null;var ee=E[0],te=E[1];if(ee==="searchbot")return new BotInfo;var re=te[1]&&te[1].split(".").join("_").split("_").slice(0,3);re?re.length<REQUIRED_VERSION_PARTS&&(re=__spreadArray(__spreadArray([],re,!0),createVersionParts(REQUIRED_VERSION_PARTS-re.length),!0)):re=[];var ne=re.join("."),ie=detectOS(J),se=SEARCHBOT_OS_REGEX.exec(J);return se&&se[1]?new SearchBotDeviceInfo(ee,ne,ie,se[1]):new BrowserInfo(ee,ne,ie)}function detectOS(J){for(var E=0,ee=operatingSystemRules.length;E<ee;E++){var te=operatingSystemRules[E],re=te[0],ne=te[1],ie=ne.exec(J);if(ie)return re}return null}function getNodeVersion(){var J=typeof process<"u"&&process.version;return J?new NodeInfo(process.version.slice(1)):null}function createVersionParts(J){for(var E=[],ee=0;ee<J;ee++)E.push("0");return E}const browser$2=detect(),isFirefox$1=browser$2!=null&&browser$2.name==="firefox",nopSource$1=async function*J(){},nopSink$1=async J=>{},log$16=logger$1("libp2p:webrtc:connection");let WebRTCMultiaddrConnection$1=class{peerConnection;remoteAddr;timeline;metrics;source=nopSource$1();sink=nopSink$1;constructor(J){this.remoteAddr=J.remoteAddr,this.timeline=J.timeline,this.peerConnection=J.peerConnection,this.peerConnection.onconnectionstatechange=()=>{(this.peerConnection.connectionState==="closed"||this.peerConnection.connectionState==="disconnected"||this.peerConnection.connectionState==="failed")&&(this.timeline.close=Date.now())}}async close(J){J!==void 0&&log$16.error("error closing connection",J),log$16.trace("closing connection"),this.timeline.close=Date.now(),this.peerConnection.close(),this.metrics?.increment({close:!0})}};const defaultLengthDecoder$1=J=>unsigned.decode(J);defaultLengthDecoder$1.bytes=0;function pbStream$1(J,E){const ee=pushable();J.sink(ee).catch(ie=>{ee.end(ie)}),J.sink=async ie=>{for await(const se of ie)ee.push(se);ee.end()};let te=J.source;J.source[Symbol.iterator]!=null?te=J.source[Symbol.iterator]():J.source[Symbol.asyncIterator]!=null&&(te=J.source[Symbol.asyncIterator]());const re=new Uint8ArrayList,ne={read:async ie=>{if(ie==null){const{done:oe,value:ce}=await te.next();return oe===!0?new Uint8ArrayList:ce}for(;re.byteLength<ie;){const{value:oe,done:ce}=await te.next();if(ce===!0)throw errCode$1(new Error("unexpected end of input"),"ERR_UNEXPECTED_EOF");re.append(oe)}const se=re.sublist(0,ie);return re.consume(ie),se},readLP:async()=>{let ie=-1;const se=new Uint8ArrayList,oe=E?.lengthDecoder??defaultLengthDecoder$1;for(;;){se.append(await ne.read(1));try{ie=oe(se)}catch(ce){if(ce instanceof RangeError)continue;throw ce}if(ie>-1)break;if(E?.maxLengthLength!=null&&se.byteLength>E.maxLengthLength)throw errCode$1(new Error("message length length too long"),"ERR_MSG_LENGTH_TOO_LONG")}if(E?.maxDataLength!=null&&ie>E.maxDataLength)throw errCode$1(new Error("message length too long"),"ERR_MSG_DATA_TOO_LONG");return await ne.read(ie)},readPB:async ie=>{const se=await ne.readLP();if(se==null)throw new Error("Value is null");const oe=se instanceof Uint8Array?se:se.subarray();return ie.decode(oe)},write:ie=>{ie instanceof Uint8Array?ee.push(ie):ee.push(ie.subarray())},writeLP:ie=>{ne.write(encode$b.single(ie,E))},writePB:(ie,se)=>{ne.writeLP(se.encode(ie))},pb:ie=>({read:async()=>await ne.readPB(ie),write:se=>{ne.writePB(se,ie)},unwrap:()=>ne}),unwrap:()=>{const ie=J.source;return J.source=async function*(){yield*re,yield*ie}(),J}};return ne}var Message$7;(function(J){(function(te){te.FIN="FIN",te.STOP_SENDING="STOP_SENDING",te.RESET="RESET"})(J.Flag||(J.Flag={}));let E;(function(te){te[te.FIN=0]="FIN",te[te.STOP_SENDING=1]="STOP_SENDING",te[te.RESET=2]="RESET"})(E||(E={})),function(te){te.codec=()=>enumeration(E)}(J.Flag||(J.Flag={}));let ee;J.codec=()=>(ee==null&&(ee=message((te,re,ne={})=>{ne.lengthDelimited!==!1&&re.fork(),te.flag!=null&&(re.uint32(8),J.Flag.codec().encode(te.flag,re)),te.message!=null&&(re.uint32(18),re.bytes(te.message)),ne.lengthDelimited!==!1&&re.ldelim()},(te,re)=>{const ne={},ie=re==null?te.len:te.pos+re;for(;te.pos<ie;){const se=te.uint32();switch(se>>>3){case 1:ne.flag=J.Flag.codec().decode(te);break;case 2:ne.message=te.bytes();break;default:te.skipType(se&7);break}}return ne})),ee),J.encode=te=>encodeMessage(te,J.codec()),J.decode=te=>decodeMessage$1(te,J.codec())})(Message$7||(Message$7={}));const log$15=logger$1("libp2p:webrtc:stream");var StreamStates;(function(J){J[J.OPEN=0]="OPEN",J[J.READ_CLOSED=1]="READ_CLOSED",J[J.WRITE_CLOSED=2]="WRITE_CLOSED",J[J.CLOSED=3]="CLOSED"})(StreamStates||(StreamStates={}));function unreachableBranch(J){throw new Error("Case not handled in switch")}let StreamState$1=class{state=StreamStates.OPEN;isWriteClosed(){return this.state===StreamStates.CLOSED||this.state===StreamStates.WRITE_CLOSED}transition({direction:J,flag:E}){const ee=this.state;if(this.state===StreamStates.CLOSED)return[ee,StreamStates.CLOSED];if(J==="inbound")switch(E){case Message$7.Flag.FIN:this.state===StreamStates.OPEN?this.state=StreamStates.READ_CLOSED:this.state===StreamStates.WRITE_CLOSED&&(this.state=StreamStates.CLOSED);break;case Message$7.Flag.STOP_SENDING:this.state===StreamStates.OPEN?this.state=StreamStates.WRITE_CLOSED:this.state===StreamStates.READ_CLOSED&&(this.state=StreamStates.CLOSED);break;case Message$7.Flag.RESET:this.state=StreamStates.CLOSED;break;default:unreachableBranch()}else switch(E){case Message$7.Flag.FIN:this.state===StreamStates.OPEN?this.state=StreamStates.WRITE_CLOSED:this.state===StreamStates.READ_CLOSED&&(this.state=StreamStates.CLOSED);break;case Message$7.Flag.STOP_SENDING:this.state===StreamStates.OPEN?this.state=StreamStates.READ_CLOSED:this.state===StreamStates.WRITE_CLOSED&&(this.state=StreamStates.CLOSED);break;case Message$7.Flag.RESET:this.state=StreamStates.CLOSED;break;default:unreachableBranch()}return[ee,this.state]}},WebRTCStream$1=class Ht{id;stat;metadata;channel;streamState=new StreamState$1;_src;_innersrc=pushable();opened=pDefer();_sinkCalled=!1;closeWritePromise=pDefer();closeCb;constructor(E){switch(this.channel=E.channel,this.channel.binaryType="arraybuffer",this.id=this.channel.label,this.stat=E.stat,this.channel.readyState){case"open":this.opened.resolve();break;case"closed":case"closing":this.streamState.state=StreamStates.CLOSED,(this.stat.timeline.close===void 0||this.stat.timeline.close===0)&&(this.stat.timeline.close=new Date().getTime()),this.opened.resolve();break;case"connecting":break;default:unreachableBranch(this.channel.readyState)}this.metadata=E.metadata??{},this.channel.onopen=te=>{this.stat.timeline.open=new Date().getTime(),this.opened.resolve()},this.channel.onclose=te=>{this.close()},this.channel.onerror=te=>{const re=te.error;this.abort(re)};const ee=this;this.channel.onmessage=async({data:te})=>{te===null||te.length===0||this._innersrc.push(new Uint8Array(te))},this._src=pipe$1(this._innersrc,te=>decode$b(te),te=>async function*(){for await(const re of te){const ne=ee.processIncomingProtobuf(re.subarray());ne!=null&&(yield new Uint8ArrayList(ne))}}())}set source(E){}get source(){return this._src}async sink(E){if(this._sinkCalled)throw new Error("sink already called on this stream");await this.opened.promise;try{await this._sink(E)}finally{this.closeWrite()}}async _sink(E){const ee=this._closeWriteIterable();for await(const te of merge$2(ee,E)){if(this.streamState.isWriteClosed())return;const re=Message$7.encode({message:te.subarray()}),ne=encode$b.single(re);this.channel.send(ne.subarray())}}processIncomingProtobuf(E){const ee=Message$7.decode(E);if(ee.flag!==void 0){const[te,re]=this.streamState.transition({direction:"inbound",flag:ee.flag});if(te!==re)switch(re){case StreamStates.READ_CLOSED:this._innersrc.end();break;case StreamStates.WRITE_CLOSED:this.closeWritePromise.resolve();break;case StreamStates.CLOSED:this.close();break;case StreamStates.OPEN:break;default:unreachableBranch()}}return ee.message}close(){this.stat.timeline.close=new Date().getTime(),this.streamState.state=StreamStates.CLOSED,this._innersrc.end(),this.closeWritePromise.resolve(),this.channel.close(),this.closeCb!==void 0&&this.closeCb(this)}closeRead(){const[E,ee]=this.streamState.transition({direction:"outbound",flag:Message$7.Flag.STOP_SENDING});E!==ee&&((E===StreamStates.OPEN||E===StreamStates.WRITE_CLOSED)&&(this._sendFlag(Message$7.Flag.STOP_SENDING),this._innersrc.end()),ee===StreamStates.CLOSED&&this.close())}closeWrite(){const[E,ee]=this.streamState.transition({direction:"outbound",flag:Message$7.Flag.FIN});E!==ee&&((E===StreamStates.OPEN||E===StreamStates.READ_CLOSED)&&(this._sendFlag(Message$7.Flag.FIN),this.closeWritePromise.resolve()),ee===StreamStates.CLOSED&&this.close())}abort(E){log$15.error(`An error occurred, closing the stream for reading and writing: ${E.message}`),this.close()}reset(){const[E,ee]=this.streamState.transition({direction:"outbound",flag:Message$7.Flag.RESET});E!==ee&&(this._sendFlag(Message$7.Flag.RESET),this.close())}_sendFlag(E){try{log$15.trace("Sending flag: %s",E.toString());const ee=Message$7.encode({flag:E});this.channel.send(encode$b.single(ee).subarray())}catch(ee){ee instanceof Error&&log$15.error(`Exception while sending flag ${E}: ${ee.message}`)}}_closeWriteIterable(){const E=this;return{async*[Symbol.asyncIterator](){await E.closeWritePromise.promise,yield new Uint8Array(0)}}}eq(E){return E instanceof Ht?E.channel.id===this.channel.id:!1}},DataChannelMuxerFactory$1=class{protocol;peerConnection;streamBuffer=[];metrics;constructor(J,E,ee="/webrtc"){this.protocol=ee,this.peerConnection=J,this.peerConnection.ondatachannel=({channel:te})=>{const re=new WebRTCStream$1({channel:te,stat:{direction:"inbound",timeline:{open:0}},closeCb:ne=>{this.streamBuffer=this.streamBuffer.filter(ie=>!ne.eq(ie))}});this.streamBuffer.push(re)},this.metrics=E}createStreamMuxer(J){return new DataChannelMuxer$1(this.peerConnection,this.streamBuffer,this.protocol,J,this.metrics)}},DataChannelMuxer$1=class{protocol;peerConnection;metrics;streams=[];init;close=()=>{};source=nopSource$1();sink=nopSink$1;constructor(J,E,ee="/webrtc",te,re){this.protocol=ee,this.init=te,this.peerConnection=J,this.peerConnection.ondatachannel=({channel:ie})=>{const se=new WebRTCStream$1({channel:ie,stat:{direction:"inbound",timeline:{open:0}},closeCb:this.wrapStreamEnd(te?.onIncomingStream)});this.streams.push(se),te?.onIncomingStream!=null&&(this.metrics?.increment({incoming_stream:!0}),te.onIncomingStream(se))},this.streams=E.filter(ie=>ie.stat.timeline.close==null).map(ie=>(ie.closeCb=this.wrapStreamEnd(te?.onStreamEnd),ie));const ne=te?.onIncomingStream;ne!=null&&this.streams.forEach(ie=>{ne(ie)})}newStream(){const J=this.peerConnection.createDataChannel(""),E=te=>{this.metrics?.increment({stream_end:!0}),this.init?.onStreamEnd?.(te)},ee=new WebRTCStream$1({channel:J,stat:{direction:"outbound",timeline:{open:0}},closeCb:this.wrapStreamEnd(E)});return this.streams.push(ee),this.metrics?.increment({outgoing_stream:!0}),ee}wrapStreamEnd(J){const E=this;return ee=>{E.streams=E.streams.filter(te=>!(ee instanceof WebRTCStream$1&&ee.eq(te))),J?.(ee)}}};var Message$6;(function(J){(function(te){te.SDP_OFFER="SDP_OFFER",te.SDP_ANSWER="SDP_ANSWER",te.ICE_CANDIDATE="ICE_CANDIDATE"})(J.Type||(J.Type={}));let E;(function(te){te[te.SDP_OFFER=0]="SDP_OFFER",te[te.SDP_ANSWER=1]="SDP_ANSWER",te[te.ICE_CANDIDATE=2]="ICE_CANDIDATE"})(E||(E={})),function(te){te.codec=()=>enumeration(E)}(J.Type||(J.Type={}));let ee;J.codec=()=>(ee==null&&(ee=message((te,re,ne={})=>{ne.lengthDelimited!==!1&&re.fork(),te.type!=null&&(re.uint32(8),J.Type.codec().encode(te.type,re)),te.data!=null&&(re.uint32(18),re.string(te.data)),ne.lengthDelimited!==!1&&re.ldelim()},(te,re)=>{const ne={},ie=re==null?te.len:te.pos+re;for(;te.pos<ie;){const se=te.uint32();switch(se>>>3){case 1:ne.type=J.Type.codec().decode(te);break;case 2:ne.data=te.string();break;default:te.skipType(se&7);break}}return ne})),ee),J.encode=te=>encodeMessage(te,J.codec()),J.decode=te=>decodeMessage$1(te,J.codec())})(Message$6||(Message$6={}));const log$14=logger$1("libp2p:webrtc:peer:util"),readCandidatesUntilConnected$1=async(J,E,ee)=>{for(;;){const te=await Promise.race([J.promise,ee.read()]);if(te instanceof Object){const re=te;if(re.type!==Message$6.Type.ICE_CANDIDATE)throw new Error("expected only ice candidates");if(re.data==null||re.data===""){log$14.trace("end-of-candidates received");break}log$14.trace("received new ICE candidate: %s",re.data);try{await E.addIceCandidate(new RTCIceCandidate(JSON.parse(re.data)))}catch(ne){throw log$14.error("bad candidate received: ",ne),new Error("bad candidate received")}}else break}await J.promise};function resolveOnConnected$1(J,E){J[isFirefox$1?"oniceconnectionstatechange":"onconnectionstatechange"]=ee=>{switch(log$14.trace("receiver peerConnectionState state: ",J.connectionState),isFirefox$1?J.iceConnectionState:J.connectionState){case"connected":E.resolve();break;case"failed":case"disconnected":case"closed":E.reject(new Error("RTCPeerConnection was closed"));break}}}const DEFAULT_TIMEOUT$1=30*1e3,log$13=logger$1("libp2p:webrtc:peer");async function handleIncomingStream$1({rtcConfiguration:J,stream:E}){const ee=AbortSignal.timeout(DEFAULT_TIMEOUT$1),te=pbStream$1(abortableDuplex(E,ee)).pb(Message$6),re=new RTCPeerConnection(J),ne=new DataChannelMuxerFactory$1(re),ie=pDefer(),se=pDefer();ee.onabort=()=>{ie.reject()},re.onicecandidate=({candidate:ue})=>{se.promise.then(()=>{te.write({type:Message$6.Type.ICE_CANDIDATE,data:ue!=null?JSON.stringify(ue.toJSON()):""})},he=>{log$13.error("cannot set candidate since sending answer failed",he)})},resolveOnConnected$1(re,ie);const oe=await te.read();if(oe.type!==Message$6.Type.SDP_OFFER)throw new Error(`expected message type SDP_OFFER, received: ${oe.type??"undefined"} `);const ce=new RTCSessionDescription({type:"offer",sdp:oe.data});await re.setRemoteDescription(ce).catch(ue=>{throw log$13.error("could not execute setRemoteDescription",ue),new Error("Failed to set remoteDescription")});const ae=await re.createAnswer().catch(ue=>{throw log$13.error("could not execute createAnswer",ue),se.reject(ue),new Error("Failed to create answer")});te.write({type:Message$6.Type.SDP_ANSWER,data:ae.sdp}),await re.setLocalDescription(ae).catch(ue=>{throw log$13.error("could not execute setLocalDescription",ue),se.reject(ue),new Error("Failed to set localDescription")}),se.resolve(),await readCandidatesUntilConnected$1(ie,re,te);const le=parseRemoteAddress$1(re.currentRemoteDescription?.sdp??"");return{pc:re,muxerFactory:ne,remoteAddress:le}}async function initiateConnection$1({rtcConfiguration:J,signal:E,stream:ee}){const te=pbStream$1(abortableDuplex(ee,E)).pb(Message$6),re=new RTCPeerConnection(J),ne=new DataChannelMuxerFactory$1(re),ie=pDefer();resolveOnConnected$1(re,ie),E.onabort=ie.reject;const se=re.createDataChannel("init");re.onicecandidate=({candidate:ue})=>{te.write({type:Message$6.Type.ICE_CANDIDATE,data:ue!=null?JSON.stringify(ue.toJSON()):""})};const oe=await re.createOffer();te.write({type:Message$6.Type.SDP_OFFER,data:oe.sdp}),await re.setLocalDescription(oe).catch(ue=>{throw log$13.error("could not execute setLocalDescription",ue),new Error("Failed to set localDescription")});const ce=await te.read();if(ce.type!==Message$6.Type.SDP_ANSWER)throw new Error("remote should send an SDP answer");const ae=new RTCSessionDescription({type:"answer",sdp:ce.data});await re.setRemoteDescription(ae).catch(ue=>{throw log$13.error("could not execute setRemoteDescription",ue),new Error("Failed to set remoteDescription")}),await readCandidatesUntilConnected$1(ie,re,te),se.close();const le=parseRemoteAddress$1(re.currentRemoteDescription?.sdp??"");return{pc:re,muxerFactory:ne,remoteAddress:le}}function parseRemoteAddress$1(J){const E=J.split(`\r
`).filter(te=>te.startsWith("a=candidate")).pop(),ee=E?.split(" ");return E==null||ee==null||ee.length<5?(log$13("could not parse remote address from",E),"/webrtc"):`/dnsaddr/${ee[4]}/${ee[2]}/${ee[3]}/webrtc`}let WebRTCPeerListener$1=class extends EventEmitter$3{peerId;transportManager;constructor(J){super(),this.peerId=J.peerId,this.transportManager=J.transportManager}async listen(){this.safeDispatchEvent("listening",{})}getAddrs(){return this.transportManager.getListeners().filter(J=>J!==this).map(J=>J.getAddrs().filter(E=>Circuit.matches(E)).map(E=>E.encapsulate(`/webrtc/p2p/${this.peerId}`))).flat()}async close(){this.safeDispatchEvent("close",{})}};const log$12=logger$1("libp2p:webrtc:peer"),WEBRTC_TRANSPORT$1="/webrtc",CIRCUIT_RELAY_TRANSPORT$1="/p2p-circuit",SIGNALING_PROTO_ID$1="/webrtc-signaling/0.0.1",WEBRTC_CODE$3=getProtocol("webrtc").code;let WebRTCTransport$1=class{components;init;_started=!1;constructor(J,E){this.components=J,this.init=E}isStarted(){return this._started}async start(){await this.components.registrar.handle(SIGNALING_PROTO_ID$1,J=>{this._onProtocol(J).catch(E=>{log$12.error("failed to handle incoming connect from %p",J.connection.remotePeer,E)})}),this._started=!0}async stop(){await this.components.registrar.unhandle(SIGNALING_PROTO_ID$1),this._started=!1}createListener(J){return new WebRTCPeerListener$1(this.components)}[Symbol.toStringTag]="@libp2p/webrtc";[symbol$2]=!0;filter(J){return J.filter(E=>E.protoCodes().includes(WEBRTC_CODE$3))}splitAddr(J){const E=J.toString().split(WEBRTC_TRANSPORT$1);if(E.length!==2)throw new CodeError("webrtc protocol was not present in multiaddr",codes$4.ERR_INVALID_MULTIADDR);if(!E[0].includes(CIRCUIT_RELAY_TRANSPORT$1))throw new CodeError("p2p-circuit protocol was not present in multiaddr",codes$4.ERR_INVALID_MULTIADDR);let ee=multiaddr(E[0]);const te=multiaddr(E[1]).getPeerId();if(te==null)throw new CodeError("destination peer id was missing",codes$4.ERR_INVALID_MULTIADDR);const re=ee.protos().pop();if(re===void 0)throw new CodeError("invalid multiaddr",codes$4.ERR_INVALID_MULTIADDR);return re.name!=="p2p"&&(ee=ee.encapsulate(`/p2p/${te}`)),{baseAddr:ee,peerId:peerIdFromString(te)}}async dial(J,E){log$12.trace("dialing address: ",J);const{baseAddr:ee,peerId:te}=this.splitAddr(J);if(E.signal==null){const ne=new AbortController;E.signal=ne.signal}const re=await(await this.components.transportManager.dial(ee,E)).newStream([SIGNALING_PROTO_ID$1],E);try{const{pc:ne,muxerFactory:ie,remoteAddress:se}=await initiateConnection$1({stream:re,rtcConfiguration:this.init.rtcConfiguration,signal:E.signal}),oe=await E.upgrader.upgradeOutbound(new WebRTCMultiaddrConnection$1({peerConnection:ne,timeline:{open:Date.now()},remoteAddr:multiaddr(se).encapsulate(`/p2p/${te.toString()}`)}),{skipProtection:!0,skipEncryption:!0,muxerFactory:ie});return re.close(),oe}catch(ne){throw re.reset(),ne}}async _onProtocol({connection:J,stream:E}){try{const{pc:ee,muxerFactory:te,remoteAddress:re}=await handleIncomingStream$1({rtcConfiguration:this.init.rtcConfiguration,connection:J,stream:E});await this.components.upgrader.upgradeInbound(new WebRTCMultiaddrConnection$1({peerConnection:ee,timeline:{open:new Date().getTime()},remoteAddr:multiaddr(re).encapsulate(`/p2p/${J.remotePeer.toString()}`)}),{skipEncryption:!0,skipProtection:!0,muxerFactory:te})}catch(ee){throw E.reset(),ee}}};function pair(){const J=pDefer();let E=!1;return{sink:async ee=>{if(E)throw new Error("already piped");E=!0,J.resolve(ee)},source:async function*(){yield*await J.promise}()}}function duplexPair(){const J=pair(),E=pair();return[{source:J.source,sink:E.sink},{source:E.source,sink:J.sink}]}const NOISE_MSG_MAX_LENGTH_BYTES$1=65535,NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG$1=NOISE_MSG_MAX_LENGTH_BYTES$1-16,DUMP_SESSION_KEYS$1=!!globalThis.process?.env?.DUMP_SESSION_KEYS;function number(J){if(!Number.isSafeInteger(J)||J<0)throw new Error(`Wrong positive integer: ${J}`)}function bool(J){if(typeof J!="boolean")throw new Error(`Expected boolean, not ${J}`)}function bytes(J,...E){if(!(J instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(E.length>0&&!E.includes(J.length))throw new TypeError(`Expected Uint8Array of length ${E}, not of length=${J.length}`)}function hash$1(J){if(typeof J!="function"||typeof J.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");number(J.outputLen),number(J.blockLen)}function exists$1(J,E=!0){if(J.destroyed)throw new Error("Hash instance has been destroyed");if(E&&J.finished)throw new Error("Hash#digest() has already been called")}function output(J,E){bytes(J);const ee=E.outputLen;if(J.length<ee)throw new Error(`digestInto() expects output buffer of length at least ${ee}`)}const assert={number,bool,bytes,hash:hash$1,exists:exists$1,output};/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const createView=J=>new DataView(J.buffer,J.byteOffset,J.byteLength),rotr=(J,E)=>J<<32-E|J>>>E,isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE)throw new Error("Non little-endian hardware is not supported");Array.from({length:256},(J,E)=>E.toString(16).padStart(2,"0"));function utf8ToBytes$1(J){if(typeof J!="string")throw new TypeError(`utf8ToBytes expected string, got ${typeof J}`);return new TextEncoder().encode(J)}function toBytes(J){if(typeof J=="string"&&(J=utf8ToBytes$1(J)),!(J instanceof Uint8Array))throw new TypeError(`Expected input type is Uint8Array (got ${typeof J})`);return J}class Hash{clone(){return this._cloneInto()}}function wrapConstructor(J){const E=te=>J().update(toBytes(te)).digest(),ee=J();return E.outputLen=ee.outputLen,E.blockLen=ee.blockLen,E.create=()=>J(),E}let HMAC$1=class extends Hash{constructor(J,E){super(),this.finished=!1,this.destroyed=!1,assert.hash(J);const ee=toBytes(E);if(this.iHash=J.create(),typeof this.iHash.update!="function")throw new TypeError("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const te=this.blockLen,re=new Uint8Array(te);re.set(ee.length>te?J.create().update(ee).digest():ee);for(let ne=0;ne<re.length;ne++)re[ne]^=54;this.iHash.update(re),this.oHash=J.create();for(let ne=0;ne<re.length;ne++)re[ne]^=106;this.oHash.update(re),re.fill(0)}update(J){return assert.exists(this),this.iHash.update(J),this}digestInto(J){assert.exists(this),assert.bytes(J,this.outputLen),this.finished=!0,this.iHash.digestInto(J),this.oHash.update(J),this.oHash.digestInto(J),this.destroy()}digest(){const J=new Uint8Array(this.oHash.outputLen);return this.digestInto(J),J}_cloneInto(J){J||(J=Object.create(Object.getPrototypeOf(this),{}));const{oHash:E,iHash:ee,finished:te,destroyed:re,blockLen:ne,outputLen:ie}=this;return J=J,J.finished=te,J.destroyed=re,J.blockLen=ne,J.outputLen=ie,J.oHash=E._cloneInto(J.oHash),J.iHash=ee._cloneInto(J.iHash),J}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};const hmac$2=(J,E,ee)=>new HMAC$1(J,E).update(ee).digest();hmac$2.create=(J,E)=>new HMAC$1(J,E);function extract(J,E,ee){return assert.hash(J),ee===void 0&&(ee=new Uint8Array(J.outputLen)),hmac$2(J,toBytes(ee),toBytes(E))}const HKDF_COUNTER=new Uint8Array([0]),EMPTY_BUFFER=new Uint8Array;function expand(J,E,ee,te=32){if(assert.hash(J),assert.number(te),te>255*J.outputLen)throw new Error("Length should be <= 255*HashLen");const re=Math.ceil(te/J.outputLen);ee===void 0&&(ee=EMPTY_BUFFER);const ne=new Uint8Array(re*J.outputLen),ie=hmac$2.create(J,E),se=ie._cloneInto(),oe=new Uint8Array(ie.outputLen);for(let ce=0;ce<re;ce++)HKDF_COUNTER[0]=ce+1,se.update(ce===0?EMPTY_BUFFER:oe).update(ee).update(HKDF_COUNTER).digestInto(oe),ne.set(oe,J.outputLen*ce),ie._cloneInto(se);return ie.destroy(),se.destroy(),oe.fill(0),HKDF_COUNTER.fill(0),ne.slice(0,te)}const hkdf$1=(J,E,ee,te,re)=>expand(J,extract(J,E,ee),te,re);function setBigUint64(J,E,ee,te){if(typeof J.setBigUint64=="function")return J.setBigUint64(E,ee,te);const re=BigInt(32),ne=BigInt(4294967295),ie=Number(ee>>re&ne),se=Number(ee&ne),oe=te?4:0,ce=te?0:4;J.setUint32(E+oe,ie,te),J.setUint32(E+ce,se,te)}class SHA2 extends Hash{constructor(E,ee,te,re){super(),this.blockLen=E,this.outputLen=ee,this.padOffset=te,this.isLE=re,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(E),this.view=createView(this.buffer)}update(E){assert.exists(this);const{view:ee,buffer:te,blockLen:re}=this;E=toBytes(E);const ne=E.length;for(let ie=0;ie<ne;){const se=Math.min(re-this.pos,ne-ie);if(se===re){const oe=createView(E);for(;re<=ne-ie;ie+=re)this.process(oe,ie);continue}te.set(E.subarray(ie,ie+se),this.pos),this.pos+=se,ie+=se,this.pos===re&&(this.process(ee,0),this.pos=0)}return this.length+=E.length,this.roundClean(),this}digestInto(E){assert.exists(this),assert.output(E,this),this.finished=!0;const{buffer:ee,view:te,blockLen:re,isLE:ne}=this;let{pos:ie}=this;ee[ie++]=128,this.buffer.subarray(ie).fill(0),this.padOffset>re-ie&&(this.process(te,0),ie=0);for(let le=ie;le<re;le++)ee[le]=0;setBigUint64(te,re-8,BigInt(this.length*8),ne),this.process(te,0);const se=createView(E),oe=this.outputLen;if(oe%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const ce=oe/4,ae=this.get();if(ce>ae.length)throw new Error("_sha2: outputLen bigger than state");for(let le=0;le<ce;le++)se.setUint32(4*le,ae[le],ne)}digest(){const{buffer:E,outputLen:ee}=this;this.digestInto(E);const te=E.slice(0,ee);return this.destroy(),te}_cloneInto(E){E||(E=new this.constructor),E.set(...this.get());const{blockLen:ee,buffer:te,length:re,finished:ne,destroyed:ie,pos:se}=this;return E.length=re,E.pos=se,E.finished=ne,E.destroyed=ie,re%ee&&E.buffer.set(te),E}}const Chi=(J,E,ee)=>J&E^~J&ee,Maj=(J,E,ee)=>J&E^J&ee^E&ee,SHA256_K=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),IV=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W=new Uint32Array(64);class SHA256 extends SHA2{constructor(){super(64,32,8,!1),this.A=IV[0]|0,this.B=IV[1]|0,this.C=IV[2]|0,this.D=IV[3]|0,this.E=IV[4]|0,this.F=IV[5]|0,this.G=IV[6]|0,this.H=IV[7]|0}get(){const{A:E,B:ee,C:te,D:re,E:ne,F:ie,G:se,H:oe}=this;return[E,ee,te,re,ne,ie,se,oe]}set(E,ee,te,re,ne,ie,se,oe){this.A=E|0,this.B=ee|0,this.C=te|0,this.D=re|0,this.E=ne|0,this.F=ie|0,this.G=se|0,this.H=oe|0}process(E,ee){for(let le=0;le<16;le++,ee+=4)SHA256_W[le]=E.getUint32(ee,!1);for(let le=16;le<64;le++){const ue=SHA256_W[le-15],he=SHA256_W[le-2],pe=rotr(ue,7)^rotr(ue,18)^ue>>>3,de=rotr(he,17)^rotr(he,19)^he>>>10;SHA256_W[le]=de+SHA256_W[le-7]+pe+SHA256_W[le-16]|0}let{A:te,B:re,C:ne,D:ie,E:se,F:oe,G:ce,H:ae}=this;for(let le=0;le<64;le++){const ue=rotr(se,6)^rotr(se,11)^rotr(se,25),he=ae+ue+Chi(se,oe,ce)+SHA256_K[le]+SHA256_W[le]|0,pe=(rotr(te,2)^rotr(te,13)^rotr(te,22))+Maj(te,re,ne)|0;ae=ce,ce=oe,oe=se,se=ie+he|0,ie=ne,ne=re,re=te,te=he+pe|0}te=te+this.A|0,re=re+this.B|0,ne=ne+this.C|0,ie=ie+this.D|0,se=se+this.E|0,oe=oe+this.F|0,ce=ce+this.G|0,ae=ae+this.H|0,this.set(te,re,ne,ie,se,oe,ce,ae)}roundClean(){SHA256_W.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class SHA224 extends SHA256{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const sha256$1=wrapConstructor(()=>new SHA256);wrapConstructor(()=>new SHA224);var chacha20poly1305={},chacha={};Object.defineProperty(chacha,"__esModule",{value:!0});var binary_1=binary,wipe_1$2=wipe$1,ROUNDS=20;function core(J,E,ee){for(var te=1634760805,re=857760878,ne=2036477234,ie=1797285236,se=ee[3]<<24|ee[2]<<16|ee[1]<<8|ee[0],oe=ee[7]<<24|ee[6]<<16|ee[5]<<8|ee[4],ce=ee[11]<<24|ee[10]<<16|ee[9]<<8|ee[8],ae=ee[15]<<24|ee[14]<<16|ee[13]<<8|ee[12],le=ee[19]<<24|ee[18]<<16|ee[17]<<8|ee[16],ue=ee[23]<<24|ee[22]<<16|ee[21]<<8|ee[20],he=ee[27]<<24|ee[26]<<16|ee[25]<<8|ee[24],pe=ee[31]<<24|ee[30]<<16|ee[29]<<8|ee[28],de=E[3]<<24|E[2]<<16|E[1]<<8|E[0],fe=E[7]<<24|E[6]<<16|E[5]<<8|E[4],me=E[11]<<24|E[10]<<16|E[9]<<8|E[8],_e=E[15]<<24|E[14]<<16|E[13]<<8|E[12],be=te,Ee=re,ve=ne,we=ie,ge=se,Se=oe,$e=ce,Pe=ae,Me=le,xe=ue,Fe=he,ke=pe,Te=de,Ve=fe,Ce=me,Ne=_e,Oe=0;Oe<ROUNDS;Oe+=2)be=be+ge|0,Te^=be,Te=Te>>>32-16|Te<<16,Me=Me+Te|0,ge^=Me,ge=ge>>>32-12|ge<<12,Ee=Ee+Se|0,Ve^=Ee,Ve=Ve>>>32-16|Ve<<16,xe=xe+Ve|0,Se^=xe,Se=Se>>>32-12|Se<<12,ve=ve+$e|0,Ce^=ve,Ce=Ce>>>32-16|Ce<<16,Fe=Fe+Ce|0,$e^=Fe,$e=$e>>>32-12|$e<<12,we=we+Pe|0,Ne^=we,Ne=Ne>>>32-16|Ne<<16,ke=ke+Ne|0,Pe^=ke,Pe=Pe>>>32-12|Pe<<12,ve=ve+$e|0,Ce^=ve,Ce=Ce>>>32-8|Ce<<8,Fe=Fe+Ce|0,$e^=Fe,$e=$e>>>32-7|$e<<7,we=we+Pe|0,Ne^=we,Ne=Ne>>>32-8|Ne<<8,ke=ke+Ne|0,Pe^=ke,Pe=Pe>>>32-7|Pe<<7,Ee=Ee+Se|0,Ve^=Ee,Ve=Ve>>>32-8|Ve<<8,xe=xe+Ve|0,Se^=xe,Se=Se>>>32-7|Se<<7,be=be+ge|0,Te^=be,Te=Te>>>32-8|Te<<8,Me=Me+Te|0,ge^=Me,ge=ge>>>32-7|ge<<7,be=be+Se|0,Ne^=be,Ne=Ne>>>32-16|Ne<<16,Fe=Fe+Ne|0,Se^=Fe,Se=Se>>>32-12|Se<<12,Ee=Ee+$e|0,Te^=Ee,Te=Te>>>32-16|Te<<16,ke=ke+Te|0,$e^=ke,$e=$e>>>32-12|$e<<12,ve=ve+Pe|0,Ve^=ve,Ve=Ve>>>32-16|Ve<<16,Me=Me+Ve|0,Pe^=Me,Pe=Pe>>>32-12|Pe<<12,we=we+ge|0,Ce^=we,Ce=Ce>>>32-16|Ce<<16,xe=xe+Ce|0,ge^=xe,ge=ge>>>32-12|ge<<12,ve=ve+Pe|0,Ve^=ve,Ve=Ve>>>32-8|Ve<<8,Me=Me+Ve|0,Pe^=Me,Pe=Pe>>>32-7|Pe<<7,we=we+ge|0,Ce^=we,Ce=Ce>>>32-8|Ce<<8,xe=xe+Ce|0,ge^=xe,ge=ge>>>32-7|ge<<7,Ee=Ee+$e|0,Te^=Ee,Te=Te>>>32-8|Te<<8,ke=ke+Te|0,$e^=ke,$e=$e>>>32-7|$e<<7,be=be+Se|0,Ne^=be,Ne=Ne>>>32-8|Ne<<8,Fe=Fe+Ne|0,Se^=Fe,Se=Se>>>32-7|Se<<7;binary_1.writeUint32LE(be+te|0,J,0),binary_1.writeUint32LE(Ee+re|0,J,4),binary_1.writeUint32LE(ve+ne|0,J,8),binary_1.writeUint32LE(we+ie|0,J,12),binary_1.writeUint32LE(ge+se|0,J,16),binary_1.writeUint32LE(Se+oe|0,J,20),binary_1.writeUint32LE($e+ce|0,J,24),binary_1.writeUint32LE(Pe+ae|0,J,28),binary_1.writeUint32LE(Me+le|0,J,32),binary_1.writeUint32LE(xe+ue|0,J,36),binary_1.writeUint32LE(Fe+he|0,J,40),binary_1.writeUint32LE(ke+pe|0,J,44),binary_1.writeUint32LE(Te+de|0,J,48),binary_1.writeUint32LE(Ve+fe|0,J,52),binary_1.writeUint32LE(Ce+me|0,J,56),binary_1.writeUint32LE(Ne+_e|0,J,60)}function streamXOR(J,E,ee,te,re){if(re===void 0&&(re=0),J.length!==32)throw new Error("ChaCha: key size must be 32 bytes");if(te.length<ee.length)throw new Error("ChaCha: destination is shorter than source");var ne,ie;if(re===0){if(E.length!==8&&E.length!==12)throw new Error("ChaCha nonce must be 8 or 12 bytes");ne=new Uint8Array(16),ie=ne.length-E.length,ne.set(E,ie)}else{if(E.length!==16)throw new Error("ChaCha nonce with counter must be 16 bytes");ne=E,ie=re}for(var se=new Uint8Array(64),oe=0;oe<ee.length;oe+=64){core(se,ne,J);for(var ce=oe;ce<oe+64&&ce<ee.length;ce++)te[ce]=ee[ce]^se[ce-oe];incrementCounter(ne,0,ie)}return wipe_1$2.wipe(se),re===0&&wipe_1$2.wipe(ne),te}chacha.streamXOR=streamXOR;function stream(J,E,ee,te){return te===void 0&&(te=0),wipe_1$2.wipe(ee),streamXOR(J,E,ee,ee,te)}chacha.stream=stream;function incrementCounter(J,E,ee){for(var te=1;ee--;)te=te+(J[E]&255)|0,J[E]=te&255,te>>>=8,E++;if(te>0)throw new Error("ChaCha: counter overflow")}var poly1305={},constantTime={};Object.defineProperty(constantTime,"__esModule",{value:!0});function select(J,E,ee){return~(J-1)&E|J-1&ee}constantTime.select=select;function lessOrEqual(J,E){return(J|0)-(E|0)-1>>>31&1}constantTime.lessOrEqual=lessOrEqual;function compare$2(J,E){if(J.length!==E.length)return 0;for(var ee=0,te=0;te<J.length;te++)ee|=J[te]^E[te];return 1&ee-1>>>8}constantTime.compare=compare$2;function equal(J,E){return J.length===0||E.length===0?!1:compare$2(J,E)!==0}constantTime.equal=equal;(function(J){Object.defineProperty(J,"__esModule",{value:!0});var E=constantTime,ee=wipe$1;J.DIGEST_LENGTH=16;var te=function(){function ie(se){this.digestLength=J.DIGEST_LENGTH,this._buffer=new Uint8Array(16),this._r=new Uint16Array(10),this._h=new Uint16Array(10),this._pad=new Uint16Array(8),this._leftover=0,this._fin=0,this._finished=!1;var oe=se[0]|se[1]<<8;this._r[0]=oe&8191;var ce=se[2]|se[3]<<8;this._r[1]=(oe>>>13|ce<<3)&8191;var ae=se[4]|se[5]<<8;this._r[2]=(ce>>>10|ae<<6)&7939;var le=se[6]|se[7]<<8;this._r[3]=(ae>>>7|le<<9)&8191;var ue=se[8]|se[9]<<8;this._r[4]=(le>>>4|ue<<12)&255,this._r[5]=ue>>>1&8190;var he=se[10]|se[11]<<8;this._r[6]=(ue>>>14|he<<2)&8191;var pe=se[12]|se[13]<<8;this._r[7]=(he>>>11|pe<<5)&8065;var de=se[14]|se[15]<<8;this._r[8]=(pe>>>8|de<<8)&8191,this._r[9]=de>>>5&127,this._pad[0]=se[16]|se[17]<<8,this._pad[1]=se[18]|se[19]<<8,this._pad[2]=se[20]|se[21]<<8,this._pad[3]=se[22]|se[23]<<8,this._pad[4]=se[24]|se[25]<<8,this._pad[5]=se[26]|se[27]<<8,this._pad[6]=se[28]|se[29]<<8,this._pad[7]=se[30]|se[31]<<8}return ie.prototype._blocks=function(se,oe,ce){for(var ae=this._fin?0:2048,le=this._h[0],ue=this._h[1],he=this._h[2],pe=this._h[3],de=this._h[4],fe=this._h[5],me=this._h[6],_e=this._h[7],be=this._h[8],Ee=this._h[9],ve=this._r[0],we=this._r[1],ge=this._r[2],Se=this._r[3],$e=this._r[4],Pe=this._r[5],Me=this._r[6],xe=this._r[7],Fe=this._r[8],ke=this._r[9];ce>=16;){var Te=se[oe+0]|se[oe+1]<<8;le+=Te&8191;var Ve=se[oe+2]|se[oe+3]<<8;ue+=(Te>>>13|Ve<<3)&8191;var Ce=se[oe+4]|se[oe+5]<<8;he+=(Ve>>>10|Ce<<6)&8191;var Ne=se[oe+6]|se[oe+7]<<8;pe+=(Ce>>>7|Ne<<9)&8191;var Oe=se[oe+8]|se[oe+9]<<8;de+=(Ne>>>4|Oe<<12)&8191,fe+=Oe>>>1&8191;var Le=se[oe+10]|se[oe+11]<<8;me+=(Oe>>>14|Le<<2)&8191;var Be=se[oe+12]|se[oe+13]<<8;_e+=(Le>>>11|Be<<5)&8191;var ze=se[oe+14]|se[oe+15]<<8;be+=(Be>>>8|ze<<8)&8191,Ee+=ze>>>5|ae;var Ue=0,Ge=Ue;Ge+=le*ve,Ge+=ue*(5*ke),Ge+=he*(5*Fe),Ge+=pe*(5*xe),Ge+=de*(5*Me),Ue=Ge>>>13,Ge&=8191,Ge+=fe*(5*Pe),Ge+=me*(5*$e),Ge+=_e*(5*Se),Ge+=be*(5*ge),Ge+=Ee*(5*we),Ue+=Ge>>>13,Ge&=8191;var je=Ue;je+=le*we,je+=ue*ve,je+=he*(5*ke),je+=pe*(5*Fe),je+=de*(5*xe),Ue=je>>>13,je&=8191,je+=fe*(5*Me),je+=me*(5*Pe),je+=_e*(5*$e),je+=be*(5*Se),je+=Ee*(5*ge),Ue+=je>>>13,je&=8191;var We=Ue;We+=le*ge,We+=ue*we,We+=he*ve,We+=pe*(5*ke),We+=de*(5*Fe),Ue=We>>>13,We&=8191,We+=fe*(5*xe),We+=me*(5*Me),We+=_e*(5*Pe),We+=be*(5*$e),We+=Ee*(5*Se),Ue+=We>>>13,We&=8191;var Ae=Ue;Ae+=le*Se,Ae+=ue*ge,Ae+=he*we,Ae+=pe*ve,Ae+=de*(5*ke),Ue=Ae>>>13,Ae&=8191,Ae+=fe*(5*Fe),Ae+=me*(5*xe),Ae+=_e*(5*Me),Ae+=be*(5*Pe),Ae+=Ee*(5*$e),Ue+=Ae>>>13,Ae&=8191;var De=Ue;De+=le*$e,De+=ue*Se,De+=he*ge,De+=pe*we,De+=de*ve,Ue=De>>>13,De&=8191,De+=fe*(5*ke),De+=me*(5*Fe),De+=_e*(5*xe),De+=be*(5*Me),De+=Ee*(5*Pe),Ue+=De>>>13,De&=8191;var Ie=Ue;Ie+=le*Pe,Ie+=ue*$e,Ie+=he*Se,Ie+=pe*ge,Ie+=de*we,Ue=Ie>>>13,Ie&=8191,Ie+=fe*ve,Ie+=me*(5*ke),Ie+=_e*(5*Fe),Ie+=be*(5*xe),Ie+=Ee*(5*Me),Ue+=Ie>>>13,Ie&=8191;var ye=Ue;ye+=le*Me,ye+=ue*Pe,ye+=he*$e,ye+=pe*Se,ye+=de*ge,Ue=ye>>>13,ye&=8191,ye+=fe*we,ye+=me*ve,ye+=_e*(5*ke),ye+=be*(5*Fe),ye+=Ee*(5*xe),Ue+=ye>>>13,ye&=8191;var Re=Ue;Re+=le*xe,Re+=ue*Me,Re+=he*Pe,Re+=pe*$e,Re+=de*Se,Ue=Re>>>13,Re&=8191,Re+=fe*ge,Re+=me*we,Re+=_e*ve,Re+=be*(5*ke),Re+=Ee*(5*Fe),Ue+=Re>>>13,Re&=8191;var Ke=Ue;Ke+=le*Fe,Ke+=ue*xe,Ke+=he*Me,Ke+=pe*Pe,Ke+=de*$e,Ue=Ke>>>13,Ke&=8191,Ke+=fe*Se,Ke+=me*ge,Ke+=_e*we,Ke+=be*ve,Ke+=Ee*(5*ke),Ue+=Ke>>>13,Ke&=8191;var He=Ue;He+=le*ke,He+=ue*Fe,He+=he*xe,He+=pe*Me,He+=de*Pe,Ue=He>>>13,He&=8191,He+=fe*$e,He+=me*Se,He+=_e*ge,He+=be*we,He+=Ee*ve,Ue+=He>>>13,He&=8191,Ue=(Ue<<2)+Ue|0,Ue=Ue+Ge|0,Ge=Ue&8191,Ue=Ue>>>13,je+=Ue,le=Ge,ue=je,he=We,pe=Ae,de=De,fe=Ie,me=ye,_e=Re,be=Ke,Ee=He,oe+=16,ce-=16}this._h[0]=le,this._h[1]=ue,this._h[2]=he,this._h[3]=pe,this._h[4]=de,this._h[5]=fe,this._h[6]=me,this._h[7]=_e,this._h[8]=be,this._h[9]=Ee},ie.prototype.finish=function(se,oe){oe===void 0&&(oe=0);var ce=new Uint16Array(10),ae,le,ue,he;if(this._leftover){for(he=this._leftover,this._buffer[he++]=1;he<16;he++)this._buffer[he]=0;this._fin=1,this._blocks(this._buffer,0,16)}for(ae=this._h[1]>>>13,this._h[1]&=8191,he=2;he<10;he++)this._h[he]+=ae,ae=this._h[he]>>>13,this._h[he]&=8191;for(this._h[0]+=ae*5,ae=this._h[0]>>>13,this._h[0]&=8191,this._h[1]+=ae,ae=this._h[1]>>>13,this._h[1]&=8191,this._h[2]+=ae,ce[0]=this._h[0]+5,ae=ce[0]>>>13,ce[0]&=8191,he=1;he<10;he++)ce[he]=this._h[he]+ae,ae=ce[he]>>>13,ce[he]&=8191;for(ce[9]-=8192,le=(ae^1)-1,he=0;he<10;he++)ce[he]&=le;for(le=~le,he=0;he<10;he++)this._h[he]=this._h[he]&le|ce[he];for(this._h[0]=(this._h[0]|this._h[1]<<13)&65535,this._h[1]=(this._h[1]>>>3|this._h[2]<<10)&65535,this._h[2]=(this._h[2]>>>6|this._h[3]<<7)&65535,this._h[3]=(this._h[3]>>>9|this._h[4]<<4)&65535,this._h[4]=(this._h[4]>>>12|this._h[5]<<1|this._h[6]<<14)&65535,this._h[5]=(this._h[6]>>>2|this._h[7]<<11)&65535,this._h[6]=(this._h[7]>>>5|this._h[8]<<8)&65535,this._h[7]=(this._h[8]>>>8|this._h[9]<<5)&65535,ue=this._h[0]+this._pad[0],this._h[0]=ue&65535,he=1;he<8;he++)ue=(this._h[he]+this._pad[he]|0)+(ue>>>16)|0,this._h[he]=ue&65535;return se[oe+0]=this._h[0]>>>0,se[oe+1]=this._h[0]>>>8,se[oe+2]=this._h[1]>>>0,se[oe+3]=this._h[1]>>>8,se[oe+4]=this._h[2]>>>0,se[oe+5]=this._h[2]>>>8,se[oe+6]=this._h[3]>>>0,se[oe+7]=this._h[3]>>>8,se[oe+8]=this._h[4]>>>0,se[oe+9]=this._h[4]>>>8,se[oe+10]=this._h[5]>>>0,se[oe+11]=this._h[5]>>>8,se[oe+12]=this._h[6]>>>0,se[oe+13]=this._h[6]>>>8,se[oe+14]=this._h[7]>>>0,se[oe+15]=this._h[7]>>>8,this._finished=!0,this},ie.prototype.update=function(se){var oe=0,ce=se.length,ae;if(this._leftover){ae=16-this._leftover,ae>ce&&(ae=ce);for(var le=0;le<ae;le++)this._buffer[this._leftover+le]=se[oe+le];if(ce-=ae,oe+=ae,this._leftover+=ae,this._leftover<16)return this;this._blocks(this._buffer,0,16),this._leftover=0}if(ce>=16&&(ae=ce-ce%16,this._blocks(se,oe,ae),oe+=ae,ce-=ae),ce){for(var le=0;le<ce;le++)this._buffer[this._leftover+le]=se[oe+le];this._leftover+=ce}return this},ie.prototype.digest=function(){if(this._finished)throw new Error("Poly1305 was finished");var se=new Uint8Array(16);return this.finish(se),se},ie.prototype.clean=function(){return ee.wipe(this._buffer),ee.wipe(this._r),ee.wipe(this._h),ee.wipe(this._pad),this._leftover=0,this._fin=0,this._finished=!0,this},ie}();J.Poly1305=te;function re(ie,se){var oe=new te(ie);oe.update(se);var ce=oe.digest();return oe.clean(),ce}J.oneTimeAuth=re;function ne(ie,se){return ie.length!==J.DIGEST_LENGTH||se.length!==J.DIGEST_LENGTH?!1:E.equal(ie,se)}J.equal=ne})(poly1305);(function(J){Object.defineProperty(J,"__esModule",{value:!0});var E=chacha,ee=poly1305,te=wipe$1,re=binary,ne=constantTime;J.KEY_LENGTH=32,J.NONCE_LENGTH=12,J.TAG_LENGTH=16;var ie=new Uint8Array(16),se=function(){function oe(ce){if(this.nonceLength=J.NONCE_LENGTH,this.tagLength=J.TAG_LENGTH,ce.length!==J.KEY_LENGTH)throw new Error("ChaCha20Poly1305 needs 32-byte key");this._key=new Uint8Array(ce)}return oe.prototype.seal=function(ce,ae,le,ue){if(ce.length>16)throw new Error("ChaCha20Poly1305: incorrect nonce length");var he=new Uint8Array(16);he.set(ce,he.length-ce.length);var pe=new Uint8Array(32);E.stream(this._key,he,pe,4);var de=ae.length+this.tagLength,fe;if(ue){if(ue.length!==de)throw new Error("ChaCha20Poly1305: incorrect destination length");fe=ue}else fe=new Uint8Array(de);return E.streamXOR(this._key,he,ae,fe,4),this._authenticate(fe.subarray(fe.length-this.tagLength,fe.length),pe,fe.subarray(0,fe.length-this.tagLength),le),te.wipe(he),fe},oe.prototype.open=function(ce,ae,le,ue){if(ce.length>16)throw new Error("ChaCha20Poly1305: incorrect nonce length");if(ae.length<this.tagLength)return null;var he=new Uint8Array(16);he.set(ce,he.length-ce.length);var pe=new Uint8Array(32);E.stream(this._key,he,pe,4);var de=new Uint8Array(this.tagLength);if(this._authenticate(de,pe,ae.subarray(0,ae.length-this.tagLength),le),!ne.equal(de,ae.subarray(ae.length-this.tagLength,ae.length)))return null;var fe=ae.length-this.tagLength,me;if(ue){if(ue.length!==fe)throw new Error("ChaCha20Poly1305: incorrect destination length");me=ue}else me=new Uint8Array(fe);return E.streamXOR(this._key,he,ae.subarray(0,ae.length-this.tagLength),me,4),te.wipe(he),me},oe.prototype.clean=function(){return te.wipe(this._key),this},oe.prototype._authenticate=function(ce,ae,le,ue){var he=new ee.Poly1305(ae);ue&&(he.update(ue),ue.length%16>0&&he.update(ie.subarray(ue.length%16))),he.update(le),le.length%16>0&&he.update(ie.subarray(le.length%16));var pe=new Uint8Array(8);ue&&re.writeUint64LE(ue.length,pe),he.update(pe),re.writeUint64LE(le.length,pe),he.update(pe);for(var de=he.digest(),fe=0;fe<de.length;fe++)ce[fe]=de[fe];he.clean(),te.wipe(de),te.wipe(pe)},oe}();J.ChaCha20Poly1305=se})(chacha20poly1305);var x25519={};(function(J){Object.defineProperty(J,"__esModule",{value:!0}),J.sharedKey=J.generateKeyPair=J.generateKeyPairFromSeed=J.scalarMultBase=J.scalarMult=J.SHARED_KEY_LENGTH=J.SECRET_KEY_LENGTH=J.PUBLIC_KEY_LENGTH=void 0;const E=random,ee=wipe$1;J.PUBLIC_KEY_LENGTH=32,J.SECRET_KEY_LENGTH=32,J.SHARED_KEY_LENGTH=32;function te(Ee){const ve=new Float64Array(16);if(Ee)for(let we=0;we<Ee.length;we++)ve[we]=Ee[we];return ve}const re=new Uint8Array(32);re[0]=9;const ne=te([56129,1]);function ie(Ee){let ve=1;for(let we=0;we<16;we++){let ge=Ee[we]+ve+65535;ve=Math.floor(ge/65536),Ee[we]=ge-ve*65536}Ee[0]+=ve-1+37*(ve-1)}function se(Ee,ve,we){const ge=~(we-1);for(let Se=0;Se<16;Se++){const $e=ge&(Ee[Se]^ve[Se]);Ee[Se]^=$e,ve[Se]^=$e}}function oe(Ee,ve){const we=te(),ge=te();for(let Se=0;Se<16;Se++)ge[Se]=ve[Se];ie(ge),ie(ge),ie(ge);for(let Se=0;Se<2;Se++){we[0]=ge[0]-65517;for(let Pe=1;Pe<15;Pe++)we[Pe]=ge[Pe]-65535-(we[Pe-1]>>16&1),we[Pe-1]&=65535;we[15]=ge[15]-32767-(we[14]>>16&1);const $e=we[15]>>16&1;we[14]&=65535,se(ge,we,1-$e)}for(let Se=0;Se<16;Se++)Ee[2*Se]=ge[Se]&255,Ee[2*Se+1]=ge[Se]>>8}function ce(Ee,ve){for(let we=0;we<16;we++)Ee[we]=ve[2*we]+(ve[2*we+1]<<8);Ee[15]&=32767}function ae(Ee,ve,we){for(let ge=0;ge<16;ge++)Ee[ge]=ve[ge]+we[ge]}function le(Ee,ve,we){for(let ge=0;ge<16;ge++)Ee[ge]=ve[ge]-we[ge]}function ue(Ee,ve,we){let ge,Se,$e=0,Pe=0,Me=0,xe=0,Fe=0,ke=0,Te=0,Ve=0,Ce=0,Ne=0,Oe=0,Le=0,Be=0,ze=0,Ue=0,Ge=0,je=0,We=0,Ae=0,De=0,Ie=0,ye=0,Re=0,Ke=0,He=0,qe=0,Ye=0,rt=0,ot=0,ft=0,gt=0,it=we[0],nt=we[1],et=we[2],tt=we[3],Qe=we[4],Xe=we[5],Je=we[6],Ze=we[7],st=we[8],at=we[9],ct=we[10],lt=we[11],ut=we[12],ht=we[13],dt=we[14],pt=we[15];ge=ve[0],$e+=ge*it,Pe+=ge*nt,Me+=ge*et,xe+=ge*tt,Fe+=ge*Qe,ke+=ge*Xe,Te+=ge*Je,Ve+=ge*Ze,Ce+=ge*st,Ne+=ge*at,Oe+=ge*ct,Le+=ge*lt,Be+=ge*ut,ze+=ge*ht,Ue+=ge*dt,Ge+=ge*pt,ge=ve[1],Pe+=ge*it,Me+=ge*nt,xe+=ge*et,Fe+=ge*tt,ke+=ge*Qe,Te+=ge*Xe,Ve+=ge*Je,Ce+=ge*Ze,Ne+=ge*st,Oe+=ge*at,Le+=ge*ct,Be+=ge*lt,ze+=ge*ut,Ue+=ge*ht,Ge+=ge*dt,je+=ge*pt,ge=ve[2],Me+=ge*it,xe+=ge*nt,Fe+=ge*et,ke+=ge*tt,Te+=ge*Qe,Ve+=ge*Xe,Ce+=ge*Je,Ne+=ge*Ze,Oe+=ge*st,Le+=ge*at,Be+=ge*ct,ze+=ge*lt,Ue+=ge*ut,Ge+=ge*ht,je+=ge*dt,We+=ge*pt,ge=ve[3],xe+=ge*it,Fe+=ge*nt,ke+=ge*et,Te+=ge*tt,Ve+=ge*Qe,Ce+=ge*Xe,Ne+=ge*Je,Oe+=ge*Ze,Le+=ge*st,Be+=ge*at,ze+=ge*ct,Ue+=ge*lt,Ge+=ge*ut,je+=ge*ht,We+=ge*dt,Ae+=ge*pt,ge=ve[4],Fe+=ge*it,ke+=ge*nt,Te+=ge*et,Ve+=ge*tt,Ce+=ge*Qe,Ne+=ge*Xe,Oe+=ge*Je,Le+=ge*Ze,Be+=ge*st,ze+=ge*at,Ue+=ge*ct,Ge+=ge*lt,je+=ge*ut,We+=ge*ht,Ae+=ge*dt,De+=ge*pt,ge=ve[5],ke+=ge*it,Te+=ge*nt,Ve+=ge*et,Ce+=ge*tt,Ne+=ge*Qe,Oe+=ge*Xe,Le+=ge*Je,Be+=ge*Ze,ze+=ge*st,Ue+=ge*at,Ge+=ge*ct,je+=ge*lt,We+=ge*ut,Ae+=ge*ht,De+=ge*dt,Ie+=ge*pt,ge=ve[6],Te+=ge*it,Ve+=ge*nt,Ce+=ge*et,Ne+=ge*tt,Oe+=ge*Qe,Le+=ge*Xe,Be+=ge*Je,ze+=ge*Ze,Ue+=ge*st,Ge+=ge*at,je+=ge*ct,We+=ge*lt,Ae+=ge*ut,De+=ge*ht,Ie+=ge*dt,ye+=ge*pt,ge=ve[7],Ve+=ge*it,Ce+=ge*nt,Ne+=ge*et,Oe+=ge*tt,Le+=ge*Qe,Be+=ge*Xe,ze+=ge*Je,Ue+=ge*Ze,Ge+=ge*st,je+=ge*at,We+=ge*ct,Ae+=ge*lt,De+=ge*ut,Ie+=ge*ht,ye+=ge*dt,Re+=ge*pt,ge=ve[8],Ce+=ge*it,Ne+=ge*nt,Oe+=ge*et,Le+=ge*tt,Be+=ge*Qe,ze+=ge*Xe,Ue+=ge*Je,Ge+=ge*Ze,je+=ge*st,We+=ge*at,Ae+=ge*ct,De+=ge*lt,Ie+=ge*ut,ye+=ge*ht,Re+=ge*dt,Ke+=ge*pt,ge=ve[9],Ne+=ge*it,Oe+=ge*nt,Le+=ge*et,Be+=ge*tt,ze+=ge*Qe,Ue+=ge*Xe,Ge+=ge*Je,je+=ge*Ze,We+=ge*st,Ae+=ge*at,De+=ge*ct,Ie+=ge*lt,ye+=ge*ut,Re+=ge*ht,Ke+=ge*dt,He+=ge*pt,ge=ve[10],Oe+=ge*it,Le+=ge*nt,Be+=ge*et,ze+=ge*tt,Ue+=ge*Qe,Ge+=ge*Xe,je+=ge*Je,We+=ge*Ze,Ae+=ge*st,De+=ge*at,Ie+=ge*ct,ye+=ge*lt,Re+=ge*ut,Ke+=ge*ht,He+=ge*dt,qe+=ge*pt,ge=ve[11],Le+=ge*it,Be+=ge*nt,ze+=ge*et,Ue+=ge*tt,Ge+=ge*Qe,je+=ge*Xe,We+=ge*Je,Ae+=ge*Ze,De+=ge*st,Ie+=ge*at,ye+=ge*ct,Re+=ge*lt,Ke+=ge*ut,He+=ge*ht,qe+=ge*dt,Ye+=ge*pt,ge=ve[12],Be+=ge*it,ze+=ge*nt,Ue+=ge*et,Ge+=ge*tt,je+=ge*Qe,We+=ge*Xe,Ae+=ge*Je,De+=ge*Ze,Ie+=ge*st,ye+=ge*at,Re+=ge*ct,Ke+=ge*lt,He+=ge*ut,qe+=ge*ht,Ye+=ge*dt,rt+=ge*pt,ge=ve[13],ze+=ge*it,Ue+=ge*nt,Ge+=ge*et,je+=ge*tt,We+=ge*Qe,Ae+=ge*Xe,De+=ge*Je,Ie+=ge*Ze,ye+=ge*st,Re+=ge*at,Ke+=ge*ct,He+=ge*lt,qe+=ge*ut,Ye+=ge*ht,rt+=ge*dt,ot+=ge*pt,ge=ve[14],Ue+=ge*it,Ge+=ge*nt,je+=ge*et,We+=ge*tt,Ae+=ge*Qe,De+=ge*Xe,Ie+=ge*Je,ye+=ge*Ze,Re+=ge*st,Ke+=ge*at,He+=ge*ct,qe+=ge*lt,Ye+=ge*ut,rt+=ge*ht,ot+=ge*dt,ft+=ge*pt,ge=ve[15],Ge+=ge*it,je+=ge*nt,We+=ge*et,Ae+=ge*tt,De+=ge*Qe,Ie+=ge*Xe,ye+=ge*Je,Re+=ge*Ze,Ke+=ge*st,He+=ge*at,qe+=ge*ct,Ye+=ge*lt,rt+=ge*ut,ot+=ge*ht,ft+=ge*dt,gt+=ge*pt,$e+=38*je,Pe+=38*We,Me+=38*Ae,xe+=38*De,Fe+=38*Ie,ke+=38*ye,Te+=38*Re,Ve+=38*Ke,Ce+=38*He,Ne+=38*qe,Oe+=38*Ye,Le+=38*rt,Be+=38*ot,ze+=38*ft,Ue+=38*gt,Se=1,ge=$e+Se+65535,Se=Math.floor(ge/65536),$e=ge-Se*65536,ge=Pe+Se+65535,Se=Math.floor(ge/65536),Pe=ge-Se*65536,ge=Me+Se+65535,Se=Math.floor(ge/65536),Me=ge-Se*65536,ge=xe+Se+65535,Se=Math.floor(ge/65536),xe=ge-Se*65536,ge=Fe+Se+65535,Se=Math.floor(ge/65536),Fe=ge-Se*65536,ge=ke+Se+65535,Se=Math.floor(ge/65536),ke=ge-Se*65536,ge=Te+Se+65535,Se=Math.floor(ge/65536),Te=ge-Se*65536,ge=Ve+Se+65535,Se=Math.floor(ge/65536),Ve=ge-Se*65536,ge=Ce+Se+65535,Se=Math.floor(ge/65536),Ce=ge-Se*65536,ge=Ne+Se+65535,Se=Math.floor(ge/65536),Ne=ge-Se*65536,ge=Oe+Se+65535,Se=Math.floor(ge/65536),Oe=ge-Se*65536,ge=Le+Se+65535,Se=Math.floor(ge/65536),Le=ge-Se*65536,ge=Be+Se+65535,Se=Math.floor(ge/65536),Be=ge-Se*65536,ge=ze+Se+65535,Se=Math.floor(ge/65536),ze=ge-Se*65536,ge=Ue+Se+65535,Se=Math.floor(ge/65536),Ue=ge-Se*65536,ge=Ge+Se+65535,Se=Math.floor(ge/65536),Ge=ge-Se*65536,$e+=Se-1+37*(Se-1),Se=1,ge=$e+Se+65535,Se=Math.floor(ge/65536),$e=ge-Se*65536,ge=Pe+Se+65535,Se=Math.floor(ge/65536),Pe=ge-Se*65536,ge=Me+Se+65535,Se=Math.floor(ge/65536),Me=ge-Se*65536,ge=xe+Se+65535,Se=Math.floor(ge/65536),xe=ge-Se*65536,ge=Fe+Se+65535,Se=Math.floor(ge/65536),Fe=ge-Se*65536,ge=ke+Se+65535,Se=Math.floor(ge/65536),ke=ge-Se*65536,ge=Te+Se+65535,Se=Math.floor(ge/65536),Te=ge-Se*65536,ge=Ve+Se+65535,Se=Math.floor(ge/65536),Ve=ge-Se*65536,ge=Ce+Se+65535,Se=Math.floor(ge/65536),Ce=ge-Se*65536,ge=Ne+Se+65535,Se=Math.floor(ge/65536),Ne=ge-Se*65536,ge=Oe+Se+65535,Se=Math.floor(ge/65536),Oe=ge-Se*65536,ge=Le+Se+65535,Se=Math.floor(ge/65536),Le=ge-Se*65536,ge=Be+Se+65535,Se=Math.floor(ge/65536),Be=ge-Se*65536,ge=ze+Se+65535,Se=Math.floor(ge/65536),ze=ge-Se*65536,ge=Ue+Se+65535,Se=Math.floor(ge/65536),Ue=ge-Se*65536,ge=Ge+Se+65535,Se=Math.floor(ge/65536),Ge=ge-Se*65536,$e+=Se-1+37*(Se-1),Ee[0]=$e,Ee[1]=Pe,Ee[2]=Me,Ee[3]=xe,Ee[4]=Fe,Ee[5]=ke,Ee[6]=Te,Ee[7]=Ve,Ee[8]=Ce,Ee[9]=Ne,Ee[10]=Oe,Ee[11]=Le,Ee[12]=Be,Ee[13]=ze,Ee[14]=Ue,Ee[15]=Ge}function he(Ee,ve){ue(Ee,ve,ve)}function pe(Ee,ve){const we=te();for(let ge=0;ge<16;ge++)we[ge]=ve[ge];for(let ge=253;ge>=0;ge--)he(we,we),ge!==2&&ge!==4&&ue(we,we,ve);for(let ge=0;ge<16;ge++)Ee[ge]=we[ge]}function de(Ee,ve){const we=new Uint8Array(32),ge=new Float64Array(80),Se=te(),$e=te(),Pe=te(),Me=te(),xe=te(),Fe=te();for(let Ce=0;Ce<31;Ce++)we[Ce]=Ee[Ce];we[31]=Ee[31]&127|64,we[0]&=248,ce(ge,ve);for(let Ce=0;Ce<16;Ce++)$e[Ce]=ge[Ce];Se[0]=Me[0]=1;for(let Ce=254;Ce>=0;--Ce){const Ne=we[Ce>>>3]>>>(Ce&7)&1;se(Se,$e,Ne),se(Pe,Me,Ne),ae(xe,Se,Pe),le(Se,Se,Pe),ae(Pe,$e,Me),le($e,$e,Me),he(Me,xe),he(Fe,Se),ue(Se,Pe,Se),ue(Pe,$e,xe),ae(xe,Se,Pe),le(Se,Se,Pe),he($e,Se),le(Pe,Me,Fe),ue(Se,Pe,ne),ae(Se,Se,Me),ue(Pe,Pe,Se),ue(Se,Me,Fe),ue(Me,$e,ge),he($e,xe),se(Se,$e,Ne),se(Pe,Me,Ne)}for(let Ce=0;Ce<16;Ce++)ge[Ce+16]=Se[Ce],ge[Ce+32]=Pe[Ce],ge[Ce+48]=$e[Ce],ge[Ce+64]=Me[Ce];const ke=ge.subarray(32),Te=ge.subarray(16);pe(ke,ke),ue(Te,Te,ke);const Ve=new Uint8Array(32);return oe(Ve,Te),Ve}J.scalarMult=de;function fe(Ee){return de(Ee,re)}J.scalarMultBase=fe;function me(Ee){if(Ee.length!==J.SECRET_KEY_LENGTH)throw new Error(`x25519: seed must be ${J.SECRET_KEY_LENGTH} bytes`);const ve=new Uint8Array(Ee);return{publicKey:fe(ve),secretKey:ve}}J.generateKeyPairFromSeed=me;function _e(Ee){const ve=(0,E.randomBytes)(32,Ee),we=me(ve);return(0,ee.wipe)(ve),we}J.generateKeyPair=_e;function be(Ee,ve,we=!1){if(Ee.length!==J.PUBLIC_KEY_LENGTH)throw new Error("X25519: incorrect secret key length");if(ve.length!==J.PUBLIC_KEY_LENGTH)throw new Error("X25519: incorrect public key length");const ge=de(Ee,ve);if(we){let Se=0;for(let $e=0;$e<ge.length;$e++)Se|=ge[$e];if(Se===0)throw new Error("X25519: invalid shared key")}return ge}J.sharedKey=be})(x25519);const pureJsCrypto={hashSHA256(J){return sha256$1(J)},getHKDF(J,E){const ee=hkdf$1(sha256$1,E,J,void 0,96),te=ee.subarray(0,32),re=ee.subarray(32,64),ne=ee.subarray(64,96);return[te,re,ne]},generateX25519KeyPair(){const J=x25519.generateKeyPair();return{publicKey:J.publicKey,privateKey:J.secretKey}},generateX25519KeyPairFromSeed(J){const E=x25519.generateKeyPairFromSeed(J);return{publicKey:E.publicKey,privateKey:E.secretKey}},generateX25519SharedKey(J,E){return x25519.sharedKey(J,E)},chaCha20Poly1305Encrypt(J,E,ee,te){return new chacha20poly1305.ChaCha20Poly1305(te).seal(E,J,ee)},chaCha20Poly1305Decrypt(J,E,ee,te,re){return new chacha20poly1305.ChaCha20Poly1305(te).open(E,J,ee,re)}},allocUnsafe$4=J=>globalThis.Buffer?globalThis.Buffer.allocUnsafe(J):new Uint8Array(J),uint16BEEncode$1=J=>{const E=allocUnsafe$4(2);return new DataView(E.buffer,E.byteOffset,E.byteLength).setUint16(0,J,!1),E};uint16BEEncode$1.bytes=2;const uint16BEDecode$1=J=>{if(J.length<2)throw RangeError("Could not decode int16BE");return J instanceof Uint8Array?new DataView(J.buffer,J.byteOffset,J.byteLength).getUint16(0,!1):J.getUint16(0)};uint16BEDecode$1.bytes=2;function encode0$1(J){return concat$4([J.ne,J.ciphertext],J.ne.length+J.ciphertext.length)}function encode1$1(J){return concat$4([J.ne,J.ns,J.ciphertext],J.ne.length+J.ns.length+J.ciphertext.length)}function encode2$1(J){return concat$4([J.ns,J.ciphertext],J.ns.length+J.ciphertext.length)}function decode0$1(J){if(J.length<32)throw new Error("Cannot decode stage 0 MessageBuffer: length less than 32 bytes.");return{ne:J.subarray(0,32),ciphertext:J.subarray(32,J.length),ns:new Uint8Array(0)}}function decode1$1(J){if(J.length<80)throw new Error("Cannot decode stage 1 MessageBuffer: length less than 80 bytes.");return{ne:J.subarray(0,32),ns:J.subarray(32,80),ciphertext:J.subarray(80,J.length)}}function decode2$1(J){if(J.length<48)throw new Error("Cannot decode stage 2 MessageBuffer: length less than 48 bytes.");return{ne:new Uint8Array(0),ns:J.subarray(0,48),ciphertext:J.subarray(48,J.length)}}function encryptStream$1(J,E){return async function*(ee){for await(const te of ee)for(let re=0;re<te.length;re+=NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG$1){let ne=re+NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG$1;ne>te.length&&(ne=te.length);const ie=J.encrypt(te.subarray(re,ne),J.session);E?.encryptedPackets.increment(),yield uint16BEEncode$1(ie.byteLength),yield ie}}}function decryptStream$1(J,E){return async function*(ee){for await(const te of ee)for(let re=0;re<te.length;re+=NOISE_MSG_MAX_LENGTH_BYTES$1){let ne=re+NOISE_MSG_MAX_LENGTH_BYTES$1;if(ne>te.length&&(ne=te.length),ne-chacha20poly1305.TAG_LENGTH<re)throw new Error("Invalid chunk");const ie=te.subarray(re,ne),se=te.subarray(re,ne-chacha20poly1305.TAG_LENGTH),{plaintext:oe,valid:ce}=J.decrypt(ie,J.session,se);if(!ce)throw E?.decryptErrors.increment(),new Error("Failed to validate decrypted chunk");E?.decryptedPackets.increment(),yield oe}}}let UnexpectedPeerError$1=class Gt extends Error{code;constructor(E="Unexpected Peer"){super(E),this.code=Gt.code}static code="ERR_UNEXPECTED_PEER"},InvalidCryptoExchangeError$1=class zt extends Error{code;constructor(E="Invalid crypto exchange"){super(E),this.code=zt.code}static code="ERR_INVALID_CRYPTO_EXCHANGE"};var NoiseExtensions$1;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{if(re.lengthDelimited!==!1&&te.fork(),ee.webtransportCerthashes!=null)for(const ne of ee.webtransportCerthashes)te.uint32(10),te.bytes(ne);re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={webtransportCerthashes:[]},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.webtransportCerthashes.push(ee.bytes());break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage$1(ee,J.codec())})(NoiseExtensions$1||(NoiseExtensions$1={}));var NoiseHandshakePayload$1;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{re.lengthDelimited!==!1&&te.fork(),(re.writeDefaults===!0||ee.identityKey!=null&&ee.identityKey.byteLength>0)&&(te.uint32(10),te.bytes(ee.identityKey??new Uint8Array(0))),(re.writeDefaults===!0||ee.identitySig!=null&&ee.identitySig.byteLength>0)&&(te.uint32(18),te.bytes(ee.identitySig??new Uint8Array(0))),ee.extensions!=null&&(te.uint32(34),NoiseExtensions$1.codec().encode(ee.extensions,te,{writeDefaults:!1})),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={identityKey:new Uint8Array(0),identitySig:new Uint8Array(0)},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.identityKey=ee.bytes();break;case 2:re.identitySig=ee.bytes();break;case 4:re.extensions=NoiseExtensions$1.codec().decode(ee,ee.uint32());break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage$1(ee,J.codec())})(NoiseHandshakePayload$1||(NoiseHandshakePayload$1={}));async function getPayload$1(J,E,ee){const te=await signPayload$1(J,getHandshakePayload$1(E));if(J.publicKey==null)throw new Error("PublicKey was missing from local PeerId");return createHandshakePayload$1(J.publicKey,te,ee)}function createHandshakePayload$1(J,E,ee){return NoiseHandshakePayload$1.encode({identityKey:J,identitySig:E,extensions:ee??{webtransportCerthashes:[]}}).subarray()}async function signPayload$1(J,E){if(J.privateKey==null)throw new Error("PrivateKey was missing from PeerId");return(await unmarshalPrivateKey(J.privateKey)).sign(E)}async function getPeerIdFromPayload$1(J){return peerIdFromKeys(J.identityKey)}function decodePayload$1(J){return NoiseHandshakePayload$1.decode(J)}function getHandshakePayload$1(J){const E=fromString$5("noise-libp2p-static-key:");return concat$4([E,J],E.length+J.length)}async function verifySignedPayload$1(J,E,ee){const te=await peerIdFromKeys(E.identityKey);if(!te.equals(ee))throw new Error(`Payload identity key ${te.toString()} does not match expected remote peer ${ee.toString()}`);const re=getHandshakePayload$1(J);if(te.publicKey==null)throw new Error("PublicKey was missing from PeerId");if(E.identitySig==null)throw new Error("Signature was missing from message");if(!await unmarshalPublicKey(te.publicKey).verify(re,E.identitySig))throw new Error("Static key doesn't match to peer that signed payload!");return te}function isValidPublicKey$1(J){return!(!(J instanceof Uint8Array)||J.length!==32)}function compare$1(J,E){for(let ee=0;ee<J.byteLength;ee++){if(J[ee]<E[ee])return-1;if(J[ee]>E[ee])return 1}return J.byteLength>E.byteLength?1:J.byteLength<E.byteLength?-1:0}function xor(J,E){if(J.length!==E.length)throw new Error("Inputs should have the same length");const ee=allocUnsafe$5(J.length);for(let te=0;te<J.length;te++)ee[te]=J[te]^E[te];return asUint8Array$1(ee)}const log$11=logger$1("libp2p:noise");let keyLogger$1;DUMP_SESSION_KEYS$1?keyLogger$1=log$11:keyLogger$1=Object.assign(()=>{},{enabled:!1,trace:()=>{},error:()=>{}});function logLocalStaticKeys$1(J){keyLogger$1(`LOCAL_STATIC_PUBLIC_KEY ${toString$5(J.publicKey,"hex")}`),keyLogger$1(`LOCAL_STATIC_PRIVATE_KEY ${toString$5(J.privateKey,"hex")}`)}function logLocalEphemeralKeys$1(J){J?(keyLogger$1(`LOCAL_PUBLIC_EPHEMERAL_KEY ${toString$5(J.publicKey,"hex")}`),keyLogger$1(`LOCAL_PRIVATE_EPHEMERAL_KEY ${toString$5(J.privateKey,"hex")}`)):keyLogger$1("Missing local ephemeral keys.")}function logRemoteStaticKey$1(J){keyLogger$1(`REMOTE_STATIC_PUBLIC_KEY ${toString$5(J,"hex")}`)}function logRemoteEphemeralKey$1(J){keyLogger$1(`REMOTE_EPHEMERAL_PUBLIC_KEY ${toString$5(J,"hex")}`)}function logCipherState$1(J){J.cs1&&J.cs2?(keyLogger$1(`CIPHER_STATE_1 ${J.cs1.n.getUint64()} ${toString$5(J.cs1.k,"hex")}`),keyLogger$1(`CIPHER_STATE_2 ${J.cs2.n.getUint64()} ${toString$5(J.cs2.k,"hex")}`)):keyLogger$1("Missing cipher state.")}const MIN_NONCE$1=0,MAX_NONCE$1=4294967295,ERR_MAX_NONCE$1="Cipherstate has reached maximum n, a new handshake must be performed";let Nonce$1=class{n;bytes;view;constructor(J=MIN_NONCE$1){this.n=J,this.bytes=new Uint8Array(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,J,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>MAX_NONCE$1)throw new Error(ERR_MAX_NONCE$1)}},AbstractHandshake$1=class{crypto;constructor(J){this.crypto=J}encryptWithAd(J,E,ee){const te=this.encrypt(J.k,J.n,E,ee);return J.n.increment(),te}decryptWithAd(J,E,ee,te){const{plaintext:re,valid:ne}=this.decrypt(J.k,J.n,E,ee,te);return ne&&J.n.increment(),{plaintext:re,valid:ne}}hasKey(J){return!this.isEmptyKey(J.k)}createEmptyKey(){return new Uint8Array(32)}isEmptyKey(J){const E=this.createEmptyKey();return equals(E,J)}encrypt(J,E,ee,te){return E.assertValue(),this.crypto.chaCha20Poly1305Encrypt(te,E.getBytes(),ee,J)}encryptAndHash(J,E){let ee;return this.hasKey(J.cs)?ee=this.encryptWithAd(J.cs,J.h,E):ee=E,this.mixHash(J,ee),ee}decrypt(J,E,ee,te,re){E.assertValue();const ne=this.crypto.chaCha20Poly1305Decrypt(te,E.getBytes(),ee,J,re);return ne?{plaintext:ne,valid:!0}:{plaintext:new Uint8Array(0),valid:!1}}decryptAndHash(J,E){let ee,te=!0;return this.hasKey(J.cs)?{plaintext:ee,valid:te}=this.decryptWithAd(J.cs,J.h,E):ee=E,this.mixHash(J,E),{plaintext:ee,valid:te}}dh(J,E){try{const ee=this.crypto.generateX25519SharedKey(J,E);return ee.length===32?ee:ee.subarray(0,32)}catch(ee){const te=ee;return log$11.error(te),new Uint8Array(32)}}mixHash(J,E){J.h=this.getHash(J.h,E)}getHash(J,E){return this.crypto.hashSHA256(concat$4([J,E],J.length+E.length))}mixKey(J,E){const[ee,te]=this.crypto.getHKDF(J.ck,E);J.cs=this.initializeKey(te),J.ck=ee}initializeKey(J){return{k:J,n:new Nonce$1}}initializeSymmetric(J){const E=fromString$5(J,"utf-8"),ee=this.hashProtocolName(E),te=ee,re=this.createEmptyKey();return{cs:this.initializeKey(re),ck:te,h:ee}}hashProtocolName(J){if(J.length<=32){const E=new Uint8Array(32);return E.set(J),E}else return this.getHash(J,new Uint8Array(0))}split(J){const[E,ee]=this.crypto.getHKDF(J.ck,new Uint8Array(0)),te=this.initializeKey(E),re=this.initializeKey(ee);return{cs1:te,cs2:re}}writeMessageRegular(J,E){const ee=this.encryptWithAd(J,new Uint8Array(0),E),te=this.createEmptyKey(),re=new Uint8Array(0);return{ne:te,ns:re,ciphertext:ee}}readMessageRegular(J,E){return this.decryptWithAd(J,new Uint8Array(0),E.ciphertext)}},XX$1=class extends AbstractHandshake$1{initializeInitiator(J,E,ee,te){const re="Noise_XX_25519_ChaChaPoly_SHA256",ne=this.initializeSymmetric(re);this.mixHash(ne,J);const ie=new Uint8Array(32);return{ss:ne,s:E,rs:ee,psk:te,re:ie}}initializeResponder(J,E,ee,te){const re="Noise_XX_25519_ChaChaPoly_SHA256",ne=this.initializeSymmetric(re);this.mixHash(ne,J);const ie=new Uint8Array(32);return{ss:ne,s:E,rs:ee,psk:te,re:ie}}writeMessageA(J,E,ee){const te=new Uint8Array(0);ee!==void 0?J.e=ee:J.e=this.crypto.generateX25519KeyPair();const re=J.e.publicKey;this.mixHash(J.ss,re);const ne=this.encryptAndHash(J.ss,E);return{ne:re,ns:te,ciphertext:ne}}writeMessageB(J,E){J.e=this.crypto.generateX25519KeyPair();const ee=J.e.publicKey;this.mixHash(J.ss,ee),this.mixKey(J.ss,this.dh(J.e.privateKey,J.re));const te=J.s.publicKey,re=this.encryptAndHash(J.ss,te);this.mixKey(J.ss,this.dh(J.s.privateKey,J.re));const ne=this.encryptAndHash(J.ss,E);return{ne:ee,ns:re,ciphertext:ne}}writeMessageC(J,E){const ee=J.s.publicKey,te=this.encryptAndHash(J.ss,ee);this.mixKey(J.ss,this.dh(J.s.privateKey,J.re));const re=this.encryptAndHash(J.ss,E),ne={ne:this.createEmptyKey(),ns:te,ciphertext:re},{cs1:ie,cs2:se}=this.split(J.ss);return{h:J.ss.h,messageBuffer:ne,cs1:ie,cs2:se}}readMessageA(J,E){return isValidPublicKey$1(E.ne)&&(J.re=E.ne),this.mixHash(J.ss,J.re),this.decryptAndHash(J.ss,E.ciphertext)}readMessageB(J,E){if(isValidPublicKey$1(E.ne)&&(J.re=E.ne),this.mixHash(J.ss,J.re),!J.e)throw new Error("Handshake state `e` param is missing.");this.mixKey(J.ss,this.dh(J.e.privateKey,J.re));const{plaintext:ee,valid:te}=this.decryptAndHash(J.ss,E.ns);te&&isValidPublicKey$1(ee)&&(J.rs=ee),this.mixKey(J.ss,this.dh(J.e.privateKey,J.rs));const{plaintext:re,valid:ne}=this.decryptAndHash(J.ss,E.ciphertext);return{plaintext:re,valid:te&&ne}}readMessageC(J,E){const{plaintext:ee,valid:te}=this.decryptAndHash(J.ss,E.ns);if(te&&isValidPublicKey$1(ee)&&(J.rs=ee),!J.e)throw new Error("Handshake state `e` param is missing.");this.mixKey(J.ss,this.dh(J.e.privateKey,J.rs));const{plaintext:re,valid:ne}=this.decryptAndHash(J.ss,E.ciphertext),{cs1:ie,cs2:se}=this.split(J.ss);return{h:J.ss.h,plaintext:re,valid:te&&ne,cs1:ie,cs2:se}}initSession(J,E,ee){const te=this.createEmptyKey(),re=new Uint8Array(32);let ne;return J?ne=this.initializeInitiator(E,ee,re,te):ne=this.initializeResponder(E,ee,re,te),{hs:ne,i:J,mc:0}}sendMessage(J,E,ee){let te;if(J.mc===0)te=this.writeMessageA(J.hs,E,ee);else if(J.mc===1)te=this.writeMessageB(J.hs,E);else if(J.mc===2){const{h:re,messageBuffer:ne,cs1:ie,cs2:se}=this.writeMessageC(J.hs,E);te=ne,J.h=re,J.cs1=ie,J.cs2=se}else if(J.mc>2)if(J.i){if(!J.cs1)throw new Error("CS1 (cipher state) is not defined");te=this.writeMessageRegular(J.cs1,E)}else{if(!J.cs2)throw new Error("CS2 (cipher state) is not defined");te=this.writeMessageRegular(J.cs2,E)}else throw new Error("Session invalid.");return J.mc++,te}recvMessage(J,E){let ee=new Uint8Array(0),te=!1;if(J.mc===0)({plaintext:ee,valid:te}=this.readMessageA(J.hs,E));else if(J.mc===1)({plaintext:ee,valid:te}=this.readMessageB(J.hs,E));else if(J.mc===2){const{h:re,plaintext:ne,valid:ie,cs1:se,cs2:oe}=this.readMessageC(J.hs,E);ee=ne,te=ie,J.h=re,J.cs1=se,J.cs2=oe}return J.mc++,{plaintext:ee,valid:te}}},XXHandshake$1=class{isInitiator;session;remotePeer;remoteExtensions={webtransportCerthashes:[]};payload;connection;xx;staticKeypair;prologue;constructor(J,E,ee,te,re,ne,ie,se){this.isInitiator=J,this.payload=E,this.prologue=ee,this.staticKeypair=re,this.connection=ne,ie&&(this.remotePeer=ie),this.xx=se??new XX$1(te),this.session=this.xx.initSession(this.isInitiator,this.prologue,this.staticKeypair)}async propose(){if(logLocalStaticKeys$1(this.session.hs.s),this.isInitiator){log$11.trace("Stage 0 - Initiator starting to send first message.");const J=this.xx.sendMessage(this.session,new Uint8Array(0));this.connection.writeLP(encode0$1(J)),log$11.trace("Stage 0 - Initiator finished sending first message."),logLocalEphemeralKeys$1(this.session.hs.e)}else{log$11.trace("Stage 0 - Responder waiting to receive first message...");const J=decode0$1((await this.connection.readLP()).subarray()),{valid:E}=this.xx.recvMessage(this.session,J);if(!E)throw new InvalidCryptoExchangeError$1("xx handshake stage 0 validation fail");log$11.trace("Stage 0 - Responder received first message."),logRemoteEphemeralKey$1(this.session.hs.re)}}async exchange(){if(this.isInitiator){log$11.trace("Stage 1 - Initiator waiting to receive first message from responder...");const J=decode1$1((await this.connection.readLP()).subarray()),{plaintext:E,valid:ee}=this.xx.recvMessage(this.session,J);if(!ee)throw new InvalidCryptoExchangeError$1("xx handshake stage 1 validation fail");log$11.trace("Stage 1 - Initiator received the message."),logRemoteEphemeralKey$1(this.session.hs.re),logRemoteStaticKey$1(this.session.hs.rs),log$11.trace("Initiator going to check remote's signature...");try{const te=decodePayload$1(E);this.remotePeer=this.remotePeer||await getPeerIdFromPayload$1(te),await verifySignedPayload$1(this.session.hs.rs,te,this.remotePeer),this.setRemoteNoiseExtension(te.extensions)}catch(te){const re=te;throw new UnexpectedPeerError$1(`Error occurred while verifying signed payload: ${re.message}`)}log$11.trace("All good with the signature!")}else{log$11.trace("Stage 1 - Responder sending out first message with signed payload and static key.");const J=this.xx.sendMessage(this.session,this.payload);this.connection.writeLP(encode1$1(J)),log$11.trace("Stage 1 - Responder sent the second handshake message with signed payload."),logLocalEphemeralKeys$1(this.session.hs.e)}}async finish(){if(this.isInitiator){log$11.trace("Stage 2 - Initiator sending third handshake message.");const J=this.xx.sendMessage(this.session,this.payload);this.connection.writeLP(encode2$1(J)),log$11.trace("Stage 2 - Initiator sent message with signed payload.")}else{log$11.trace("Stage 2 - Responder waiting for third handshake message...");const J=decode2$1((await this.connection.readLP()).subarray()),{plaintext:E,valid:ee}=this.xx.recvMessage(this.session,J);if(!ee)throw new InvalidCryptoExchangeError$1("xx handshake stage 2 validation fail");log$11.trace("Stage 2 - Responder received the message, finished handshake.");try{const te=decodePayload$1(E);this.remotePeer=this.remotePeer||await getPeerIdFromPayload$1(te),await verifySignedPayload$1(this.session.hs.rs,te,this.remotePeer),this.setRemoteNoiseExtension(te.extensions)}catch(te){const re=te;throw new UnexpectedPeerError$1(`Error occurred while verifying signed payload: ${re.message}`)}}logCipherState$1(this.session)}encrypt(J,E){const ee=this.getCS(E);return this.xx.encryptWithAd(ee,new Uint8Array(0),J)}decrypt(J,E,ee){const te=this.getCS(E,!1);return this.xx.decryptWithAd(te,new Uint8Array(0),J,ee)}getRemoteStaticKey(){return this.session.hs.rs}getCS(J,E=!0){if(!J.cs1||!J.cs2)throw new InvalidCryptoExchangeError$1("Handshake not completed properly, cipher state does not exist.");return this.isInitiator?E?J.cs1:J.cs2:E?J.cs2:J.cs1}setRemoteNoiseExtension(J){J&&(this.remoteExtensions=J)}};function registerMetrics$1(J){return{xxHandshakeSuccesses:J.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:J.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:J.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:J.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:J.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}let Noise$1=class{protocol="/noise";crypto;prologue;staticKeys;extensions;metrics;constructor(J={}){const{staticNoiseKey:E,extensions:ee,crypto:te,prologueBytes:re,metrics:ne}=J;this.crypto=te??pureJsCrypto,this.extensions=ee,this.metrics=ne?registerMetrics$1(ne):void 0,E?this.staticKeys=this.crypto.generateX25519KeyPairFromSeed(E):this.staticKeys=this.crypto.generateX25519KeyPair(),this.prologue=re??new Uint8Array(0)}async secureOutbound(J,E,ee){const te=pbStream$1(E,{lengthEncoder:uint16BEEncode$1,lengthDecoder:uint16BEDecode$1,maxDataLength:NOISE_MSG_MAX_LENGTH_BYTES$1}),re=await this.performHandshake({connection:te,isInitiator:!0,localPeer:J,remotePeer:ee});return{conn:await this.createSecureConnection(te,re),remoteExtensions:re.remoteExtensions,remotePeer:re.remotePeer}}async secureInbound(J,E,ee){const te=pbStream$1(E,{lengthEncoder:uint16BEEncode$1,lengthDecoder:uint16BEDecode$1,maxDataLength:NOISE_MSG_MAX_LENGTH_BYTES$1}),re=await this.performHandshake({connection:te,isInitiator:!1,localPeer:J,remotePeer:ee});return{conn:await this.createSecureConnection(te,re),remotePeer:re.remotePeer,remoteExtensions:re.remoteExtensions}}async performHandshake(J){const E=await getPayload$1(J.localPeer,this.staticKeys.publicKey,this.extensions);return this.performXXHandshake(J,E)}async performXXHandshake(J,E){const{isInitiator:ee,remotePeer:te,connection:re}=J,ne=new XXHandshake$1(ee,E,this.prologue,this.crypto,this.staticKeys,re,te);try{await ne.propose(),await ne.exchange(),await ne.finish(),this.metrics?.xxHandshakeSuccesses.increment()}catch(ie){if(this.metrics?.xxHandshakeErrors.increment(),ie instanceof Error)throw ie.message=`Error occurred during XX handshake: ${ie.message}`,ie}return ne}async createSecureConnection(J,E){const[ee,te]=duplexPair(),re=J.unwrap();return await pipe$1(ee,encryptStream$1(E,this.metrics),re,ne=>decode$b(ne,{lengthDecoder:uint16BEDecode$1}),decryptStream$1(E,this.metrics),ee),te}};function noise$1(J={}){return()=>new Noise$1(J)}var src$4={exports:{}};function base$2(J){if(J.length>=255)throw new TypeError("Alphabet too long");for(var E=new Uint8Array(256),ee=0;ee<E.length;ee++)E[ee]=255;for(var te=0;te<J.length;te++){var re=J.charAt(te),ne=re.charCodeAt(0);if(E[ne]!==255)throw new TypeError(re+" is ambiguous");E[ne]=te}var ie=J.length,se=J.charAt(0),oe=Math.log(ie)/Math.log(256),ce=Math.log(256)/Math.log(ie);function ae(he){if(he instanceof Uint8Array||(ArrayBuffer.isView(he)?he=new Uint8Array(he.buffer,he.byteOffset,he.byteLength):Array.isArray(he)&&(he=Uint8Array.from(he))),!(he instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(he.length===0)return"";for(var pe=0,de=0,fe=0,me=he.length;fe!==me&&he[fe]===0;)fe++,pe++;for(var _e=(me-fe)*ce+1>>>0,be=new Uint8Array(_e);fe!==me;){for(var Ee=he[fe],ve=0,we=_e-1;(Ee!==0||ve<de)&&we!==-1;we--,ve++)Ee+=256*be[we]>>>0,be[we]=Ee%ie>>>0,Ee=Ee/ie>>>0;if(Ee!==0)throw new Error("Non-zero carry");de=ve,fe++}for(var ge=_e-de;ge!==_e&&be[ge]===0;)ge++;for(var Se=se.repeat(pe);ge<_e;++ge)Se+=J.charAt(be[ge]);return Se}function le(he){if(typeof he!="string")throw new TypeError("Expected String");if(he.length===0)return new Uint8Array;var pe=0;if(he[pe]!==" "){for(var de=0,fe=0;he[pe]===se;)de++,pe++;for(var me=(he.length-pe)*oe+1>>>0,_e=new Uint8Array(me);he[pe];){var be=E[he.charCodeAt(pe)];if(be===255)return;for(var Ee=0,ve=me-1;(be!==0||Ee<fe)&&ve!==-1;ve--,Ee++)be+=ie*_e[ve]>>>0,_e[ve]=be%256>>>0,be=be/256>>>0;if(be!==0)throw new Error("Non-zero carry");fe=Ee,pe++}if(he[pe]!==" "){for(var we=me-fe;we!==me&&_e[we]===0;)we++;for(var ge=new Uint8Array(de+(me-we)),Se=de;we!==me;)ge[Se++]=_e[we++];return ge}}}function ue(he){var pe=le(he);if(pe)return pe;throw new Error("Non-base"+ie+" character")}return{encode:ae,decodeUnsafe:le,decode:ue}}var src$3=base$2;const textDecoder$2=new TextDecoder,decodeText$1=J=>textDecoder$2.decode(J),textEncoder$3=new TextEncoder,encodeText$2=J=>textEncoder$3.encode(J);function concat$3(J,E){const ee=new Uint8Array(E);let te=0;for(const re of J)ee.set(re,te),te+=re.length;return ee}var util={decodeText:decodeText$1,encodeText:encodeText$2,concat:concat$3};const{encodeText:encodeText$1}=util;let Base$1=class{constructor(J,E,ee,te){this.name=J,this.code=E,this.codeBuf=encodeText$1(this.code),this.alphabet=te,this.codec=ee(te)}encode(J){return this.codec.encode(J)}decode(J){for(const E of J)if(this.alphabet&&this.alphabet.indexOf(E)<0)throw new Error(`invalid character '${E}' in '${J}'`);return this.codec.decode(J)}};var base$1=Base$1;const decode$a=(J,E,ee)=>{const te={};for(let ce=0;ce<E.length;++ce)te[E[ce]]=ce;let re=J.length;for(;J[re-1]==="=";)--re;const ne=new Uint8Array(re*ee/8|0);let ie=0,se=0,oe=0;for(let ce=0;ce<re;++ce){const ae=te[J[ce]];if(ae===void 0)throw new SyntaxError("Invalid character "+J[ce]);se=se<<ee|ae,ie+=ee,ie>=8&&(ie-=8,ne[oe++]=255&se>>ie)}if(ie>=ee||255&se<<8-ie)throw new SyntaxError("Unexpected end of data");return ne},encode$9=(J,E,ee)=>{const te=E[E.length-1]==="=",re=(1<<ee)-1;let ne="",ie=0,se=0;for(let oe=0;oe<J.length;++oe)for(se=se<<8|J[oe],ie+=8;ie>ee;)ie-=ee,ne+=E[re&se>>ie];if(ie&&(ne+=E[re&se<<ee-ie]),te)for(;ne.length*ee&7;)ne+="=";return ne},rfc4648$2=J=>E=>({encode(ee){return encode$9(ee,E,J)},decode(ee){return decode$a(ee,E,J)}});var rfc4648_1={rfc4648:rfc4648$2};const baseX$1=src$3,Base=base$1,{rfc4648:rfc4648$1}=rfc4648_1,{decodeText,encodeText}=util,identity$1=()=>({encode:decodeText,decode:encodeText}),constants$1=[["identity","\0",identity$1,""],["base2","0",rfc4648$1(1),"01"],["base8","7",rfc4648$1(3),"01234567"],["base10","9",baseX$1,"0123456789"],["base16","f",rfc4648$1(4),"0123456789abcdef"],["base16upper","F",rfc4648$1(4),"0123456789ABCDEF"],["base32hex","v",rfc4648$1(5),"0123456789abcdefghijklmnopqrstuv"],["base32hexupper","V",rfc4648$1(5),"0123456789ABCDEFGHIJKLMNOPQRSTUV"],["base32hexpad","t",rfc4648$1(5),"0123456789abcdefghijklmnopqrstuv="],["base32hexpadupper","T",rfc4648$1(5),"0123456789ABCDEFGHIJKLMNOPQRSTUV="],["base32","b",rfc4648$1(5),"abcdefghijklmnopqrstuvwxyz234567"],["base32upper","B",rfc4648$1(5),"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"],["base32pad","c",rfc4648$1(5),"abcdefghijklmnopqrstuvwxyz234567="],["base32padupper","C",rfc4648$1(5),"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567="],["base32z","h",rfc4648$1(5),"ybndrfg8ejkmcpqxot1uwisza345h769"],["base36","k",baseX$1,"0123456789abcdefghijklmnopqrstuvwxyz"],["base36upper","K",baseX$1,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"],["base58btc","z",baseX$1,"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],["base58flickr","Z",baseX$1,"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],["base64","m",rfc4648$1(6),"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],["base64pad","M",rfc4648$1(6),"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="],["base64url","u",rfc4648$1(6),"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"],["base64urlpad","U",rfc4648$1(6),"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]],names$2=constants$1.reduce((J,E)=>(J[E[0]]=new Base(E[0],E[1],E[2],E[3]),J),{}),codes$3=constants$1.reduce((J,E)=>(J[E[1]]=names$2[E[0]],J),{});var constants_1={names:names$2,codes:codes$3};(function(J,E){const ee=constants_1,{encodeText:te,decodeText:re,concat:ne}=util;function ie(de,fe){if(!fe)throw new Error("requires an encoded Uint8Array");const{name:me,codeBuf:_e}=le(de);return ae(me,fe),ne([_e,fe],_e.length+fe.length)}function se(de,fe){const me=le(de),_e=te(me.encode(fe));return ne([me.codeBuf,_e],me.codeBuf.length+_e.length)}function oe(de){de instanceof Uint8Array&&(de=re(de));const fe=de[0];return["f","F","v","V","t","T","b","B","c","C","h","k","K"].includes(fe)&&(de=de.toLowerCase()),le(de[0]).decode(de.substring(1))}function ce(de){if(de instanceof Uint8Array&&(de=re(de)),Object.prototype.toString.call(de)!=="[object String]")return!1;try{return le(de[0]).name}catch{return!1}}function ae(de,fe){le(de).decode(re(fe))}function le(de){if(Object.prototype.hasOwnProperty.call(ee.names,de))return ee.names[de];if(Object.prototype.hasOwnProperty.call(ee.codes,de))return ee.codes[de];throw new Error(`Unsupported encoding: ${de}`)}function ue(de){return de instanceof Uint8Array&&(de=re(de)),le(de[0])}E=J.exports=ie,E.encode=se,E.decode=oe,E.isEncoded=ce,E.encoding=le,E.encodingFromData=ue;const he=Object.freeze(ee.names),pe=Object.freeze(ee.codes);E.names=he,E.codes=pe})(src$4,src$4.exports);var srcExports=src$4.exports,encode_1=encode$8,MSB$3=128,REST$3=127,MSBALL=~REST$3,INT=Math.pow(2,31);function encode$8(J,E,ee){E=E||[],ee=ee||0;for(var te=ee;J>=INT;)E[ee++]=J&255|MSB$3,J/=128;for(;J&MSBALL;)E[ee++]=J&255|MSB$3,J>>>=7;return E[ee]=J|0,encode$8.bytes=ee-te+1,E}var decode$9=read,MSB$2=128,REST$2=127;function read(J,te){var ee=0,te=te||0,re=0,ne=te,ie,se=J.length;do{if(ne>=se)throw read.bytes=0,new RangeError("Could not decode varint");ie=J[ne++],ee+=re<28?(ie&REST$2)<<re:(ie&REST$2)*Math.pow(2,re),re+=7}while(ie>=MSB$2);return read.bytes=ne-te,ee}var N1=Math.pow(2,7),N2=Math.pow(2,14),N3=Math.pow(2,21),N4=Math.pow(2,28),N5=Math.pow(2,35),N6=Math.pow(2,42),N7=Math.pow(2,49),N8=Math.pow(2,56),N9=Math.pow(2,63),length$1=function(J){return J<N1?1:J<N2?2:J<N3?3:J<N4?4:J<N5?5:J<N6?6:J<N7?7:J<N8?8:J<N9?9:10},varint$2={encode:encode_1,decode:decode$9,encodingLength:length$1};const names$1=Object.freeze({identity:0,sha1:17,"sha2-256":18,"sha2-512":19,"sha3-512":20,"sha3-384":21,"sha3-256":22,"sha3-224":23,"shake-128":24,"shake-256":25,"keccak-224":26,"keccak-256":27,"keccak-384":28,"keccak-512":29,blake3:30,"murmur3-128":34,"murmur3-32":35,"dbl-sha2-256":86,md4:212,md5:213,bmt:214,"sha2-256-trunc254-padded":4114,"ripemd-128":4178,"ripemd-160":4179,"ripemd-256":4180,"ripemd-320":4181,x11:4352,kangarootwelve:7425,"sm3-256":21325,"blake2b-8":45569,"blake2b-16":45570,"blake2b-24":45571,"blake2b-32":45572,"blake2b-40":45573,"blake2b-48":45574,"blake2b-56":45575,"blake2b-64":45576,"blake2b-72":45577,"blake2b-80":45578,"blake2b-88":45579,"blake2b-96":45580,"blake2b-104":45581,"blake2b-112":45582,"blake2b-120":45583,"blake2b-128":45584,"blake2b-136":45585,"blake2b-144":45586,"blake2b-152":45587,"blake2b-160":45588,"blake2b-168":45589,"blake2b-176":45590,"blake2b-184":45591,"blake2b-192":45592,"blake2b-200":45593,"blake2b-208":45594,"blake2b-216":45595,"blake2b-224":45596,"blake2b-232":45597,"blake2b-240":45598,"blake2b-248":45599,"blake2b-256":45600,"blake2b-264":45601,"blake2b-272":45602,"blake2b-280":45603,"blake2b-288":45604,"blake2b-296":45605,"blake2b-304":45606,"blake2b-312":45607,"blake2b-320":45608,"blake2b-328":45609,"blake2b-336":45610,"blake2b-344":45611,"blake2b-352":45612,"blake2b-360":45613,"blake2b-368":45614,"blake2b-376":45615,"blake2b-384":45616,"blake2b-392":45617,"blake2b-400":45618,"blake2b-408":45619,"blake2b-416":45620,"blake2b-424":45621,"blake2b-432":45622,"blake2b-440":45623,"blake2b-448":45624,"blake2b-456":45625,"blake2b-464":45626,"blake2b-472":45627,"blake2b-480":45628,"blake2b-488":45629,"blake2b-496":45630,"blake2b-504":45631,"blake2b-512":45632,"blake2s-8":45633,"blake2s-16":45634,"blake2s-24":45635,"blake2s-32":45636,"blake2s-40":45637,"blake2s-48":45638,"blake2s-56":45639,"blake2s-64":45640,"blake2s-72":45641,"blake2s-80":45642,"blake2s-88":45643,"blake2s-96":45644,"blake2s-104":45645,"blake2s-112":45646,"blake2s-120":45647,"blake2s-128":45648,"blake2s-136":45649,"blake2s-144":45650,"blake2s-152":45651,"blake2s-160":45652,"blake2s-168":45653,"blake2s-176":45654,"blake2s-184":45655,"blake2s-192":45656,"blake2s-200":45657,"blake2s-208":45658,"blake2s-216":45659,"blake2s-224":45660,"blake2s-232":45661,"blake2s-240":45662,"blake2s-248":45663,"blake2s-256":45664,"skein256-8":45825,"skein256-16":45826,"skein256-24":45827,"skein256-32":45828,"skein256-40":45829,"skein256-48":45830,"skein256-56":45831,"skein256-64":45832,"skein256-72":45833,"skein256-80":45834,"skein256-88":45835,"skein256-96":45836,"skein256-104":45837,"skein256-112":45838,"skein256-120":45839,"skein256-128":45840,"skein256-136":45841,"skein256-144":45842,"skein256-152":45843,"skein256-160":45844,"skein256-168":45845,"skein256-176":45846,"skein256-184":45847,"skein256-192":45848,"skein256-200":45849,"skein256-208":45850,"skein256-216":45851,"skein256-224":45852,"skein256-232":45853,"skein256-240":45854,"skein256-248":45855,"skein256-256":45856,"skein512-8":45857,"skein512-16":45858,"skein512-24":45859,"skein512-32":45860,"skein512-40":45861,"skein512-48":45862,"skein512-56":45863,"skein512-64":45864,"skein512-72":45865,"skein512-80":45866,"skein512-88":45867,"skein512-96":45868,"skein512-104":45869,"skein512-112":45870,"skein512-120":45871,"skein512-128":45872,"skein512-136":45873,"skein512-144":45874,"skein512-152":45875,"skein512-160":45876,"skein512-168":45877,"skein512-176":45878,"skein512-184":45879,"skein512-192":45880,"skein512-200":45881,"skein512-208":45882,"skein512-216":45883,"skein512-224":45884,"skein512-232":45885,"skein512-240":45886,"skein512-248":45887,"skein512-256":45888,"skein512-264":45889,"skein512-272":45890,"skein512-280":45891,"skein512-288":45892,"skein512-296":45893,"skein512-304":45894,"skein512-312":45895,"skein512-320":45896,"skein512-328":45897,"skein512-336":45898,"skein512-344":45899,"skein512-352":45900,"skein512-360":45901,"skein512-368":45902,"skein512-376":45903,"skein512-384":45904,"skein512-392":45905,"skein512-400":45906,"skein512-408":45907,"skein512-416":45908,"skein512-424":45909,"skein512-432":45910,"skein512-440":45911,"skein512-448":45912,"skein512-456":45913,"skein512-464":45914,"skein512-472":45915,"skein512-480":45916,"skein512-488":45917,"skein512-496":45918,"skein512-504":45919,"skein512-512":45920,"skein1024-8":45921,"skein1024-16":45922,"skein1024-24":45923,"skein1024-32":45924,"skein1024-40":45925,"skein1024-48":45926,"skein1024-56":45927,"skein1024-64":45928,"skein1024-72":45929,"skein1024-80":45930,"skein1024-88":45931,"skein1024-96":45932,"skein1024-104":45933,"skein1024-112":45934,"skein1024-120":45935,"skein1024-128":45936,"skein1024-136":45937,"skein1024-144":45938,"skein1024-152":45939,"skein1024-160":45940,"skein1024-168":45941,"skein1024-176":45942,"skein1024-184":45943,"skein1024-192":45944,"skein1024-200":45945,"skein1024-208":45946,"skein1024-216":45947,"skein1024-224":45948,"skein1024-232":45949,"skein1024-240":45950,"skein1024-248":45951,"skein1024-256":45952,"skein1024-264":45953,"skein1024-272":45954,"skein1024-280":45955,"skein1024-288":45956,"skein1024-296":45957,"skein1024-304":45958,"skein1024-312":45959,"skein1024-320":45960,"skein1024-328":45961,"skein1024-336":45962,"skein1024-344":45963,"skein1024-352":45964,"skein1024-360":45965,"skein1024-368":45966,"skein1024-376":45967,"skein1024-384":45968,"skein1024-392":45969,"skein1024-400":45970,"skein1024-408":45971,"skein1024-416":45972,"skein1024-424":45973,"skein1024-432":45974,"skein1024-440":45975,"skein1024-448":45976,"skein1024-456":45977,"skein1024-464":45978,"skein1024-472":45979,"skein1024-480":45980,"skein1024-488":45981,"skein1024-496":45982,"skein1024-504":45983,"skein1024-512":45984,"skein1024-520":45985,"skein1024-528":45986,"skein1024-536":45987,"skein1024-544":45988,"skein1024-552":45989,"skein1024-560":45990,"skein1024-568":45991,"skein1024-576":45992,"skein1024-584":45993,"skein1024-592":45994,"skein1024-600":45995,"skein1024-608":45996,"skein1024-616":45997,"skein1024-624":45998,"skein1024-632":45999,"skein1024-640":46e3,"skein1024-648":46001,"skein1024-656":46002,"skein1024-664":46003,"skein1024-672":46004,"skein1024-680":46005,"skein1024-688":46006,"skein1024-696":46007,"skein1024-704":46008,"skein1024-712":46009,"skein1024-720":46010,"skein1024-728":46011,"skein1024-736":46012,"skein1024-744":46013,"skein1024-752":46014,"skein1024-760":46015,"skein1024-768":46016,"skein1024-776":46017,"skein1024-784":46018,"skein1024-792":46019,"skein1024-800":46020,"skein1024-808":46021,"skein1024-816":46022,"skein1024-824":46023,"skein1024-832":46024,"skein1024-840":46025,"skein1024-848":46026,"skein1024-856":46027,"skein1024-864":46028,"skein1024-872":46029,"skein1024-880":46030,"skein1024-888":46031,"skein1024-896":46032,"skein1024-904":46033,"skein1024-912":46034,"skein1024-920":46035,"skein1024-928":46036,"skein1024-936":46037,"skein1024-944":46038,"skein1024-952":46039,"skein1024-960":46040,"skein1024-968":46041,"skein1024-976":46042,"skein1024-984":46043,"skein1024-992":46044,"skein1024-1000":46045,"skein1024-1008":46046,"skein1024-1016":46047,"skein1024-1024":46048,"poseidon-bls12_381-a2-fc1":46081,"poseidon-bls12_381-a2-fc1-sc":46082});var constants={names:names$1};function base(J,E){if(J.length>=255)throw new TypeError("Alphabet too long");for(var ee=new Uint8Array(256),te=0;te<ee.length;te++)ee[te]=255;for(var re=0;re<J.length;re++){var ne=J.charAt(re),ie=ne.charCodeAt(0);if(ee[ie]!==255)throw new TypeError(ne+" is ambiguous");ee[ie]=re}var se=J.length,oe=J.charAt(0),ce=Math.log(se)/Math.log(256),ae=Math.log(256)/Math.log(se);function le(pe){if(pe instanceof Uint8Array||(ArrayBuffer.isView(pe)?pe=new Uint8Array(pe.buffer,pe.byteOffset,pe.byteLength):Array.isArray(pe)&&(pe=Uint8Array.from(pe))),!(pe instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(pe.length===0)return"";for(var de=0,fe=0,me=0,_e=pe.length;me!==_e&&pe[me]===0;)me++,de++;for(var be=(_e-me)*ae+1>>>0,Ee=new Uint8Array(be);me!==_e;){for(var ve=pe[me],we=0,ge=be-1;(ve!==0||we<fe)&&ge!==-1;ge--,we++)ve+=256*Ee[ge]>>>0,Ee[ge]=ve%se>>>0,ve=ve/se>>>0;if(ve!==0)throw new Error("Non-zero carry");fe=we,me++}for(var Se=be-fe;Se!==be&&Ee[Se]===0;)Se++;for(var $e=oe.repeat(de);Se<be;++Se)$e+=J.charAt(Ee[Se]);return $e}function ue(pe){if(typeof pe!="string")throw new TypeError("Expected String");if(pe.length===0)return new Uint8Array;var de=0;if(pe[de]!==" "){for(var fe=0,me=0;pe[de]===oe;)fe++,de++;for(var _e=(pe.length-de)*ce+1>>>0,be=new Uint8Array(_e);pe[de];){var Ee=ee[pe.charCodeAt(de)];if(Ee===255)return;for(var ve=0,we=_e-1;(Ee!==0||ve<me)&&we!==-1;we--,ve++)Ee+=se*be[we]>>>0,be[we]=Ee%256>>>0,Ee=Ee/256>>>0;if(Ee!==0)throw new Error("Non-zero carry");me=ve,de++}if(pe[de]!==" "){for(var ge=_e-me;ge!==_e&&be[ge]===0;)ge++;for(var Se=new Uint8Array(fe+(_e-ge)),$e=fe;ge!==_e;)Se[$e++]=be[ge++];return Se}}}function he(pe){var de=ue(pe);if(de)return de;throw new Error(`Non-${E} character`)}return{encode:le,decodeUnsafe:ue,decode:he}}var src$2=base,_brrp__multiformats_scope_baseX=src$2;const coerce=J=>{if(J instanceof Uint8Array&&J.constructor.name==="Uint8Array")return J;if(J instanceof ArrayBuffer)return new Uint8Array(J);if(ArrayBuffer.isView(J))return new Uint8Array(J.buffer,J.byteOffset,J.byteLength);throw new Error("Unknown type, must be binary type")},fromString$3=J=>new TextEncoder().encode(J),toString$3=J=>new TextDecoder().decode(J);let Encoder$2=class{constructor(J,E,ee){this.name=J,this.prefix=E,this.baseEncode=ee}encode(J){if(J instanceof Uint8Array)return`${this.prefix}${this.baseEncode(J)}`;throw Error("Unknown type, must be binary type")}},Decoder$3=class{constructor(J,E,ee){if(this.name=J,this.prefix=E,E.codePointAt(0)===void 0)throw new Error("Invalid prefix character");this.prefixCodePoint=E.codePointAt(0),this.baseDecode=ee}decode(J){if(typeof J=="string"){if(J.codePointAt(0)!==this.prefixCodePoint)throw Error(`Unable to decode multibase string ${JSON.stringify(J)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);return this.baseDecode(J.slice(this.prefix.length))}else throw Error("Can only multibase decode strings")}or(J){return or(this,J)}};class ComposedDecoder{constructor(E){this.decoders=E}or(E){return or(this,E)}decode(E){const ee=E[0],te=this.decoders[ee];if(te)return te.decode(E);throw RangeError(`Unable to decode multibase string ${JSON.stringify(E)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}}const or=(J,E)=>new ComposedDecoder({...J.decoders||{[J.prefix]:J},...E.decoders||{[E.prefix]:E}});class Codec{constructor(E,ee,te,re){this.name=E,this.prefix=ee,this.baseEncode=te,this.baseDecode=re,this.encoder=new Encoder$2(E,ee,te),this.decoder=new Decoder$3(E,ee,re)}encode(E){return this.encoder.encode(E)}decode(E){return this.decoder.decode(E)}}const from=({name:J,prefix:E,encode:ee,decode:te})=>new Codec(J,E,ee,te),baseX=({prefix:J,name:E,alphabet:ee})=>{const{encode:te,decode:re}=_brrp__multiformats_scope_baseX(ee,E);return from({prefix:J,name:E,encode:te,decode:ne=>coerce(re(ne))})},decode$8=(J,E,ee,te)=>{const re={};for(let ae=0;ae<E.length;++ae)re[E[ae]]=ae;let ne=J.length;for(;J[ne-1]==="=";)--ne;const ie=new Uint8Array(ne*ee/8|0);let se=0,oe=0,ce=0;for(let ae=0;ae<ne;++ae){const le=re[J[ae]];if(le===void 0)throw new SyntaxError(`Non-${te} character`);oe=oe<<ee|le,se+=ee,se>=8&&(se-=8,ie[ce++]=255&oe>>se)}if(se>=ee||255&oe<<8-se)throw new SyntaxError("Unexpected end of data");return ie},encode$7=(J,E,ee)=>{const te=E[E.length-1]==="=",re=(1<<ee)-1;let ne="",ie=0,se=0;for(let oe=0;oe<J.length;++oe)for(se=se<<8|J[oe],ie+=8;ie>ee;)ie-=ee,ne+=E[re&se>>ie];if(ie&&(ne+=E[re&se<<ee-ie]),te)for(;ne.length*ee&7;)ne+="=";return ne},rfc4648=({name:J,prefix:E,bitsPerChar:ee,alphabet:te})=>from({prefix:E,name:J,encode(re){return encode$7(re,te,ee)},decode(re){return decode$8(re,te,ee,J)}}),identity=from({prefix:"\0",name:"identity",encode:J=>toString$3(J),decode:J=>fromString$3(J)}),identityBase=Object.freeze(Object.defineProperty({__proto__:null,identity},Symbol.toStringTag,{value:"Module"})),base2=rfc4648({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1}),base2$1=Object.freeze(Object.defineProperty({__proto__:null,base2},Symbol.toStringTag,{value:"Module"})),base8=rfc4648({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3}),base8$1=Object.freeze(Object.defineProperty({__proto__:null,base8},Symbol.toStringTag,{value:"Module"})),base10=baseX({prefix:"9",name:"base10",alphabet:"0123456789"}),base10$1=Object.freeze(Object.defineProperty({__proto__:null,base10},Symbol.toStringTag,{value:"Module"})),base16=rfc4648({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),base16upper=rfc4648({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4}),base16$1=Object.freeze(Object.defineProperty({__proto__:null,base16,base16upper},Symbol.toStringTag,{value:"Module"})),base32=rfc4648({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),base32upper=rfc4648({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),base32pad=rfc4648({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),base32padupper=rfc4648({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),base32hex=rfc4648({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),base32hexupper=rfc4648({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),base32hexpad=rfc4648({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),base32hexpadupper=rfc4648({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),base32z=rfc4648({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5}),base32$1=Object.freeze(Object.defineProperty({__proto__:null,base32,base32hex,base32hexpad,base32hexpadupper,base32hexupper,base32pad,base32padupper,base32upper,base32z},Symbol.toStringTag,{value:"Module"})),base36=baseX({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),base36upper=baseX({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"}),base36$1=Object.freeze(Object.defineProperty({__proto__:null,base36,base36upper},Symbol.toStringTag,{value:"Module"})),base58btc=baseX({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),base58flickr=baseX({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"}),base58=Object.freeze(Object.defineProperty({__proto__:null,base58btc,base58flickr},Symbol.toStringTag,{value:"Module"})),base64=rfc4648({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),base64pad=rfc4648({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),base64url=rfc4648({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),base64urlpad=rfc4648({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6}),base64$1=Object.freeze(Object.defineProperty({__proto__:null,base64,base64pad,base64url,base64urlpad},Symbol.toStringTag,{value:"Module"})),alphabet=Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"),alphabetBytesToChars=alphabet.reduce((J,E,ee)=>(J[ee]=E,J),[]),alphabetCharsToBytes=alphabet.reduce((J,E,ee)=>(J[E.codePointAt(0)]=ee,J),[]);function encode$6(J){return J.reduce((E,ee)=>(E+=alphabetBytesToChars[ee],E),"")}function decode$7(J){const E=[];for(const ee of J){const te=alphabetCharsToBytes[ee.codePointAt(0)];if(te===void 0)throw new Error(`Non-base256emoji character: ${ee}`);E.push(te)}return new Uint8Array(E)}const base256emoji=from({prefix:"🚀",name:"base256emoji",encode:encode$6,decode:decode$7}),base256emoji$1=Object.freeze(Object.defineProperty({__proto__:null,base256emoji},Symbol.toStringTag,{value:"Module"}));new TextEncoder;new TextDecoder;const bases={...identityBase,...base2$1,...base8$1,...base10$1,...base16$1,...base32$1,...base36$1,...base58,...base64$1,...base256emoji$1};function asUint8Array(J){return globalThis.Buffer!=null?new Uint8Array(J.buffer,J.byteOffset,J.byteLength):J}function allocUnsafe$3(J=0){return globalThis.Buffer!=null&&globalThis.Buffer.allocUnsafe!=null?asUint8Array(globalThis.Buffer.allocUnsafe(J)):new Uint8Array(J)}function createCodec(J,E,ee,te){return{name:J,prefix:E,encoder:{name:J,prefix:E,encode:ee},decoder:{decode:te}}}const string=createCodec("utf8","u",J=>"u"+new TextDecoder("utf8").decode(J),J=>new TextEncoder().encode(J.substring(1))),ascii=createCodec("ascii","a",J=>{let E="a";for(let ee=0;ee<J.length;ee++)E+=String.fromCharCode(J[ee]);return E},J=>{J=J.substring(1);const E=allocUnsafe$3(J.length);for(let ee=0;ee<J.length;ee++)E[ee]=J.charCodeAt(ee);return E}),BASES={utf8:string,"utf-8":string,hex:bases.base16,latin1:ascii,ascii,binary:ascii,...bases};function toString$1(J,E="utf8"){const ee=BASES[E];if(!ee)throw new Error(`Unsupported encoding "${E}"`);return(E==="utf8"||E==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?globalThis.Buffer.from(J.buffer,J.byteOffset,J.byteLength).toString("utf8"):ee.encoder.encode(J).substring(1)}const toString$2=Object.freeze(Object.defineProperty({__proto__:null,toString:toString$1},Symbol.toStringTag,{value:"Module"})),require$$3=getAugmentedNamespace(toString$2);function fromString$1(J,E="utf8"){const ee=BASES[E];if(!ee)throw new Error(`Unsupported encoding "${E}"`);return(E==="utf8"||E==="utf-8")&&globalThis.Buffer!=null&&globalThis.Buffer.from!=null?asUint8Array(globalThis.Buffer.from(J,"utf-8")):ee.decoder.decode(`${ee.prefix}${J}`)}const fromString$2=Object.freeze(Object.defineProperty({__proto__:null,fromString:fromString$1},Symbol.toStringTag,{value:"Module"})),require$$4=getAugmentedNamespace(fromString$2);function concat$1(J,E){E||(E=J.reduce((re,ne)=>re+ne.length,0));const ee=allocUnsafe$3(E);let te=0;for(const re of J)ee.set(re,te),te+=re.length;return asUint8Array(ee)}const concat$2=Object.freeze(Object.defineProperty({__proto__:null,concat:concat$1},Symbol.toStringTag,{value:"Module"})),require$$5=getAugmentedNamespace(concat$2),multibase=srcExports,varint$1=varint$2,{names}=constants,{toString:uint8ArrayToString}=require$$3,{fromString:uint8ArrayFromString}=require$$4,{concat:uint8ArrayConcat}=require$$5,codes$2={};for(const J in names){const E=J;codes$2[names[E]]=E}Object.freeze(codes$2);function toHexString(J){if(!(J instanceof Uint8Array))throw new Error("must be passed a Uint8Array");return uint8ArrayToString(J,"base16")}function fromHexString(J){return uint8ArrayFromString(J,"base16")}function toB58String(J){if(!(J instanceof Uint8Array))throw new Error("must be passed a Uint8Array");return uint8ArrayToString(multibase.encode("base58btc",J)).slice(1)}function fromB58String(J){const E=J instanceof Uint8Array?uint8ArrayToString(J):J;return multibase.decode("z"+E)}function decode$6(J){if(!(J instanceof Uint8Array))throw new Error("multihash must be a Uint8Array");if(J.length<2)throw new Error("multihash too short. must be > 2 bytes.");const E=varint$1.decode(J);if(!isValidCode(E))throw new Error(`multihash unknown function code: 0x${E.toString(16)}`);J=J.slice(varint$1.decode.bytes);const ee=varint$1.decode(J);if(ee<0)throw new Error(`multihash invalid length: ${ee}`);if(J=J.slice(varint$1.decode.bytes),J.length!==ee)throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(J,"base16")}`);return{code:E,name:codes$2[E],length:ee,digest:J}}function encode$5(J,E,ee){if(!J||E===void 0)throw new Error("multihash encode requires at least two args: digest, code");const te=coerceCode(E);if(!(J instanceof Uint8Array))throw new Error("digest should be a Uint8Array");if(ee==null&&(ee=J.length),ee&&J.length!==ee)throw new Error("digest length should be equal to specified length.");const re=varint$1.encode(te),ne=varint$1.encode(ee);return uint8ArrayConcat([re,ne,J],re.length+ne.length+J.length)}function coerceCode(J){let E=J;if(typeof J=="string"){if(names[J]===void 0)throw new Error(`Unrecognized hash function named: ${J}`);E=names[J]}if(typeof E!="number")throw new Error(`Hash function code should be a number. Got: ${E}`);if(codes$2[E]===void 0&&!isAppCode(E))throw new Error(`Unrecognized function code: ${E}`);return E}function isAppCode(J){return J>0&&J<16}function isValidCode(J){return!!(isAppCode(J)||codes$2[J])}function validate$2(J){decode$6(J)}function prefix(J){return validate$2(J),J.subarray(0,2)}var src$1={names,codes:codes$2,toHexString,fromHexString,toB58String,fromB58String,decode:decode$6,encode:encode$5,coerceCode,isAppCode,validate:validate$2,prefix,isValidCode};const log$10=logger$1("libp2p:webrtc:sdp"),mbdecoder$1=Object.values(bases$1).map(J=>J.decoder).reduce((J,E)=>J.or(E));function getLocalFingerprint$1(J){const E=J.getConfiguration().certificates?.at(0);if(E==null||E.getFingerprints==null){log$10.trace("fetching fingerprint from local SDP");const te=J.localDescription;return te==null?void 0:getFingerprintFromSdp$1(te.sdp)}if(log$10.trace("fetching fingerprint from local certificate"),E.getFingerprints().length===0)return;const ee=E.getFingerprints()[0].value;if(ee==null)throw invalidFingerprint$1("","no fingerprint on local certificate");return ee}const fingerprintRegex$1=/^a=fingerprint:(?:\w+-[0-9]+)\s(?<fingerprint>(:?[0-9a-fA-F]{2})+)$/m;function getFingerprintFromSdp$1(J){return J.match(fingerprintRegex$1)?.groups?.fingerprint}function ipv$1(J){for(const E of J.protoNames())if(E.startsWith("ip"))return E.toUpperCase();return log$10("Warning: multiaddr does not appear to contain IP4 or IP6, defaulting to IP6",J),"IP6"}function certhash$1(J){const E=J.stringTuples().filter(ee=>ee[0]===CERTHASH_CODE$1).map(ee=>ee[1])[0];if(E===void 0||E==="")throw inappropriateMultiaddr$1(`Couldn't find a certhash component of multiaddr: ${J.toString()}`);return E}function decodeCerthash$1(J){const E=mbdecoder$1.decode(J);return src$1.decode(E)}function ma2Fingerprint$1(J){const E=decodeCerthash$1(certhash$1(J)),ee=toSupportedHashFunction$1(E.name),te=E.digest.reduce((ne,ie)=>ne+ie.toString(16).padStart(2,"0"),""),re=te.match(/.{1,2}/g);if(re==null)throw invalidFingerprint$1(te,J.toString());return[`${ee.toUpperCase()} ${re.join(":").toUpperCase()}`,te]}function toSupportedHashFunction$1(J){switch(J){case"sha1":return"sha-1";case"sha2-256":return"sha-256";case"sha2-512":return"sha-512";default:throw unsupportedHashAlgorithm$1(J)}}function ma2sdp$1(J,E){const{host:ee,port:te}=J.toOptions(),re=ipv$1(J),[ne]=ma2Fingerprint$1(J);return`v=0
o=- 0 0 IN ${re} ${ee}
s=-
c=IN ${re} ${ee}
t=0 0
a=ice-lite
m=application ${te} UDP/DTLS/SCTP webrtc-datachannel
a=mid:0
a=setup:passive
a=ice-ufrag:${E}
a=ice-pwd:${E}
a=fingerprint:${ne}
a=sctp-port:5000
a=max-message-size:100000
a=candidate:1467250027 1 UDP 1467250027 ${ee} ${te} typ host\r
`}function fromMultiAddr$1(J,E){return{type:"answer",sdp:ma2sdp$1(J,E)}}function munge$1(J,E){if(J.sdp===void 0)throw invalidArgument$1("Can't munge a missing SDP");return J.sdp=J.sdp.replace(/\na=ice-ufrag:[^\n]*\n/,`
a=ice-ufrag:`+E+`
`).replace(/\na=ice-pwd:[^\n]*\n/,`
a=ice-pwd:`+E+`
`),J}const charset$1=Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),genUfrag$1=J=>[...Array(J)].map(()=>charset$1.at(Math.floor(Math.random()*charset$1.length))).join(""),log$$=logger$1("libp2p:webrtc:transport"),HANDSHAKE_TIMEOUT_MS$1=1e4,WEBRTC_CODE$2=getProtocol("webrtc-direct").code,CERTHASH_CODE$1=getProtocol("certhash").code;let WebRTCDirectTransport$1=class{metrics;components;constructor(J){this.components=J,J.metrics!=null&&(this.metrics={dialerEvents:J.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total",{label:"event",help:"Total count of WebRTC dial events by type"})})}async dial(J,E){const ee=await this._connect(J,E);return log$$(`dialing address - ${J.toString()}`),ee}createListener(J){throw unimplemented$1("WebRTCTransport.createListener")}filter(J){return J.filter(validMa$1)}[Symbol.toStringTag]="@libp2p/webrtc-direct";[symbol$2]=!0;async _connect(J,E){const ee=new AbortController,te=ee.signal,re=J.getPeerId();if(re===null)throw inappropriateMultiaddr$1("we need to have the remote's PeerId");const ne=peerIdFromString(re),ie=decodeCerthash$1(certhash$1(J)),se=await RTCPeerConnection.generateCertificate({name:"ECDSA",namedCurve:"P-256",hash:toSupportedHashFunction$1(ie.name)}),oe=new RTCPeerConnection({certificates:[se]}),ce=new Promise((ge,Se)=>{const $e=oe.createDataChannel("",{negotiated:!0,id:0}),Pe=setTimeout(()=>{const Me=`Data channel was never opened: state: ${$e.readyState}`;log$$.error(Me),this.metrics?.dialerEvents.increment({open_error:!0}),Se(dataChannelError$1("data",Me))},HANDSHAKE_TIMEOUT_MS$1);$e.onopen=Me=>{clearTimeout(Pe),ge($e)},$e.onerror=Me=>{clearTimeout(Pe);const xe=`Error opening a data channel for handshaking: ${Me.target?.toString()??"not specified"}`;log$$.error(xe),this.metrics?.dialerEvents.increment({unknown_error:!0}),Se(dataChannelError$1("data",xe))}}),ae="libp2p+webrtc+v1/"+genUfrag$1(32),le=await oe.createOffer(),ue=munge$1(le,ae);await oe.setLocalDescription(ue);const he=fromMultiAddr$1(J,ae);await oe.setRemoteDescription(he);const pe=await ce,de=this.components.peerId,fe=this.generateNoisePrologue(oe,ie.code,J),me=noise$1({prologueBytes:fe})(),_e=new WebRTCStream$1({channel:pe,stat:{direction:"inbound",timeline:{open:1}}}),be={..._e,sink:_e.sink.bind(_e),source:async function*(){for await(const ge of _e.source)for(const Se of ge)yield Se}()},Ee=new WebRTCMultiaddrConnection$1({peerConnection:oe,remoteAddr:J,timeline:{open:Date.now()},metrics:this.metrics?.dialerEvents}),ve=isFirefox$1?"iceconnectionstatechange":"connectionstatechange";oe.addEventListener(ve,()=>{switch(oe.connectionState){case"failed":case"disconnected":case"closed":Ee.close().catch(ge=>{log$$.error("error closing connection",ge)}).finally(()=>{ee.abort()});break}},{signal:te}),this.metrics?.dialerEvents.increment({peer_connection:!0});const we=new DataChannelMuxerFactory$1(oe,this.metrics?.dialerEvents);return await me.secureInbound(de,be,ne),E.upgrader.upgradeOutbound(Ee,{skipProtection:!0,skipEncryption:!0,muxerFactory:we})}generateNoisePrologue(J,E,ee){if(J.getConfiguration().certificates?.length===0)throw invalidArgument$1("no local certificate");const te=getLocalFingerprint$1(J);if(te==null)throw invalidArgument$1("no local fingerprint found");const re=te.trim().toLowerCase().replaceAll(":",""),ne=fromString$5(re,"hex"),ie=src$1.encode(ne,E),se=mbdecoder$1.decode(certhash$1(ee)),oe=fromString$5("libp2p-webrtc-noise:");return concat$4([oe,ie,se])}};function validMa$1(J){const E=J.protoCodes();return E.includes(WEBRTC_CODE$2)&&E.includes(CERTHASH_CODE$1)&&J.getPeerId()!=null&&!E.includes(getProtocol("p2p-circuit").code)}function webRTCDirect$1(){return J=>new WebRTCDirectTransport$1(J)}function webRTC$1(J){return E=>new WebRTCTransport$1(E,J??{})}const WebSocket$1=WebSocket;var dom={},eventIterator={};Object.defineProperty(eventIterator,"__esModule",{value:!0});class EventQueue{constructor(){this.pullQueue=[],this.pushQueue=[],this.eventHandlers={},this.isPaused=!1,this.isStopped=!1}push(E){if(this.isStopped)return;const ee={value:E,done:!1};if(this.pullQueue.length){const te=this.pullQueue.shift();te&&te.resolve(ee)}else this.pushQueue.push(Promise.resolve(ee)),this.highWaterMark!==void 0&&this.pushQueue.length>=this.highWaterMark&&!this.isPaused&&(this.isPaused=!0,this.eventHandlers.highWater?this.eventHandlers.highWater():console&&console.warn(`EventIterator queue reached ${this.pushQueue.length} items`))}stop(){if(!this.isStopped){this.isStopped=!0,this.remove();for(const E of this.pullQueue)E.resolve({value:void 0,done:!0});this.pullQueue.length=0}}fail(E){if(!this.isStopped)if(this.isStopped=!0,this.remove(),this.pullQueue.length){for(const ee of this.pullQueue)ee.reject(E);this.pullQueue.length=0}else{const ee=Promise.reject(E);ee.catch(()=>{}),this.pushQueue.push(ee)}}remove(){Promise.resolve().then(()=>{this.removeCallback&&this.removeCallback()})}[Symbol.asyncIterator](){return{next:E=>{const ee=this.pushQueue.shift();return ee?(this.lowWaterMark!==void 0&&this.pushQueue.length<=this.lowWaterMark&&this.isPaused&&(this.isPaused=!1,this.eventHandlers.lowWater&&this.eventHandlers.lowWater()),ee):this.isStopped?Promise.resolve({value:void 0,done:!0}):new Promise((te,re)=>{this.pullQueue.push({resolve:te,reject:re})})},return:()=>(this.isStopped=!0,this.pushQueue.length=0,this.remove(),Promise.resolve({value:void 0,done:!0}))}}}let EventIterator$1=class{constructor(J,{highWaterMark:E=100,lowWaterMark:ee=1}={}){const te=new EventQueue;te.highWaterMark=E,te.lowWaterMark=ee,te.removeCallback=J({push:re=>te.push(re),stop:()=>te.stop(),fail:re=>te.fail(re),on:(re,ne)=>{te.eventHandlers[re]=ne}})||(()=>{}),this[Symbol.asyncIterator]=()=>te[Symbol.asyncIterator](),Object.freeze(this)}};eventIterator.EventIterator=EventIterator$1;eventIterator.default=EventIterator$1;Object.defineProperty(dom,"__esModule",{value:!0});const event_iterator_1=eventIterator;var EventIterator=dom.EventIterator=event_iterator_1.EventIterator;function subscribe(J,E,ee){return new event_iterator_1.EventIterator(({push:te})=>(this.addEventListener(J,te,E),()=>this.removeEventListener(J,te,E)),ee)}dom.subscribe=subscribe;dom.default=event_iterator_1.EventIterator;function isArrayBuffer(J){return J instanceof ArrayBuffer||J?.constructor?.name==="ArrayBuffer"&&typeof J?.byteLength=="number"}const source=J=>{J.binaryType="arraybuffer";const E=async()=>{await new Promise((ne,ie)=>{if(te){ne();return}if(re!=null){ie(re);return}const se=ae=>{J.removeEventListener("open",oe),J.removeEventListener("error",ce),ae()},oe=()=>{se(ne)},ce=ae=>{se(()=>{ie(ae.error??new Error(`connect ECONNREFUSED ${J.url}`))})};J.addEventListener("open",oe),J.addEventListener("error",ce)})},ee=async function*(){const ne=new EventIterator(({push:ie,stop:se,fail:oe})=>{const ce=le=>{let ue=null;typeof le.data=="string"&&(ue=fromString$5(le.data)),isArrayBuffer(le.data)&&(ue=new Uint8Array(le.data)),le.data instanceof Uint8Array&&(ue=le.data),ue!=null&&ie(ue)},ae=le=>{oe(le.error??new Error("Socket error"))};return J.addEventListener("message",ce),J.addEventListener("error",ae),J.addEventListener("close",se),()=>{J.removeEventListener("message",ce),J.removeEventListener("error",ae),J.removeEventListener("close",se)}},{highWaterMark:1/0});await E();for await(const ie of ne)yield isArrayBuffer(ie)?new Uint8Array(ie):ie}();let te=J.readyState===1,re;return J.addEventListener("open",()=>{te=!0,re=null}),J.addEventListener("close",()=>{te=!1,re=null}),J.addEventListener("error",ne=>{te||(re=ne.error??new Error(`connect ECONNREFUSED ${J.url}`))}),Object.assign(ee,{connected:E})},ready=async J=>{if(J.readyState>=2)throw new Error("socket closed");J.readyState!==1&&await new Promise((E,ee)=>{function te(){J.removeEventListener("open",re),J.removeEventListener("error",ne)}function re(){te(),E()}function ne(ie){te(),ee(ie.error??new Error(`connect ECONNREFUSED ${J.url}`))}J.addEventListener("open",re),J.addEventListener("error",ne)})},sink=(J,E)=>(E=E??{},E.closeOnEnd=E.closeOnEnd!==!1,async ee=>{for await(const te of ee){try{await ready(J)}catch(re){if(re.message==="socket closed")break;throw re}J.send(te)}E.closeOnEnd!=null&&J.readyState<=1&&await new Promise((te,re)=>{J.addEventListener("close",ne=>{if(ne.wasClean||ne.code===1006)te();else{const ie=Object.assign(new Error("ws error"),{event:ne});re(ie)}}),setTimeout(()=>{J.close()})})}),duplex=(J,E)=>{E=E??{};const ee=source(J);let te=E.remoteAddress,re=E.remotePort;if(J.url!=null)try{const ne=new URL(J.url);te=ne.hostname,re=parseInt(ne.port,10)}catch{}if(te==null||re==null)throw new Error("Remote connection did not have address and/or port");return{sink:sink(J,E),source:ee,connected:async()=>{await ee.connected()},close:async()=>{(J.readyState===J.CONNECTING||J.readyState===J.OPEN)&&await new Promise(ne=>{J.addEventListener("close",()=>{ne()}),J.close()})},destroy:()=>{J.terminate!=null?J.terminate():J.close()},remoteAddress:te,remotePort:re,socket:J}},isReactNative$1=typeof navigator<"u"&&navigator.product==="ReactNative";function getDefaultBase(){return isReactNative$1?"http://localhost":self.location?self.location.protocol+"//"+self.location.host:""}const URL$1=self.URL,defaultBase$1=getDefaultBase();let URLWithLegacySupport$2=class{constructor(J="",E=defaultBase$1){this.super=new URL$1(J,E),this.path=this.pathname+this.search,this.auth=this.username&&this.password?this.username+":"+this.password:null,this.query=this.search&&this.search.startsWith("?")?this.search.slice(1):null}get hash(){return this.super.hash}get host(){return this.super.host}get hostname(){return this.super.hostname}get href(){return this.super.href}get origin(){return this.super.origin}get password(){return this.super.password}get pathname(){return this.super.pathname}get port(){return this.super.port}get protocol(){return this.super.protocol}get search(){return this.super.search}get searchParams(){return this.super.searchParams}get username(){return this.super.username}set hash(J){this.super.hash=J}set host(J){this.super.host=J}set hostname(J){this.super.hostname=J}set href(J){this.super.href=J}set password(J){this.super.password=J}set pathname(J){this.super.pathname=J}set port(J){this.super.port=J}set protocol(J){this.super.protocol=J}set search(J){this.super.search=J}set username(J){this.super.username=J}static createObjectURL(J){return URL$1.createObjectURL(J)}static revokeObjectURL(J){URL$1.revokeObjectURL(J)}toJSON(){return this.super.toJSON()}toString(){return this.super.toString()}format(){return this.toString()}};function format$2(J){if(typeof J=="string")return new URL$1(J).toString();if(!(J instanceof URL$1)){const E=J.username&&J.password?`${J.username}:${J.password}@`:"",ee=J.auth?J.auth+"@":"",te=J.port?":"+J.port:"",re=J.protocol?J.protocol+"//":"",ne=J.host||"",ie=J.hostname||"",se=J.search||(J.query?"?"+J.query:""),oe=J.hash||"",ce=J.pathname||"",ae=J.path||ce+se;return`${re}${E||ee}${ne||ie+te}${ae}${oe}`}}var urlBrowser={URLWithLegacySupport:URLWithLegacySupport$2,URLSearchParams:self.URLSearchParams,defaultBase:defaultBase$1,format:format$2};const{URLWithLegacySupport:URLWithLegacySupport$1,format:format$1}=urlBrowser;var relative$1=(J,E={},ee={},te)=>{let re=E.protocol?E.protocol.replace(":",""):"http";re=(ee[re]||te||re)+":";let ne;try{ne=new URLWithLegacySupport$1(J)}catch{ne={}}const ie=Object.assign({},E,{protocol:re||ne.protocol,host:E.host||ne.host});return new URLWithLegacySupport$1(J,format$1(ie)).toString()};const{URLWithLegacySupport,format,URLSearchParams,defaultBase}=urlBrowser,relative=relative$1;var isoUrl={URL:URLWithLegacySupport,URLSearchParams,format,relative,defaultBase};const map={http:"ws",https:"wss"},def="ws",wsurl=(J,E)=>isoUrl.relative(J,E,map,def);function connect(J,E){const ee=typeof window>"u"?"":window.location;E=E??{};const te=wsurl(J,ee.toString()),re=new WebSocket$1(te,E.websocket);return duplex(re,E)}const reduceValue=(J,E)=>E,tcpUri=(J,E,ee,te)=>{if(te!=null&&te.assumeHttp===!1)return`tcp://${J}:${E}`;let re="tcp",ne=`:${E}`;return ee[ee.length-1].protocol==="tcp"&&(re=E==="443"?"https":"http",ne=E==="443"||E==="80"?"":ne),`${re}://${J}${ne}`},Reducers={ip4:reduceValue,ip6:(J,E,ee,te)=>te.length===1&&te[0].protocol==="ip6"?E:`[${E}]`,tcp:(J,E,ee,te,re)=>te.some(ne=>["http","https","ws","wss"].includes(ne.protocol))?`${J}:${E}`:tcpUri(J,E,te,re),udp:(J,E)=>`udp://${J}:${E}`,dnsaddr:reduceValue,dns4:reduceValue,dns6:reduceValue,ipfs:(J,E)=>`${J}/ipfs/${E}`,p2p:(J,E)=>`${J}/p2p/${E}`,http:J=>`http://${J}`,https:J=>`https://${J}`,ws:J=>`ws://${J}`,wss:J=>`wss://${J}`,"p2p-websocket-star":J=>`${J}/p2p-websocket-star`,"p2p-webrtc-star":J=>`${J}/p2p-webrtc-star`,"p2p-webrtc-direct":J=>`${J}/p2p-webrtc-direct`};function multiaddrToUri(J,E){const ee=multiaddr(J),te=ee.toString().split("/").slice(1);return ee.tuples().map(re=>({protocol:te.shift()??"",content:re[1]!=null?te.shift()??"":""})).reduce((re,ne,ie,se)=>{const oe=Reducers[ne.protocol];if(oe==null)throw new Error(`Unsupported protocol ${ne.protocol}`);return oe(re,ne.content,ie,se,E)},"")}function isElectron$1(){return!!(typeof window<"u"&&typeof window.process=="object"&&window.process.type==="renderer"||typeof process<"u"&&typeof process.versions=="object"&&process.versions.electron||typeof navigator=="object"&&typeof navigator.userAgent=="string"&&navigator.userAgent.indexOf("Electron")>=0)}var isElectron_1=isElectron$1;const detectElectron=getDefaultExportFromCjs(isElectron_1),isEnvWithDom=typeof window=="object"&&typeof document=="object"&&document.nodeType===9,isElectron=detectElectron(),isBrowser=isEnvWithDom&&!isElectron,isElectronMain=isElectron&&!isEnvWithDom,isElectronRenderer=isElectron&&isEnvWithDom,isNode=typeof globalThis.process<"u"&&typeof globalThis.process.release<"u"&&globalThis.process.release.name==="node"&&!isElectron,isWebWorker=typeof importScripts=="function"&&typeof self<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope;typeof globalThis.process<"u"&&typeof globalThis.process.env<"u"&&globalThis.process.env["NODE"+(()=>"_")()+"ENV"];const isReactNative=typeof navigator<"u"&&navigator.product==="ReactNative";function createListener$2(){throw new Error("WebSocket Servers can not be created in the browser!")}const CODE_P2P=421,CODE_CIRCUIT=290,CLOSE_TIMEOUT=2e3,log$_=logger$1("libp2p:websockets:socket");function socketToMaConn(J,E,ee){ee=ee??{};const te={async sink(re){ee?.signal!=null&&(re=abortableSource$1(re,ee.signal));try{await J.sink(re)}catch(ne){ne.type!=="aborted"&&log$_.error(ne)}},source:ee.signal!=null?abortableSource$1(J.source,ee.signal):J.source,remoteAddr:E,timeline:{open:Date.now()},async close(){const re=Date.now();try{await pTimeout(J.close(),{milliseconds:CLOSE_TIMEOUT})}catch{const{host:ne,port:ie}=te.remoteAddr.toOptions();log$_("timeout closing stream to %s:%s after %dms, destroying it manually",ne,ie,Date.now()-re),J.destroy()}finally{te.timeline.close=Date.now()}}};return J.socket.addEventListener("close",()=>{te.timeline.close==null&&(te.timeline.close=Date.now())},{once:!0}),te}function all(J){return J.filter(E=>{if(E.protoCodes().includes(CODE_CIRCUIT))return!1;const ee=E.decapsulateCode(CODE_P2P);return WebSockets$1.matches(ee)||WebSocketsSecure.matches(ee)})}function wss(J){return J.filter(E=>{if(E.protoCodes().includes(CODE_CIRCUIT))return!1;const ee=E.decapsulateCode(CODE_P2P);return WebSocketsSecure.matches(ee)})}const log$Z=logger$1("libp2p:websockets");class WebSockets{constructor(E){this.init=E}get[Symbol.toStringTag](){return"@libp2p/websockets"}get[symbol$2](){return!0}async dial(E,ee){log$Z("dialing %s",E),ee=ee??{};const te=await this._connect(E,ee),re=socketToMaConn(te,E);log$Z("new outbound connection %s",re.remoteAddr);const ne=await ee.upgrader.upgradeOutbound(re);return log$Z("outbound connection %s upgraded",re.remoteAddr),ne}async _connect(E,ee){if(ee?.signal?.aborted===!0)throw new AbortError$5;const te=E.toOptions();log$Z("dialing %s:%s",te.host,te.port);const re=pDefer(),ne=ce=>{log$Z.error("connection error:",ce),re.reject(ce)},ie=connect(multiaddrToUri(E),this.init);if(ie.socket.on!=null?ie.socket.on("error",ne):ie.socket.onerror=ne,ee.signal==null)return await Promise.race([ie.connected(),re.promise]),log$Z("connected %s",E),ie;let se;const oe=new Promise((ce,ae)=>{if(se=()=>{ae(new AbortError$5),ie.close().catch(le=>{log$Z.error("error closing raw socket",le)})},ee?.signal?.aborted===!0){se();return}ee?.signal?.addEventListener("abort",se)});try{await Promise.race([oe,re.promise,ie.connected()])}finally{se!=null&&ee?.signal?.removeEventListener("abort",se)}return log$Z("connected %s",E),ie}createListener(E){return createListener$2({...this.init,...E})}filter(E){return E=Array.isArray(E)?E:[E],this.init?.filter!=null?this.init?.filter(E):isBrowser||isWebWorker?wss(E):all(E)}}function webSockets(J={}){return()=>new WebSockets(J)}function allocUnsafe$2(J){return new Uint8Array(J)}var MessageTypes$1;(function(J){J[J.NEW_STREAM=0]="NEW_STREAM",J[J.MESSAGE_RECEIVER=1]="MESSAGE_RECEIVER",J[J.MESSAGE_INITIATOR=2]="MESSAGE_INITIATOR",J[J.CLOSE_RECEIVER=3]="CLOSE_RECEIVER",J[J.CLOSE_INITIATOR=4]="CLOSE_INITIATOR",J[J.RESET_RECEIVER=5]="RESET_RECEIVER",J[J.RESET_INITIATOR=6]="RESET_INITIATOR"})(MessageTypes$1||(MessageTypes$1={}));const MessageTypeNames$1=Object.freeze({0:"NEW_STREAM",1:"MESSAGE_RECEIVER",2:"MESSAGE_INITIATOR",3:"CLOSE_RECEIVER",4:"CLOSE_INITIATOR",5:"RESET_RECEIVER",6:"RESET_INITIATOR"}),InitiatorMessageTypes$1=Object.freeze({NEW_STREAM:MessageTypes$1.NEW_STREAM,MESSAGE:MessageTypes$1.MESSAGE_INITIATOR,CLOSE:MessageTypes$1.CLOSE_INITIATOR,RESET:MessageTypes$1.RESET_INITIATOR}),ReceiverMessageTypes$1=Object.freeze({MESSAGE:MessageTypes$1.MESSAGE_RECEIVER,CLOSE:MessageTypes$1.CLOSE_RECEIVER,RESET:MessageTypes$1.RESET_RECEIVER});function isAsyncIterable$5(J){return J[Symbol.asyncIterator]!=null}const DEFAULT_BATCH_SIZE=1024*1024,DEFAULT_SERIALIZE=(J,E)=>{E.append(J)};function batchedBytes(J,E){return isAsyncIterable$5(J)?async function*(){let ee=new Uint8ArrayList,te=!1,re=pDefer(),ne=Number(E?.size??DEFAULT_BATCH_SIZE);if((isNaN(ne)||ne===0||ne<0)&&(ne=DEFAULT_BATCH_SIZE),ne!==Math.round(ne))throw new Error("Batch size must be an integer");const ie=E?.yieldAfter??0,se=E?.serialize??DEFAULT_SERIALIZE;for(Promise.resolve().then(async()=>{try{let oe;for await(const ce of J){if(se(ce,ee),ee.byteLength>=ne){clearTimeout(oe),re.resolve();continue}oe=setTimeout(()=>{re.resolve()},ie)}clearTimeout(oe),re.resolve()}catch(oe){re.reject(oe)}finally{te=!0}});!te;)if(await re.promise,re=pDefer(),ee.byteLength>0){const oe=ee;ee=new Uint8ArrayList,yield oe.subarray()}}():function*(){const ee=new Uint8ArrayList;let te=Number(E?.size??DEFAULT_BATCH_SIZE);if((isNaN(te)||te===0||te<0)&&(te=DEFAULT_BATCH_SIZE),te!==Math.round(te))throw new Error("Batch size must be an integer");const re=E?.serialize??DEFAULT_SERIALIZE;for(const ne of J)re(ne,ee),ee.byteLength>=te&&(yield ee.subarray(0,te),ee.consume(te));ee.byteLength>0&&(yield ee.subarray())}()}const POOL_SIZE$1=10*1024;let Encoder$1=class{constructor(){this._pool=allocUnsafe$2(POOL_SIZE$1),this._poolOffset=0}write(J,E){const ee=this._pool;let te=this._poolOffset;varint$4.encode(J.id<<3|J.type,ee,te),te+=varint$4.encode.bytes??0,(J.type===MessageTypes$1.NEW_STREAM||J.type===MessageTypes$1.MESSAGE_INITIATOR||J.type===MessageTypes$1.MESSAGE_RECEIVER)&&J.data!=null?varint$4.encode(J.data.length,ee,te):varint$4.encode(0,ee,te),te+=varint$4.encode.bytes??0;const re=ee.subarray(this._poolOffset,te);POOL_SIZE$1-te<100?(this._pool=allocUnsafe$2(POOL_SIZE$1),this._poolOffset=0):this._poolOffset=te,E.append(re),(J.type===MessageTypes$1.NEW_STREAM||J.type===MessageTypes$1.MESSAGE_INITIATOR||J.type===MessageTypes$1.MESSAGE_RECEIVER)&&J.data!=null&&E.append(J.data)}};const encoder$2=new Encoder$1;async function*encode$4(J,E=0){if(E==null||E===0){for await(const ee of J){const te=new Uint8ArrayList;for(const re of ee)encoder$2.write(re,te);yield te.subarray()}return}yield*batchedBytes(J,{size:E,serialize:(ee,te)=>{for(const re of ee)encoder$2.write(re,te)}})}const MAX_MSG_SIZE$1=1<<20,MAX_MSG_QUEUE_SIZE$1=4<<20;let Decoder$2=class{constructor(J=MAX_MSG_SIZE$1,E=MAX_MSG_QUEUE_SIZE$1){this._buffer=new Uint8ArrayList,this._headerInfo=null,this._maxMessageSize=J,this._maxUnprocessedMessageQueueSize=E}write(J){if(J==null||J.length===0)return[];if(this._buffer.append(J),this._buffer.byteLength>this._maxUnprocessedMessageQueueSize)throw Object.assign(new Error("unprocessed message queue size too large!"),{code:"ERR_MSG_QUEUE_TOO_BIG"});const E=[];for(;this._buffer.length!==0;){if(this._headerInfo==null)try{this._headerInfo=this._decodeHeader(this._buffer)}catch(se){if(se.code==="ERR_MSG_TOO_BIG")throw se;break}const{id:ee,type:te,length:re,offset:ne}=this._headerInfo;if(this._buffer.length-ne<re)break;const ie={id:ee,type:te};(te===MessageTypes$1.NEW_STREAM||te===MessageTypes$1.MESSAGE_INITIATOR||te===MessageTypes$1.MESSAGE_RECEIVER)&&(ie.data=this._buffer.sublist(ne,ne+re)),E.push(ie),this._buffer.consume(ne+re),this._headerInfo=null}return E}_decodeHeader(J){const{value:E,offset:ee}=readVarInt$1(J),{value:te,offset:re}=readVarInt$1(J,ee),ne=E&7;if(MessageTypeNames$1[ne]==null)throw new Error(`Invalid type received: ${ne}`);if(te>this._maxMessageSize)throw Object.assign(new Error("message size too large!"),{code:"ERR_MSG_TOO_BIG"});return{id:E>>3,type:ne,offset:ee+re,length:te}}};const MSB$1=128,REST$1=127;function readVarInt$1(J,E=0){let ee=0,te=0,re=E,ne;const ie=J.length;do{if(re>=ie||te>49)throw E=0,new RangeError("Could not decode varint");ne=J.get(re++),ee+=te<28?(ne&REST$1)<<te:(ne&REST$1)*Math.pow(2,te),te+=7}while(ne>=MSB$1);return E=re-E,{value:ee,offset:E}}const log$Y=logger$1("libp2p:mplex:stream"),ERR_STREAM_RESET$2="ERR_STREAM_RESET",ERR_STREAM_ABORT$2="ERR_STREAM_ABORT",ERR_SINK_ENDED$1="ERR_SINK_ENDED",ERR_DOUBLE_SINK$1="ERR_DOUBLE_SINK";function createStream$2(J){const{id:E,name:ee,send:te,onEnd:re,type:ne="initiator",maxMsgSize:ie=MAX_MSG_SIZE$1}=J,se=new AbortController,oe=new AbortController,ce=new AbortController,ae=ne==="initiator"?InitiatorMessageTypes$1:ReceiverMessageTypes$1,le=ne==="initiator"?`i${E}`:`r${E}`,ue=`${ee??E}`;let he=!1,pe=!1,de=!1,fe;const me={open:Date.now()},_e=we=>{he||(he=!0,log$Y.trace("%s stream %s source end - err: %o",ne,ue,we),we!=null&&fe==null&&(fe=we),pe&&(ve.stat.timeline.close=Date.now(),re?.(fe)))},be=we=>{pe||(pe=!0,log$Y.trace("%s stream %s sink end - err: %o",ne,ue,we),we!=null&&fe==null&&(fe=we),he&&(me.close=Date.now(),re?.(fe)))},Ee=pushable({onEnd:_e}),ve={close:()=>{log$Y.trace("%s stream %s close",ne,ue),ve.closeRead(),ve.closeWrite()},closeRead:()=>{log$Y.trace("%s stream %s closeRead",ne,ue),!he&&Ee.end()},closeWrite:()=>{if(log$Y.trace("%s stream %s closeWrite",ne,ue),!pe){ce.abort();try{te({id:E,type:ae.CLOSE})}catch(we){log$Y.trace("%s stream %s error sending close",ne,ee,we)}be()}},abort:we=>{log$Y.trace("%s stream %s abort",ne,ue,we),Ee.end(we),se.abort(),be(we)},reset:()=>{const we=new CodeError("stream reset",ERR_STREAM_RESET$2);oe.abort(),Ee.end(we),be(we)},sink:async we=>{if(de)throw new CodeError("sink already called on stream",ERR_DOUBLE_SINK$1);if(de=!0,pe)throw new CodeError("stream closed for writing",ERR_SINK_ENDED$1);const ge=anySignal([se.signal,oe.signal,ce.signal]);try{we=abortableSource$1(we,ge),ne==="initiator"&&te({id:E,type:InitiatorMessageTypes$1.NEW_STREAM,data:new Uint8ArrayList(fromString$5(ue))});for await(let Se of we)for(;Se.length>0;){if(Se.length<=ie){te({id:E,type:ae.MESSAGE,data:Se instanceof Uint8Array?new Uint8ArrayList(Se):Se});break}Se=Se instanceof Uint8Array?new Uint8ArrayList(Se):Se,te({id:E,type:ae.MESSAGE,data:Se.sublist(0,ie)}),Se.consume(ie)}}catch(Se){if(Se.type==="aborted"&&Se.message==="The operation was aborted"){if(ce.signal.aborted)return;oe.signal.aborted&&(Se.message="stream reset",Se.code=ERR_STREAM_RESET$2),se.signal.aborted&&(Se.message="stream aborted",Se.code=ERR_STREAM_ABORT$2)}if(Se.code===ERR_STREAM_RESET$2)log$Y.trace("%s stream %s reset",ne,ee);else{log$Y.trace("%s stream %s error",ne,ee,Se);try{te({id:E,type:ae.RESET})}catch($e){log$Y.trace("%s stream %s error sending reset",ne,ee,$e)}}Ee.end(Se),be(Se);return}finally{ge.clear()}try{te({id:E,type:ae.CLOSE})}catch(Se){log$Y.trace("%s stream %s error sending close",ne,ee,Se)}be()},source:Ee,sourcePush:we=>{Ee.push(we)},sourceReadableLength(){return Ee.readableLength},stat:{direction:ne==="initiator"?"outbound":"inbound",timeline:me},metadata:{},id:le};return ve}const log$X=logger$1("libp2p:mplex"),MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION$1=1024,MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION$1=1024,MAX_STREAM_BUFFER_SIZE$1=1024*1024*4,DISCONNECT_THRESHOLD$1=5;function printMessage$1(J){const E={...J,type:`${MessageTypeNames$1[J.type]} (${J.type})`};return J.type===MessageTypes$1.NEW_STREAM&&(E.data=toString$5(J.data instanceof Uint8Array?J.data:J.data.subarray())),(J.type===MessageTypes$1.MESSAGE_INITIATOR||J.type===MessageTypes$1.MESSAGE_RECEIVER)&&(E.data=toString$5(J.data instanceof Uint8Array?J.data:J.data.subarray(),"base16")),E}let MplexStreamMuxer$1=class{constructor(J){this.protocol="/mplex/6.7.0",J=J??{},this._streamId=0,this._streams={initiators:new Map,receivers:new Map},this._init=J,this.sink=this._createSink();const E=this._createSource();this._source=E,this.source=E,this.closeController=new AbortController,this.rateLimiter=new rateLimiterFlexible.RateLimiterMemory({points:J.disconnectThreshold??DISCONNECT_THRESHOLD$1,duration:1})}get streams(){const J=[];for(const E of this._streams.initiators.values())J.push(E);for(const E of this._streams.receivers.values())J.push(E);return J}newStream(J){if(this.closeController.signal.aborted)throw new Error("Muxer already closed");const E=this._streamId++;J=J==null?E.toString():J.toString();const ee=this._streams.initiators;return this._newStream({id:E,name:J,type:"initiator",registry:ee})}close(J){this.closeController.signal.aborted||(J!=null?this.streams.forEach(E=>{E.abort(J)}):this.streams.forEach(E=>{E.close()}),this.closeController.abort())}_newReceiverStream(J){const{id:E,name:ee}=J,te=this._streams.receivers;return this._newStream({id:E,name:ee,type:"receiver",registry:te})}_newStream(J){const{id:E,name:ee,type:te,registry:re}=J;if(log$X("new %s stream %s",te,E),te==="initiator"&&this._streams.initiators.size===(this._init.maxOutboundStreams??MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION$1))throw new CodeError("Too many outbound streams open","ERR_TOO_MANY_OUTBOUND_STREAMS");if(re.has(E))throw new Error(`${te} stream ${E} already exists!`);const ne=createStream$2({id:E,name:ee,send:ie=>{log$X.enabled&&log$X.trace("%s stream %s send",te,E,printMessage$1(ie)),this._source.push(ie)},type:te,onEnd:()=>{log$X("%s stream with id %s and protocol %s ended",te,E,ne.stat.protocol),re.delete(E),this._init.onStreamEnd!=null&&this._init.onStreamEnd(ne)},maxMsgSize:this._init.maxMsgSize});return re.set(E,ne),ne}_createSink(){return async J=>{const E=anySignal([this.closeController.signal,this._init.signal]);try{J=abortableSource$1(J,E);const ee=new Decoder$2(this._init.maxMsgSize,this._init.maxUnprocessedMessageQueueSize);for await(const te of J)for(const re of ee.write(te))await this._handleIncoming(re);this._source.end()}catch(ee){log$X("error in sink",ee),this._source.end(ee)}finally{E.clear()}}}_createSource(){const J=pushableV({objectMode:!0,onEnd:E=>{this.close(E)}});return Object.assign(encode$4(J,this._init.minSendBytes),{push:J.push,end:J.end,return:J.return})}async _handleIncoming(J){const{id:E,type:ee}=J;if(log$X.enabled&&log$X.trace("incoming message",printMessage$1(J)),J.type===MessageTypes$1.NEW_STREAM){if(this._streams.receivers.size===(this._init.maxInboundStreams??MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION$1)){log$X("too many inbound streams open"),this._source.push({id:E,type:MessageTypes$1.RESET_RECEIVER});try{await this.rateLimiter.consume("new-stream",1)}catch{log$X("rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection"),this._source.end(new Error("Too many open streams"));return}return}const ne=this._newReceiverStream({id:E,name:toString$5(J.data instanceof Uint8Array?J.data:J.data.subarray())});this._init.onIncomingStream!=null&&this._init.onIncomingStream(ne);return}const te=((ee&1)===1?this._streams.initiators:this._streams.receivers).get(E);if(te==null){log$X("missing stream %s for message type %s",E,MessageTypeNames$1[ee]);return}const re=this._init.maxStreamBufferSize??MAX_STREAM_BUFFER_SIZE$1;switch(ee){case MessageTypes$1.MESSAGE_INITIATOR:case MessageTypes$1.MESSAGE_RECEIVER:if(te.sourceReadableLength()>re){this._source.push({id:J.id,type:ee===MessageTypes$1.MESSAGE_INITIATOR?MessageTypes$1.RESET_RECEIVER:MessageTypes$1.RESET_INITIATOR});const ne=new CodeError("Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers","ERR_STREAM_INPUT_BUFFER_FULL");te.abort(ne);return}te.sourcePush(J.data);break;case MessageTypes$1.CLOSE_INITIATOR:case MessageTypes$1.CLOSE_RECEIVER:te.closeRead();break;case MessageTypes$1.RESET_INITIATOR:case MessageTypes$1.RESET_RECEIVER:te.reset();break;default:log$X("unknown message type %s",ee)}}},Mplex$1=class{constructor(J={}){this.protocol="/mplex/6.7.0",this._init=J}createStreamMuxer(J={}){return new MplexStreamMuxer$1({...J,...this._init})}};function mplex$1(J={}){return()=>new Mplex$1(J)}const CIRCUIT_PROTO_CODE$1=290,RELAY_RENDEZVOUS_NS$1="/libp2p/relay",DEFAULT_RESERVATION_CONCURRENCY$1=1,RELAY_TAG$1="circuit-relay-relay";BigInt(1<<17);const RELAY_V2_HOP_CODEC$1="/libp2p/circuit/relay/0.2.0/hop",RELAY_V2_STOP_CODEC$1="/libp2p/circuit/relay/0.2.0/stop";logger$1("libp2p:circuit-relay:utils");async function namespaceToCid$1(J){const E=new TextEncoder().encode(J),ee=await sha256$3.digest(E);return CID.createV0(ee)}function getExpirationMilliseconds$1(J){const E=J*BigInt(1e3);return Number(E-BigInt(new Date().getTime()))}var HopMessage$1;(function(J){(function(te){te.RESERVE="RESERVE",te.CONNECT="CONNECT",te.STATUS="STATUS"})(J.Type||(J.Type={}));let E;(function(te){te[te.RESERVE=0]="RESERVE",te[te.CONNECT=1]="CONNECT",te[te.STATUS=2]="STATUS"})(E||(E={})),function(te){te.codec=()=>enumeration(E)}(J.Type||(J.Type={}));let ee;J.codec=()=>(ee==null&&(ee=message((te,re,ne={})=>{ne.lengthDelimited!==!1&&re.fork(),te.type!=null&&(re.uint32(8),J.Type.codec().encode(te.type,re)),te.peer!=null&&(re.uint32(18),Peer$1.codec().encode(te.peer,re)),te.reservation!=null&&(re.uint32(26),Reservation$1.codec().encode(te.reservation,re)),te.limit!=null&&(re.uint32(34),Limit$1.codec().encode(te.limit,re)),te.status!=null&&(re.uint32(40),Status$1.codec().encode(te.status,re)),ne.lengthDelimited!==!1&&re.ldelim()},(te,re)=>{const ne={},ie=re==null?te.len:te.pos+re;for(;te.pos<ie;){const se=te.uint32();switch(se>>>3){case 1:ne.type=J.Type.codec().decode(te);break;case 2:ne.peer=Peer$1.codec().decode(te,te.uint32());break;case 3:ne.reservation=Reservation$1.codec().decode(te,te.uint32());break;case 4:ne.limit=Limit$1.codec().decode(te,te.uint32());break;case 5:ne.status=Status$1.codec().decode(te);break;default:te.skipType(se&7);break}}return ne})),ee),J.encode=te=>encodeMessage(te,J.codec()),J.decode=te=>decodeMessage$1(te,J.codec())})(HopMessage$1||(HopMessage$1={}));var StopMessage$1;(function(J){(function(te){te.CONNECT="CONNECT",te.STATUS="STATUS"})(J.Type||(J.Type={}));let E;(function(te){te[te.CONNECT=0]="CONNECT",te[te.STATUS=1]="STATUS"})(E||(E={})),function(te){te.codec=()=>enumeration(E)}(J.Type||(J.Type={}));let ee;J.codec=()=>(ee==null&&(ee=message((te,re,ne={})=>{ne.lengthDelimited!==!1&&re.fork(),te.type!=null&&(re.uint32(8),J.Type.codec().encode(te.type,re)),te.peer!=null&&(re.uint32(18),Peer$1.codec().encode(te.peer,re)),te.limit!=null&&(re.uint32(26),Limit$1.codec().encode(te.limit,re)),te.status!=null&&(re.uint32(32),Status$1.codec().encode(te.status,re)),ne.lengthDelimited!==!1&&re.ldelim()},(te,re)=>{const ne={},ie=re==null?te.len:te.pos+re;for(;te.pos<ie;){const se=te.uint32();switch(se>>>3){case 1:ne.type=J.Type.codec().decode(te);break;case 2:ne.peer=Peer$1.codec().decode(te,te.uint32());break;case 3:ne.limit=Limit$1.codec().decode(te,te.uint32());break;case 4:ne.status=Status$1.codec().decode(te);break;default:te.skipType(se&7);break}}return ne})),ee),J.encode=te=>encodeMessage(te,J.codec()),J.decode=te=>decodeMessage$1(te,J.codec())})(StopMessage$1||(StopMessage$1={}));var Peer$1;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{if(re.lengthDelimited!==!1&&te.fork(),ee.id!=null&&ee.id.byteLength>0&&(te.uint32(10),te.bytes(ee.id)),ee.addrs!=null)for(const ne of ee.addrs)te.uint32(18),te.bytes(ne);re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={id:new Uint8Array(0),addrs:[]},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.id=ee.bytes();break;case 2:re.addrs.push(ee.bytes());break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage$1(ee,J.codec())})(Peer$1||(Peer$1={}));var Reservation$1;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{if(re.lengthDelimited!==!1&&te.fork(),ee.expire!=null&&ee.expire!==0n&&(te.uint32(8),te.uint64(ee.expire)),ee.addrs!=null)for(const ne of ee.addrs)te.uint32(18),te.bytes(ne);ee.voucher!=null&&(te.uint32(26),te.bytes(ee.voucher)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={expire:0n,addrs:[]},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.expire=ee.uint64();break;case 2:re.addrs.push(ee.bytes());break;case 3:re.voucher=ee.bytes();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage$1(ee,J.codec())})(Reservation$1||(Reservation$1={}));var Limit$1;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{re.lengthDelimited!==!1&&te.fork(),ee.duration!=null&&(te.uint32(8),te.uint32(ee.duration)),ee.data!=null&&(te.uint32(16),te.uint64(ee.data)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.duration=ee.uint32();break;case 2:re.data=ee.uint64();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage$1(ee,J.codec())})(Limit$1||(Limit$1={}));var Status$1;(function(J){J.UNUSED="UNUSED",J.OK="OK",J.RESERVATION_REFUSED="RESERVATION_REFUSED",J.RESOURCE_LIMIT_EXCEEDED="RESOURCE_LIMIT_EXCEEDED",J.PERMISSION_DENIED="PERMISSION_DENIED",J.CONNECTION_FAILED="CONNECTION_FAILED",J.NO_RESERVATION="NO_RESERVATION",J.MALFORMED_MESSAGE="MALFORMED_MESSAGE",J.UNEXPECTED_MESSAGE="UNEXPECTED_MESSAGE"})(Status$1||(Status$1={}));var __StatusValues$1;(function(J){J[J.UNUSED=0]="UNUSED",J[J.OK=100]="OK",J[J.RESERVATION_REFUSED=200]="RESERVATION_REFUSED",J[J.RESOURCE_LIMIT_EXCEEDED=201]="RESOURCE_LIMIT_EXCEEDED",J[J.PERMISSION_DENIED=202]="PERMISSION_DENIED",J[J.CONNECTION_FAILED=203]="CONNECTION_FAILED",J[J.NO_RESERVATION=204]="NO_RESERVATION",J[J.MALFORMED_MESSAGE=400]="MALFORMED_MESSAGE",J[J.UNEXPECTED_MESSAGE=401]="UNEXPECTED_MESSAGE"})(__StatusValues$1||(__StatusValues$1={}));(function(J){J.codec=()=>enumeration(__StatusValues$1)})(Status$1||(Status$1={}));var ReservationVoucher$1;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{re.lengthDelimited!==!1&&te.fork(),ee.relay!=null&&ee.relay.byteLength>0&&(te.uint32(10),te.bytes(ee.relay)),ee.peer!=null&&ee.peer.byteLength>0&&(te.uint32(18),te.bytes(ee.peer)),ee.expiration!=null&&ee.expiration!==0n&&(te.uint32(24),te.uint64(ee.expiration)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={relay:new Uint8Array(0),peer:new Uint8Array(0),expiration:0n},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.relay=ee.bytes();break;case 2:re.peer=ee.bytes();break;case 3:re.expiration=ee.uint64();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage$1(ee,J.codec())})(ReservationVoucher$1||(ReservationVoucher$1={}));var retry={};function RetryOperation(J,E){typeof E=="boolean"&&(E={forever:E}),this._originalTimeouts=JSON.parse(JSON.stringify(J)),this._timeouts=J,this._options=E||{},this._maxRetryTime=E&&E.maxRetryTime||1/0,this._fn=null,this._errors=[],this._attempts=1,this._operationTimeout=null,this._operationTimeoutCb=null,this._timeout=null,this._operationStart=null,this._timer=null,this._options.forever&&(this._cachedTimeouts=this._timeouts.slice(0))}var retry_operation=RetryOperation;RetryOperation.prototype.reset=function(){this._attempts=1,this._timeouts=this._originalTimeouts.slice(0)};RetryOperation.prototype.stop=function(){this._timeout&&clearTimeout(this._timeout),this._timer&&clearTimeout(this._timer),this._timeouts=[],this._cachedTimeouts=null};RetryOperation.prototype.retry=function(J){if(this._timeout&&clearTimeout(this._timeout),!J)return!1;var E=new Date().getTime();if(J&&E-this._operationStart>=this._maxRetryTime)return this._errors.push(J),this._errors.unshift(new Error("RetryOperation timeout occurred")),!1;this._errors.push(J);var ee=this._timeouts.shift();if(ee===void 0)if(this._cachedTimeouts)this._errors.splice(0,this._errors.length-1),ee=this._cachedTimeouts.slice(-1);else return!1;var te=this;return this._timer=setTimeout(function(){te._attempts++,te._operationTimeoutCb&&(te._timeout=setTimeout(function(){te._operationTimeoutCb(te._attempts)},te._operationTimeout),te._options.unref&&te._timeout.unref()),te._fn(te._attempts)},ee),this._options.unref&&this._timer.unref(),!0};RetryOperation.prototype.attempt=function(J,E){this._fn=J,E&&(E.timeout&&(this._operationTimeout=E.timeout),E.cb&&(this._operationTimeoutCb=E.cb));var ee=this;this._operationTimeoutCb&&(this._timeout=setTimeout(function(){ee._operationTimeoutCb()},ee._operationTimeout)),this._operationStart=new Date().getTime(),this._fn(this._attempts)};RetryOperation.prototype.try=function(J){console.log("Using RetryOperation.try() is deprecated"),this.attempt(J)};RetryOperation.prototype.start=function(J){console.log("Using RetryOperation.start() is deprecated"),this.attempt(J)};RetryOperation.prototype.start=RetryOperation.prototype.try;RetryOperation.prototype.errors=function(){return this._errors};RetryOperation.prototype.attempts=function(){return this._attempts};RetryOperation.prototype.mainError=function(){if(this._errors.length===0)return null;for(var J={},E=null,ee=0,te=0;te<this._errors.length;te++){var re=this._errors[te],ne=re.message,ie=(J[ne]||0)+1;J[ne]=ie,ie>=ee&&(E=re,ee=ie)}return E};(function(J){var E=retry_operation;J.operation=function(ee){var te=J.timeouts(ee);return new E(te,{forever:ee&&(ee.forever||ee.retries===1/0),unref:ee&&ee.unref,maxRetryTime:ee&&ee.maxRetryTime})},J.timeouts=function(ee){if(ee instanceof Array)return[].concat(ee);var te={retries:10,factor:2,minTimeout:1*1e3,maxTimeout:1/0,randomize:!1};for(var re in ee)te[re]=ee[re];if(te.minTimeout>te.maxTimeout)throw new Error("minTimeout is greater than maxTimeout");for(var ne=[],ie=0;ie<te.retries;ie++)ne.push(this.createTimeout(ie,te));return ee&&ee.forever&&!ne.length&&ne.push(this.createTimeout(ie,te)),ne.sort(function(se,oe){return se-oe}),ne},J.createTimeout=function(ee,te){var re=te.randomize?Math.random()+1:1,ne=Math.round(re*Math.max(te.minTimeout,1)*Math.pow(te.factor,ee));return ne=Math.min(ne,te.maxTimeout),ne},J.wrap=function(ee,te,re){if(te instanceof Array&&(re=te,te=null),!re){re=[];for(var ne in ee)typeof ee[ne]=="function"&&re.push(ne)}for(var ie=0;ie<re.length;ie++){var se=re[ie],oe=ee[se];ee[se]=function(ce){var ae=J.operation(te),le=Array.prototype.slice.call(arguments,1),ue=le.pop();le.push(function(he){ae.retry(he)||(he&&(arguments[0]=ae.mainError()),ue.apply(this,arguments))}),ae.attempt(function(){ce.apply(ee,le)})}.bind(ee,oe),ee[se].options=te}}})(retry);logger$1("libp2p:circuit-relay:advert-service");logger$1("libp2p:circuit-relay:server");const log$W=logger$1("libp2p:stream:converter");function streamToMaConnection(J,E={}){const{stream:ee,remoteAddr:te}=J,{sink:re,source:ne}=ee,ie=async function*(){for await(const ce of ne)ce instanceof Uint8Array?yield ce:yield*ce}(),se={async sink(ce){E.signal!=null&&(ce=abortableSource$1(ce,E.signal));try{await re(ce),await oe()}catch(ae){ae.type!=="aborted"&&log$W(ae)}},source:E.signal!=null?abortableSource$1(ie,E.signal):ie,remoteAddr:te,timeline:{open:Date.now(),close:void 0},async close(){await re(async function*(){yield new Uint8Array(0)}()),await oe()}};async function oe(){se.timeline.close==null&&(se.timeline.close=Date.now()),await Promise.resolve()}return se}var __classPrivateFieldGet$2=globalThis&&globalThis.__classPrivateFieldGet||function(J,E,ee,te){if(ee==="a"&&!te)throw new TypeError("Private accessor was defined without a getter");if(typeof E=="function"?J!==E||!te:!E.has(J))throw new TypeError("Cannot read private member from an object whose class did not declare it");return ee==="m"?te:ee==="a"?te.call(J):te?te.value:E.get(J)},_CircuitRelayTransportListener_instances,_CircuitRelayTransportListener_removeRelayPeer;const log$V=logger$1("libp2p:circuit-relay:transport:listener");let CircuitRelayTransportListener$1=class extends EventEmitter$3{constructor(J){super(),_CircuitRelayTransportListener_instances.add(this),this.connectionManager=J.connectionManager,this.relayStore=J.relayStore,this.listeningAddrs=new PeerMap,this.relayStore.addEventListener("relay:removed",E=>{__classPrivateFieldGet$2(this,_CircuitRelayTransportListener_instances,"m",_CircuitRelayTransportListener_removeRelayPeer).call(this,E.detail)})}async listen(J){log$V("listen on %s",J);const E=J.getPeerId();let ee;if(E!=null){const re=peerIdFromString(E),ne=this.connectionManager.getConnectionsMap().get(re)??[];ne.length>0&&(ee=ne[0])}if(ee==null){const re=J.toString().split("/p2p-circuit").find(ie=>ie!==""),ne=multiaddr(re);ee=await this.connectionManager.openConnection(ne)}if(!this.relayStore.hasReservation(ee.remotePeer)){await this.relayStore.addRelay(ee.remotePeer,"configured");return}const te=this.relayStore.getReservation(ee.remotePeer);if(te==null)throw new CodeError("Did not have reservation after making reservation","ERR_NO_RESERVATION");if(this.listeningAddrs.has(ee.remotePeer)){log$V("already listening on relay %p",ee.remotePeer);return}this.listeningAddrs.set(ee.remotePeer,te.addrs.map(re=>multiaddr(re).encapsulate("/p2p-circuit"))),this.safeDispatchEvent("listening",{})}getAddrs(){return[...this.listeningAddrs.values()].flat()}async close(){}};_CircuitRelayTransportListener_instances=new WeakSet,_CircuitRelayTransportListener_removeRelayPeer=function J(E){const ee=this.listeningAddrs.has(E);this.listeningAddrs.delete(E),ee&&this.safeDispatchEvent("close",{})};function createListener$1(J){return new CircuitRelayTransportListener$1(J)}var __classPrivateFieldGet$1=globalThis&&globalThis.__classPrivateFieldGet||function(J,E,ee,te){if(ee==="a"&&!te)throw new TypeError("Private accessor was defined without a getter");if(typeof E=="function"?J!==E||!te:!E.has(J))throw new TypeError("Cannot read private member from an object whose class did not declare it");return ee==="m"?te:ee==="a"?te.call(J):te?te.value:E.get(J)},_ReservationStore_instances,_ReservationStore_createReservation,_ReservationStore_removeRelay;const log$U=logger$1("libp2p:circuit-relay:transport:reservation-store"),REFRESH_WINDOW$1=60*1e3*10,REFRESH_TIMEOUT$1=60*1e3*5,REFRESH_TIMEOUT_MIN$1=30*1e3;let ReservationStore$1=class extends EventEmitter$3{constructor(J,E){super(),_ReservationStore_instances.add(this),this.peerId=J.peerId,this.connectionManager=J.connectionManager,this.transportManager=J.transportManager,this.peerStore=J.peerStore,this.events=J.events,this.reservations=new PeerMap,this.maxDiscoveredRelays=E?.discoverRelays??0,this.started=!1,this.reserveQueue=new PQueue({concurrency:E?.reservationConcurrency??DEFAULT_RESERVATION_CONCURRENCY$1}),this.events.addEventListener("peer:disconnect",ee=>{__classPrivateFieldGet$1(this,_ReservationStore_instances,"m",_ReservationStore_removeRelay).call(this,ee.detail)})}isStarted(){return this.started}async start(){this.started=!0}async stop(){this.reservations.forEach(({timeout:J})=>{clearTimeout(J)}),this.reservations.clear(),this.started=!0}async addRelay(J,E){if(this.peerId.equals(J)){log$U("not trying to use self as relay");return}log$U("add relay %p",J),await this.reserveQueue.add(async()=>{try{const ee=this.reservations.get(J);if(ee!=null){if(getExpirationMilliseconds$1(ee.reservation.expire)>REFRESH_WINDOW$1){log$U("already have reservation on relay peer %p and it expires in more than 10 minutes",J);return}clearTimeout(ee.timeout),this.reservations.delete(J)}if(E==="discovered"&&[...this.reservations.values()].reduce((oe,ce)=>(ce.type==="discovered"&&oe++,oe),0)>=this.maxDiscoveredRelays){log$U("already have enough discovered relays");return}const te=await this.connectionManager.openConnection(J);if(te.remoteAddr.protoNames().includes("p2p-circuit")){log$U("not creating reservation over relayed connection");return}const re=await __classPrivateFieldGet$1(this,_ReservationStore_instances,"m",_ReservationStore_createReservation).call(this,te);log$U("created reservation on relay peer %p",J);const ne=getExpirationMilliseconds$1(re.expire),ie=Math.min(Math.max(ne-REFRESH_TIMEOUT$1,REFRESH_TIMEOUT_MIN$1),Math.pow(2,31)-1),se=setTimeout(()=>{this.addRelay(J,E).catch(oe=>{log$U.error("could not refresh reservation to relay %p",J,oe)})},ie);this.reservations.set(J,{timeout:se,reservation:re,type:E}),await this.peerStore.merge(J,{tags:{[RELAY_TAG$1]:{value:1,ttl:ne}}}),await this.transportManager.listen([multiaddr(`/p2p/${J.toString()}/p2p-circuit`)])}catch(ee){log$U.error("could not reserve slot on %p",J,ee),this.reservations.delete(J)}})}hasReservation(J){return this.reservations.has(J)}getReservation(J){return this.reservations.get(J)?.reservation}};_ReservationStore_instances=new WeakSet,_ReservationStore_createReservation=async function J(E){log$U("requesting reservation from %s",E.remotePeer);const ee=await E.newStream(RELAY_V2_HOP_CODEC$1),te=pbStream$1(ee).pb(HopMessage$1);te.write({type:HopMessage$1.Type.RESERVE});let re;try{re=await te.read()}catch(ie){throw log$U.error("error parsing reserve message response from %p because",E.remotePeer,ie),ie}finally{ee.close()}if(re.status===Status$1.OK&&re.reservation!=null)return re.reservation;const ne=`reservation failed with status ${re.status??"undefined"}`;throw log$U.error(ne),new Error(ne)},_ReservationStore_removeRelay=function J(E){const ee=this.reservations.get(E);ee!=null&&(log$U("connection to relay %p closed, removing reservation from local store",E),clearTimeout(ee.timeout),this.reservations.delete(E),this.safeDispatchEvent("relay:removed",{detail:E}),this.reservations.size<this.maxDiscoveredRelays&&(log$U("not enough relays %d/%d",this.reservations.size,this.maxDiscoveredRelays),this.safeDispatchEvent("relay:not-enough-relays",{})))};const noop=()=>{};class TopologyImpl{constructor(E){this.min=E.min??0,this.max=E.max??1/0,this.peers=new Set,this.onConnect=E.onConnect??noop,this.onDisconnect=E.onDisconnect??noop}get[Symbol.toStringTag](){return topologySymbol.toString()}get[topologySymbol](){return!0}async setRegistrar(E){this.registrar=E}disconnect(E){this.onDisconnect(E)}}function createTopology(J){return new TopologyImpl(J)}const log$T=logger$1("libp2p:circuit-relay:discover-relays");let RelayDiscovery$1=class extends EventEmitter$3{constructor(J){super(),this.started=!1,this.peerId=J.peerId,this.peerStore=J.peerStore,this.contentRouting=J.contentRouting,this.registrar=J.registrar}isStarted(){return this.started}async start(){this.topologyId=await this.registrar.register(RELAY_V2_HOP_CODEC$1,createTopology({onConnect:J=>{this.safeDispatchEvent("relay:discover",{detail:J})}})),this.discover().catch(J=>{log$T.error("error listening on relays",J)}),this.started=!0}stop(){this.topologyId!=null&&this.registrar.unregister(this.topologyId),this.started=!1}async discover(){log$T("searching peer store for relays");const J=(await this.peerStore.all()).filter(({protocols:E})=>E.includes(RELAY_V2_HOP_CODEC$1)).sort(()=>Math.random()-.5);for(const E of J)log$T("found relay peer %p in content peer store",E.id),this.safeDispatchEvent("relay:discover",{detail:E.id});log$T("found %d relay peers in peer store",J.length);try{log$T("searching content routing for relays");const E=await namespaceToCid$1(RELAY_RENDEZVOUS_NS$1);let ee=0;for await(const te of this.contentRouting.findProviders(E))if(te.multiaddrs.length>0&&!te.id.equals(this.peerId)){const re=te.id;ee++,await this.peerStore.merge(re,{multiaddrs:te.multiaddrs}),log$T("found relay peer %p in content routing",re),this.safeDispatchEvent("relay:discover",{detail:re})}log$T("found %d relay peers in content routing",ee)}catch(E){log$T.error("failed when finding relays on the network",E)}}};const log$S=logger$1("libp2p:circuit-relay:transport"),isValidStop$1=J=>{if(J.peer==null)return!1;try{J.peer.addrs.forEach(multiaddr)}catch{return!1}return!0};let CircuitRelayTransport$1=class{constructor(J,E){this.registrar=J.registrar,this.peerStore=J.peerStore,this.connectionManager=J.connectionManager,this.peerId=J.peerId,this.upgrader=J.upgrader,this.addressManager=J.addressManager,this.connectionGater=J.connectionGater,E.discoverRelays!=null&&E.discoverRelays>0&&(this.discovery=new RelayDiscovery$1(J),this.discovery.addEventListener("relay:discover",ee=>{this.reservationStore.addRelay(ee.detail,"discovered").catch(te=>{log$S.error("could not add discovered relay %p",ee.detail,te)})})),this.reservationStore=new ReservationStore$1(J,E),this.reservationStore.addEventListener("relay:not-enough-relays",()=>{this.discovery?.discover().catch(ee=>{log$S.error("could not discover relays",ee)})}),this.started=!1}isStarted(){return this.started}async start(){await this.reservationStore.start(),await this.discovery?.start(),await this.registrar.handle(RELAY_V2_STOP_CODEC$1,J=>{this.onStop(J).catch(E=>{log$S.error(E)})}),this.started=!0}async stop(){this.discovery?.stop(),await this.reservationStore.stop(),await this.registrar.unhandle(RELAY_V2_STOP_CODEC$1),this.started=!1}get[symbol$2](){return!0}get[Symbol.toStringTag](){return"libp2p/circuit-relay-v2"}async dial(J,E={}){if(J.protoCodes().filter(le=>le===CIRCUIT_PROTO_CODE$1).length!==1){const le="Invalid circuit relay address";throw log$S.error(le,J),new CodeError(le,codes$8.ERR_RELAYED_DIAL)}const ee=J.toString().split("/p2p-circuit"),te=multiaddr(ee[0]),re=multiaddr(ee[ee.length-1]),ne=te.getPeerId(),ie=re.getPeerId();if(ne==null||ie==null){const le=`Circuit relay dial to ${J.toString()} failed as address did not have peer ids`;throw log$S.error(le),new CodeError(le,codes$8.ERR_RELAYED_DIAL)}const se=peerIdFromString(ne),oe=peerIdFromString(ie);let ce=!1,ae=this.connectionManager.getConnections(se)[0];ae==null&&(await this.peerStore.merge(se,{multiaddrs:[te]}),ae=await this.connectionManager.openConnection(se,E),ce=!0);try{const le=await ae.newStream([RELAY_V2_HOP_CODEC$1]);return await this.connectV2({stream:le,connection:ae,destinationPeer:oe,destinationAddr:re,relayAddr:te,ma:J,disconnectOnFailure:ce})}catch(le){throw log$S.error(`Circuit relay dial to destination ${oe.toString()} via relay ${se.toString()} failed`,le),ce&&await ae.close(),le}}async connectV2({stream:J,connection:E,destinationPeer:ee,destinationAddr:te,relayAddr:re,ma:ne,disconnectOnFailure:ie}){try{const se=pbStream$1(J),oe=se.pb(HopMessage$1);oe.write({type:HopMessage$1.Type.CONNECT,peer:{id:ee.toBytes(),addrs:[multiaddr(te).bytes]}});const ce=await oe.read();if(ce.status!==Status$1.OK)throw new CodeError(`failed to connect via relay with status ${ce?.status?.toString()??"undefined"}`,codes$8.ERR_HOP_REQUEST_FAILED);const ae=streamToMaConnection({stream:se.unwrap(),remoteAddr:ne,localAddr:re.encapsulate(`/p2p-circuit/p2p/${this.peerId.toString()}`)});return log$S("new outbound connection %s",ae.remoteAddr),await this.upgrader.upgradeOutbound(ae)}catch(se){throw log$S.error(`Circuit relay dial to destination ${ee.toString()} via relay ${E.remotePeer.toString()} failed`,se),ie&&await E.close(),se}}createListener(J){return createListener$1({connectionManager:this.connectionManager,relayStore:this.reservationStore})}filter(J){return J=Array.isArray(J)?J:[J],J.filter(E=>Circuit.matches(E))}async onStop({connection:J,stream:E}){const ee=pbStream$1(E),te=await ee.readPB(StopMessage$1);if(log$S("received circuit v2 stop protocol request from %s",J.remotePeer),te?.type===void 0)return;const re=ee.pb(StopMessage$1);if(log$S("new circuit relay v2 stop stream from %s",J.remotePeer),te.type!==StopMessage$1.Type.CONNECT){log$S.error("invalid stop connect request via peer %s",J.remotePeer),re.write({type:StopMessage$1.Type.STATUS,status:Status$1.UNEXPECTED_MESSAGE});return}if(!isValidStop$1(te)){log$S.error("invalid stop connect request via peer %s",J.remotePeer),re.write({type:StopMessage$1.Type.STATUS,status:Status$1.MALFORMED_MESSAGE});return}const ne=peerIdFromBytes(te.peer.id);if(await this.connectionGater.denyInboundRelayedConnection?.(J.remotePeer,ne)===!0){re.write({type:StopMessage$1.Type.STATUS,status:Status$1.PERMISSION_DENIED});return}re.write({type:StopMessage$1.Type.STATUS,status:Status$1.OK});const ie=J.remoteAddr.encapsulate(`/p2p-circuit/p2p/${ne.toString()}`),se=this.addressManager.getAddresses()[0],oe=streamToMaConnection({stream:ee.unwrap(),remoteAddr:ie,localAddr:se});log$S("new inbound connection %s",oe.remoteAddr),await this.upgrader.upgradeInbound(oe),log$S("%s connection %s upgraded","inbound",oe.remoteAddr)}};function circuitRelayTransport$1(J={}){return E=>new CircuitRelayTransport$1(E,J)}var Identify$1;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{if(re.lengthDelimited!==!1&&te.fork(),ee.protocolVersion!=null&&(te.uint32(42),te.string(ee.protocolVersion)),ee.agentVersion!=null&&(te.uint32(50),te.string(ee.agentVersion)),ee.publicKey!=null&&(te.uint32(10),te.bytes(ee.publicKey)),ee.listenAddrs!=null)for(const ne of ee.listenAddrs)te.uint32(18),te.bytes(ne);if(ee.observedAddr!=null&&(te.uint32(34),te.bytes(ee.observedAddr)),ee.protocols!=null)for(const ne of ee.protocols)te.uint32(26),te.string(ne);ee.signedPeerRecord!=null&&(te.uint32(66),te.bytes(ee.signedPeerRecord)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={listenAddrs:[],protocols:[]},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 5:re.protocolVersion=ee.string();break;case 6:re.agentVersion=ee.string();break;case 1:re.publicKey=ee.bytes();break;case 2:re.listenAddrs.push(ee.bytes());break;case 4:re.observedAddr=ee.bytes();break;case 3:re.protocols.push(ee.string());break;case 8:re.signedPeerRecord=ee.bytes();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage$1(ee,J.codec())})(Identify$1||(Identify$1={}));const version$2="0.45.0",AGENT_VERSION$1=`js-libp2p/${version$2}`,IDENTIFY_PROTOCOL_VERSION$1="0.1.0",MULTICODEC_IDENTIFY_PROTOCOL_NAME$1="id",MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME$1="id/push",MULTICODEC_IDENTIFY_PROTOCOL_VERSION$1="1.0.0",MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION$1="1.0.0";var __classPrivateFieldGet=globalThis&&globalThis.__classPrivateFieldGet||function(J,E,ee,te){if(ee==="a"&&!te)throw new TypeError("Private accessor was defined without a getter");if(typeof E=="function"?J!==E||!te:!E.has(J))throw new TypeError("Cannot read private member from an object whose class did not declare it");return ee==="m"?te:ee==="a"?te.call(J):te?te.value:E.get(J)},_DefaultIdentifyService_instances,_DefaultIdentifyService_consumeIdentifyMessage;const log$R=logger$1("libp2p:identify"),MAX_IDENTIFY_MESSAGE_SIZE$1=1024*8,defaultValues$2={protocolPrefix:"ipfs",agentVersion:AGENT_VERSION$1,timeout:6e4,maxInboundStreams:1,maxOutboundStreams:1,maxPushIncomingStreams:1,maxPushOutgoingStreams:1,maxObservedAddresses:10,maxIdentifyMessageSize:8192};let DefaultIdentifyService$1=class{constructor(J,E){_DefaultIdentifyService_instances.add(this),this.started=!1,this.peerId=J.peerId,this.peerStore=J.peerStore,this.registrar=J.registrar,this.addressManager=J.addressManager,this.connectionManager=J.connectionManager,this.events=J.events,this.identifyProtocolStr=`/${E.protocolPrefix??defaultValues$2.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME$1}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION$1}`,this.identifyPushProtocolStr=`/${E.protocolPrefix??defaultValues$2.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME$1}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION$1}`,this.timeout=E.timeout??defaultValues$2.timeout,this.maxInboundStreams=E.maxInboundStreams??defaultValues$2.maxInboundStreams,this.maxOutboundStreams=E.maxOutboundStreams??defaultValues$2.maxOutboundStreams,this.maxPushIncomingStreams=E.maxPushIncomingStreams??defaultValues$2.maxPushIncomingStreams,this.maxPushOutgoingStreams=E.maxPushOutgoingStreams??defaultValues$2.maxPushOutgoingStreams,this.maxIdentifyMessageSize=E.maxIdentifyMessageSize??defaultValues$2.maxIdentifyMessageSize,this.maxObservedAddresses=E.maxObservedAddresses??defaultValues$2.maxObservedAddresses,this.host={protocolVersion:`${E.protocolPrefix??defaultValues$2.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION$1}`,agentVersion:E.agentVersion??defaultValues$2.agentVersion},J.events.addEventListener("connection:open",ee=>{const te=ee.detail;this.identify(te).catch(re=>{log$R.error("error during identify trigged by connection:open",re)})}),J.events.addEventListener("self:peer:update",ee=>{this.push().catch(te=>{log$R.error(te)})}),this.host.agentVersion===AGENT_VERSION$1&&(isNode||isElectronMain?this.host.agentVersion+=` UserAgent=${globalThis.process.version}`:(isBrowser||isWebWorker||isElectronRenderer||isReactNative)&&(this.host.agentVersion+=` UserAgent=${globalThis.navigator.userAgent}`))}isStarted(){return this.started}async start(){this.started||(await this.peerStore.merge(this.peerId,{metadata:{AgentVersion:fromString$5(this.host.agentVersion),ProtocolVersion:fromString$5(this.host.protocolVersion)}}),await this.registrar.handle(this.identifyProtocolStr,J=>{this._handleIdentify(J).catch(E=>{log$R.error(E)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams}),await this.registrar.handle(this.identifyPushProtocolStr,J=>{this._handlePush(J).catch(E=>{log$R.error(E)})},{maxInboundStreams:this.maxPushIncomingStreams,maxOutboundStreams:this.maxPushOutgoingStreams}),this.started=!0)}async stop(){await this.registrar.unhandle(this.identifyProtocolStr),await this.registrar.unhandle(this.identifyPushProtocolStr),this.started=!1}async pushToConnections(J){const E=this.addressManager.getAddresses().map(ce=>ce.decapsulateCode(getProtocol("p2p").code)),ee=new PeerRecord({peerId:this.peerId,multiaddrs:E}),te=await RecordEnvelope.seal(ee,this.peerId),re=this.registrar.getProtocols(),ne=await this.peerStore.get(this.peerId),ie=toString$5(ne.metadata.get("AgentVersion")??fromString$5(this.host.agentVersion)),se=toString$5(ne.metadata.get("ProtocolVersion")??fromString$5(this.host.protocolVersion)),oe=J.map(async ce=>{let ae;const le=AbortSignal.timeout(this.timeout);try{setMaxListeners?.(1/0,le)}catch{}try{ae=await ce.newStream([this.identifyPushProtocolStr],{signal:le}),await abortableDuplex(ae,le).sink(pipe$1([Identify$1.encode({listenAddrs:E.map(ue=>ue.bytes),signedPeerRecord:te.marshal(),protocols:re,agentVersion:ie,protocolVersion:se})],ue=>encode$b(ue)))}catch(ue){log$R.error("could not push identify update to peer",ue)}finally{ae?.close()}});await Promise.all(oe)}async push(){if(!this.isStarted())return;const J=[];await Promise.all(this.connectionManager.getConnections().map(async E=>{try{if(!(await this.peerStore.get(E.remotePeer)).protocols.includes(this.identifyPushProtocolStr))return;J.push(E)}catch(ee){if(ee.code!==codes$8.ERR_NOT_FOUND)throw ee}})),await this.pushToConnections(J)}async _identify(J,E={}){let ee;const te=anySignal([AbortSignal.timeout(this.timeout),E?.signal]);try{setMaxListeners?.(1/0,te)}catch{}try{ee=await J.newStream([this.identifyProtocolStr],{signal:te});const re=abortableDuplex(ee,te),ne=await pipe$1([],re,ie=>decode$b(ie,{maxDataLength:this.maxIdentifyMessageSize??MAX_IDENTIFY_MESSAGE_SIZE$1}),async ie=>await first(ie));if(ne==null)throw new CodeError("No data could be retrieved",codes$8.ERR_CONNECTION_ENDED);try{return Identify$1.decode(ne)}catch(ie){throw new CodeError(String(ie),codes$8.ERR_INVALID_MESSAGE)}}finally{ee?.close(),te.clear()}}async identify(J,E={}){const ee=await this._identify(J,E),{publicKey:te,protocols:re,observedAddr:ne}=ee;if(te==null)throw new CodeError("public key was missing from identify message",codes$8.ERR_MISSING_PUBLIC_KEY);const ie=await peerIdFromKeys(te);if(!J.remotePeer.equals(ie))throw new CodeError("identified peer does not match the expected peer",codes$8.ERR_INVALID_PEER);if(this.peerId.equals(ie))throw new CodeError("identified peer is our own peer id?",codes$8.ERR_INVALID_PEER);const se=getCleanMultiaddr$1(ne);log$R("identify completed for peer %p and protocols %o",ie,re),log$R("our observed address is %s",se),se!=null&&this.addressManager.getObservedAddrs().length<(this.maxObservedAddresses??1/0)&&(log$R("storing our observed address %s",se?.toString()),this.addressManager.addObservedAddr(se));const oe=await __classPrivateFieldGet(this,_DefaultIdentifyService_instances,"m",_DefaultIdentifyService_consumeIdentifyMessage).call(this,J.remotePeer,ee),ce={peerId:ie,protocolVersion:ee.protocolVersion,agentVersion:ee.agentVersion,publicKey:ee.publicKey,listenAddrs:ee.listenAddrs.map(ae=>multiaddr(ae)),observedAddr:ee.observedAddr==null?void 0:multiaddr(ee.observedAddr),protocols:ee.protocols,signedPeerRecord:oe};this.events.safeDispatchEvent("peer:identify",{detail:ce})}async _handleIdentify(J){const{connection:E,stream:ee}=J,te=AbortSignal.timeout(this.timeout);try{setMaxListeners?.(1/0,te)}catch{}try{const re=this.peerId.publicKey??new Uint8Array(0),ne=await this.peerStore.get(this.peerId),ie=this.addressManager.getAddresses().map(le=>le.decapsulateCode(getProtocol("p2p").code));let se=ne.peerRecordEnvelope;if(ie.length>0&&se==null){const le=new PeerRecord({peerId:this.peerId,multiaddrs:ie});se=(await RecordEnvelope.seal(le,this.peerId)).marshal().subarray()}const oe=Identify$1.encode({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:re,listenAddrs:ie.map(le=>le.bytes),signedPeerRecord:se,observedAddr:E.remoteAddr.bytes,protocols:ne.protocols}),ce=abortableDuplex(ee,te),ae=pipe$1([oe],le=>encode$b(le));await ce.sink(ae)}catch(re){log$R.error("could not respond to identify request",re)}finally{ee.close()}}async _handlePush(J){const{connection:E,stream:ee}=J;try{if(this.peerId.equals(E.remotePeer))throw new Error("received push from ourselves?");const te=abortableDuplex(ee,AbortSignal.timeout(this.timeout)),re=await pbStream$1(te,{maxDataLength:this.maxIdentifyMessageSize??MAX_IDENTIFY_MESSAGE_SIZE$1}).readPB(Identify$1);await __classPrivateFieldGet(this,_DefaultIdentifyService_instances,"m",_DefaultIdentifyService_consumeIdentifyMessage).call(this,E.remotePeer,re)}catch(te){log$R.error("received invalid message",te);return}finally{ee.close()}log$R("handled push from %p",E.remotePeer)}};_DefaultIdentifyService_instances=new WeakSet,_DefaultIdentifyService_consumeIdentifyMessage=async function J(E,ee){if(ee==null)throw new Error("Message was null or undefined");if(log$R("received identify from %p",E),ee.signedPeerRecord==null)return;const te=await RecordEnvelope.openAndCertify(ee.signedPeerRecord,PeerRecord.DOMAIN),re=PeerRecord.createFromProtobuf(te.payload);if(!re.peerId.equals(te.peerId))throw new Error("signing key does not match PeerId in the PeerRecord");if(!E.equals(re.peerId))throw new Error("signing key does not match remote PeerId");let ne;try{ne=await this.peerStore.get(re.peerId)}catch(se){if(se.code!=="ERR_NOT_FOUND")throw se}log$R("received signedPeerRecord in push from %p",E);let ie=new Map;if(ne?.peerRecordEnvelope!=null){const se=await RecordEnvelope.createFromProtobuf(ne.peerRecordEnvelope),oe=PeerRecord.createFromProtobuf(se.payload);oe.seqNumber>=re.seqNumber&&log$R("sequence number was lower or equal to existing sequence number - stored: %d received: %d",oe.seqNumber,re.seqNumber),ie=ne.metadata}return ee.agentVersion!=null&&ie.set("AgentVersion",fromString$5(ee.agentVersion)),ee.protocolVersion!=null&&ie.set("ProtocolVersion",fromString$5(ee.protocolVersion)),await this.peerStore.patch(re.peerId,{peerRecordEnvelope:ee.signedPeerRecord,protocols:ee.protocols,addresses:re.multiaddrs.map(se=>({isCertified:!0,multiaddr:se})),metadata:ie}),log$R("consumed signedPeerRecord sent in push from %p",E),{seq:re.seqNumber,addresses:re.multiaddrs}};function getCleanMultiaddr$1(J){if(J!=null&&J.length>0)try{return multiaddr(J)}catch{}}function identifyService$1(J={}){return E=>new DefaultIdentifyService$1(E,J)}async function createPrivateLibp2pNode(J){const E=await createLibp2p$2({addresses:{listen:["/webrtc"]},transports:[webRTC$1(),webRTCDirect$1(),webSockets({filter:all}),circuitRelayTransport$1({discoverRelays:1})],connectionEncryption:[noise$1()],streamMuxers:[mplex$1(),yamux$1()],peerDiscovery:J?.bootstrapAddrs?.length?[bootstrap({list:J.bootstrapAddrs,timeout:1e3,tagName:"bootstrap",tagValue:50,tagTTL:12e4})]:[],connectionGater:{denyDialMultiaddr:()=>!1},services:{identify:identifyService$1()}}),ee=J.relayAddr;return ee?new Promise(te=>{E.addEventListener("self:peer:update",re=>{for(const ne of E.getMultiaddrs()){const ie=ne.toString();ie.includes(ee)&&ie.includes("webrtc")&&te({node:E,connectingAddr:ie})}}),E.dial(multiaddr(ee))}):{node:E}}async function createPublicLibp2pNode(J){const{tcp:E}=await __vitePreload(()=>import("./index-18086297-bd27886b.js"),[]),ee=await createLibp2p$2({addresses:{listen:["/ip4/0.0.0.0/tcp/0","/ip4/0.0.0.0/tcp/0/ws","/ip4/0.0.0.0/udp/0/webrtc-direct","/ip4/0.0.0.0/udp/0/webrtc"]},transports:[E(),webSockets({filter:all}),webRTCDirect$1()],connectionEncryption:[noise$1()],streamMuxers:[mplex$1(),yamux$1()],peerDiscovery:J?.bootstrapAddrs?.length?[bootstrap({list:J.bootstrapAddrs,timeout:1e3,tagName:"bootstrap",tagValue:50,tagTTL:12e4})]:[],connectionGater:{denyDialMultiaddr:()=>!1},services:{identify:identifyService$1()}});return await ee.start(),ee}const PROTO="/ipdm/1.0.0";class P2PTransport{#e;#t=pushable();#r;#n;constructor(E,ee){this.#e=E,this.#r=ee?.connectingAddress,E.addEventListener("connection:open",te=>{console.log("connection:open",te.detail)}),E.addEventListener("connection:close",te=>{console.log("connection:close",te.detail)})}#s(){const E=this;let ee=!1,te=!1;return{async next(){const re=await E.#i();if(!ee)return ee=!0,{done:!1,value:new MessageEvent("open",{data:{readyState:1}})};if(te)return{done:!0,value:null};const ne=await re.source.next();return ne.done?(te=!0,{done:!1,value:new MessageEvent("error",{data:{readyState:2}})}):{done:!1,value:new MessageEvent("message",{data:new TextDecoder().decode(ne.value.subarray())})}},async return(){return{done:!0,value:new MessageEvent("error",{data:{readyState:2}})}},async throw(){return{done:!0,value:new MessageEvent("error",{data:{readyState:2}})}},[Symbol.asyncIterator](){return this}}}listen(E){return this.#s()[Symbol.asyncIterator]()}async closeListener(){this.#n?.close(),await this.#e.unhandle(PROTO)}async#i(){if(this.#n)return this.#n;if(this.#r){const E=this.#r,ee=multiaddr(E),te=await(await this.#e.dial(ee)).newStream([PROTO]);this.#n=te,pipe$1(this.#t,te)}else this.#n=await new Promise(E=>{this.#e.handle(PROTO,({stream:ee,connection:te})=>{pipe$1(this.#t,ee),E(ee)})});return this.#n}async send(E,ee){return await this.#i(),this.#t.push(new TextEncoder().encode(E)),{ok:!0,status:200,statusText:"OK"}}async closeSender(){this.#n?.close(),this.#t.end()}}class P2PTransportCreator{#e;#t;constructor(E){this.#e=E}static async createPrivateLibp2pNode(E){return createPrivateLibp2pNode(E)}static async createPublicLibp2pNode(E){return createPublicLibp2pNode(E)}async createSenderTransport(E){return this.#t||(this.#t=new P2PTransport(this.#e,E)),new P2PSenderTransport(this.#t)}async createReceiverTransport(E){return this.#t||(this.#t=new P2PTransport(this.#e,E)),new P2PReceiverTransport(this.#t)}}class P2PReceiverTransport{#e;constructor(E){this.#e=E}listen(E){return this.#e.listen(E)}async close(){this.#e.closeListener()}}class P2PSenderTransport{#e;constructor(E){this.#e=E}async send(E,ee){return this.#e.send(E,ee)}async close(){this.#e.closeSender()}}const encoder$1=new TextEncoder,decoder=new TextDecoder,encodeBase64=J=>{let E=J;typeof E=="string"&&(E=encoder$1.encode(E));const ee=32768,te=[];for(let re=0;re<E.length;re+=ee)te.push(String.fromCharCode.apply(null,E.subarray(re,re+ee)));return btoa(te.join(""))},encode$3=J=>encodeBase64(J).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_"),decodeBase64=J=>{const E=atob(J),ee=new Uint8Array(E.length);for(let te=0;te<E.length;te++)ee[te]=E.charCodeAt(te);return ee},decode$5=J=>{let E=J;E instanceof Uint8Array&&(E=decoder.decode(E)),E=E.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return decodeBase64(E)}catch{throw new TypeError("The input to be decoded is not correctly encoded.")}};class JOSEError extends Error{static get code(){return"ERR_JOSE_GENERIC"}constructor(E){var ee;super(E),this.code="ERR_JOSE_GENERIC",this.name=this.constructor.name,(ee=Error.captureStackTrace)===null||ee===void 0||ee.call(Error,this,this.constructor)}}class JWTClaimValidationFailed extends JOSEError{static get code(){return"ERR_JWT_CLAIM_VALIDATION_FAILED"}constructor(E,ee="unspecified",te="unspecified"){super(E),this.code="ERR_JWT_CLAIM_VALIDATION_FAILED",this.claim=ee,this.reason=te}}class JWTExpired extends JOSEError{static get code(){return"ERR_JWT_EXPIRED"}constructor(E,ee="unspecified",te="unspecified"){super(E),this.code="ERR_JWT_EXPIRED",this.claim=ee,this.reason=te}}class JWTInvalid extends JOSEError{constructor(){super(...arguments),this.code="ERR_JWT_INVALID"}static get code(){return"ERR_JWT_INVALID"}}function isObjectLike(J){return typeof J=="object"&&J!==null}function isObject(J){if(!isObjectLike(J)||Object.prototype.toString.call(J)!=="[object Object]")return!1;if(Object.getPrototypeOf(J)===null)return!0;let E=J;for(;Object.getPrototypeOf(E)!==null;)E=Object.getPrototypeOf(E);return Object.getPrototypeOf(J)===E}const epoch=J=>Math.floor(J.getTime()/1e3),minute$2=60,hour$1=minute$2*60,day=hour$1*24,week=day*7,year=day*365.25,REGEX=/^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i,secs=J=>{const E=REGEX.exec(J);if(!E)throw new TypeError("Invalid time period format");const ee=parseFloat(E[1]);switch(E[2].toLowerCase()){case"sec":case"secs":case"second":case"seconds":case"s":return Math.round(ee);case"minute":case"minutes":case"min":case"mins":case"m":return Math.round(ee*minute$2);case"hour":case"hours":case"hr":case"hrs":case"h":return Math.round(ee*hour$1);case"day":case"days":case"d":return Math.round(ee*day);case"week":case"weeks":case"w":return Math.round(ee*week);default:return Math.round(ee*year)}},normalizeTyp=J=>J.toLowerCase().replace(/^application\//,""),checkAudiencePresence=(J,E)=>typeof J=="string"?E.includes(J):Array.isArray(J)?E.some(Set.prototype.has.bind(new Set(J))):!1,jwtPayload=(J,E,ee={})=>{const{typ:te}=ee;if(te&&(typeof J.typ!="string"||normalizeTyp(J.typ)!==normalizeTyp(te)))throw new JWTClaimValidationFailed('unexpected "typ" JWT header value',"typ","check_failed");let re;try{re=JSON.parse(decoder.decode(E))}catch{}if(!isObject(re))throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");const{requiredClaims:ne=[],issuer:ie,subject:se,audience:oe,maxTokenAge:ce}=ee;ce!==void 0&&ne.push("iat"),oe!==void 0&&ne.push("aud"),se!==void 0&&ne.push("sub"),ie!==void 0&&ne.push("iss");for(const he of new Set(ne.reverse()))if(!(he in re))throw new JWTClaimValidationFailed(`missing required "${he}" claim`,he,"missing");if(ie&&!(Array.isArray(ie)?ie:[ie]).includes(re.iss))throw new JWTClaimValidationFailed('unexpected "iss" claim value',"iss","check_failed");if(se&&re.sub!==se)throw new JWTClaimValidationFailed('unexpected "sub" claim value',"sub","check_failed");if(oe&&!checkAudiencePresence(re.aud,typeof oe=="string"?[oe]:oe))throw new JWTClaimValidationFailed('unexpected "aud" claim value',"aud","check_failed");let ae;switch(typeof ee.clockTolerance){case"string":ae=secs(ee.clockTolerance);break;case"number":ae=ee.clockTolerance;break;case"undefined":ae=0;break;default:throw new TypeError("Invalid clockTolerance option type")}const{currentDate:le}=ee,ue=epoch(le||new Date);if((re.iat!==void 0||ce)&&typeof re.iat!="number")throw new JWTClaimValidationFailed('"iat" claim must be a number',"iat","invalid");if(re.nbf!==void 0){if(typeof re.nbf!="number")throw new JWTClaimValidationFailed('"nbf" claim must be a number',"nbf","invalid");if(re.nbf>ue+ae)throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed',"nbf","check_failed")}if(re.exp!==void 0){if(typeof re.exp!="number")throw new JWTClaimValidationFailed('"exp" claim must be a number',"exp","invalid");if(re.exp<=ue-ae)throw new JWTExpired('"exp" claim timestamp check failed',"exp","check_failed")}if(ce){const he=ue-re.iat,pe=typeof ce=="number"?ce:secs(ce);if(he-ae>pe)throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)',"iat","check_failed");if(he<0-ae)throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)',"iat","check_failed")}return re};class ProduceJWT{constructor(E){if(!isObject(E))throw new TypeError("JWT Claims Set MUST be an object");this._payload=E}setIssuer(E){return this._payload={...this._payload,iss:E},this}setSubject(E){return this._payload={...this._payload,sub:E},this}setAudience(E){return this._payload={...this._payload,aud:E},this}setJti(E){return this._payload={...this._payload,jti:E},this}setNotBefore(E){return typeof E=="number"?this._payload={...this._payload,nbf:E}:this._payload={...this._payload,nbf:epoch(new Date)+secs(E)},this}setExpirationTime(E){return typeof E=="number"?this._payload={...this._payload,exp:E}:this._payload={...this._payload,exp:epoch(new Date)+secs(E)},this}setIssuedAt(E){return typeof E>"u"?this._payload={...this._payload,iat:epoch(new Date)}:this._payload={...this._payload,iat:E},this}}class UnsecuredJWT extends ProduceJWT{encode(){const E=encode$3(JSON.stringify({alg:"none"})),ee=encode$3(JSON.stringify(this._payload));return`${E}.${ee}.`}static decode(E,ee){if(typeof E!="string")throw new JWTInvalid("Unsecured JWT must be a string");const{0:te,1:re,2:ne,length:ie}=E.split(".");if(ie!==3||ne!=="")throw new JWTInvalid("Invalid Unsecured JWT");let se;try{if(se=JSON.parse(decoder.decode(decode$5(te))),se.alg!=="none")throw new Error}catch{throw new JWTInvalid("Invalid Unsecured JWT")}return{payload:jwtPayload(se,decode$5(re),ee),header:se}}}const EDWARDS_DID_PREFIX=new Uint8Array([237,1]),BASE58_DID_PREFIX="did:key:z";function keyBytesFromDid(J,E){if(!J.startsWith(BASE58_DID_PREFIX))throw new Error("Please use a base58-encoded DID formatted `did:key:z...`");const ee=J.slice(BASE58_DID_PREFIX.length),te=fromString$7(ee,"base58btc");if(!hasPrefix(te,E))throw new Error(`Expected prefix: ${E}`);return te.slice(E.length)}function didFromKeyBytes(J,E){const ee=concat$5([E,J]),te=toString$7(ee,"base58btc");return BASE58_DID_PREFIX+te}const hasPrefix=(J,E)=>equals$3(E,J.subarray(0,E.byteLength));class DecentralizedIdentity{#e;#t;constructor(E={},ee=EDWARDS_DID_PREFIX){this.#e=ee,this.#t=E}encode(E){return didFromKeyBytes(E,this.#e)}decode(E){return keyBytesFromDid(E,this.#e)}encodeInvite(E){const{iss:ee,claims:te}=E;return new UnsecuredJWT({...this.#t,...te}).setIssuer(this.encode(ee)).encode()}decodeInvite(E){const ee=UnsecuredJWT.decode(E);if(!ee.payload.iss)throw new Error("invalid invite");console.log("invite payload",ee);const te=this.decode(ee.payload.iss),re=ee.payload,ne={};return re?.addr&&(ne.addr=re.addr),{iss:te,claims:ne}}}var SessionEventType=(J=>(J.channel_error="channel_error",J.channel_open="channel_open",J.open_error="open_error",J.message="message",J.handshake="handshake",J))(SessionEventType||{});class EncryptedSession{constructor(E,ee=new SseTransport,te=new FetchSenderTransport,re=new Base64EnvelopeEncoding,ne=new InternalFormatJson,ie=!0){this.cryptoContext=E,this.receiver=ee,this.sender=te,this.wireFormat=re,this.format=ne,this.enableCache=ie}sessionId;toSessionId;async disconnect(){await this.receiver.close()}async*waitForJoin(){if(!(this.cryptoContext instanceof InitiatorCryptoContext)||!this.cryptoContext.handshakeChannelId)throw new Error("Must be the initiating party to accept joins");const E=encodeUrlParam(this.cryptoContext.handshakeChannelId);for await(const ee of this.receiver.listen(E))if(ee.type==="open")yield this.#t(ee);else if(ee.type==="error")yield this.#r(ee);else try{const te=this.wireFormat.decodeHandshakeEnvelope(ee.data),{plaintext:re,toSessionId:ne,sessionId:ie}=await this.cryptoContext.handleJoin(te);this.sessionId=encodeUrlParam(ie),this.toSessionId=encodeUrlParam(ne),yield this.#e("handshake",re);return}catch(te){console.warn(ee,te)}}async join(E,ee){if(!(this.cryptoContext instanceof JoinerCryptoContext))throw new Error("Must be the joining party to join");const{envelope:te,toChannelId:re,sessionId:ne,toSessionId:ie}=await this.cryptoContext.initSender(E,ee),se=this.wireFormat.encodeHandshakeEnvelope(te);this.sessionId=encodeUrlParam(ne),this.toSessionId=encodeUrlParam(ie),await this.sender.send(se,encodeUrlParam(re))}#e(E,ee){return{type:E,detail:ee}}#t(E){return this.#e("channel_open",{readyState:E.target?.readyState??E.data?.readyState})}#r(E){return this.#e("channel_error",{readyState:E.target?.readyState??E.data?.readyState})}async*listen(){if(!this.sessionId)throw this.notInitializedError();for await(const E of this.receiver.listen(this.sessionId))if(E.type==="open")yield this.#t(E);else if(E.type==="error")yield this.#r(E);else try{const ee=this.wireFormat.decodeEnvelope(E.data),te=await this.cryptoContext.open(ee.payload,ee.header);yield this.#e("message",te)}catch(ee){console.warn(E,ee),yield this.#e("open_error",{})}}#n=0;async senderSend(E){const ee=this.#n++;return{...await this.sender.send(E,this.toSessionId),requestId:ee}}async send(E){if(!this.toSessionId)throw this.notInitializedError();const ee=await this.cryptoContext.seal(E),te=this.wireFormat.encodeEnvelope(ee);return this.senderSend(te)}notInitializedError(){return new Error("Not initialized")}}class EncryptedSessionCreator{constructor(E=new HttpTransportCreator,ee=new DecentralizedIdentity){this.transportCreator=E,this.identity=ee}async createInitiatorSession(E,ee){return new EncryptedSession(E,await this.transportCreator.createReceiverTransport(ee),await this.transportCreator.createSenderTransport(ee))}async createJoinerSession(E,ee){return new EncryptedSession(E,await this.transportCreator.createReceiverTransport(ee),await this.transportCreator.createSenderTransport(ee))}async#e(){const E=new InitiatorCryptoContext,{serializedPublicKey:ee}=await E.init(),te=this.identity.encodeInvite({iss:new Uint8Array(ee)});return{initiator:E,invite:te}}async waitForJoin(E){const{initiator:ee,invite:te}=await this.#e(),re=await this.createInitiatorSession(ee);return{invite:te,joinPromise:new Promise(async(ne,ie)=>{let se;for await(const oe of re.waitForJoin()){if(oe.type==="handshake"){se=oe.detail;break}E&&E(oe)}return ne({joinMessage:se,session:this.#r(re)})})}}async joinWithInvite(E,ee){const te=new JoinerCryptoContext,re=this.identity.decodeInvite(E),ne=await this.createJoinerSession(te,re.claims?.addr?{connectingAddress:re.claims.addr}:void 0);return await ne.join(re.iss,ee),this.#r(ne)}#t(E){return!(!("sessionId"in E)||!("toSessionId"in E))}#r(E){if(!this.#t(E))throw new Error("bad session");return E}}class EncryptedSessionWithReplay extends EncryptedSession{#e=new Map;async senderSend(E){const ee=await super.senderSend(E);return this.#e.set(ee.requestId,E),ee}clearCache(E){for(const ee of E)this.#e.delete(ee)}async resendFromCache(E){if(!this.toSessionId)throw this.notInitializedError();for(const ee of E){const te=this.#e.get(ee);te&&await this.sender.send(te,this.toSessionId)}}}class EncryptedSessionWithReplayCreator extends EncryptedSessionCreator{async createInitiatorSession(E,ee){return new EncryptedSessionWithReplay(E,await this.transportCreator.createReceiverTransport(ee),await this.transportCreator.createSenderTransport(ee))}async createJoinerSession(E,ee){return new EncryptedSessionWithReplay(E,await this.transportCreator.createReceiverTransport(ee),await this.transportCreator.createSenderTransport(ee))}}class ChatContext{constructor(E,ee,te=new InternalFormatJson){this.eventTarget=E,this.sessionCreator=ee,this.format=te}session;#e;#t=0;#r=0;#n=0;#s=0;#i=!0;static createEncryptedChatContext({baseApiUrl:E}={}){let ee;E&&(ee={baseSendApiUrl:`${E}/api/send?channelId=`,baseRecieveApiUrl:`${E}/api/sse?channelId=`});const te=new EventTarget;return new DurableChatContext(te,new EncryptedSessionWithReplayCreator(new HttpTransportCreator(ee)))}static async createP2PEncryptedChatContext({node:E,connectingAddr:ee}){const te=new EventTarget,re=new P2PTransportCreator(E),ne=new DecentralizedIdentity({addr:ee});return new DurableChatContext(te,new EncryptedSessionWithReplayCreator(re,ne))}emit(E,ee){this.eventTarget.dispatchEvent(new ChatEvent(E,{detail:ee}))}on(E,ee){ChatEvent.addTypedListener(this.eventTarget,E,ee)}async joinWithInvite(E){if(this.session)return;const ee={type:MessageType$1.meta,name:this.#e||"👽",id:0,lastSeenId:0};this.session=await this.sessionCreator.joinWithInvite(E,this.format.encode(ee)),this.#u(),this.emit(ChatEventType.initiated,{})}async createInviteAndWait(){const{invite:E,joinPromise:ee}=await this.sessionCreator.waitForJoin(ne=>this.#c(ne));this.emit(ChatEventType.invite,{invite:E});const{session:te,joinMessage:re}=await ee;this.session=te,this.#u(),await this.#l(re),this.emit(ChatEventType.initiated,{}),await this.#o(MessageType$1.meta,{name:this.#e||"🤡"})}#c(E){switch(E.type){case SessionEventType.channel_error:this.emit(ChatEventType.channel_error,E.detail);break;case SessionEventType.channel_open:this.emit(ChatEventType.channel_open,E.detail);break}}async setUsername(E){this.#e=E,this.session&&await this.#o(MessageType$1.meta,{name:E})}async send(E){this.session&&await this.#o(MessageType$1.message,E)}async ping(){return await this.sendAck()}async sendAck(){await this.#o(MessageType$1.ack,{})}async disconnect(){this.session&&(await this.#o(MessageType$1.disconnect,{}),await this.#a(!0))}async#a(E){this.session&&(await this.session.disconnect(),this.emit(ChatEventType.disconnected,{local:E}),this.session=void 0)}async sessionSend(E){return await this.session.send(this.format.encode(E))}async#o(E,ee){if(this.session){const te=++this.#t,re={...ee,type:E,id:te,lastSeenId:this.#n};this.emit(ChatEventType.queued,re);try{await this.sessionSend(re),this.#r=Date.now(),this.emit(ChatEventType.sent,re),setTimeout(()=>this.#h(),31e3)}catch{this.emit(ChatEventType.failed,re)}}}#h(){const E=Date.now()-3e4;!this.#i&&this.#r<E&&this.sendAck()}decodePlaintext(E){const ee=this.format.decode(E);if(!this.#d(ee))throw new Error("bad message");return ee}#d(E){return!(!("id"in E)||!("type"in E)||!("lastSeenId"in E))}async#l(E){const ee=this.decodePlaintext(E);ee.id>this.#n&&(this.#n=ee.id),this.#s=Date.now(),this.#i&&(this.#i=!1,this.emit(ChatEventType.active,{})),this.emit(ChatEventType.message,ee),ee.type===MessageType$1.disconnect&&await this.#a(!1),setTimeout(()=>this.#p(),61e3)}#p(){if(!this.session)return;const E=Date.now()-6e4;!this.#i&&this.#s<E&&(this.#i=!0,this.emit(ChatEventType.idle,{}))}async*sessionListen(){for await(const E of this.session.listen())yield E}async#u(){if(!this.session)throw new Error("Session hasn't been initiated.");for await(const E of this.sessionListen())switch(E.type){case SessionEventType.message:await this.#l(E.detail);break}}}class DurableChatContext extends ChatContext{#e=0;#t=0;#r=0;#n=!1;#s=0;#i=new Map;async sessionSend(E){const ee=await this.session.send(this.format.encode(E));return this.#i.set(E.id,ee.requestId),this.#e=E.id,ee}async*sessionListen(){let E=0,ee=!1;this.#n=!1,this.#s=this.#r;for await(const te of this.session.listen()){switch(te.type){case SessionEventType.message:{const re=this.decodePlaintext(te.detail);E=0,this.#r=re.lastSeenId,await this.#c(),this.#n&&this.#r>=this.#s&&(this.#n=!1);break}case SessionEventType.open_error:this.#s=this.#r,E++,this.#n||await this.sendAck(),E===9&&this.emit(ChatEventType.dead_session,{openErrors:E}),this.#n=!0;break;case SessionEventType.channel_error:this.emit(ChatEventType.channel_error,te.detail),ee=!0;break;case SessionEventType.channel_open:this.emit(ChatEventType.channel_open,te.detail),ee&&(ee=!1,await this.sendAck());break}yield te}}async#c(){this.#r>this.#t&&this.#a(this.#r),!this.#n&&this.#r<this.#e&&await this.#o()}#a(E){const ee=[];for(const[te,re]of this.#i)te<=E&&(ee.push(re),this.#i.delete(te));this.session.clearCache(ee),this.#t=E}async#o(){const E=[...this.#i.values()];await this.session.resendFromCache(E)}}function isAsyncIterable$4(J){return J[Symbol.asyncIterator]!=null}function batch(J,E=1){return E=Number(E),isAsyncIterable$4(J)?async function*(){let ee=[];if(E<1&&(E=1),E!==Math.round(E))throw new Error("Batch size must be an integer");for await(const te of J)for(ee.push(te);ee.length>=E;)yield ee.slice(0,E),ee=ee.slice(E);for(;ee.length>0;)yield ee.slice(0,E),ee=ee.slice(E)}():function*(){let ee=[];if(E<1&&(E=1),E!==Math.round(E))throw new Error("Batch size must be an integer");for(const te of J)for(ee.push(te);ee.length>=E;)yield ee.slice(0,E),ee=ee.slice(E);for(;ee.length>0;)yield ee.slice(0,E),ee=ee.slice(E)}()}async function*parallelBatch(J,E=1){for await(const ee of batch(J,E)){const te=ee.map(async re=>re().then(ne=>({ok:!0,value:ne}),ne=>({ok:!1,err:ne})));for(let re=0;re<te.length;re++){const ne=await te[re];if(ne.ok)yield ne.value;else throw ne.err}}}const DEFAULT_CHUNK_SIZE=262144,fixedSize=(J={})=>{const E=J.chunkSize??DEFAULT_CHUNK_SIZE;return async function*(ee){let te=new Uint8ArrayList,re=0,ne=!1;for await(const ie of ee)for(te.append(ie),re+=ie.length;re>=E;)if(yield te.slice(0,E),ne=!0,E===te.length)te=new Uint8ArrayList,re=0;else{const se=new Uint8ArrayList;se.append(te.sublist(E)),te=se,re-=E}(!ne||re>0)&&(yield te.subarray(0,re))}},textDecoder$1=new TextDecoder;function decodeVarint(J,E){let ee=0;for(let te=0;;te+=7){if(te>=64)throw new Error("protobuf: varint overflow");if(E>=J.length)throw new Error("protobuf: unexpected end of data");const re=J[E++];if(ee+=te<28?(re&127)<<te:(re&127)*2**te,re<128)break}return[ee,E]}function decodeBytes(J,E){let ee;[ee,E]=decodeVarint(J,E);const te=E+ee;if(ee<0||te<0)throw new Error("protobuf: invalid length");if(te>J.length)throw new Error("protobuf: unexpected end of data");return[J.subarray(E,te),te]}function decodeKey(J,E){let ee;return[ee,E]=decodeVarint(J,E),[ee&7,ee>>3,E]}function decodeLink(J){const E={},ee=J.length;let te=0;for(;te<ee;){let re,ne;if([re,ne,te]=decodeKey(J,te),ne===1){if(E.Hash)throw new Error("protobuf: (PBLink) duplicate Hash section");if(re!==2)throw new Error(`protobuf: (PBLink) wrong wireType (${re}) for Hash`);if(E.Name!==void 0)throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");if(E.Tsize!==void 0)throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");[E.Hash,te]=decodeBytes(J,te)}else if(ne===2){if(E.Name!==void 0)throw new Error("protobuf: (PBLink) duplicate Name section");if(re!==2)throw new Error(`protobuf: (PBLink) wrong wireType (${re}) for Name`);if(E.Tsize!==void 0)throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");let ie;[ie,te]=decodeBytes(J,te),E.Name=textDecoder$1.decode(ie)}else if(ne===3){if(E.Tsize!==void 0)throw new Error("protobuf: (PBLink) duplicate Tsize section");if(re!==0)throw new Error(`protobuf: (PBLink) wrong wireType (${re}) for Tsize`);[E.Tsize,te]=decodeVarint(J,te)}else throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${ne}`)}if(te>ee)throw new Error("protobuf: (PBLink) unexpected end of data");return E}function decodeNode(J){const E=J.length;let ee=0,te,re=!1,ne;for(;ee<E;){let se,oe;if([se,oe,ee]=decodeKey(J,ee),se!==2)throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${se}`);if(oe===1){if(ne)throw new Error("protobuf: (PBNode) duplicate Data section");[ne,ee]=decodeBytes(J,ee),te&&(re=!0)}else if(oe===2){if(re)throw new Error("protobuf: (PBNode) duplicate Links section");te||(te=[]);let ce;[ce,ee]=decodeBytes(J,ee),te.push(decodeLink(ce))}else throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${oe}`)}if(ee>E)throw new Error("protobuf: (PBNode) unexpected end of data");const ie={};return ne&&(ie.Data=ne),ie.Links=te||[],ie}const textEncoder$2=new TextEncoder,maxInt32=2**32,maxUInt32=2**31;function encodeLink(J,E){let ee=E.length;if(typeof J.Tsize=="number"){if(J.Tsize<0)throw new Error("Tsize cannot be negative");if(!Number.isSafeInteger(J.Tsize))throw new Error("Tsize too large for encoding");ee=encodeVarint(E,ee,J.Tsize)-1,E[ee]=24}if(typeof J.Name=="string"){const te=textEncoder$2.encode(J.Name);ee-=te.length,E.set(te,ee),ee=encodeVarint(E,ee,te.length)-1,E[ee]=18}return J.Hash&&(ee-=J.Hash.length,E.set(J.Hash,ee),ee=encodeVarint(E,ee,J.Hash.length)-1,E[ee]=10),E.length-ee}function encodeNode(J){const E=sizeNode(J),ee=new Uint8Array(E);let te=E;if(J.Data&&(te-=J.Data.length,ee.set(J.Data,te),te=encodeVarint(ee,te,J.Data.length)-1,ee[te]=10),J.Links)for(let re=J.Links.length-1;re>=0;re--){const ne=encodeLink(J.Links[re],ee.subarray(0,te));te-=ne,te=encodeVarint(ee,te,ne)-1,ee[te]=18}return ee}function sizeLink(J){let E=0;if(J.Hash){const ee=J.Hash.length;E+=1+ee+sov(ee)}if(typeof J.Name=="string"){const ee=textEncoder$2.encode(J.Name).length;E+=1+ee+sov(ee)}return typeof J.Tsize=="number"&&(E+=1+sov(J.Tsize)),E}function sizeNode(J){let E=0;if(J.Data){const ee=J.Data.length;E+=1+ee+sov(ee)}if(J.Links)for(const ee of J.Links){const te=sizeLink(ee);E+=1+te+sov(te)}return E}function encodeVarint(J,E,ee){E-=sov(ee);const te=E;for(;ee>=maxUInt32;)J[E++]=ee&127|128,ee/=128;for(;ee>=128;)J[E++]=ee&127|128,ee>>>=7;return J[E]=ee,te}function sov(J){return J%2===0&&J++,Math.floor((len64(J)+6)/7)}function len64(J){let E=0;return J>=maxInt32&&(J=Math.floor(J/maxInt32),E=32),J>=65536&&(J>>>=16,E+=16),J>=256&&(J>>>=8,E+=8),E+len8tab[J]}const len8tab=[0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8],pbNodeProperties=["Data","Links"],pbLinkProperties=["Hash","Name","Tsize"],textEncoder$1=new TextEncoder;function linkComparator(J,E){if(J===E)return 0;const ee=J.Name?textEncoder$1.encode(J.Name):[],te=E.Name?textEncoder$1.encode(E.Name):[];let re=ee.length,ne=te.length;for(let ie=0,se=Math.min(re,ne);ie<se;++ie)if(ee[ie]!==te[ie]){re=ee[ie],ne=te[ie];break}return re<ne?-1:ne<re?1:0}function hasOnlyProperties(J,E){return!Object.keys(J).some(ee=>!E.includes(ee))}function asLink(J){if(typeof J.asCID=="object"){const ee=CID.asCID(J);if(!ee)throw new TypeError("Invalid DAG-PB form");return{Hash:ee}}if(typeof J!="object"||Array.isArray(J))throw new TypeError("Invalid DAG-PB form");const E={};if(J.Hash){let ee=CID.asCID(J.Hash);try{ee||(typeof J.Hash=="string"?ee=CID.parse(J.Hash):J.Hash instanceof Uint8Array&&(ee=CID.decode(J.Hash)))}catch(te){throw new TypeError(`Invalid DAG-PB form: ${te.message}`)}ee&&(E.Hash=ee)}if(!E.Hash)throw new TypeError("Invalid DAG-PB form");return typeof J.Name=="string"&&(E.Name=J.Name),typeof J.Tsize=="number"&&(E.Tsize=J.Tsize),E}function prepare(J){if((J instanceof Uint8Array||typeof J=="string")&&(J={Data:J}),typeof J!="object"||Array.isArray(J))throw new TypeError("Invalid DAG-PB form");const E={};if(J.Data!==void 0)if(typeof J.Data=="string")E.Data=textEncoder$1.encode(J.Data);else if(J.Data instanceof Uint8Array)E.Data=J.Data;else throw new TypeError("Invalid DAG-PB form");if(J.Links!==void 0)if(Array.isArray(J.Links))E.Links=J.Links.map(asLink),E.Links.sort(linkComparator);else throw new TypeError("Invalid DAG-PB form");else E.Links=[];return E}function validate$1(J){if(!J||typeof J!="object"||Array.isArray(J)||J instanceof Uint8Array||J["/"]&&J["/"]===J.bytes)throw new TypeError("Invalid DAG-PB form");if(!hasOnlyProperties(J,pbNodeProperties))throw new TypeError("Invalid DAG-PB form (extraneous properties)");if(J.Data!==void 0&&!(J.Data instanceof Uint8Array))throw new TypeError("Invalid DAG-PB form (Data must be bytes)");if(!Array.isArray(J.Links))throw new TypeError("Invalid DAG-PB form (Links must be a list)");for(let E=0;E<J.Links.length;E++){const ee=J.Links[E];if(!ee||typeof ee!="object"||Array.isArray(ee)||ee instanceof Uint8Array||ee["/"]&&ee["/"]===ee.bytes)throw new TypeError("Invalid DAG-PB form (bad link)");if(!hasOnlyProperties(ee,pbLinkProperties))throw new TypeError("Invalid DAG-PB form (extraneous properties on link)");if(ee.Hash===void 0)throw new TypeError("Invalid DAG-PB form (link must have a Hash)");if(ee.Hash==null||!ee.Hash["/"]||ee.Hash["/"]!==ee.Hash.bytes)throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");if(ee.Name!==void 0&&typeof ee.Name!="string")throw new TypeError("Invalid DAG-PB form (link Name must be a string)");if(ee.Tsize!==void 0){if(typeof ee.Tsize!="number"||ee.Tsize%1!==0)throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");if(ee.Tsize<0)throw new TypeError("Invalid DAG-PB form (link Tsize cannot be negative)")}if(E>0&&linkComparator(ee,J.Links[E-1])===-1)throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)")}}function createNode$1(J,E=[]){return prepare({Data:J,Links:E})}function createLink(J,E,ee){return asLink({Hash:ee,Name:J,Tsize:E})}const name$1="dag-pb",code$1=112;function encode$2(J){validate$1(J);const E={};return J.Links&&(E.Links=J.Links.map(ee=>{const te={};return ee.Hash&&(te.Hash=ee.Hash.bytes),ee.Name!==void 0&&(te.Name=ee.Name),ee.Tsize!==void 0&&(te.Tsize=ee.Tsize),te})),J.Data&&(E.Data=J.Data),encodeNode(E)}function decode$4(J){const E=decodeNode(J),ee={};return E.Data&&(ee.Data=E.Data),E.Links&&(ee.Links=E.Links.map(te=>{const re={};try{re.Hash=CID.decode(te.Hash)}catch{}if(!re.Hash)throw new Error("Invalid Hash field found in link, expected CID");return te.Name!==void 0&&(re.Name=te.Name),te.Tsize!==void 0&&(re.Tsize=te.Tsize),re})),ee}const dagPB=Object.freeze(Object.defineProperty({__proto__:null,code:code$1,createLink,createNode:createNode$1,decode:decode$4,encode:encode$2,name:name$1,prepare,validate:validate$1},Symbol.toStringTag,{value:"Module"}));var Data;(function(J){(function(te){te.Raw="Raw",te.Directory="Directory",te.File="File",te.Metadata="Metadata",te.Symlink="Symlink",te.HAMTShard="HAMTShard"})(J.DataType||(J.DataType={}));let E;(function(te){te[te.Raw=0]="Raw",te[te.Directory=1]="Directory",te[te.File=2]="File",te[te.Metadata=3]="Metadata",te[te.Symlink=4]="Symlink",te[te.HAMTShard=5]="HAMTShard"})(E||(E={})),function(te){te.codec=()=>enumeration(E)}(J.DataType||(J.DataType={}));let ee;J.codec=()=>(ee==null&&(ee=message((te,re,ne={})=>{if(ne.lengthDelimited!==!1&&re.fork(),te.Type!=null&&(re.uint32(8),J.DataType.codec().encode(te.Type,re)),te.Data!=null&&(re.uint32(18),re.bytes(te.Data)),te.filesize!=null&&(re.uint32(24),re.uint64(te.filesize)),te.blocksizes!=null)for(const ie of te.blocksizes)re.uint32(32),re.uint64(ie);te.hashType!=null&&(re.uint32(40),re.uint64(te.hashType)),te.fanout!=null&&(re.uint32(48),re.uint64(te.fanout)),te.mode!=null&&(re.uint32(56),re.uint32(te.mode)),te.mtime!=null&&(re.uint32(66),UnixTime.codec().encode(te.mtime,re)),ne.lengthDelimited!==!1&&re.ldelim()},(te,re)=>{const ne={blocksizes:[]},ie=re==null?te.len:te.pos+re;for(;te.pos<ie;){const se=te.uint32();switch(se>>>3){case 1:ne.Type=J.DataType.codec().decode(te);break;case 2:ne.Data=te.bytes();break;case 3:ne.filesize=te.uint64();break;case 4:ne.blocksizes.push(te.uint64());break;case 5:ne.hashType=te.uint64();break;case 6:ne.fanout=te.uint64();break;case 7:ne.mode=te.uint32();break;case 8:ne.mtime=UnixTime.codec().decode(te,te.uint32());break;default:te.skipType(se&7);break}}return ne})),ee),J.encode=te=>encodeMessage(te,J.codec()),J.decode=te=>decodeMessage$1(te,J.codec())})(Data||(Data={}));var UnixTime;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{re.lengthDelimited!==!1&&te.fork(),ee.Seconds!=null&&(te.uint32(8),te.int64(ee.Seconds)),ee.FractionalNanoseconds!=null&&(te.uint32(21),te.fixed32(ee.FractionalNanoseconds)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.Seconds=ee.int64();break;case 2:re.FractionalNanoseconds=ee.fixed32();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage$1(ee,J.codec())})(UnixTime||(UnixTime={}));var Metadata;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{re.lengthDelimited!==!1&&te.fork(),ee.MimeType!=null&&(te.uint32(10),te.string(ee.MimeType)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.MimeType=ee.string();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage$1(ee,J.codec())})(Metadata||(Metadata={}));const types={Raw:"raw",Directory:"directory",File:"file",Metadata:"metadata",Symlink:"symlink",HAMTShard:"hamt-sharded-directory"},dirTypes=["directory","hamt-sharded-directory"],DEFAULT_FILE_MODE=parseInt("0644",8),DEFAULT_DIRECTORY_MODE=parseInt("0755",8);class UnixFS{static unmarshal(E){const ee=Data.decode(E),te=new UnixFS({type:types[ee.Type!=null?ee.Type.toString():"File"],data:ee.Data,blockSizes:ee.blocksizes,mode:ee.mode,mtime:ee.mtime!=null?{secs:ee.mtime.Seconds??0n,nsecs:ee.mtime.FractionalNanoseconds}:void 0});return te._originalMode=ee.mode??0,te}type;data;blockSizes;hashType;fanout;mtime;_mode;_originalMode;constructor(E={type:"file"}){const{type:ee,data:te,blockSizes:re,hashType:ne,fanout:ie,mtime:se,mode:oe}=E;if(ee!=null&&!Object.values(types).includes(ee))throw errCode$1(new Error("Type: "+ee+" is not valid"),"ERR_INVALID_TYPE");this.type=ee??"file",this.data=te,this.hashType=ne,this.fanout=ie,this.blockSizes=re??[],this._originalMode=0,this.mode=oe,this.mtime=se}set mode(E){E==null?this._mode=this.isDirectory()?DEFAULT_DIRECTORY_MODE:DEFAULT_FILE_MODE:this._mode=E&4095}get mode(){return this._mode}isDirectory(){return dirTypes.includes(this.type)}addBlockSize(E){this.blockSizes.push(E)}removeBlockSize(E){this.blockSizes.splice(E,1)}fileSize(){if(this.isDirectory())return 0n;let E=0n;return this.blockSizes.forEach(ee=>{E+=ee}),this.data!=null&&(E+=BigInt(this.data.length)),E}marshal(){let E;switch(this.type){case"raw":E=Data.DataType.Raw;break;case"directory":E=Data.DataType.Directory;break;case"file":E=Data.DataType.File;break;case"metadata":E=Data.DataType.Metadata;break;case"symlink":E=Data.DataType.Symlink;break;case"hamt-sharded-directory":E=Data.DataType.HAMTShard;break;default:throw errCode$1(new Error(`Type: ${E} is not valid`),"ERR_INVALID_TYPE")}let ee=this.data;(this.data==null||this.data.length===0)&&(ee=void 0);let te;this.mode!=null&&(te=this._originalMode&4294963200|(this.mode??0),te===DEFAULT_FILE_MODE&&!this.isDirectory()&&(te=void 0),te===DEFAULT_DIRECTORY_MODE&&this.isDirectory()&&(te=void 0));let re;return this.mtime!=null&&(re={Seconds:this.mtime.secs,FractionalNanoseconds:this.mtime.nsecs}),Data.encode({Type:E,Data:ee,filesize:this.isDirectory()?void 0:this.fileSize(),blocksizes:this.blockSizes,hashType:this.hashType,fanout:this.fanout,mode:te,mtime:re})}}class CustomProgressEvent extends Event{constructor(E,ee){super(E),this.detail=ee}}const persist$1=async(J,E,ee)=>{ee.codec==null&&(ee.codec=dagPB);const te=await sha256$3.digest(J),re=CID.create(ee.cidVersion,ee.codec.code,te);return await E.put(re,J,ee),re};function defaultBufferImporter(J){return async function*(E,ee){let te=0n;for await(let re of E.content)yield async()=>{let ne;const ie={codec:dagPB,cidVersion:J.cidVersion,onProgress:J.onProgress};J.rawLeaves?(ie.codec=raw,ie.cidVersion=1):(ne=new UnixFS({type:J.leafType,data:re}),re=encode$2({Data:ne.marshal(),Links:[]}));const se=await persist$1(re,ee,ie);return te+=BigInt(re.byteLength),J.onProgress?.(new CustomProgressEvent("unixfs:importer:progress:file:write",{bytesWritten:te,cid:se,path:E.path})),{cid:se,unixfs:ne,size:BigInt(re.length),block:re}}}}const dirBuilder=async(J,E,ee)=>{const te=new UnixFS({type:"directory",mtime:J.mtime,mode:J.mode}),re=encode$2(prepare({Data:te.marshal()})),ne=await persist$1(re,E,ee),ie=J.path;return{cid:ne,path:ie,unixfs:te,size:BigInt(re.length),originalPath:J.originalPath,block:re}};async function*buildFileBatch(J,E,ee){let te=-1,re;for await(const ne of parallelBatch(ee.bufferImporter(J,E),ee.blockWriteConcurrency)){if(te++,te===0){re={...ne,single:!0};continue}else te===1&&re!=null&&(yield{...re,block:void 0,single:void 0},re=void 0);yield{...ne,block:void 0}}re!=null&&(yield re)}function isSingleBlockImport(J){return J.single===!0}const reduce=(J,E,ee)=>async function(te){if(te.length===1&&isSingleBlockImport(te[0])&&ee.reduceSingleLeafToSelf){const ce=te[0];let ae=ce.block;return isSingleBlockImport(ce)&&(J.mtime!==void 0||J.mode!==void 0)&&(ce.unixfs=new UnixFS({type:"file",mtime:J.mtime,mode:J.mode,data:ce.block}),ae={Data:ce.unixfs.marshal(),Links:[]},ce.block=encode$2(prepare(ae)),ce.cid=await persist$1(ce.block,E,{...ee,cidVersion:ee.cidVersion}),ce.size=BigInt(ce.block.length)),ee.onProgress?.(new CustomProgressEvent("unixfs:importer:progress:file:layout",{cid:ce.cid,path:ce.originalPath})),{cid:ce.cid,path:J.path,unixfs:ce.unixfs,size:ce.size,originalPath:ce.originalPath}}const re=new UnixFS({type:"file",mtime:J.mtime,mode:J.mode}),ne=te.filter(ce=>ce.cid.code===code$2&&ce.size>0||ce.unixfs!=null&&ce.unixfs.data==null&&ce.unixfs.fileSize()>0n?!0:!!ce.unixfs?.data?.length).map(ce=>ce.cid.code===code$2?(re.addBlockSize(ce.size),{Name:"",Tsize:Number(ce.size),Hash:ce.cid}):(ce.unixfs==null||ce.unixfs.data==null?re.addBlockSize(ce.unixfs?.fileSize()??0n):re.addBlockSize(BigInt(ce.unixfs.data.length)),{Name:"",Tsize:Number(ce.size),Hash:ce.cid})),ie={Data:re.marshal(),Links:ne},se=encode$2(prepare(ie)),oe=await persist$1(se,E,ee);return ee.onProgress?.(new CustomProgressEvent("unixfs:importer:progress:file:layout",{cid:oe,path:J.originalPath})),{cid:oe,path:J.path,unixfs:re,size:BigInt(se.length+ie.Links.reduce((ce,ae)=>ce+(ae.Tsize??0),0)),originalPath:J.originalPath,block:se}},fileBuilder=async(J,E,ee)=>ee.layout(buildFileBatch(J,E,ee),reduce(J,E,ee));function isIterable$1(J){return Symbol.iterator in J}function isAsyncIterable$3(J){return Symbol.asyncIterator in J}function contentAsAsyncIterable(J){try{if(J instanceof Uint8Array)return async function*(){yield J}();if(isIterable$1(J))return async function*(){yield*J}();if(isAsyncIterable$3(J))return J}catch{throw errCode$1(new Error("Content was invalid"),"ERR_INVALID_CONTENT")}throw errCode$1(new Error("Content was invalid"),"ERR_INVALID_CONTENT")}function defaultDagBuilder(J){return async function*(E,ee){for await(const te of E){let re;if(te.path!=null&&(re=te.path,te.path=te.path.split("/").filter(ne=>ne!=null&&ne!==".").join("/")),isFileCandidate(te)){const ne={path:te.path,mtime:te.mtime,mode:te.mode,content:async function*(){let ie=0n;for await(const se of J.chunker(J.chunkValidator(contentAsAsyncIterable(te.content)))){const oe=BigInt(se.byteLength);ie+=oe,J.onProgress?.(new CustomProgressEvent("unixfs:importer:progress:file:read",{bytesRead:ie,chunkSize:oe,path:te.path})),yield se}}(),originalPath:re};yield async()=>fileBuilder(ne,ee,J)}else if(te.path!=null){const ne={path:te.path,mtime:te.mtime,mode:te.mode,originalPath:re};yield async()=>dirBuilder(ne,ee,J)}else throw new Error("Import candidate must have content or path or both")}}}function isFileCandidate(J){return J.content!=null}const defaultChunkValidator=()=>async function*(J){for await(const E of J){if(E.length===void 0)throw errCode$1(new Error("Content was invalid"),"ERR_INVALID_CONTENT");if(typeof E=="string"||E instanceof String)yield fromString$5(E.toString());else if(Array.isArray(E))yield Uint8Array.from(E);else if(E instanceof Uint8Array)yield E;else throw errCode$1(new Error("Content was invalid"),"ERR_INVALID_CONTENT")}},DEFAULT_MAX_CHILDREN_PER_NODE=174;function balanced(J){const E=J?.maxChildrenPerNode??DEFAULT_MAX_CHILDREN_PER_NODE;return async function ee(te,re){const ne=[];for await(const ie of batch(te,E))ne.push(await re(ie));return ne.length>1?ee(ne,re):ne[0]}}let Dir$1=class{options;root;dir;path;dirty;flat;parent;parentKey;unixfs;mode;mtime;cid;size;nodeSize;constructor(J,E){this.options=E??{},this.root=J.root,this.dir=J.dir,this.path=J.path,this.dirty=J.dirty,this.flat=J.flat,this.parent=J.parent,this.parentKey=J.parentKey,this.unixfs=J.unixfs,this.mode=J.mode,this.mtime=J.mtime}};const CID_V0$1=CID.parse("QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn"),CID_V1$1=CID.parse("zdj7WbTaiJT1fgatdet9Ei9iDB5hdCxkbVyhyh8YTUnXMiwYi");class DirFlat extends Dir$1{_children;constructor(E,ee){super(E,ee),this._children=new Map}async put(E,ee){this.cid=void 0,this.size=void 0,this.nodeSize=void 0,this._children.set(E,ee)}async get(E){return Promise.resolve(this._children.get(E))}childCount(){return this._children.size}directChildrenCount(){return this.childCount()}onlyChild(){return this._children.values().next().value}async*eachChildSeries(){for(const[E,ee]of this._children.entries())yield{key:E,child:ee}}estimateNodeSize(){if(this.nodeSize!==void 0)return this.nodeSize;this.nodeSize=0;for(const[E,ee]of this._children.entries())ee.size!=null&&ee.cid!=null&&(this.nodeSize+=E.length+(this.options.cidVersion===1?CID_V1$1.bytes.byteLength:CID_V0$1.bytes.byteLength));return this.nodeSize}async*flush(E){const ee=[];for(const[oe,ce]of this._children.entries()){let ae=ce;if(ce instanceof Dir$1)for await(const le of ce.flush(E))ae=le,yield le;ae.size!=null&&ae.cid!=null&&ee.push({Name:oe,Tsize:Number(ae.size),Hash:ae.cid})}const te=new UnixFS({type:"directory",mtime:this.mtime,mode:this.mode}),re={Data:te.marshal(),Links:ee},ne=encode$2(prepare(re)),ie=await persist$1(ne,E,this.options),se=ne.length+re.Links.reduce((oe,ce)=>oe+(ce.Tsize==null?0:ce.Tsize),0);this.cid=ie,this.size=se,yield{cid:ie,unixfs:te,path:this.path,size:BigInt(se)}}}var murmurHash3js={exports:{}};(function(J,E){(function(ee,te){var re={version:"3.0.0",x86:{},x64:{},inputValidation:!0};function ne(de){if(!Array.isArray(de)&&!ArrayBuffer.isView(de))return!1;for(var fe=0;fe<de.length;fe++)if(!Number.isInteger(de[fe])||de[fe]<0||de[fe]>255)return!1;return!0}function ie(de,fe){return(de&65535)*fe+(((de>>>16)*fe&65535)<<16)}function se(de,fe){return de<<fe|de>>>32-fe}function oe(de){return de^=de>>>16,de=ie(de,2246822507),de^=de>>>13,de=ie(de,3266489909),de^=de>>>16,de}function ce(de,fe){de=[de[0]>>>16,de[0]&65535,de[1]>>>16,de[1]&65535],fe=[fe[0]>>>16,fe[0]&65535,fe[1]>>>16,fe[1]&65535];var me=[0,0,0,0];return me[3]+=de[3]+fe[3],me[2]+=me[3]>>>16,me[3]&=65535,me[2]+=de[2]+fe[2],me[1]+=me[2]>>>16,me[2]&=65535,me[1]+=de[1]+fe[1],me[0]+=me[1]>>>16,me[1]&=65535,me[0]+=de[0]+fe[0],me[0]&=65535,[me[0]<<16|me[1],me[2]<<16|me[3]]}function ae(de,fe){de=[de[0]>>>16,de[0]&65535,de[1]>>>16,de[1]&65535],fe=[fe[0]>>>16,fe[0]&65535,fe[1]>>>16,fe[1]&65535];var me=[0,0,0,0];return me[3]+=de[3]*fe[3],me[2]+=me[3]>>>16,me[3]&=65535,me[2]+=de[2]*fe[3],me[1]+=me[2]>>>16,me[2]&=65535,me[2]+=de[3]*fe[2],me[1]+=me[2]>>>16,me[2]&=65535,me[1]+=de[1]*fe[3],me[0]+=me[1]>>>16,me[1]&=65535,me[1]+=de[2]*fe[2],me[0]+=me[1]>>>16,me[1]&=65535,me[1]+=de[3]*fe[1],me[0]+=me[1]>>>16,me[1]&=65535,me[0]+=de[0]*fe[3]+de[1]*fe[2]+de[2]*fe[1]+de[3]*fe[0],me[0]&=65535,[me[0]<<16|me[1],me[2]<<16|me[3]]}function le(de,fe){return fe%=64,fe===32?[de[1],de[0]]:fe<32?[de[0]<<fe|de[1]>>>32-fe,de[1]<<fe|de[0]>>>32-fe]:(fe-=32,[de[1]<<fe|de[0]>>>32-fe,de[0]<<fe|de[1]>>>32-fe])}function ue(de,fe){return fe%=64,fe===0?de:fe<32?[de[0]<<fe|de[1]>>>32-fe,de[1]<<fe]:[de[1]<<fe-32,0]}function he(de,fe){return[de[0]^fe[0],de[1]^fe[1]]}function pe(de){return de=he(de,[0,de[0]>>>1]),de=ae(de,[4283543511,3981806797]),de=he(de,[0,de[0]>>>1]),de=ae(de,[3301882366,444984403]),de=he(de,[0,de[0]>>>1]),de}re.x86.hash32=function(de,fe){if(re.inputValidation&&!ne(de))return te;fe=fe||0;for(var me=de.length%4,_e=de.length-me,be=fe,Ee=0,ve=3432918353,we=461845907,ge=0;ge<_e;ge=ge+4)Ee=de[ge]|de[ge+1]<<8|de[ge+2]<<16|de[ge+3]<<24,Ee=ie(Ee,ve),Ee=se(Ee,15),Ee=ie(Ee,we),be^=Ee,be=se(be,13),be=ie(be,5)+3864292196;switch(Ee=0,me){case 3:Ee^=de[ge+2]<<16;case 2:Ee^=de[ge+1]<<8;case 1:Ee^=de[ge],Ee=ie(Ee,ve),Ee=se(Ee,15),Ee=ie(Ee,we),be^=Ee}return be^=de.length,be=oe(be),be>>>0},re.x86.hash128=function(de,fe){if(re.inputValidation&&!ne(de))return te;fe=fe||0;for(var me=de.length%16,_e=de.length-me,be=fe,Ee=fe,ve=fe,we=fe,ge=0,Se=0,$e=0,Pe=0,Me=597399067,xe=2869860233,Fe=951274213,ke=2716044179,Te=0;Te<_e;Te=Te+16)ge=de[Te]|de[Te+1]<<8|de[Te+2]<<16|de[Te+3]<<24,Se=de[Te+4]|de[Te+5]<<8|de[Te+6]<<16|de[Te+7]<<24,$e=de[Te+8]|de[Te+9]<<8|de[Te+10]<<16|de[Te+11]<<24,Pe=de[Te+12]|de[Te+13]<<8|de[Te+14]<<16|de[Te+15]<<24,ge=ie(ge,Me),ge=se(ge,15),ge=ie(ge,xe),be^=ge,be=se(be,19),be+=Ee,be=ie(be,5)+1444728091,Se=ie(Se,xe),Se=se(Se,16),Se=ie(Se,Fe),Ee^=Se,Ee=se(Ee,17),Ee+=ve,Ee=ie(Ee,5)+197830471,$e=ie($e,Fe),$e=se($e,17),$e=ie($e,ke),ve^=$e,ve=se(ve,15),ve+=we,ve=ie(ve,5)+2530024501,Pe=ie(Pe,ke),Pe=se(Pe,18),Pe=ie(Pe,Me),we^=Pe,we=se(we,13),we+=be,we=ie(we,5)+850148119;switch(ge=0,Se=0,$e=0,Pe=0,me){case 15:Pe^=de[Te+14]<<16;case 14:Pe^=de[Te+13]<<8;case 13:Pe^=de[Te+12],Pe=ie(Pe,ke),Pe=se(Pe,18),Pe=ie(Pe,Me),we^=Pe;case 12:$e^=de[Te+11]<<24;case 11:$e^=de[Te+10]<<16;case 10:$e^=de[Te+9]<<8;case 9:$e^=de[Te+8],$e=ie($e,Fe),$e=se($e,17),$e=ie($e,ke),ve^=$e;case 8:Se^=de[Te+7]<<24;case 7:Se^=de[Te+6]<<16;case 6:Se^=de[Te+5]<<8;case 5:Se^=de[Te+4],Se=ie(Se,xe),Se=se(Se,16),Se=ie(Se,Fe),Ee^=Se;case 4:ge^=de[Te+3]<<24;case 3:ge^=de[Te+2]<<16;case 2:ge^=de[Te+1]<<8;case 1:ge^=de[Te],ge=ie(ge,Me),ge=se(ge,15),ge=ie(ge,xe),be^=ge}return be^=de.length,Ee^=de.length,ve^=de.length,we^=de.length,be+=Ee,be+=ve,be+=we,Ee+=be,ve+=be,we+=be,be=oe(be),Ee=oe(Ee),ve=oe(ve),we=oe(we),be+=Ee,be+=ve,be+=we,Ee+=be,ve+=be,we+=be,("00000000"+(be>>>0).toString(16)).slice(-8)+("00000000"+(Ee>>>0).toString(16)).slice(-8)+("00000000"+(ve>>>0).toString(16)).slice(-8)+("00000000"+(we>>>0).toString(16)).slice(-8)},re.x64.hash128=function(de,fe){if(re.inputValidation&&!ne(de))return te;fe=fe||0;for(var me=de.length%16,_e=de.length-me,be=[0,fe],Ee=[0,fe],ve=[0,0],we=[0,0],ge=[2277735313,289559509],Se=[1291169091,658871167],$e=0;$e<_e;$e=$e+16)ve=[de[$e+4]|de[$e+5]<<8|de[$e+6]<<16|de[$e+7]<<24,de[$e]|de[$e+1]<<8|de[$e+2]<<16|de[$e+3]<<24],we=[de[$e+12]|de[$e+13]<<8|de[$e+14]<<16|de[$e+15]<<24,de[$e+8]|de[$e+9]<<8|de[$e+10]<<16|de[$e+11]<<24],ve=ae(ve,ge),ve=le(ve,31),ve=ae(ve,Se),be=he(be,ve),be=le(be,27),be=ce(be,Ee),be=ce(ae(be,[0,5]),[0,1390208809]),we=ae(we,Se),we=le(we,33),we=ae(we,ge),Ee=he(Ee,we),Ee=le(Ee,31),Ee=ce(Ee,be),Ee=ce(ae(Ee,[0,5]),[0,944331445]);switch(ve=[0,0],we=[0,0],me){case 15:we=he(we,ue([0,de[$e+14]],48));case 14:we=he(we,ue([0,de[$e+13]],40));case 13:we=he(we,ue([0,de[$e+12]],32));case 12:we=he(we,ue([0,de[$e+11]],24));case 11:we=he(we,ue([0,de[$e+10]],16));case 10:we=he(we,ue([0,de[$e+9]],8));case 9:we=he(we,[0,de[$e+8]]),we=ae(we,Se),we=le(we,33),we=ae(we,ge),Ee=he(Ee,we);case 8:ve=he(ve,ue([0,de[$e+7]],56));case 7:ve=he(ve,ue([0,de[$e+6]],48));case 6:ve=he(ve,ue([0,de[$e+5]],40));case 5:ve=he(ve,ue([0,de[$e+4]],32));case 4:ve=he(ve,ue([0,de[$e+3]],24));case 3:ve=he(ve,ue([0,de[$e+2]],16));case 2:ve=he(ve,ue([0,de[$e+1]],8));case 1:ve=he(ve,[0,de[$e]]),ve=ae(ve,ge),ve=le(ve,31),ve=ae(ve,Se),be=he(be,ve)}return be=he(be,[0,de.length]),Ee=he(Ee,[0,de.length]),be=ce(be,Ee),Ee=ce(Ee,be),be=pe(be),Ee=pe(Ee),be=ce(be,Ee),Ee=ce(Ee,be),("00000000"+(be[0]>>>0).toString(16)).slice(-8)+("00000000"+(be[1]>>>0).toString(16)).slice(-8)+("00000000"+(Ee[0]>>>0).toString(16)).slice(-8)+("00000000"+(Ee[1]>>>0).toString(16)).slice(-8)},J.exports&&(E=J.exports=re),E.murmurHash3=re})()})(murmurHash3js,murmurHash3js.exports);var murmurHash3jsExports=murmurHash3js.exports,murmurhash3jsRevisited=murmurHash3jsExports;const mur=getDefaultExportFromCjs(murmurhash3jsRevisited),murmur3128=from$1({name:"murmur3-128",code:34,encode:J=>fromHex(mur.x64.hash128(J))}),BITS_PER_BYTE=7;var sparseArray=class{constructor(){this._bitArrays=[],this._data=[],this._length=0,this._changedLength=!1,this._changedData=!1}set(J,E){let ee=this._internalPositionFor(J,!1);if(E===void 0)ee!==-1&&(this._unsetInternalPos(ee),this._unsetBit(J),this._changedLength=!0,this._changedData=!0);else{let te=!1;ee===-1?(ee=this._data.length,this._setBit(J),this._changedData=!0):te=!0,this._setInternalPos(ee,J,E,te),this._changedLength=!0}}unset(J){this.set(J,void 0)}get(J){this._sortData();const E=this._internalPositionFor(J,!0);if(E!==-1)return this._data[E][1]}push(J){return this.set(this.length,J),this.length}get length(){if(this._sortData(),this._changedLength){const J=this._data[this._data.length-1];this._length=J?J[0]+1:0,this._changedLength=!1}return this._length}forEach(J){let E=0;for(;E<this.length;)J(this.get(E),E,this),E++}map(J){let E=0,ee=new Array(this.length);for(;E<this.length;)ee[E]=J(this.get(E),E,this),E++;return ee}reduce(J,E){let ee=0,te=E;for(;ee<this.length;){const re=this.get(ee);te=J(te,re,ee),ee++}return te}find(J){let E=0,ee,te;for(;E<this.length&&!ee;)te=this.get(E),ee=J(te),E++;return ee?te:void 0}_internalPositionFor(J,E){const ee=this._bytePosFor(J,E);if(ee>=this._bitArrays.length)return-1;const te=this._bitArrays[ee],re=J-ee*BITS_PER_BYTE;if(!((te&1<<re)>0))return-1;const ne=this._bitArrays.slice(0,ee).reduce(popCountReduce,0),ie=~(4294967295<<re+1),se=popCount(te&ie);return ne+se-1}_bytePosFor(J,E){const ee=Math.floor(J/BITS_PER_BYTE),te=ee+1;for(;!E&&this._bitArrays.length<te;)this._bitArrays.push(0);return ee}_setBit(J){const E=this._bytePosFor(J,!1);this._bitArrays[E]|=1<<J-E*BITS_PER_BYTE}_unsetBit(J){const E=this._bytePosFor(J,!1);this._bitArrays[E]&=~(1<<J-E*BITS_PER_BYTE)}_setInternalPos(J,E,ee,te){const re=this._data,ne=[E,ee];if(te)this._sortData(),re[J]=ne;else{if(re.length)if(re[re.length-1][0]>=E)re.push(ne);else if(re[0][0]<=E)re.unshift(ne);else{const ie=Math.round(re.length/2);this._data=re.slice(0,ie).concat(ne).concat(re.slice(ie))}else this._data.push(ne);this._changedData=!0,this._changedLength=!0}}_unsetInternalPos(J){this._data.splice(J,1)}_sortData(){this._changedData&&this._data.sort(sortInternal),this._changedData=!1}bitField(){const J=[];let E=8,ee=0,te=0,re;const ne=this._bitArrays.slice();for(;ne.length||ee;){ee===0&&(re=ne.shift(),ee=7);const se=Math.min(ee,E),oe=~(255<<se),ce=re&oe;te|=ce<<8-E,re=re>>>se,ee-=se,E-=se,(!E||!ee&&!ne.length)&&(J.push(te),te=0,E=8)}for(var ie=J.length-1;ie>0&&J[ie]===0;ie--)J.pop();return J}compactArray(){return this._sortData(),this._data.map(valueOnly)}};function popCountReduce(J,E){return J+popCount(E)}function popCount(J){let E=J;return E=E-(E>>1&1431655765),E=(E&858993459)+(E>>2&858993459),(E+(E>>4)&252645135)*16843009>>24}function sortInternal(J,E){return J[0]-E[0]}function valueOnly(J){return J[1]}const SparseArray=getDefaultExportFromCjs(sparseArray);class Bucket{constructor(E,ee,te=0){this._options=E,this._popCount=0,this._parent=ee,this._posAtParent=te,this._children=new SparseArray,this.key=null}async put(E,ee){const te=await this._findNewBucketAndPos(E);await te.bucket._putAt(te,E,ee)}async get(E){const ee=await this._findChild(E);if(ee!=null)return ee.value}async del(E){const ee=await this._findPlace(E),te=ee.bucket._at(ee.pos);te!=null&&te.key===E&&ee.bucket._delAt(ee.pos)}leafCount(){return this._children.compactArray().reduce((E,ee)=>ee instanceof Bucket?E+ee.leafCount():E+1,0)}childrenCount(){return this._children.length}onlyChild(){return this._children.get(0)}*eachLeafSeries(){const E=this._children.compactArray();for(const ee of E)ee instanceof Bucket?yield*ee.eachLeafSeries():yield ee}serialize(E,ee){const te=[];return ee(this._children.reduce((re,ne,ie)=>(ne!=null&&(ne instanceof Bucket?re.push(ne.serialize(E,ee)):re.push(E(ne,ie))),re),te))}async asyncTransform(E,ee){return await asyncTransformBucket(this,E,ee)}toJSON(){return this.serialize(mapNode,reduceNodes)}prettyPrint(){return JSON.stringify(this.toJSON(),null,"  ")}tableSize(){return Math.pow(2,this._options.bits)}async _findChild(E){const ee=await this._findPlace(E),te=ee.bucket._at(ee.pos);if(!(te instanceof Bucket)&&te!=null&&te.key===E)return te}async _findPlace(E){const ee=this._options.hash(typeof E=="string"?fromString$5(E):E),te=await ee.take(this._options.bits),re=this._children.get(te);return re instanceof Bucket?await re._findPlace(ee):{bucket:this,pos:te,hash:ee,existingChild:re}}async _findNewBucketAndPos(E){const ee=await this._findPlace(E);if(ee.existingChild!=null&&ee.existingChild.key!==E){const te=new Bucket(this._options,ee.bucket,ee.pos);ee.bucket._putObjectAt(ee.pos,te);const re=await te._findPlace(ee.existingChild.hash);return re.bucket._putAt(re,ee.existingChild.key,ee.existingChild.value),await te._findNewBucketAndPos(ee.hash)}return ee}_putAt(E,ee,te){this._putObjectAt(E.pos,{key:ee,value:te,hash:E.hash})}_putObjectAt(E,ee){this._children.get(E)==null&&this._popCount++,this._children.set(E,ee)}_delAt(E){if(E===-1)throw new Error("Invalid position");this._children.get(E)!=null&&this._popCount--,this._children.unset(E),this._level()}_level(){if(this._parent!=null&&this._popCount<=1)if(this._popCount===1){const E=this._children.find(exists);if(E!=null&&!(E instanceof Bucket)){const ee=E.hash;ee.untake(this._options.bits);const te={pos:this._posAtParent,hash:ee,bucket:this._parent};this._parent._putAt(te,E.key,E.value)}}else this._parent._delAt(this._posAtParent)}_at(E){return this._children.get(E)}}function exists(J){return!!J}function mapNode(J,E){return J.key}function reduceNodes(J){return J}async function asyncTransformBucket(J,E,ee){const te=[];for(const re of J._children.compactArray())if(re instanceof Bucket)await asyncTransformBucket(re,E,ee);else{const ne=await E(re);te.push({bitField:J._children.bitField(),children:ne})}return await ee(te)}const START_MASKS$1=[255,254,252,248,240,224,192,128],STOP_MASKS$1=[1,3,7,15,31,63,127,255];let ConsumableBuffer$1=class{constructor(J){this._value=J,this._currentBytePos=J.length-1,this._currentBitPos=7}availableBits(){return this._currentBitPos+1+this._currentBytePos*8}totalBits(){return this._value.length*8}take(J){let E=J,ee=0;for(;E>0&&this._haveBits();){const te=this._value[this._currentBytePos],re=this._currentBitPos+1,ne=Math.min(re,E),ie=byteBitsToInt$1(te,re-ne,ne);ee=(ee<<ne)+ie,E-=ne,this._currentBitPos-=ne,this._currentBitPos<0&&(this._currentBitPos=7,this._currentBytePos--)}return ee}untake(J){for(this._currentBitPos+=J;this._currentBitPos>7;)this._currentBitPos-=8,this._currentBytePos+=1}_haveBits(){return this._currentBytePos>=0}};function byteBitsToInt$1(J,E,ee){const te=maskFor$1(E,ee);return(J&te)>>>E}function maskFor$1(J,E){return START_MASKS$1[J]&STOP_MASKS$1[Math.min(E+J-1,7)]}function wrapHash$1(J){function E(ee){return ee instanceof InfiniteHash$1?ee:new InfiniteHash$1(ee,J)}return E}let InfiniteHash$1=class{constructor(J,E){if(!(J instanceof Uint8Array))throw new Error("can only hash Uint8Arrays");this._value=J,this._hashFn=E,this._depth=-1,this._availableBits=0,this._currentBufferIndex=0,this._buffers=[]}async take(J){let E=J;for(;this._availableBits<E;)await this._produceMoreBits();let ee=0;for(;E>0;){const te=this._buffers[this._currentBufferIndex],re=Math.min(te.availableBits(),E),ne=te.take(re);ee=(ee<<re)+ne,E-=re,this._availableBits-=re,te.availableBits()===0&&this._currentBufferIndex++}return ee}untake(J){let E=J;for(;E>0;){const ee=this._buffers[this._currentBufferIndex],te=Math.min(ee.totalBits()-ee.availableBits(),E);ee.untake(te),E-=te,this._availableBits+=te,this._currentBufferIndex>0&&ee.totalBits()===ee.availableBits()&&(this._depth--,this._currentBufferIndex--)}}async _produceMoreBits(){this._depth++;const J=this._depth>0?concat$4([this._value,Uint8Array.from([this._depth])]):this._value,E=await this._hashFn(J),ee=new ConsumableBuffer$1(E);this._buffers.push(ee),this._availableBits+=ee.availableBits()}};function createHAMT(J){if(J==null||J.hashFn==null)throw new Error("please define an options.hashFn");const E={bits:J.bits??8,hash:wrapHash$1(J.hashFn)};return new Bucket(E)}async function hamtHashFn$1(J){return(await murmur3128.encode(J)).slice(0,8).reverse()}const HAMT_HASH_CODE=BigInt(34);let DirSharded$1=class extends Dir$1{_bucket;constructor(J,E){super(J,E),this._bucket=createHAMT({hashFn:hamtHashFn$1,bits:8})}async put(J,E){this.cid=void 0,this.size=void 0,this.nodeSize=void 0,await this._bucket.put(J,E)}async get(J){return this._bucket.get(J)}childCount(){return this._bucket.leafCount()}directChildrenCount(){return this._bucket.childrenCount()}onlyChild(){return this._bucket.onlyChild()}async*eachChildSeries(){for await(const{key:J,value:E}of this._bucket.eachLeafSeries())yield{key:J,child:E}}estimateNodeSize(){return this.nodeSize!==void 0?this.nodeSize:(this.nodeSize=calculateSize$1(this._bucket,this,this.options),this.nodeSize)}async*flush(J){for await(const E of flush$1(this._bucket,J,this,this.options))yield{...E,path:this.path}}};async function*flush$1(J,E,ee,te){const re=J._children,ne=[];let ie=0n;for(let he=0;he<re.length;he++){const pe=re.get(he);if(pe==null)continue;const de=he.toString(16).toUpperCase().padStart(2,"0");if(pe instanceof Bucket){let fe;for await(const me of flush$1(pe,E,null,te))fe=me;if(fe==null)throw new Error("Could not flush sharded directory, no subshard found");ne.push({Name:de,Tsize:Number(fe.size),Hash:fe.cid}),ie+=fe.size}else if(isDir$1(pe.value)){const fe=pe.value;let me;for await(const be of fe.flush(E))me=be,yield me;if(me==null)throw new Error("Did not flush dir");const _e=de+pe.key;ne.push({Name:_e,Tsize:Number(me.size),Hash:me.cid}),ie+=me.size}else{const fe=pe.value;if(fe.cid==null)continue;const me=de+pe.key,_e=fe.size;ne.push({Name:me,Tsize:Number(_e),Hash:fe.cid}),ie+=BigInt(_e??0)}}const se=Uint8Array.from(re.bitField().reverse()),oe=new UnixFS({type:"hamt-sharded-directory",data:se,fanout:BigInt(J.tableSize()),hashType:HAMT_HASH_CODE,mtime:ee?.mtime,mode:ee?.mode}),ce={Data:oe.marshal(),Links:ne},ae=encode$2(prepare(ce)),le=await persist$1(ae,E,te),ue=BigInt(ae.byteLength)+ie;yield{cid:le,unixfs:oe,size:ue}}function isDir$1(J){return typeof J.flush=="function"}function calculateSize$1(J,E,ee){const te=J._children,re=[];for(let se=0;se<te.length;se++){const oe=te.get(se);if(oe==null)continue;const ce=se.toString(16).toUpperCase().padStart(2,"0");if(oe instanceof Bucket){const ae=calculateSize$1(oe,null,ee);re.push({Name:ce,Tsize:Number(ae),Hash:ee.cidVersion===0?CID_V0$1:CID_V1$1})}else if(typeof oe.value.flush=="function"){const ae=oe.value.nodeSize();re.push({Name:ce+oe.key,Tsize:Number(ae),Hash:ee.cidVersion===0?CID_V0$1:CID_V1$1})}else{const ae=oe.value;if(ae.cid==null)continue;const le=ce+oe.key,ue=ae.size;re.push({Name:le,Tsize:Number(ue),Hash:ae.cid})}}const ne=Uint8Array.from(te.bitField().reverse()),ie=new UnixFS({type:"hamt-sharded-directory",data:ne,fanout:BigInt(J.tableSize()),hashType:HAMT_HASH_CODE,mtime:E?.mtime,mode:E?.mode});return encode$2(prepare({Data:ie.marshal(),Links:re})).length}async function flatToShard(J,E,ee,te){let re=E;E instanceof DirFlat&&E.estimateNodeSize()>ee&&(re=await convertToShard(E,te));const ne=re.parent;if(ne!=null){if(re!==E){if(J!=null&&(J.parent=re),re.parentKey==null)throw new Error("No parent key found");await ne.put(re.parentKey,re)}return flatToShard(re,ne,ee,te)}return re}async function convertToShard(J,E){const ee=new DirSharded$1({root:J.root,dir:!0,parent:J.parent,parentKey:J.parentKey,path:J.path,dirty:J.dirty,flat:!1,mtime:J.mtime,mode:J.mode},E);for await(const{key:te,child:re}of J.eachChildSeries())await ee.put(te,re);return ee}const toPathComponents$1=(J="")=>(J.trim().match(/([^\\/]|\\\/)+/g)??[]).filter(Boolean);async function addToTree(J,E,ee){const te=toPathComponents$1(J.path??""),re=te.length-1;let ne=E,ie="";for(let se=0;se<te.length;se++){const oe=te[se];ie+=`${ie!==""?"/":""}${oe}`;const ce=se===re;if(ne.dirty=!0,ne.cid=void 0,ne.size=void 0,ce)await ne.put(oe,J),E=await flatToShard(null,ne,ee.shardSplitThresholdBytes,ee);else{let ae=await ne.get(oe);(ae==null||!(ae instanceof Dir$1))&&(ae=new DirFlat({root:!1,dir:!0,parent:ne,parentKey:oe,path:ie,dirty:!0,flat:!0,mtime:ae?.unixfs?.mtime,mode:ae?.unixfs?.mode},ee)),await ne.put(oe,ae),ne=ae}}return E}async function*flushAndYield(J,E){if(!(J instanceof Dir$1)){J.unixfs?.isDirectory()===!0&&(yield J);return}yield*J.flush(E)}function defaultTreeBuilder(J){return async function*(E,ee){let te=new DirFlat({root:!0,dir:!0,path:"",dirty:!0,flat:!0},J),re,ne=!1;for await(const ie of E){if(ie==null)continue;const se=`${ie.originalPath??""}`.split("/")[0];se!=null&&se!==""&&(re==null?(re=se,ne=!0):re!==se&&(ne=!1)),te=await addToTree(ie,te,J),(ie.unixfs==null||!ie.unixfs.isDirectory())&&(yield ie)}if(J.wrapWithDirectory||ne&&te.childCount()>1)yield*flushAndYield(te,ee);else for await(const ie of te.eachChildSeries())ie!=null&&(yield*flushAndYield(ie.child,ee))}}async function*importer(J,E,ee={}){let te;Symbol.asyncIterator in J||Symbol.iterator in J?te=J:te=[J];const re=ee.wrapWithDirectory??!1,ne=ee.shardSplitThresholdBytes??262144,ie=ee.cidVersion??1,se=ee.rawLeaves??!0,oe=ee.leafType??"file",ce=ee.fileImportConcurrency??50,ae=ee.blockWriteConcurrency??10,le=ee.reduceSingleLeafToSelf??!0,ue=ee.chunker??fixedSize(),he=ee.chunkValidator??defaultChunkValidator(),pe=ee.dagBuilder??defaultDagBuilder({chunker:ue,chunkValidator:he,wrapWithDirectory:re,layout:ee.layout??balanced(),bufferImporter:ee.bufferImporter??defaultBufferImporter({cidVersion:ie,rawLeaves:se,leafType:oe,onProgress:ee.onProgress}),blockWriteConcurrency:ae,reduceSingleLeafToSelf:le,cidVersion:ie,onProgress:ee.onProgress}),de=ee.treeBuilder??defaultTreeBuilder({wrapWithDirectory:re,shardSplitThresholdBytes:ne,cidVersion:ie,onProgress:ee.onProgress});for await(const fe of de(parallelBatch(pe(te,E),ce),E))yield{cid:fe.cid,path:fe.path,unixfs:fe.unixfs,size:fe.size}}async function importFile(J,E,ee={}){const te=await first(importer([J],E,ee));if(te==null)throw errCode$1(new Error("Nothing imported"),"ERR_INVALID_PARAMS");return te}async function importDirectory(J,E,ee={}){const te=await first(importer([J],E,ee));if(te==null)throw errCode$1(new Error("Nothing imported"),"ERR_INVALID_PARAMS");return te}async function importBytes(J,E,ee={}){return importFile({content:J},E,ee)}async function importByteStream(J,E,ee={}){return importFile({content:J},E,ee)}const defaultImporterSettings={cidVersion:1,rawLeaves:!0,layout:balanced({maxChildrenPerNode:1024}),chunker:fixedSize({chunkSize:1048576})};async function*addAll(J,E,ee={}){yield*importer(J,E,{...defaultImporterSettings,...ee})}async function addBytes(J,E,ee={}){const{cid:te}=await importBytes(J,E,{...defaultImporterSettings,...ee});return te}async function addByteStream(J,E,ee={}){const{cid:te}=await importByteStream(J,E,{...defaultImporterSettings,...ee});return te}async function addFile(J,E,ee={}){const{cid:te}=await importFile(J,E,{...defaultImporterSettings,...ee});return te}async function addDirectory(J,E,ee={}){const{cid:te}=await importDirectory({...J,path:J.path??"-"},E,{...defaultImporterSettings,...ee});return te}function isAsyncIterable$2(J){return J[Symbol.asyncIterator]!=null}function last(J){if(isAsyncIterable$2(J))return(async()=>{let ee;for await(const te of J)ee=te;return ee})();let E;for(const ee of J)E=ee;return E}const typeofs=["string","number","bigint","symbol"],objectTypeNames=["Function","Generator","AsyncGenerator","GeneratorFunction","AsyncGeneratorFunction","AsyncFunction","Observable","Array","Buffer","Object","RegExp","Date","Error","Map","Set","WeakMap","WeakSet","ArrayBuffer","SharedArrayBuffer","DataView","Promise","URL","HTMLElement","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","BigInt64Array","BigUint64Array"];function is(J){if(J===null)return"null";if(J===void 0)return"undefined";if(J===!0||J===!1)return"boolean";const E=typeof J;return typeofs.includes(E)?E:E==="function"?"Function":Array.isArray(J)?"Array":isBuffer$1(J)?"Buffer":getObjectType(J)||"Object"}function isBuffer$1(J){return J&&J.constructor&&J.constructor.isBuffer&&J.constructor.isBuffer.call(null,J)}function getObjectType(J){const E=Object.prototype.toString.call(J).slice(8,-1);if(objectTypeNames.includes(E))return E}class Type{constructor(E,ee,te){this.major=E,this.majorEncoded=E<<5,this.name=ee,this.terminal=te}toString(){return`Type[${this.major}].${this.name}`}compare(E){return this.major<E.major?-1:this.major>E.major?1:0}}Type.uint=new Type(0,"uint",!0);Type.negint=new Type(1,"negint",!0);Type.bytes=new Type(2,"bytes",!0);Type.string=new Type(3,"string",!0);Type.array=new Type(4,"array",!1);Type.map=new Type(5,"map",!1);Type.tag=new Type(6,"tag",!1);Type.float=new Type(7,"float",!0);Type.false=new Type(7,"false",!0);Type.true=new Type(7,"true",!0);Type.null=new Type(7,"null",!0);Type.undefined=new Type(7,"undefined",!0);Type.break=new Type(7,"break",!0);class Token{constructor(E,ee,te){this.type=E,this.value=ee,this.encodedLength=te,this.encodedBytes=void 0,this.byteValue=void 0}toString(){return`Token[${this.type}].${this.value}`}}const useBuffer=globalThis.process&&!globalThis.process.browser&&globalThis.Buffer&&typeof globalThis.Buffer.isBuffer=="function",textDecoder=new TextDecoder,textEncoder=new TextEncoder;function isBuffer(J){return useBuffer&&globalThis.Buffer.isBuffer(J)}function asU8A(J){return J instanceof Uint8Array?isBuffer(J)?new Uint8Array(J.buffer,J.byteOffset,J.byteLength):J:Uint8Array.from(J)}const toString=useBuffer?(J,E,ee)=>ee-E>64?globalThis.Buffer.from(J.subarray(E,ee)).toString("utf8"):utf8Slice(J,E,ee):(J,E,ee)=>ee-E>64?textDecoder.decode(J.subarray(E,ee)):utf8Slice(J,E,ee),fromString=useBuffer?J=>J.length>64?globalThis.Buffer.from(J):utf8ToBytes(J):J=>J.length>64?textEncoder.encode(J):utf8ToBytes(J),fromArray=J=>Uint8Array.from(J),slice=useBuffer?(J,E,ee)=>isBuffer(J)?new Uint8Array(J.subarray(E,ee)):J.slice(E,ee):(J,E,ee)=>J.slice(E,ee),concat=useBuffer?(J,E)=>(J=J.map(ee=>ee instanceof Uint8Array?ee:globalThis.Buffer.from(ee)),asU8A(globalThis.Buffer.concat(J,E))):(J,E)=>{const ee=new Uint8Array(E);let te=0;for(let re of J)te+re.length>ee.length&&(re=re.subarray(0,ee.length-te)),ee.set(re,te),te+=re.length;return ee},alloc=useBuffer?J=>globalThis.Buffer.allocUnsafe(J):J=>new Uint8Array(J);function compare(J,E){if(isBuffer(J)&&isBuffer(E))return J.compare(E);for(let ee=0;ee<J.length;ee++)if(J[ee]!==E[ee])return J[ee]<E[ee]?-1:1;return 0}function utf8ToBytes(J,E=1/0){let ee;const te=J.length;let re=null;const ne=[];for(let ie=0;ie<te;++ie){if(ee=J.charCodeAt(ie),ee>55295&&ee<57344){if(!re){if(ee>56319){(E-=3)>-1&&ne.push(239,191,189);continue}else if(ie+1===te){(E-=3)>-1&&ne.push(239,191,189);continue}re=ee;continue}if(ee<56320){(E-=3)>-1&&ne.push(239,191,189),re=ee;continue}ee=(re-55296<<10|ee-56320)+65536}else re&&(E-=3)>-1&&ne.push(239,191,189);if(re=null,ee<128){if((E-=1)<0)break;ne.push(ee)}else if(ee<2048){if((E-=2)<0)break;ne.push(ee>>6|192,ee&63|128)}else if(ee<65536){if((E-=3)<0)break;ne.push(ee>>12|224,ee>>6&63|128,ee&63|128)}else if(ee<1114112){if((E-=4)<0)break;ne.push(ee>>18|240,ee>>12&63|128,ee>>6&63|128,ee&63|128)}else throw new Error("Invalid code point")}return ne}function utf8Slice(J,E,ee){const te=[];for(;E<ee;){const re=J[E];let ne=null,ie=re>239?4:re>223?3:re>191?2:1;if(E+ie<=ee){let se,oe,ce,ae;switch(ie){case 1:re<128&&(ne=re);break;case 2:se=J[E+1],(se&192)===128&&(ae=(re&31)<<6|se&63,ae>127&&(ne=ae));break;case 3:se=J[E+1],oe=J[E+2],(se&192)===128&&(oe&192)===128&&(ae=(re&15)<<12|(se&63)<<6|oe&63,ae>2047&&(ae<55296||ae>57343)&&(ne=ae));break;case 4:se=J[E+1],oe=J[E+2],ce=J[E+3],(se&192)===128&&(oe&192)===128&&(ce&192)===128&&(ae=(re&15)<<18|(se&63)<<12|(oe&63)<<6|ce&63,ae>65535&&ae<1114112&&(ne=ae))}}ne===null?(ne=65533,ie=1):ne>65535&&(ne-=65536,te.push(ne>>>10&1023|55296),ne=56320|ne&1023),te.push(ne),E+=ie}return decodeCodePointsArray(te)}const MAX_ARGUMENTS_LENGTH=4096;function decodeCodePointsArray(J){const E=J.length;if(E<=MAX_ARGUMENTS_LENGTH)return String.fromCharCode.apply(String,J);let ee="",te=0;for(;te<E;)ee+=String.fromCharCode.apply(String,J.slice(te,te+=MAX_ARGUMENTS_LENGTH));return ee}const defaultChunkSize=256;class Bl{constructor(E=defaultChunkSize){this.chunkSize=E,this.cursor=0,this.maxCursor=-1,this.chunks=[],this._initReuseChunk=null}reset(){this.cursor=0,this.maxCursor=-1,this.chunks.length&&(this.chunks=[]),this._initReuseChunk!==null&&(this.chunks.push(this._initReuseChunk),this.maxCursor=this._initReuseChunk.length-1)}push(E){let ee=this.chunks[this.chunks.length-1];if(this.cursor+E.length<=this.maxCursor+1){const te=ee.length-(this.maxCursor-this.cursor)-1;ee.set(E,te)}else{if(ee){const te=ee.length-(this.maxCursor-this.cursor)-1;te<ee.length&&(this.chunks[this.chunks.length-1]=ee.subarray(0,te),this.maxCursor=this.cursor-1)}E.length<64&&E.length<this.chunkSize?(ee=alloc(this.chunkSize),this.chunks.push(ee),this.maxCursor+=ee.length,this._initReuseChunk===null&&(this._initReuseChunk=ee),ee.set(E,0)):(this.chunks.push(E),this.maxCursor+=E.length)}this.cursor+=E.length}toBytes(E=!1){let ee;if(this.chunks.length===1){const te=this.chunks[0];E&&this.cursor>te.length/2?(ee=this.cursor===te.length?te:te.subarray(0,this.cursor),this._initReuseChunk=null,this.chunks=[]):ee=slice(te,0,this.cursor)}else ee=concat(this.chunks,this.cursor);return E&&this.reset(),ee}}const decodeErrPrefix="CBOR decode error:",encodeErrPrefix="CBOR encode error:";function assertEnoughData(J,E,ee){if(J.length-E<ee)throw new Error(`${decodeErrPrefix} not enough data for type`)}const uintBoundaries=[24,256,65536,4294967296,BigInt("18446744073709551616")];function readUint8(J,E,ee){assertEnoughData(J,E,1);const te=J[E];if(ee.strict===!0&&te<uintBoundaries[0])throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);return te}function readUint16(J,E,ee){assertEnoughData(J,E,2);const te=J[E]<<8|J[E+1];if(ee.strict===!0&&te<uintBoundaries[1])throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);return te}function readUint32(J,E,ee){assertEnoughData(J,E,4);const te=J[E]*16777216+(J[E+1]<<16)+(J[E+2]<<8)+J[E+3];if(ee.strict===!0&&te<uintBoundaries[2])throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);return te}function readUint64(J,E,ee){assertEnoughData(J,E,8);const te=J[E]*16777216+(J[E+1]<<16)+(J[E+2]<<8)+J[E+3],re=J[E+4]*16777216+(J[E+5]<<16)+(J[E+6]<<8)+J[E+7],ne=(BigInt(te)<<BigInt(32))+BigInt(re);if(ee.strict===!0&&ne<uintBoundaries[3])throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);if(ne<=Number.MAX_SAFE_INTEGER)return Number(ne);if(ee.allowBigInt===!0)return ne;throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`)}function decodeUint8(J,E,ee,te){return new Token(Type.uint,readUint8(J,E+1,te),2)}function decodeUint16(J,E,ee,te){return new Token(Type.uint,readUint16(J,E+1,te),3)}function decodeUint32(J,E,ee,te){return new Token(Type.uint,readUint32(J,E+1,te),5)}function decodeUint64(J,E,ee,te){return new Token(Type.uint,readUint64(J,E+1,te),9)}function encodeUint(J,E){return encodeUintValue(J,0,E.value)}function encodeUintValue(J,E,ee){if(ee<uintBoundaries[0]){const te=Number(ee);J.push([E|te])}else if(ee<uintBoundaries[1]){const te=Number(ee);J.push([E|24,te])}else if(ee<uintBoundaries[2]){const te=Number(ee);J.push([E|25,te>>>8,te&255])}else if(ee<uintBoundaries[3]){const te=Number(ee);J.push([E|26,te>>>24&255,te>>>16&255,te>>>8&255,te&255])}else{const te=BigInt(ee);if(te<uintBoundaries[4]){const re=[E|27,0,0,0,0,0,0,0];let ne=Number(te&BigInt(4294967295)),ie=Number(te>>BigInt(32)&BigInt(4294967295));re[8]=ne&255,ne=ne>>8,re[7]=ne&255,ne=ne>>8,re[6]=ne&255,ne=ne>>8,re[5]=ne&255,re[4]=ie&255,ie=ie>>8,re[3]=ie&255,ie=ie>>8,re[2]=ie&255,ie=ie>>8,re[1]=ie&255,J.push(re)}else throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`)}}encodeUint.encodedSize=function J(E){return encodeUintValue.encodedSize(E.value)};encodeUintValue.encodedSize=function J(E){return E<uintBoundaries[0]?1:E<uintBoundaries[1]?2:E<uintBoundaries[2]?3:E<uintBoundaries[3]?5:9};encodeUint.compareTokens=function J(E,ee){return E.value<ee.value?-1:E.value>ee.value?1:0};function decodeNegint8(J,E,ee,te){return new Token(Type.negint,-1-readUint8(J,E+1,te),2)}function decodeNegint16(J,E,ee,te){return new Token(Type.negint,-1-readUint16(J,E+1,te),3)}function decodeNegint32(J,E,ee,te){return new Token(Type.negint,-1-readUint32(J,E+1,te),5)}const neg1b=BigInt(-1),pos1b=BigInt(1);function decodeNegint64(J,E,ee,te){const re=readUint64(J,E+1,te);if(typeof re!="bigint"){const ne=-1-re;if(ne>=Number.MIN_SAFE_INTEGER)return new Token(Type.negint,ne,9)}if(te.allowBigInt!==!0)throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);return new Token(Type.negint,neg1b-BigInt(re),9)}function encodeNegint(J,E){const ee=E.value,te=typeof ee=="bigint"?ee*neg1b-pos1b:ee*-1-1;encodeUintValue(J,E.type.majorEncoded,te)}encodeNegint.encodedSize=function J(E){const ee=E.value,te=typeof ee=="bigint"?ee*neg1b-pos1b:ee*-1-1;return te<uintBoundaries[0]?1:te<uintBoundaries[1]?2:te<uintBoundaries[2]?3:te<uintBoundaries[3]?5:9};encodeNegint.compareTokens=function J(E,ee){return E.value<ee.value?1:E.value>ee.value?-1:0};function toToken$3(J,E,ee,te){assertEnoughData(J,E,ee+te);const re=slice(J,E+ee,E+ee+te);return new Token(Type.bytes,re,ee+te)}function decodeBytesCompact(J,E,ee,te){return toToken$3(J,E,1,ee)}function decodeBytes8(J,E,ee,te){return toToken$3(J,E,2,readUint8(J,E+1,te))}function decodeBytes16(J,E,ee,te){return toToken$3(J,E,3,readUint16(J,E+1,te))}function decodeBytes32(J,E,ee,te){return toToken$3(J,E,5,readUint32(J,E+1,te))}function decodeBytes64(J,E,ee,te){const re=readUint64(J,E+1,te);if(typeof re=="bigint")throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);return toToken$3(J,E,9,re)}function tokenBytes(J){return J.encodedBytes===void 0&&(J.encodedBytes=J.type===Type.string?fromString(J.value):J.value),J.encodedBytes}function encodeBytes(J,E){const ee=tokenBytes(E);encodeUintValue(J,E.type.majorEncoded,ee.length),J.push(ee)}encodeBytes.encodedSize=function J(E){const ee=tokenBytes(E);return encodeUintValue.encodedSize(ee.length)+ee.length};encodeBytes.compareTokens=function J(E,ee){return compareBytes(tokenBytes(E),tokenBytes(ee))};function compareBytes(J,E){return J.length<E.length?-1:J.length>E.length?1:compare(J,E)}function toToken$2(J,E,ee,te,re){const ne=ee+te;assertEnoughData(J,E,ne);const ie=new Token(Type.string,toString(J,E+ee,E+ne),ne);return re.retainStringBytes===!0&&(ie.byteValue=slice(J,E+ee,E+ne)),ie}function decodeStringCompact(J,E,ee,te){return toToken$2(J,E,1,ee,te)}function decodeString8(J,E,ee,te){return toToken$2(J,E,2,readUint8(J,E+1,te),te)}function decodeString16(J,E,ee,te){return toToken$2(J,E,3,readUint16(J,E+1,te),te)}function decodeString32(J,E,ee,te){return toToken$2(J,E,5,readUint32(J,E+1,te),te)}function decodeString64(J,E,ee,te){const re=readUint64(J,E+1,te);if(typeof re=="bigint")throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);return toToken$2(J,E,9,re,te)}const encodeString=encodeBytes;function toToken$1(J,E,ee,te){return new Token(Type.array,te,ee)}function decodeArrayCompact(J,E,ee,te){return toToken$1(J,E,1,ee)}function decodeArray8(J,E,ee,te){return toToken$1(J,E,2,readUint8(J,E+1,te))}function decodeArray16(J,E,ee,te){return toToken$1(J,E,3,readUint16(J,E+1,te))}function decodeArray32(J,E,ee,te){return toToken$1(J,E,5,readUint32(J,E+1,te))}function decodeArray64(J,E,ee,te){const re=readUint64(J,E+1,te);if(typeof re=="bigint")throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);return toToken$1(J,E,9,re)}function decodeArrayIndefinite(J,E,ee,te){if(te.allowIndefinite===!1)throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);return toToken$1(J,E,1,1/0)}function encodeArray(J,E){encodeUintValue(J,Type.array.majorEncoded,E.value)}encodeArray.compareTokens=encodeUint.compareTokens;encodeArray.encodedSize=function J(E){return encodeUintValue.encodedSize(E.value)};function toToken(J,E,ee,te){return new Token(Type.map,te,ee)}function decodeMapCompact(J,E,ee,te){return toToken(J,E,1,ee)}function decodeMap8(J,E,ee,te){return toToken(J,E,2,readUint8(J,E+1,te))}function decodeMap16(J,E,ee,te){return toToken(J,E,3,readUint16(J,E+1,te))}function decodeMap32(J,E,ee,te){return toToken(J,E,5,readUint32(J,E+1,te))}function decodeMap64(J,E,ee,te){const re=readUint64(J,E+1,te);if(typeof re=="bigint")throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);return toToken(J,E,9,re)}function decodeMapIndefinite(J,E,ee,te){if(te.allowIndefinite===!1)throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);return toToken(J,E,1,1/0)}function encodeMap(J,E){encodeUintValue(J,Type.map.majorEncoded,E.value)}encodeMap.compareTokens=encodeUint.compareTokens;encodeMap.encodedSize=function J(E){return encodeUintValue.encodedSize(E.value)};function decodeTagCompact(J,E,ee,te){return new Token(Type.tag,ee,1)}function decodeTag8(J,E,ee,te){return new Token(Type.tag,readUint8(J,E+1,te),2)}function decodeTag16(J,E,ee,te){return new Token(Type.tag,readUint16(J,E+1,te),3)}function decodeTag32(J,E,ee,te){return new Token(Type.tag,readUint32(J,E+1,te),5)}function decodeTag64(J,E,ee,te){return new Token(Type.tag,readUint64(J,E+1,te),9)}function encodeTag(J,E){encodeUintValue(J,Type.tag.majorEncoded,E.value)}encodeTag.compareTokens=encodeUint.compareTokens;encodeTag.encodedSize=function J(E){return encodeUintValue.encodedSize(E.value)};const MINOR_FALSE=20,MINOR_TRUE=21,MINOR_NULL=22,MINOR_UNDEFINED=23;function decodeUndefined(J,E,ee,te){if(te.allowUndefined===!1)throw new Error(`${decodeErrPrefix} undefined values are not supported`);return te.coerceUndefinedToNull===!0?new Token(Type.null,null,1):new Token(Type.undefined,void 0,1)}function decodeBreak(J,E,ee,te){if(te.allowIndefinite===!1)throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);return new Token(Type.break,void 0,1)}function createToken(J,E,ee){if(ee){if(ee.allowNaN===!1&&Number.isNaN(J))throw new Error(`${decodeErrPrefix} NaN values are not supported`);if(ee.allowInfinity===!1&&(J===1/0||J===-1/0))throw new Error(`${decodeErrPrefix} Infinity values are not supported`)}return new Token(Type.float,J,E)}function decodeFloat16(J,E,ee,te){return createToken(readFloat16(J,E+1),3,te)}function decodeFloat32(J,E,ee,te){return createToken(readFloat32(J,E+1),5,te)}function decodeFloat64(J,E,ee,te){return createToken(readFloat64(J,E+1),9,te)}function encodeFloat(J,E,ee){const te=E.value;if(te===!1)J.push([Type.float.majorEncoded|MINOR_FALSE]);else if(te===!0)J.push([Type.float.majorEncoded|MINOR_TRUE]);else if(te===null)J.push([Type.float.majorEncoded|MINOR_NULL]);else if(te===void 0)J.push([Type.float.majorEncoded|MINOR_UNDEFINED]);else{let re,ne=!1;(!ee||ee.float64!==!0)&&(encodeFloat16(te),re=readFloat16(ui8a,1),te===re||Number.isNaN(te)?(ui8a[0]=249,J.push(ui8a.slice(0,3)),ne=!0):(encodeFloat32(te),re=readFloat32(ui8a,1),te===re&&(ui8a[0]=250,J.push(ui8a.slice(0,5)),ne=!0))),ne||(encodeFloat64(te),re=readFloat64(ui8a,1),ui8a[0]=251,J.push(ui8a.slice(0,9)))}}encodeFloat.encodedSize=function J(E,ee){const te=E.value;if(te===!1||te===!0||te===null||te===void 0)return 1;if(!ee||ee.float64!==!0){encodeFloat16(te);let re=readFloat16(ui8a,1);if(te===re||Number.isNaN(te))return 3;if(encodeFloat32(te),re=readFloat32(ui8a,1),te===re)return 5}return 9};const buffer=new ArrayBuffer(9),dataView=new DataView(buffer,1),ui8a=new Uint8Array(buffer,0);function encodeFloat16(J){if(J===1/0)dataView.setUint16(0,31744,!1);else if(J===-1/0)dataView.setUint16(0,64512,!1);else if(Number.isNaN(J))dataView.setUint16(0,32256,!1);else{dataView.setFloat32(0,J);const E=dataView.getUint32(0),ee=(E&2139095040)>>23,te=E&8388607;if(ee===255)dataView.setUint16(0,31744,!1);else if(ee===0)dataView.setUint16(0,(J&2147483648)>>16|te>>13,!1);else{const re=ee-127;re<-24?dataView.setUint16(0,0):re<-14?dataView.setUint16(0,(E&2147483648)>>16|1<<24+re,!1):dataView.setUint16(0,(E&2147483648)>>16|re+15<<10|te>>13,!1)}}}function readFloat16(J,E){if(J.length-E<2)throw new Error(`${decodeErrPrefix} not enough data for float16`);const ee=(J[E]<<8)+J[E+1];if(ee===31744)return 1/0;if(ee===64512)return-1/0;if(ee===32256)return NaN;const te=ee>>10&31,re=ee&1023;let ne;return te===0?ne=re*2**-24:te!==31?ne=(re+1024)*2**(te-25):ne=re===0?1/0:NaN,ee&32768?-ne:ne}function encodeFloat32(J){dataView.setFloat32(0,J,!1)}function readFloat32(J,E){if(J.length-E<4)throw new Error(`${decodeErrPrefix} not enough data for float32`);const ee=(J.byteOffset||0)+E;return new DataView(J.buffer,ee,4).getFloat32(0,!1)}function encodeFloat64(J){dataView.setFloat64(0,J,!1)}function readFloat64(J,E){if(J.length-E<8)throw new Error(`${decodeErrPrefix} not enough data for float64`);const ee=(J.byteOffset||0)+E;return new DataView(J.buffer,ee,8).getFloat64(0,!1)}encodeFloat.compareTokens=encodeUint.compareTokens;function invalidMinor(J,E,ee){throw new Error(`${decodeErrPrefix} encountered invalid minor (${ee}) for major ${J[E]>>>5}`)}function errorer(J){return()=>{throw new Error(`${decodeErrPrefix} ${J}`)}}const jump=[];for(let J=0;J<=23;J++)jump[J]=invalidMinor;jump[24]=decodeUint8;jump[25]=decodeUint16;jump[26]=decodeUint32;jump[27]=decodeUint64;jump[28]=invalidMinor;jump[29]=invalidMinor;jump[30]=invalidMinor;jump[31]=invalidMinor;for(let J=32;J<=55;J++)jump[J]=invalidMinor;jump[56]=decodeNegint8;jump[57]=decodeNegint16;jump[58]=decodeNegint32;jump[59]=decodeNegint64;jump[60]=invalidMinor;jump[61]=invalidMinor;jump[62]=invalidMinor;jump[63]=invalidMinor;for(let J=64;J<=87;J++)jump[J]=decodeBytesCompact;jump[88]=decodeBytes8;jump[89]=decodeBytes16;jump[90]=decodeBytes32;jump[91]=decodeBytes64;jump[92]=invalidMinor;jump[93]=invalidMinor;jump[94]=invalidMinor;jump[95]=errorer("indefinite length bytes/strings are not supported");for(let J=96;J<=119;J++)jump[J]=decodeStringCompact;jump[120]=decodeString8;jump[121]=decodeString16;jump[122]=decodeString32;jump[123]=decodeString64;jump[124]=invalidMinor;jump[125]=invalidMinor;jump[126]=invalidMinor;jump[127]=errorer("indefinite length bytes/strings are not supported");for(let J=128;J<=151;J++)jump[J]=decodeArrayCompact;jump[152]=decodeArray8;jump[153]=decodeArray16;jump[154]=decodeArray32;jump[155]=decodeArray64;jump[156]=invalidMinor;jump[157]=invalidMinor;jump[158]=invalidMinor;jump[159]=decodeArrayIndefinite;for(let J=160;J<=183;J++)jump[J]=decodeMapCompact;jump[184]=decodeMap8;jump[185]=decodeMap16;jump[186]=decodeMap32;jump[187]=decodeMap64;jump[188]=invalidMinor;jump[189]=invalidMinor;jump[190]=invalidMinor;jump[191]=decodeMapIndefinite;for(let J=192;J<=215;J++)jump[J]=decodeTagCompact;jump[216]=decodeTag8;jump[217]=decodeTag16;jump[218]=decodeTag32;jump[219]=decodeTag64;jump[220]=invalidMinor;jump[221]=invalidMinor;jump[222]=invalidMinor;jump[223]=invalidMinor;for(let J=224;J<=243;J++)jump[J]=errorer("simple values are not supported");jump[244]=invalidMinor;jump[245]=invalidMinor;jump[246]=invalidMinor;jump[247]=decodeUndefined;jump[248]=errorer("simple values are not supported");jump[249]=decodeFloat16;jump[250]=decodeFloat32;jump[251]=decodeFloat64;jump[252]=invalidMinor;jump[253]=invalidMinor;jump[254]=invalidMinor;jump[255]=decodeBreak;const quick=[];for(let J=0;J<24;J++)quick[J]=new Token(Type.uint,J,1);for(let J=-1;J>=-24;J--)quick[31-J]=new Token(Type.negint,J,1);quick[64]=new Token(Type.bytes,new Uint8Array(0),1);quick[96]=new Token(Type.string,"",1);quick[128]=new Token(Type.array,0,1);quick[160]=new Token(Type.map,0,1);quick[244]=new Token(Type.false,!1,1);quick[245]=new Token(Type.true,!0,1);quick[246]=new Token(Type.null,null,1);function quickEncodeToken(J){switch(J.type){case Type.false:return fromArray([244]);case Type.true:return fromArray([245]);case Type.null:return fromArray([246]);case Type.bytes:return J.value.length?void 0:fromArray([64]);case Type.string:return J.value===""?fromArray([96]):void 0;case Type.array:return J.value===0?fromArray([128]):void 0;case Type.map:return J.value===0?fromArray([160]):void 0;case Type.uint:return J.value<24?fromArray([Number(J.value)]):void 0;case Type.negint:if(J.value>=-24)return fromArray([31-Number(J.value)])}}const defaultEncodeOptions={float64:!1,mapSorter,quickEncodeToken};function makeCborEncoders(){const J=[];return J[Type.uint.major]=encodeUint,J[Type.negint.major]=encodeNegint,J[Type.bytes.major]=encodeBytes,J[Type.string.major]=encodeString,J[Type.array.major]=encodeArray,J[Type.map.major]=encodeMap,J[Type.tag.major]=encodeTag,J[Type.float.major]=encodeFloat,J}const cborEncoders=makeCborEncoders(),buf=new Bl;class Ref{constructor(E,ee){this.obj=E,this.parent=ee}includes(E){let ee=this;do if(ee.obj===E)return!0;while(ee=ee.parent);return!1}static createCheck(E,ee){if(E&&E.includes(ee))throw new Error(`${encodeErrPrefix} object contains circular references`);return new Ref(ee,E)}}const simpleTokens={null:new Token(Type.null,null),undefined:new Token(Type.undefined,void 0),true:new Token(Type.true,!0),false:new Token(Type.false,!1),emptyArray:new Token(Type.array,0),emptyMap:new Token(Type.map,0)},typeEncoders={number(J,E,ee,te){return!Number.isInteger(J)||!Number.isSafeInteger(J)?new Token(Type.float,J):J>=0?new Token(Type.uint,J):new Token(Type.negint,J)},bigint(J,E,ee,te){return J>=BigInt(0)?new Token(Type.uint,J):new Token(Type.negint,J)},Uint8Array(J,E,ee,te){return new Token(Type.bytes,J)},string(J,E,ee,te){return new Token(Type.string,J)},boolean(J,E,ee,te){return J?simpleTokens.true:simpleTokens.false},null(J,E,ee,te){return simpleTokens.null},undefined(J,E,ee,te){return simpleTokens.undefined},ArrayBuffer(J,E,ee,te){return new Token(Type.bytes,new Uint8Array(J))},DataView(J,E,ee,te){return new Token(Type.bytes,new Uint8Array(J.buffer,J.byteOffset,J.byteLength))},Array(J,E,ee,te){if(!J.length)return ee.addBreakTokens===!0?[simpleTokens.emptyArray,new Token(Type.break)]:simpleTokens.emptyArray;te=Ref.createCheck(te,J);const re=[];let ne=0;for(const ie of J)re[ne++]=objectToTokens(ie,ee,te);return ee.addBreakTokens?[new Token(Type.array,J.length),re,new Token(Type.break)]:[new Token(Type.array,J.length),re]},Object(J,E,ee,te){const re=E!=="Object",ne=re?J.keys():Object.keys(J),ie=re?J.size:ne.length;if(!ie)return ee.addBreakTokens===!0?[simpleTokens.emptyMap,new Token(Type.break)]:simpleTokens.emptyMap;te=Ref.createCheck(te,J);const se=[];let oe=0;for(const ce of ne)se[oe++]=[objectToTokens(ce,ee,te),objectToTokens(re?J.get(ce):J[ce],ee,te)];return sortMapEntries(se,ee),ee.addBreakTokens?[new Token(Type.map,ie),se,new Token(Type.break)]:[new Token(Type.map,ie),se]}};typeEncoders.Map=typeEncoders.Object;typeEncoders.Buffer=typeEncoders.Uint8Array;for(const J of"Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" "))typeEncoders[`${J}Array`]=typeEncoders.DataView;function objectToTokens(J,E={},ee){const te=is(J),re=E&&E.typeEncoders&&E.typeEncoders[te]||typeEncoders[te];if(typeof re=="function"){const ie=re(J,te,E,ee);if(ie!=null)return ie}const ne=typeEncoders[te];if(!ne)throw new Error(`${encodeErrPrefix} unsupported type: ${te}`);return ne(J,te,E,ee)}function sortMapEntries(J,E){E.mapSorter&&J.sort(E.mapSorter)}function mapSorter(J,E){const ee=Array.isArray(J[0])?J[0][0]:J[0],te=Array.isArray(E[0])?E[0][0]:E[0];if(ee.type!==te.type)return ee.type.compare(te.type);const re=ee.type.major,ne=cborEncoders[re].compareTokens(ee,te);return ne===0&&console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone"),ne}function tokensToEncoded(J,E,ee,te){if(Array.isArray(E))for(const re of E)tokensToEncoded(J,re,ee,te);else ee[E.type.major](J,E,te)}function encodeCustom(J,E,ee){const te=objectToTokens(J,ee);if(!Array.isArray(te)&&ee.quickEncodeToken){const re=ee.quickEncodeToken(te);if(re)return re;const ne=E[te.type.major];if(ne.encodedSize){const ie=ne.encodedSize(te,ee),se=new Bl(ie);if(ne(se,te,ee),se.chunks.length!==1)throw new Error(`Unexpected error: pre-calculated length for ${te} was wrong`);return asU8A(se.chunks[0])}}return buf.reset(),tokensToEncoded(buf,te,E,ee),buf.toBytes(!0)}function encode$1(J,E){return E=Object.assign({},defaultEncodeOptions,E),encodeCustom(J,cborEncoders,E)}const defaultDecodeOptions={strict:!1,allowIndefinite:!0,allowUndefined:!0,allowBigInt:!0};class Tokeniser{constructor(E,ee={}){this.pos=0,this.data=E,this.options=ee}done(){return this.pos>=this.data.length}next(){const E=this.data[this.pos];let ee=quick[E];if(ee===void 0){const te=jump[E];if(!te)throw new Error(`${decodeErrPrefix} no decoder for major type ${E>>>5} (byte 0x${E.toString(16).padStart(2,"0")})`);const re=E&31;ee=te(this.data,this.pos,re,this.options)}return this.pos+=ee.encodedLength,ee}}const DONE=Symbol.for("DONE"),BREAK=Symbol.for("BREAK");function tokenToArray(J,E,ee){const te=[];for(let re=0;re<J.value;re++){const ne=tokensToObject(E,ee);if(ne===BREAK){if(J.value===1/0)break;throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`)}if(ne===DONE)throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${re}, expected ${J.value})`);te[re]=ne}return te}function tokenToMap(J,E,ee){const te=ee.useMaps===!0,re=te?void 0:{},ne=te?new Map:void 0;for(let ie=0;ie<J.value;ie++){const se=tokensToObject(E,ee);if(se===BREAK){if(J.value===1/0)break;throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`)}if(se===DONE)throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${ie} [no key], expected ${J.value})`);if(te!==!0&&typeof se!="string")throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof se})`);if(ee.rejectDuplicateMapKeys===!0&&(te&&ne.has(se)||!te&&se in re))throw new Error(`${decodeErrPrefix} found repeat map key "${se}"`);const oe=tokensToObject(E,ee);if(oe===DONE)throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${ie} [no value], expected ${J.value})`);te?ne.set(se,oe):re[se]=oe}return te?ne:re}function tokensToObject(J,E){if(J.done())return DONE;const ee=J.next();if(ee.type===Type.break)return BREAK;if(ee.type.terminal)return ee.value;if(ee.type===Type.array)return tokenToArray(ee,J,E);if(ee.type===Type.map)return tokenToMap(ee,J,E);if(ee.type===Type.tag){if(E.tags&&typeof E.tags[ee.value]=="function"){const te=tokensToObject(J,E);return E.tags[ee.value](te)}throw new Error(`${decodeErrPrefix} tag not supported (${ee.value})`)}throw new Error("unsupported")}function decode$3(J,E){if(!(J instanceof Uint8Array))throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);E=Object.assign({},defaultDecodeOptions,E);const ee=E.tokenizer||new Tokeniser(J,E),te=tokensToObject(ee,E);if(te===DONE)throw new Error(`${decodeErrPrefix} did not find any content to decode`);if(te===BREAK)throw new Error(`${decodeErrPrefix} got unexpected break`);if(!ee.done())throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);return te}const CID_CBOR_TAG=42;function cidDecoder(J){if(J[0]!==0)throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");return CID.decode(J.subarray(1))}const decodeOptions={allowIndefinite:!1,coerceUndefinedToNull:!0,allowNaN:!1,allowInfinity:!1,allowBigInt:!0,strict:!0,useMaps:!1,rejectDuplicateMapKeys:!0,tags:[]};decodeOptions.tags[CID_CBOR_TAG]=cidDecoder;const code=113,decode$2=J=>decode$3(J,decodeOptions),resolve$4=async(J,E,ee,te,re,ne,ie,se)=>{const oe=await ie.get(J,se),ce=decode$2(oe);let ae=ce,le=ee;for(;te.length>0;){const ue=te[0];if(ue in ae){te.shift(),le=`${le}/${ue}`;const he=CID.asCID(ae[ue]);if(he!=null)return{entry:{type:"object",name:E,path:ee,cid:J,node:oe,depth:ne,size:BigInt(oe.length),content:async function*(){yield ce}},next:{cid:he,name:ue,path:le,toResolve:te}};ae=ae[ue]}else throw errCode$1(new Error(`No property named ${ue} found in cbor node ${J}`),"ERR_NO_PROP")}return{entry:{type:"object",name:E,path:ee,cid:J,node:oe,depth:ne,size:BigInt(oe.length),content:async function*(){yield ce}}}};function extractDataFromBlock(J,E,ee,te){const re=BigInt(J.length),ne=BigInt(E+re);return ee>=ne||te<E?new Uint8Array(0):(te>=E&&te<ne&&(J=J.subarray(0,Number(te-E))),ee>=E&&ee<ne&&(J=J.subarray(Number(ee-E))),J)}const validateOffsetAndLength=(J,E=0,ee=J)=>{const te=BigInt(J),re=BigInt(E??0);let ne=BigInt(ee);if(ne!==te&&(ne=re+ne),ne>te&&(ne=te),re<0n)throw errCode$1(new Error("Offset must be greater than or equal to 0"),"ERR_INVALID_PARAMS");if(re>te)throw errCode$1(new Error("Offset must be less than the file size"),"ERR_INVALID_PARAMS");if(ne<0n)throw errCode$1(new Error("Length must be greater than or equal to 0"),"ERR_INVALID_PARAMS");if(ne>te)throw errCode$1(new Error("Length must be less than the file size"),"ERR_INVALID_PARAMS");return{start:re,end:ne}},rawContent$1=J=>{async function*E(ee={}){const{start:te,end:re}=validateOffsetAndLength(J.length,ee.offset,ee.length),ne=extractDataFromBlock(J,0n,te,re);ee.onProgress?.(new CustomProgressEvent("unixfs:exporter:progress:identity",{bytesRead:BigInt(ne.byteLength),totalBytes:re-te,fileSize:BigInt(J.byteLength)})),yield ne}return E},resolve$3=async(J,E,ee,te,re,ne,ie,se)=>{if(te.length>0)throw errCode$1(new Error(`No link named ${ee} found in raw node ${J}`),"ERR_NOT_FOUND");const oe=decode$f(J.multihash.bytes);return{entry:{type:"identity",name:E,path:ee,cid:J,content:rawContent$1(oe.digest),depth:ne,size:BigInt(oe.digest.length),node:oe.digest}}},rawContent=J=>{async function*E(ee={}){const{start:te,end:re}=validateOffsetAndLength(J.length,ee.offset,ee.length),ne=extractDataFromBlock(J,0n,te,re);ee.onProgress?.(new CustomProgressEvent("unixfs:exporter:progress:raw",{bytesRead:BigInt(ne.byteLength),totalBytes:re-te,fileSize:BigInt(J.byteLength)})),yield ne}return E},resolve$2=async(J,E,ee,te,re,ne,ie,se)=>{if(te.length>0)throw errCode$1(new Error(`No link named ${ee} found in raw node ${J}`),"ERR_NOT_FOUND");const oe=await ie.get(J,se);return{entry:{type:"raw",name:E,path:ee,cid:J,content:rawContent(oe),depth:ne,size:BigInt(oe.length),node:oe}}},hashFn=async function(J){return(await murmur3128.encode(J)).slice(0,8).reverse()},addLinksToHamtBucket=async(J,E,ee)=>{await Promise.all(J.map(async te=>{if(te.Name==null)throw new Error("Unexpected Link without a Name");if(te.Name.length===2){const re=parseInt(te.Name,16);E._putObjectAt(re,new Bucket({hash:ee._options.hash,bits:ee._options.bits},E,re));return}await ee.put(te.Name.substring(2),!0)}))},toPrefix$1=J=>J.toString(16).toUpperCase().padStart(2,"0").substring(0,2),toBucketPath=J=>{let E=J.bucket;const ee=[];for(;E._parent!=null;)ee.push(E),E=E._parent;return ee.push(E),ee.reverse()},findShardCid=async(J,E,ee,te,re)=>{if(te==null){const ae=createHAMT({hashFn});te={rootBucket:ae,hamtDepth:1,lastBucket:ae}}await addLinksToHamtBucket(J.Links,te.lastBucket,te.rootBucket);const ne=await te.rootBucket._findNewBucketAndPos(E);let ie=toPrefix$1(ne.pos);const se=toBucketPath(ne);se.length>te.hamtDepth&&(te.lastBucket=se[te.hamtDepth],ie=toPrefix$1(te.lastBucket._posAtParent));const oe=J.Links.find(ae=>{if(ae.Name==null)return!1;const le=ae.Name.substring(0,2),ue=ae.Name.substring(2);return!(le!==ie||ue!==""&&ue!==E)});if(oe==null)return;if(oe.Name!=null&&oe.Name.substring(2)===E)return oe.Hash;te.hamtDepth++;const ce=await ee.get(oe.Hash,re);return J=decode$4(ce),findShardCid(J,E,ee,te,re)},CustomEvent$1=globalThis.CustomEvent??Event;async function*parallel(J,E={}){let ee=E.concurrency??1/0;ee<1&&(ee=1/0);const te=E.ordered==null?!1:E.ordered,re=new EventTarget,ne=[];let ie=pDefer(),se=pDefer(),oe=!1,ce,ae=!1;re.addEventListener("task-complete",()=>{se.resolve()}),Promise.resolve().then(async()=>{try{for await(const pe of J){if(ne.length===ee&&(ie=pDefer(),await ie.promise),ae)break;const de={done:!1};ne.push(de),pe().then(fe=>{de.done=!0,de.ok=!0,de.value=fe,re.dispatchEvent(new CustomEvent$1("task-complete"))},fe=>{de.done=!0,de.err=fe,re.dispatchEvent(new CustomEvent$1("task-complete"))})}oe=!0,re.dispatchEvent(new CustomEvent$1("task-complete"))}catch(pe){ce=pe,re.dispatchEvent(new CustomEvent$1("task-complete"))}});function le(){return te?ne[0]?.done:!!ne.find(pe=>pe.done)}function*ue(){for(;ne.length>0&&ne[0].done;){const pe=ne[0];if(ne.shift(),pe.ok)yield pe.value;else throw ae=!0,ie.resolve(),pe.err;ie.resolve()}}function*he(){for(;le();)for(let pe=0;pe<ne.length;pe++)if(ne[pe].done){const de=ne[pe];if(ne.splice(pe,1),pe--,de.ok)yield de.value;else throw ae=!0,ie.resolve(),de.err;ie.resolve()}}for(;;){if(le()||(se=pDefer(),await se.promise),ce!=null)throw ce;if(te?yield*ue():yield*he(),oe&&ne.length===0)break}}const directoryContent=(J,E,ee,te,re,ne,ie)=>{async function*se(oe={}){const ce=oe.offset??0,ae=oe.length??E.Links.length,le=E.Links.slice(ce,ae);oe.onProgress?.(new CustomProgressEvent("unixfs:exporter:walk:directory",{cid:J})),yield*pipe$1(le,ue=>map$1(ue,he=>async()=>{const pe=he.Name??"",de=`${te}/${pe}`;return(await re(he.Hash,pe,de,[],ne+1,ie,oe)).entry}),ue=>parallel(ue,{ordered:!0}),ue=>filter(ue,he=>he!=null))}return se};async function walkDAG(J,E,ee,te,re,ne,ie){if(E instanceof Uint8Array){const ce=extractDataFromBlock(E,te,re,ne);ee.push(ce);return}if(E.Data==null)throw errCode$1(new Error("no data in PBNode"),"ERR_NOT_UNIXFS");let se;try{se=UnixFS.unmarshal(E.Data)}catch(ce){throw errCode$1(ce,"ERR_NOT_UNIXFS")}if(se.data!=null){const ce=se.data,ae=extractDataFromBlock(ce,te,re,ne);ee.push(ae),te+=BigInt(ae.byteLength)}const oe=[];if(E.Links.length!==se.blockSizes.length)throw errCode$1(new Error("Inconsistent block sizes and dag links"),"ERR_NOT_UNIXFS");for(let ce=0;ce<E.Links.length;ce++){const ae=E.Links[ce],le=te,ue=le+se.blockSizes[ce];if((re>=le&&re<ue||ne>=le&&ne<=ue||re<le&&ne>ue)&&oe.push({link:ae,blockStart:te}),te=ue,te>ne)break}await pipe$1(oe,ce=>map$1(ce,ae=>async()=>{const le=await J.get(ae.link.Hash,ie);return{...ae,block:le}}),ce=>parallel(ce,{ordered:!0}),async ce=>{for await(const{link:ae,block:le,blockStart:ue}of ce){let he;switch(ae.Hash.code){case code$1:he=decode$4(le);break;case code$2:he=le;break;default:ee.end(errCode$1(new Error(`Unsupported codec: ${ae.Hash.code}`),"ERR_NOT_UNIXFS"));return}const pe=new PQueue({concurrency:1});pe.on("error",de=>{ee.end(de)}),pe.add(async()=>{ie.onProgress?.(new CustomProgressEvent("unixfs:exporter:walk:file",{cid:ae.Hash})),await walkDAG(J,he,ee,ue,re,ne,ie)}),await pe.onIdle()}}),te>=ne&&ee.end()}const fileContent=(J,E,ee,te,re,ne,ie)=>{async function*se(oe={}){const ce=ee.fileSize();if(ce===void 0)throw new Error("File was a directory");const{start:ae,end:le}=validateOffsetAndLength(ce,oe.offset,oe.length);if(le===0n)return;let ue=0n;const he=le-ae,pe=pushable();oe.onProgress?.(new CustomProgressEvent("unixfs:exporter:walk:file",{cid:J})),walkDAG(ie,E,pe,0n,ae,le,oe).catch(de=>{pe.end(de)});for await(const de of pe)if(de!=null){if(ue+=BigInt(de.byteLength),ue>he)throw pe.end(),errCode$1(new Error("Read too many bytes - the file size reported by the UnixFS data in the root node may be incorrect"),"ERR_OVER_READ");ue===he&&pe.end(),oe.onProgress?.(new CustomProgressEvent("unixfs:exporter:progress:unixfs:file",{bytesRead:ue,totalBytes:he,fileSize:ce})),yield de}if(ue<he)throw errCode$1(new Error("Traversed entire DAG but did not read enough bytes"),"ERR_UNDER_READ")}return se},hamtShardedDirectoryContent=(J,E,ee,te,re,ne,ie)=>{function se(oe={}){return oe.onProgress?.(new CustomProgressEvent("unixfs:exporter:walk:hamt-sharded-directory",{cid:J})),listDirectory(E,te,re,ne,ie,oe)}return se};async function*listDirectory(J,E,ee,te,re,ne){const ie=J.Links,se=pipe$1(ie,oe=>map$1(oe,ce=>async()=>{const ae=ce.Name!=null?ce.Name.substring(2):null;if(ae!=null&&ae!==""){const le=await ee(ce.Hash,ae,`${E}/${ae}`,[],te+1,re,ne);return{entries:le.entry==null?[]:[le.entry]}}else{const le=await re.get(ce.Hash,ne);return J=decode$4(le),ne.onProgress?.(new CustomProgressEvent("unixfs:exporter:walk:hamt-sharded-directory",{cid:ce.Hash})),{entries:listDirectory(J,E,ee,te,re,ne)}}}),oe=>parallel(oe,{ordered:!0}));for await(const{entries:oe}of se)yield*oe}const findLinkCid=(J,E)=>J.Links.find(ee=>ee.Name===E)?.Hash,contentExporters={raw:fileContent,file:fileContent,directory:directoryContent,"hamt-sharded-directory":hamtShardedDirectoryContent,metadata:(J,E,ee,te,re,ne,ie)=>()=>[],symlink:(J,E,ee,te,re,ne,ie)=>()=>[]},unixFsResolver=async(J,E,ee,te,re,ne,ie,se)=>{const oe=await ie.get(J,se),ce=decode$4(oe);let ae,le;if(E==null&&(E=J.toString()),ce.Data==null)throw errCode$1(new Error("no data in PBNode"),"ERR_NOT_UNIXFS");try{ae=UnixFS.unmarshal(ce.Data)}catch(he){throw errCode$1(he,"ERR_NOT_UNIXFS")}if(ee==null&&(ee=E),te.length>0){let he;if(ae?.type==="hamt-sharded-directory"?he=await findShardCid(ce,te[0],ie):he=findLinkCid(ce,te[0]),he==null)throw errCode$1(new Error("file does not exist"),"ERR_NOT_FOUND");const pe=te.shift(),de=`${ee}/${pe}`;le={cid:he,toResolve:te,name:pe??"",path:de}}const ue=contentExporters[ae.type](J,ce,ae,ee,re,ne,ie);if(ue==null)throw errCode$1(new Error("could not find content exporter"),"ERR_NOT_FOUND");return ae.isDirectory()?{entry:{type:"directory",name:E,path:ee,cid:J,content:ue,unixfs:ae,depth:ne,node:ce,size:ae.fileSize()},next:le}:{entry:{type:"file",name:E,path:ee,cid:J,content:ue,unixfs:ae,depth:ne,node:ce,size:ae.fileSize()},next:le}},resolvers={[code$1]:unixFsResolver,[code$2]:resolve$2,[code]:resolve$4,[identity$2.code]:resolve$3},resolve$1=async(J,E,ee,te,re,ne,ie)=>{const se=resolvers[J.code];if(se==null)throw errCode$1(new Error(`No resolver for code ${J.code}`),"ERR_NO_RESOLVER");return se(J,E,ee,te,resolve$1,re,ne,ie)},toPathComponents=(J="")=>(J.trim().match(/([^\\^/]|\\\/)+/g)??[]).filter(Boolean),cidAndRest=J=>{if(J instanceof Uint8Array)return{cid:CID.decode(J),toResolve:[]};const E=CID.asCID(J);if(E!=null)return{cid:E,toResolve:[]};if(typeof J=="string"){J.indexOf("/ipfs/")===0&&(J=J.substring(6));const ee=toPathComponents(J);return{cid:CID.parse(ee[0]),toResolve:ee.slice(1)}}throw errCode$1(new Error(`Unknown path type ${J}`),"ERR_BAD_PATH")};async function*walkPath(J,E,ee={}){let{cid:te,toResolve:re}=cidAndRest(J),ne=te.toString(),ie=ne;const se=re.length;for(;;){const oe=await resolve$1(te,ne,ie,re,se,E,ee);if(oe.entry==null&&oe.next==null)throw errCode$1(new Error(`Could not resolve ${J}`),"ERR_NOT_FOUND");if(oe.entry!=null&&(yield oe.entry),oe.next==null)return;re=oe.next.toResolve,te=oe.next.cid,ne=oe.next.name,ie=oe.next.path}}async function exporter(J,E,ee={}){const te=await last(walkPath(J,E,ee));if(te==null)throw errCode$1(new Error(`Could not resolve ${J}`),"ERR_NOT_FOUND");return te}async function*recursive(J,E,ee={}){const te=await exporter(J,E,ee);if(te==null)return;if(yield te,te.type==="directory")for await(const ne of re(te,ee))yield ne;async function*re(ne,ie){for await(const se of ne.content(ie))yield se,!(se instanceof Uint8Array)&&se.type==="directory"&&(yield*re(se,ie))}}class UnixFSError extends Error{name;code;constructor(E,ee,te){super(E),this.name=ee,this.code=te}}class NotUnixFSError extends UnixFSError{constructor(E="not a Unixfs node"){super(E,"NotUnixFSError","ERR_NOT_UNIXFS")}}class InvalidPBNodeError extends UnixFSError{constructor(E="invalid PBNode"){super(E,"InvalidPBNodeError","ERR_INVALID_PBNODE")}}class UnknownError extends UnixFSError{constructor(E="unknown error"){super(E,"InvalidPBNodeError","ERR_UNKNOWN_ERROR")}}class AlreadyExistsError extends UnixFSError{constructor(E="path already exists"){super(E,"AlreadyExistsError","ERR_ALREADY_EXISTS")}}class DoesNotExistError extends UnixFSError{constructor(E="path does not exist"){super(E,"DoesNotExistError","ERR_DOES_NOT_EXIST")}}class NoContentError extends UnixFSError{constructor(E="no content"){super(E,"NoContentError","ERR_NO_CONTENT")}}class NotAFileError extends UnixFSError{constructor(E="not a file"){super(E,"NotAFileError","ERR_NOT_A_FILE")}}class NotADirectoryError extends UnixFSError{constructor(E="not a directory"){super(E,"NotADirectoryError","ERR_NOT_A_DIRECTORY")}}class InvalidParametersError extends UnixFSError{constructor(E="invalid parameters"){super(E,"InvalidParametersError","ERR_INVALID_PARAMETERS")}}function wrapHash(J){function E(ee){return ee instanceof InfiniteHash?ee:new InfiniteHash(ee,J)}return E}class InfiniteHash{_value;_hashFn;_depth;_availableBits;_currentBufferIndex;_buffers;constructor(E,ee){if(!(E instanceof Uint8Array))throw new Error("can only hash Uint8Arrays");this._value=E,this._hashFn=ee,this._depth=-1,this._availableBits=0,this._currentBufferIndex=0,this._buffers=[]}async take(E){let ee=E;for(;this._availableBits<ee;)await this._produceMoreBits();let te=0;for(;ee>0;){const re=this._buffers[this._currentBufferIndex],ne=Math.min(re.availableBits(),ee),ie=re.take(ne);te=(te<<ne)+ie,ee-=ne,this._availableBits-=ne,re.availableBits()===0&&this._currentBufferIndex++}return te}untake(E){let ee=E;for(;ee>0;){const te=this._buffers[this._currentBufferIndex],re=Math.min(te.totalBits()-te.availableBits(),ee);te.untake(re),ee-=re,this._availableBits+=re,this._currentBufferIndex>0&&te.totalBits()===te.availableBits()&&(this._depth--,this._currentBufferIndex--)}}async _produceMoreBits(){this._depth++;const E=this._depth>0?concat$4([this._value,Uint8Array.from([this._depth])]):this._value,ee=await this._hashFn(E),te=new ConsumableBuffer(ee);this._buffers.push(te),this._availableBits+=te.availableBits()}}const START_MASKS=[255,254,252,248,240,224,192,128],STOP_MASKS=[1,3,7,15,31,63,127,255];class ConsumableBuffer{_value;_currentBytePos;_currentBitPos;constructor(E){this._value=E,this._currentBytePos=E.length-1,this._currentBitPos=7}availableBits(){return this._currentBitPos+1+this._currentBytePos*8}totalBits(){return this._value.length*8}take(E){let ee=E,te=0;for(;ee>0&&this._haveBits();){const re=this._value[this._currentBytePos],ne=this._currentBitPos+1,ie=Math.min(ne,ee),se=byteBitsToInt(re,ne-ie,ie);te=(te<<ie)+se,ee-=ie,this._currentBitPos-=ie,this._currentBitPos<0&&(this._currentBitPos=7,this._currentBytePos--)}return te}untake(E){for(this._currentBitPos+=E;this._currentBitPos>7;)this._currentBitPos-=8,this._currentBytePos+=1}_haveBits(){return this._currentBytePos>=0}}function byteBitsToInt(J,E,ee){const te=maskFor(E,ee);return(J&te)>>>E}function maskFor(J,E){return START_MASKS[J]&STOP_MASKS[Math.min(E+J-1,7)]}const hamtHashCode=BigInt(murmur3128.code),hamtBucketBits=8;async function hamtHashFn(J){return(await murmur3128.encode(J)).subarray(0,8).reverse()}const persist=async(J,E,ee)=>{ee.codec==null&&(ee.codec=dagPB);const te=await sha256$3.digest(J),re=CID.create(ee.cidVersion,ee.codec.code,te);return await E.put(re,J,{...ee,signal:ee.signal}),re};class Dir{options;root;dir;path;dirty;flat;parent;parentKey;unixfs;mode;mtime;cid;size;nodeSize;constructor(E,ee){this.options=ee??{},this.root=E.root,this.dir=E.dir,this.path=E.path,this.dirty=E.dirty,this.flat=E.flat,this.parent=E.parent,this.parentKey=E.parentKey,this.unixfs=E.unixfs,this.mode=E.mode,this.mtime=E.mtime}}class DirSharded extends Dir{_bucket;constructor(E,ee){super(E,ee),this._bucket=createHAMT({hashFn:hamtHashFn,bits:8})}async put(E,ee){this.cid=void 0,this.size=void 0,this.nodeSize=void 0,await this._bucket.put(E,ee)}async get(E){return this._bucket.get(E)}childCount(){return this._bucket.leafCount()}directChildrenCount(){return this._bucket.childrenCount()}onlyChild(){return this._bucket.onlyChild()}async*eachChildSeries(){for await(const{key:E,value:ee}of this._bucket.eachLeafSeries())yield{key:E,child:ee}}estimateNodeSize(){return this.nodeSize!==void 0?this.nodeSize:(this.nodeSize=calculateSize(this._bucket,this,this.options),this.nodeSize)}async*flush(E){for await(const ee of flush(this._bucket,E,this,this.options))yield{...ee,path:this.path}}}async function*flush(J,E,ee,te){const re=J._children,ne=[];let ie=0n;for(let he=0;he<re.length;he++){const pe=re.get(he);if(pe==null)continue;const de=he.toString(16).toUpperCase().padStart(2,"0");if(pe instanceof Bucket){let fe;for await(const me of flush(pe,E,null,te))fe=me;if(fe==null)throw new Error("Could not flush sharded directory, no subshard found");ne.push({Name:de,Tsize:Number(fe.size),Hash:fe.cid}),ie+=fe.size}else if(isDir(pe.value)){const fe=pe.value;let me;for await(const be of fe.flush(E))me=be,yield me;if(me==null)throw new Error("Did not flush dir");const _e=de+pe.key;ne.push({Name:_e,Tsize:Number(me.size),Hash:me.cid}),ie+=me.size}else{const fe=pe.value;if(fe.cid==null)continue;const me=de+pe.key,_e=fe.size;ne.push({Name:me,Tsize:Number(_e),Hash:fe.cid}),ie+=BigInt(_e??0)}}const se=Uint8Array.from(re.bitField().reverse()),oe=new UnixFS({type:"hamt-sharded-directory",data:se,fanout:BigInt(J.tableSize()),hashType:hamtHashCode,mtime:ee?.mtime,mode:ee?.mode}),ce={Data:oe.marshal(),Links:ne},ae=encode$2(prepare(ce)),le=await persist(ae,E,te),ue=BigInt(ae.byteLength)+ie;yield{cid:le,unixfs:oe,size:ue}}function isDir(J){return typeof J.flush=="function"}function calculateSize(J,E,ee){const te=J._children,re=[];for(let se=0;se<te.length;se++){const oe=te.get(se);if(oe==null)continue;const ce=se.toString(16).toUpperCase().padStart(2,"0");if(oe instanceof Bucket){const ae=calculateSize(oe,null,ee);re.push({Name:ce,Tsize:Number(ae),Hash:ee.cidVersion===0?CID_V0:CID_V1})}else if(typeof oe.value.flush=="function"){const ae=oe.value.nodeSize();re.push({Name:ce+oe.key,Tsize:Number(ae),Hash:ee.cidVersion===0?CID_V0:CID_V1})}else{const ae=oe.value;if(ae.cid==null)continue;const le=ce+oe.key,ue=ae.size;re.push({Name:le,Tsize:Number(ue),Hash:ae.cid})}}const ne=Uint8Array.from(te.bitField().reverse()),ie=new UnixFS({type:"hamt-sharded-directory",data:ne,fanout:BigInt(J.tableSize()),hashType:hamtHashCode,mtime:E?.mtime,mode:E?.mode});return encode$2(prepare({Data:ie.marshal(),Links:re})).length}const CID_V0=CID.parse("QmUNLLsPACCz1vLxQVkXqqLX5R1X345qqfHbsf67hvA3Nn"),CID_V1=CID.parse("zdj7WbTaiJT1fgatdet9Ei9iDB5hdCxkbVyhyh8YTUnXMiwYi"),log$Q=logger$1("helia:unixfs:commands:utils:hamt-utils"),toPrefix=J=>J.toString(16).toUpperCase().padStart(2,"0").substring(0,2),createShard=async(J,E,ee)=>{const te=new DirSharded({root:!0,dir:!0,parent:void 0,parentKey:void 0,path:"",dirty:!0,flat:!1,mtime:ee.mtime,mode:ee.mode},ee);for(let ne=0;ne<E.length;ne++)await te._bucket.put(E[ne].name,{size:E[ne].size,cid:E[ne].cid});const re=await last(te.flush(J));if(re==null)throw new Error("Flushing shard yielded no result");return re},updateShardedDirectory=async(J,E,ee)=>{const te=UnixFS.unmarshal(J[0].node.Data??new Uint8Array(0)),re=BigInt(Math.pow(2,hamtBucketBits));J.reverse();let ne,ie;for(let se=0;se<J.length;se++){const oe=se===J.length-1,ce=J[se],ae=Uint8Array.from(ce.children.bitField().reverse()),le=new UnixFS({type:"hamt-sharded-directory",data:ae,fanout:re,hashType:hamtHashCode});oe&&(le.mtime=te.mtime,le.mode=te.mode),ie={Data:le.marshal(),Links:ce.node.Links};const ue=encode$2(prepare(ie));if(ne=await persist(ue,E,ee),!oe){const he=J[se+1];if(he==null)throw new Error("Was not operating on shard root but also had no parent?");log$Q("updating link in parent sub-shard with prefix %s",he.prefix),he.node.Links=he.node.Links.filter(pe=>pe.Name!==he.prefix),he.node.Links.push({Name:he.prefix,Hash:ne,Tsize:ce.node.Links.reduce((pe,de)=>pe+(de.Tsize??0),ue.byteLength)})}}if(ne==null||ie==null)throw new Error("Noting persisted");return{cid:ne,node:ie}},recreateShardedDirectory=async(J,E,ee,te)=>{const re=wrapHash(hamtHashFn)(fromString$5(E)),ne=[];for(;;){const ie=await ee.get(J,te),se=decode$4(ie),oe=new SparseArray,ce=await re.take(hamtBucketBits),ae=toPrefix(ce);ne.push({prefix:ae,children:oe,node:se});let le;for(const he of se.Links){const pe=he.Name??"";if(pe.length<2)throw new Error("Invalid HAMT - link name was too short");const de=parseInt(pe.substring(0,2),16);oe.set(de,!0),pe.startsWith(ae)&&(le=he)}if(le==null){log$Q("no link found with prefix %s for %s",ae,E);break}const ue=le.Name??"";if(ue.length<2)throw new Error("Invalid HAMT - link name was too short");if(ue.length===2){J=le.Hash,log$Q("descend into sub-shard with prefix %s",ue);continue}break}return{path:ne,hash:re}};async function isOverShardThreshold(J,E,ee,te){if(J.Data==null)throw new Error("DagPB node had no data");const re=UnixFS.unmarshal(J.Data);let ne;if(re.type==="directory")ne=estimateNodeSize(J);else if(re.type==="hamt-sharded-directory")ne=await estimateShardSize(J,0,ee,E,te);else throw new Error("Can only estimate the size of directories or shards");return ne>ee}function estimateNodeSize(J){let E=0;for(const ee of J.Links)E+=(ee.Name??"").length,E+=ee.Hash.version===1?CID_V1.bytes.byteLength:CID_V0.bytes.byteLength;return E}async function estimateShardSize(J,E,ee,te,re){if(E>ee)return ee;if(J.Data==null||!UnixFS.unmarshal(J.Data).isDirectory())return E;for(const ne of J.Links){let ie=ne.Name??"";if(ie=ie.substring(2),E+=ie.length,E+=ne.Hash.bytes.byteLength,ne.Hash.code===code$1){const se=await te.get(ne.Hash,re),oe=decode$4(se);E+=await estimateShardSize(oe,E,ee,te,re)}}return E}const log$P=logger$1("helia:unixfs:components:utils:add-link");async function addLink(J,E,ee,te){if(J.node.Data==null)throw new InvalidParametersError("Invalid parent passed to addLink");if(UnixFS.unmarshal(J.node.Data).type==="hamt-sharded-directory")return log$P("adding link to sharded directory"),addToShardedDirectory(J,E,ee,te);log$P(`adding ${E.Name} (${E.Hash}) to regular directory`);const re=await addToDirectory(J,E,ee,te);if(await isOverShardThreshold(re.node,ee,te.shardSplitThresholdBytes,te)){log$P("converting directory to sharded directory");const ne=await convertToShardedDirectory(re,ee);re.cid=ne.cid,re.node=decode$4(await ee.get(ne.cid,te))}return re}const convertToShardedDirectory=async(J,E)=>{if(J.node.Data==null)throw new InvalidParametersError("Invalid parent passed to convertToShardedDirectory");const ee=UnixFS.unmarshal(J.node.Data),te=await createShard(E,J.node.Links.map(re=>({name:re.Name??"",size:BigInt(re.Tsize??0),cid:re.Hash})),{mode:ee.mode,mtime:ee.mtime,cidVersion:J.cid.version});return log$P(`converted directory to sharded directory ${te.cid}`),te},addToDirectory=async(J,E,ee,te)=>{const re=J.node.Links.filter(ae=>{const le=ae.Name===E.Name;if(le&&!te.allowOverwriting)throw new AlreadyExistsError;return!le});if(re.push(E),J.node.Data==null)throw new InvalidPBNodeError("Parent node with no data passed to addToDirectory");const ne=UnixFS.unmarshal(J.node.Data);let ie;if(ne.mtime!=null){const ae=Date.now(),le=Math.floor(ae/1e3);ne.mtime={secs:BigInt(le),nsecs:(ae-le*1e3)*1e3},ie=ne.marshal()}else ie=J.node.Data;J.node=prepare({Data:ie,Links:re});const se=encode$2(J.node),oe=await sha256$3.digest(se),ce=CID.create(J.cid.version,code$1,oe);return await ee.put(ce,se),{node:J.node,cid:ce}},addToShardedDirectory=async(J,E,ee,te)=>{const{path:re,hash:ne}=await recreateShardedDirectory(J.cid,E.Name,ee,te),ie=re[re.length-1];if(ie==null)throw new Error("Invalid HAMT, could not generate path");const se=ie.prefix,oe=parseInt(se,16);log$P("next prefix for %s is %s",E.Name,se);const ce=`${se}${E.Name}`,ae=ie.node.Links.find(le=>(le.Name??"").startsWith(se));if(ae!=null)if(log$P("link %s was present in shard",ce),ae.Name===ce){if(!te.allowOverwriting)throw new AlreadyExistsError;log$P("overwriting %s in subshard",E.Name),ie.node.Links=ie.node.Links.filter(le=>le.Name!==ce),ie.node.Links.push({Name:ce,Hash:E.Hash,Tsize:E.Tsize})}else{if(ae.Name?.length===2)throw new Error("Existing link was subshard?!");{log$P("prefix %s already exists, creating new subshard",se);const le=ie.node.Links.findIndex(de=>de.Name?.startsWith(se)),ue=ie.node.Links.splice(le,1)[0],he=(ue.Name??"").substring(2),pe=wrapHash(hamtHashFn)(fromString$5(he));for(let de=0;de<re.length;de++)await pe.take(hamtBucketBits);for(;;){const de=await pe.take(hamtBucketBits),fe=toPrefix(de);ue.Name=`${fe}${he}`;const me=await ne.take(hamtBucketBits),_e=toPrefix(me);if(fe===_e){const Ee=new SparseArray;Ee.set(me,!0),re.push({prefix:_e,children:Ee,node:{Links:[]}});continue}const be=new SparseArray;be.set(me,!0),be.set(de,!0),re.push({prefix:se,children:be,node:{Links:[ue,{Name:`${_e}${E.Name}`,Hash:E.Hash,Tsize:E.Tsize}]}});break}}}else log$P("link %s was not present in sub-shard",ce),E.Name=ce,ie.node.Links.push(E),ie.children.set(oe,!0),log$P("adding %s to existing sub-shard",ce);return updateShardedDirectory(re,ee,te)};async function cidToDirectory(J,E,ee={}){const te=await exporter(J,E,ee);if(te.type!=="directory")throw new NotADirectoryError(`${J.toString()} was not a UnixFS directory`);return{cid:J,node:te.node}}async function cidToPBLink(J,E,ee,te){const re=await exporter(J,ee,te);if(re.type!=="directory"&&re.type!=="file"&&re.type!=="raw")throw new NotUnixFSError(`${J.toString()} was not a UnixFS node`);return{Name:E,Tsize:re.node instanceof Uint8Array?re.node.byteLength:dagNodeTsize(re.node),Hash:J}}function dagNodeTsize(J){const E=J.Links.reduce((ee,te)=>ee+(te.Tsize??0),0);return encode$2(J).byteLength+E}const log$O=logger$1("helia:unixfs:components:utils:resolve");async function resolve(J,E,ee,te){if(E==null||E==="")return{cid:J};log$O('resolve "%s" under %c',E,J);const re=E.split("/").filter(Boolean),ne=[{name:"",cid:J,size:0n}];for(let ie=0;ie<re.length;ie++){const se=re[ie],oe=await exporter(J,ee,te);if(log$O('resolving "%s"',se,oe),oe.type==="file"){if(ie<re.length-1)throw new InvalidParametersError("Path was invalid");J=oe.cid}else if(oe.type==="directory"){let ce;for await(const ae of oe.content())if(ae.name===se){ce=ae.cid;break}if(ce==null)throw new DoesNotExistError("Could not find path in directory");J=ce,ne.push({name:se,cid:J,size:oe.size})}else throw new InvalidParametersError("Could not resolve path")}return log$O("resolved %s to %c",E,J),{cid:J,path:E,segments:ne}}async function updatePathCids(J,E,ee,te){if(E.segments==null||E.segments.length===0)return J;let re=E.segments.pop();if(re==null)throw new Error("Insufficient segments");re.cid=J,E.segments.reverse();for(const ne of E.segments){const[ie,se]=await Promise.all([cidToDirectory(ne.cid,ee,te),cidToPBLink(re.cid,re.name,ee,te)]);J=(await addLink(ie,se,ee,{...te,allowOverwriting:!0,cidVersion:J.version})).cid,ne.cid=J,re=ne}return J}const mergeOptions$7=mergeOptions$9.bind({ignoreUndefined:!0}),defaultOptions$d={};async function*cat(J,E,ee={}){const te=mergeOptions$7(defaultOptions$d,ee),re=await resolve(J,te.path,E,te),ne=await exporter(re.cid,E,te);if(ne.type!=="file"&&ne.type!=="raw")throw new NotAFileError;if(ne.content==null)throw new NoContentError;yield*ne.content(te)}const SHARD_SPLIT_THRESHOLD_BYTES=262144,mergeOptions$6=mergeOptions$9.bind({ignoreUndefined:!0}),log$N=logger$1("helia:unixfs:chmod"),defaultOptions$c={recursive:!1,shardSplitThresholdBytes:SHARD_SPLIT_THRESHOLD_BYTES};async function chmod(J,E,ee,te={}){const re=mergeOptions$6(defaultOptions$c,te),ne=await resolve(J,re.path,ee,te);if(log$N("chmod %c %d",ne.cid,E),re.recursive){const ue=await pipe$1(async function*(){for await(const he of recursive(ne.cid,ee,te)){let pe,de=[];if(he.type==="raw")pe=new UnixFS({type:"file",data:he.node});else if(he.type==="file"||he.type==="directory")pe=he.unixfs,de=he.node.Links;else throw new NotUnixFSError;pe.mode=E;const fe={Data:pe.marshal(),Links:de};yield{path:he.path,content:fe}}},he=>importer(he,ee,{...re,dagBuilder:async function*(pe,de){for await(const fe of pe)yield async function(){const me=fe.content,_e=encode$2(me),be=await persist(_e,de,{...re,cidVersion:J.version});if(me.Data==null)throw new InvalidPBNodeError(`${be} had no data`);const Ee=UnixFS.unmarshal(me.Data);return{cid:be,size:BigInt(_e.length),path:fe.path,unixfs:Ee}}}}),async he=>last(he));if(ue==null)throw new UnknownError(`Could not chmod ${ne.cid.toString()}`);return updatePathCids(ue.cid,ne,ee,re)}const ie=await ee.get(ne.cid,te);let se,oe=[];if(ne.cid.code===code$2)se=new UnixFS({type:"file",data:ie});else{const ue=decode$4(ie);if(ue.Data==null)throw new InvalidPBNodeError(`${ne.cid.toString()} had no data`);oe=ue.Links,se=UnixFS.unmarshal(ue.Data)}se.mode=E;const ce=encode$2({Data:se.marshal(),Links:oe}),ae=await sha256$3.digest(ce),le=CID.create(ne.cid.version,code$1,ae);return await ee.put(le,ce),updatePathCids(le,ne,ee,re)}const mergeOptions$5=mergeOptions$9.bind({ignoreUndefined:!0}),log$M=logger$1("helia:unixfs:cp"),defaultOptions$b={force:!1,shardSplitThresholdBytes:SHARD_SPLIT_THRESHOLD_BYTES};async function cp(J,E,ee,te,re={}){const ne=mergeOptions$5(defaultOptions$b,re);if(ee.includes("/"))throw new InvalidParametersError("Name must not have slashes");const[ie,se]=await Promise.all([cidToDirectory(E,te,ne),cidToPBLink(J,ee,te,ne)]);return log$M('Adding %c as "%s" to %c',J,ee,E),(await addLink(ie,se,te,{allowOverwriting:ne.force,cidVersion:E.version,...ne})).cid}const mergeOptions$4=mergeOptions$9.bind({ignoreUndefined:!0}),defaultOptions$a={};async function*ls(J,E,ee={}){const te=mergeOptions$4(defaultOptions$a,ee),re=await resolve(J,te.path,E,te),ne=await exporter(re.cid,E);if(ne.type==="file"||ne.type==="raw"){yield ne;return}if(ne.content==null)throw new NoContentError;if(ne.type!=="directory")throw new NotADirectoryError;yield*ne.content({offset:ee.offset,length:ee.length})}const mergeOptions$3=mergeOptions$9.bind({ignoreUndefined:!0}),log$L=logger$1("helia:unixfs:mkdir"),defaultOptions$9={cidVersion:1,force:!1,shardSplitThresholdBytes:SHARD_SPLIT_THRESHOLD_BYTES};async function mkdir(J,E,ee,te={}){const re=mergeOptions$3(defaultOptions$9,te);if(E.includes("/"))throw new InvalidParametersError("Path must not have slashes");if((await exporter(J,ee,te)).type!=="directory")throw new NotADirectoryError(`${J.toString()} was not a UnixFS directory`);log$L("creating %s",E);const ne={Data:new UnixFS({type:"directory",mode:re.mode,mtime:re.mtime}).marshal(),Links:[]},ie=encode$2(ne),se=await sha256$3.digest(ie),oe=CID.create(re.cidVersion,code$1,se);await ee.put(oe,ie);const[ce,ae]=await Promise.all([cidToDirectory(J,ee,re),cidToPBLink(oe,E,ee,re)]);return log$L("adding empty dir called %s to %c",E,J),(await addLink(ce,ae,ee,{...re,allowOverwriting:re.force})).cid}const log$K=logger$1("helia:unixfs:utils:remove-link");async function removeLink(J,E,ee,te){if(J.node.Data==null)throw new InvalidPBNodeError("Parent node had no data");if(UnixFS.unmarshal(J.node.Data).type==="hamt-sharded-directory"){log$K(`removing ${E} from sharded directory`);const re=await removeFromShardedDirectory(J,E,ee,te);return await isOverShardThreshold(re.node,ee,te.shardSplitThresholdBytes,te)?re:(log$K("converting shard to flat directory %c",J.cid),convertToFlatDirectory(re,ee,te))}return log$K(`removing link ${E} regular directory`),removeFromDirectory(J,E,ee,te)}const removeFromDirectory=async(J,E,ee,te)=>{J.node.Links=J.node.Links.filter(ie=>ie.Name!==E);const re=encode$2(J.node),ne=await persist(re,ee,{...te,cidVersion:J.cid.version});return log$K(`Updated regular directory ${ne}`),{node:J.node,cid:ne}},removeFromShardedDirectory=async(J,E,ee,te)=>{const{path:re}=await recreateShardedDirectory(J.cid,E,ee,te),ne=re[re.length-1];if(ne==null)throw new Error("Invalid HAMT, could not generate path");const ie=ne.node.Links.filter(ce=>(ce.Name??"").substring(2)===E).map(ce=>ce.Name).pop();if(ie==null)throw new Error("File not found");const se=ie.substring(0,2),oe=parseInt(se,16);if(ne.node.Links=ne.node.Links.filter(ce=>ce.Name!==ie),ne.children.unset(oe),ne.node.Links.length===1)for(;re.length!==1;){const ce=re[re.length-1];if(ce==null||ce.node.Links.length>1)break;re.pop();const ae=re[re.length-1];if(ae==null)break;const le=ce.node.Links[0];ae.node.Links=ae.node.Links.filter(ue=>!(ue.Name??"").startsWith(ae.prefix)),ae.node.Links.push({Hash:le.Hash,Name:`${ae.prefix}${(le.Name??"").substring(2)}`,Tsize:le.Tsize})}return updateShardedDirectory(re,ee,te)},convertToFlatDirectory=async(J,E,ee)=>{if(J.node.Data==null)throw new InvalidParametersError("Invalid parent passed to convertToFlatDirectory");const te={Links:[]},re=await exporter(J.cid,E);if(re.type!=="directory")throw new Error("Unexpected node type");for await(const se of re.content()){let oe=0;se.node instanceof Uint8Array?oe=se.node.byteLength:oe=encode$2(se.node).length,te.Links.push({Hash:se.cid,Name:se.name,Tsize:oe})}const ne=UnixFS.unmarshal(J.node.Data);te.Data=new UnixFS({type:"directory",mode:ne.mode,mtime:ne.mtime}).marshal();const ie=encode$2(prepare(te));return{cid:await persist(ie,E,{codec:dagPB,cidVersion:J.cid.version,signal:ee.signal}),node:te}},mergeOptions$2=mergeOptions$9.bind({ignoreUndefined:!0}),log$J=logger$1("helia:unixfs:rm"),defaultOptions$8={shardSplitThresholdBytes:SHARD_SPLIT_THRESHOLD_BYTES};async function rm(J,E,ee,te={}){const re=mergeOptions$2(defaultOptions$8,te);if(E.includes("/"))throw new InvalidParametersError("Name must not have slashes");const ne=await cidToDirectory(J,ee,re);return log$J("Removing %s from %c",E,J),(await removeLink(ne,E,ee,{...re,cidVersion:J.version})).cid}const mergeOptions$1=mergeOptions$9.bind({ignoreUndefined:!0}),log$I=logger$1("helia:unixfs:stat"),defaultOptions$7={};async function stat(J,E,ee={}){const te=mergeOptions$1(defaultOptions$7,ee),re=await resolve(J,ee.path,E,te);log$I("stat %c",re.cid);const ne=await exporter(re.cid,E,te);if(ne.type!=="file"&&ne.type!=="directory"&&ne.type!=="raw")throw new NotUnixFSError;let ie=0n,se=0n,oe=0n,ce=0n,ae=0,le,ue;const he=ne.type;let pe;if(ne.type==="raw"&&(ie=BigInt(ne.node.byteLength),se=BigInt(ne.node.byteLength),oe=BigInt(ne.node.byteLength),ce=BigInt(ne.node.byteLength),ae=1),ne.type==="directory"&&(ie=0n,se=BigInt(ne.unixfs.marshal().byteLength),oe=0n,ce=se,ae=1,le=ne.unixfs.mode,ue=ne.unixfs.mtime,pe=ne.unixfs),ne.type==="file"){const de=await inspectDag(re.cid,E,te);ie=ne.unixfs.fileSize(),se=BigInt((ne.node.Data?.byteLength??0)+ne.node.Links.reduce((fe,me)=>fe+(me.Tsize??0),0)),oe=BigInt(de.localFileSize),ce=BigInt(de.localDagSize),ae=de.blocks,le=ne.unixfs.mode,ue=ne.unixfs.mtime,pe=ne.unixfs}return{cid:re.cid,mode:le,mtime:ue,fileSize:ie,dagSize:se,localFileSize:oe,localDagSize:ce,blocks:ae,type:he,unixfs:pe}}async function inspectDag(J,E,ee){const te={localFileSize:0,localDagSize:0,blocks:0};if(await E.has(J,ee)){const re=await E.get(J,ee);if(te.blocks++,te.localDagSize+=re.byteLength,J.code===code$2)te.localFileSize+=re.byteLength;else if(J.code===code$1){const ne=decode$4(re);if(ne.Links.length>0)for(const ie of ne.Links){const se=await inspectDag(ie.Hash,E,ee);te.localFileSize+=se.localFileSize,te.localDagSize+=se.localDagSize,te.blocks+=se.blocks}else{if(ne.Data==null)throw new InvalidPBNodeError(`PBNode ${J.toString()} had no data`);const ie=UnixFS.unmarshal(ne.Data);if(ie.data==null)throw new InvalidPBNodeError(`UnixFS node ${J.toString()} had no data`);te.localFileSize+=ie.data.byteLength??0}}else throw new UnknownError(`${J.toString()} was neither DAG_PB nor RAW`)}return te}const mergeOptions=mergeOptions$9.bind({ignoreUndefined:!0}),log$H=logger$1("helia:unixfs:touch"),defaultOptions$6={recursive:!1,shardSplitThresholdBytes:SHARD_SPLIT_THRESHOLD_BYTES};async function touch(J,E,ee={}){const te=mergeOptions(defaultOptions$6,ee),re=await resolve(J,te.path,E,te),ne=te.mtime??{secs:BigInt(Math.round(Date.now()/1e3)),nsecs:0};if(log$H("touch %c %o",re.cid,ne),te.recursive){const ue=await pipe$1(async function*(){for await(const he of recursive(re.cid,E)){let pe,de;if(he.type==="raw")pe=new UnixFS({data:he.node}),de=[];else if(he.type==="file"||he.type==="directory")pe=he.unixfs,de=he.node.Links;else throw new NotUnixFSError;pe.mtime=ne;const fe={Data:pe.marshal(),Links:de};yield{path:he.path,content:fe}}},he=>importer(he,E,{...te,dagBuilder:async function*(pe,de){for await(const fe of pe)yield async function(){const me=fe.content,_e=encode$2(me),be=await persist(_e,de,{...te,cidVersion:J.version});if(me.Data==null)throw new InvalidPBNodeError(`${be} had no data`);const Ee=UnixFS.unmarshal(me.Data);return{cid:be,size:BigInt(_e.length),path:fe.path,unixfs:Ee}}}}),async he=>last(he));if(ue==null)throw new UnknownError(`Could not chmod ${re.cid.toString()}`);return updatePathCids(ue.cid,re,E,te)}const ie=await E.get(re.cid,ee);let se,oe=[];if(re.cid.code===code$2)se=new UnixFS({data:ie});else{const ue=decode$4(ie);if(oe=ue.Links,ue.Data==null)throw new InvalidPBNodeError(`${re.cid.toString()} had no data`);se=UnixFS.unmarshal(ue.Data)}se.mtime=ne;const ce=encode$2({Data:se.marshal(),Links:oe}),ae=await sha256$3.digest(ce),le=CID.create(re.cid.version,code$1,ae);return await E.put(le,ce),updatePathCids(le,re,E,te)}class DefaultUnixFS{components;constructor(E){this.components=E}async*addAll(E,ee={}){yield*addAll(E,this.components.blockstore,ee)}async addBytes(E,ee={}){return addBytes(E,this.components.blockstore,ee)}async addByteStream(E,ee={}){return addByteStream(E,this.components.blockstore,ee)}async addFile(E,ee={}){return addFile(E,this.components.blockstore,ee)}async addDirectory(E={},ee={}){return addDirectory(E,this.components.blockstore,ee)}async*cat(E,ee={}){yield*cat(E,this.components.blockstore,ee)}async chmod(E,ee,te={}){return chmod(E,ee,this.components.blockstore,te)}async cp(E,ee,te,re={}){return cp(E,ee,te,this.components.blockstore,re)}async*ls(E,ee={}){yield*ls(E,this.components.blockstore,ee)}async mkdir(E,ee,te={}){return mkdir(E,ee,this.components.blockstore,te)}async rm(E,ee,te={}){return rm(E,ee,this.components.blockstore,te)}async stat(E,ee={}){return stat(E,this.components.blockstore,ee)}async touch(E,ee={}){return touch(E,this.components.blockstore,ee)}}function unixfs(J){return new DefaultUnixFS(J)}function notFoundError(J){return J=J??new Error("Not Found"),errCode$1(J,"ERR_NOT_FOUND")}class BaseBlockstore{has(E,ee){return Promise.reject(new Error(".has is not implemented"))}put(E,ee,te){return Promise.reject(new Error(".put is not implemented"))}async*putMany(E,ee){for await(const{cid:te,block:re}of E)await this.put(te,re,ee),yield te}get(E,ee){return Promise.reject(new Error(".get is not implemented"))}async*getMany(E,ee){for await(const te of E)yield{cid:te,block:await this.get(te,ee)}}async delete(E,ee){await Promise.reject(new Error(".delete is not implemented"))}async*deleteMany(E,ee){for await(const te of E)await this.delete(te,ee),yield te}async*getAll(E){throw new Error(".getAll is not implemented")}}class MemoryBlockstore extends BaseBlockstore{data;constructor(){super(),this.data=new Map}put(E,ee){return this.data.set(base32$2.encode(E.multihash.bytes),ee),E}get(E){const ee=this.data.get(base32$2.encode(E.multihash.bytes));if(ee==null)throw notFoundError();return ee}has(E){return this.data.has(base32$2.encode(E.multihash.bytes))}async delete(E){this.data.delete(base32$2.encode(E.multihash.bytes))}async*getAll(){for(const[E,ee]of this.data.entries())yield{cid:CID.createV1(code$2,decode$f(base32$2.decode(E))),block:ee}}}const SHARDING_FN="SHARDING";new Key(SHARDING_FN);logger$1("datastore:core:tiered");function isAsyncIterable$1(J){return J[Symbol.asyncIterator]!=null}function forEach(J,E){if(isAsyncIterable$1(J))return async function*(){for await(const ie of J)await E(ie),yield ie}();const ee=peekable(J),{value:te,done:re}=ee.next();if(re===!0)return function*(){}();if(typeof E(te)?.then=="function")return async function*(){yield te;for await(const ie of ee)await E(ie),yield ie}();const ne=E;return function*(){yield te;for(const ie of ee)ne(ie),yield ie}()}const varint=varint$2;var src=J=>{if(!(J instanceof Uint8Array))throw new Error("arg needs to be a Uint8Array");const E=[];for(;J.length>0;){const ee=varint.decode(J);E.push(ee),J=J.slice(varint.decode.bytes)}return E};const vd=getDefaultExportFromCjs(src);class WantListEntry{_refCounter;cid;priority;wantType;constructor(E,ee,te){this._refCounter=1,this.cid=E,this.priority=ee??1,this.wantType=te}inc(){this._refCounter+=1}dec(){this._refCounter=Math.max(0,this._refCounter-1)}hasRefs(){return this._refCounter>0}get[Symbol.toStringTag](){return`WantlistEntry <key: ${this.cid.toString(base58btc$1)}, priority: ${this.priority}, refs: ${this._refCounter}>`}equals(E){return this._refCounter===E._refCounter&&this.cid.equals(E.cid)&&this.priority===E.priority&&this.wantType===E.wantType}}class BitswapMessageEntry{entry;cancel;sendDontHave;constructor(E,ee,te,re,ne){this.entry=new WantListEntry(E,ee,te),this.cancel=!!re,this.sendDontHave=!!ne}get cid(){return this.entry.cid}set cid(E){this.entry.cid=E}get priority(){return this.entry.priority}set priority(E){this.entry.priority=E}get wantType(){return this.entry.wantType}set wantType(E){this.entry.wantType=E}get[Symbol.toStringTag](){return`BitswapMessageEntry ${this.cid.toString(base58btc$1)} <cancel: ${this.cancel}, priority: ${this.priority}>`}equals(E){return this.cancel===E.cancel&&this.sendDontHave===E.sendDontHave&&this.wantType===E.wantType&&this.entry.equals(E.entry)}}const logger=(J,E)=>{const ee=["bitswap"];return E!=null&&ee.push(E),J!=null&&ee.push(`${J.toString().slice(0,8)}`),logger$1(ee.join(":"))},isMapEqual=(J,E)=>{if(J.size!==E.size)return!1;for(const[ee,te]of J){const re=E.get(ee);if(re===void 0||te instanceof Uint8Array&&re instanceof Uint8Array&&!equals(te,re)||te instanceof BitswapMessageEntry&&re instanceof BitswapMessageEntry&&!te.equals(re))return!1}return!0};function varintEncoder(J){let E=new Uint8Array(J.reduce((te,re)=>te+varint$4.encodingLength(re),0)),ee=0;for(const te of J)E=varint$3.encode(te,E,ee),ee+=varint$4.encodingLength(te);return E}var Message$5;(function(J){(function(re){let ne;(function(oe){oe.Block="Block",oe.Have="Have"})(ne=re.WantType||(re.WantType={}));let ie;(function(oe){oe[oe.Block=0]="Block",oe[oe.Have=1]="Have"})(ie||(ie={})),function(oe){oe.codec=()=>enumeration(ie)}(ne=re.WantType||(re.WantType={})),function(oe){let ce;oe.codec=()=>(ce==null&&(ce=message((ae,le,ue={})=>{ue.lengthDelimited!==!1&&le.fork(),ae.block!=null&&ae.block.byteLength>0&&(le.uint32(10),le.bytes(ae.block)),ae.priority!=null&&ae.priority!==0&&(le.uint32(16),le.int32(ae.priority)),ae.cancel!=null&&ae.cancel!==!1&&(le.uint32(24),le.bool(ae.cancel)),ae.wantType!=null&&ie[ae.wantType]!==0&&(le.uint32(32),J.Wantlist.WantType.codec().encode(ae.wantType,le)),ae.sendDontHave!=null&&ae.sendDontHave!==!1&&(le.uint32(40),le.bool(ae.sendDontHave)),ue.lengthDelimited!==!1&&le.ldelim()},(ae,le)=>{const ue={block:new Uint8Array(0),priority:0,cancel:!1,wantType:ne.Block,sendDontHave:!1},he=le==null?ae.len:ae.pos+le;for(;ae.pos<he;){const pe=ae.uint32();switch(pe>>>3){case 1:ue.block=ae.bytes();break;case 2:ue.priority=ae.int32();break;case 3:ue.cancel=ae.bool();break;case 4:ue.wantType=J.Wantlist.WantType.codec().decode(ae);break;case 5:ue.sendDontHave=ae.bool();break;default:ae.skipType(pe&7);break}}return ue})),ce),oe.encode=ae=>encodeMessage(ae,oe.codec()),oe.decode=ae=>decodeMessage$1(ae,oe.codec())}(re.Entry||(re.Entry={}));let se;re.codec=()=>(se==null&&(se=message((oe,ce,ae={})=>{if(ae.lengthDelimited!==!1&&ce.fork(),oe.entries!=null)for(const le of oe.entries)ce.uint32(10),J.Wantlist.Entry.codec().encode(le,ce);oe.full!=null&&oe.full!==!1&&(ce.uint32(16),ce.bool(oe.full)),ae.lengthDelimited!==!1&&ce.ldelim()},(oe,ce)=>{const ae={entries:[],full:!1},le=ce==null?oe.len:oe.pos+ce;for(;oe.pos<le;){const ue=oe.uint32();switch(ue>>>3){case 1:ae.entries.push(J.Wantlist.Entry.codec().decode(oe,oe.uint32()));break;case 2:ae.full=oe.bool();break;default:oe.skipType(ue&7);break}}return ae})),se),re.encode=oe=>encodeMessage(oe,re.codec()),re.decode=oe=>decodeMessage$1(oe,re.codec())})(J.Wantlist||(J.Wantlist={})),function(re){let ne;re.codec=()=>(ne==null&&(ne=message((ie,se,oe={})=>{oe.lengthDelimited!==!1&&se.fork(),ie.prefix!=null&&ie.prefix.byteLength>0&&(se.uint32(10),se.bytes(ie.prefix)),ie.data!=null&&ie.data.byteLength>0&&(se.uint32(18),se.bytes(ie.data)),oe.lengthDelimited!==!1&&se.ldelim()},(ie,se)=>{const oe={prefix:new Uint8Array(0),data:new Uint8Array(0)},ce=se==null?ie.len:ie.pos+se;for(;ie.pos<ce;){const ae=ie.uint32();switch(ae>>>3){case 1:oe.prefix=ie.bytes();break;case 2:oe.data=ie.bytes();break;default:ie.skipType(ae&7);break}}return oe})),ne),re.encode=ie=>encodeMessage(ie,re.codec()),re.decode=ie=>decodeMessage$1(ie,re.codec())}(J.Block||(J.Block={}));let E;(function(re){re.Have="Have",re.DontHave="DontHave"})(E=J.BlockPresenceType||(J.BlockPresenceType={}));let ee;(function(re){re[re.Have=0]="Have",re[re.DontHave=1]="DontHave"})(ee||(ee={})),function(re){re.codec=()=>enumeration(ee)}(E=J.BlockPresenceType||(J.BlockPresenceType={})),function(re){let ne;re.codec=()=>(ne==null&&(ne=message((ie,se,oe={})=>{oe.lengthDelimited!==!1&&se.fork(),ie.cid!=null&&ie.cid.byteLength>0&&(se.uint32(10),se.bytes(ie.cid)),ie.type!=null&&ee[ie.type]!==0&&(se.uint32(16),J.BlockPresenceType.codec().encode(ie.type,se)),oe.lengthDelimited!==!1&&se.ldelim()},(ie,se)=>{const oe={cid:new Uint8Array(0),type:E.Have},ce=se==null?ie.len:ie.pos+se;for(;ie.pos<ce;){const ae=ie.uint32();switch(ae>>>3){case 1:oe.cid=ie.bytes();break;case 2:oe.type=J.BlockPresenceType.codec().decode(ie);break;default:ie.skipType(ae&7);break}}return oe})),ne),re.encode=ie=>encodeMessage(ie,re.codec()),re.decode=ie=>decodeMessage$1(ie,re.codec())}(J.BlockPresence||(J.BlockPresence={}));let te;J.codec=()=>(te==null&&(te=message((re,ne,ie={})=>{if(ie.lengthDelimited!==!1&&ne.fork(),re.wantlist!=null&&(ne.uint32(10),J.Wantlist.codec().encode(re.wantlist,ne)),re.blocks!=null)for(const se of re.blocks)ne.uint32(18),ne.bytes(se);if(re.payload!=null)for(const se of re.payload)ne.uint32(26),J.Block.codec().encode(se,ne);if(re.blockPresences!=null)for(const se of re.blockPresences)ne.uint32(34),J.BlockPresence.codec().encode(se,ne);re.pendingBytes!=null&&re.pendingBytes!==0&&(ne.uint32(40),ne.int32(re.pendingBytes)),ie.lengthDelimited!==!1&&ne.ldelim()},(re,ne)=>{const ie={blocks:[],payload:[],blockPresences:[],pendingBytes:0},se=ne==null?re.len:re.pos+ne;for(;re.pos<se;){const oe=re.uint32();switch(oe>>>3){case 1:ie.wantlist=J.Wantlist.codec().decode(re,re.uint32());break;case 2:ie.blocks.push(re.bytes());break;case 3:ie.payload.push(J.Block.codec().decode(re,re.uint32()));break;case 4:ie.blockPresences.push(J.BlockPresence.codec().decode(re,re.uint32()));break;case 5:ie.pendingBytes=re.int32();break;default:re.skipType(oe&7);break}}return ie})),te),J.encode=re=>encodeMessage(re,J.codec()),J.decode=re=>decodeMessage$1(re,J.codec())})(Message$5||(Message$5={}));class BitswapMessage{static Entry=BitswapMessageEntry;static WantType={Block:Message$5.Wantlist.WantType.Block,Have:Message$5.Wantlist.WantType.Have};static BlockPresenceType={Have:Message$5.BlockPresenceType.Have,DontHave:Message$5.BlockPresenceType.DontHave};static deserialize=async(E,ee)=>{const te=Message$5.decode(E),re=te.wantlist?.full===!0,ne=new BitswapMessage(re);return te.wantlist?.entries.forEach(ie=>{if(ie.block==null)return;const se=CID.decode(ie.block);ne.addEntry(se,ie.priority??0,ie.wantType,!!ie.cancel,!!ie.sendDontHave)}),te.blockPresences.forEach(ie=>{if(ie.cid==null)return;const se=CID.decode(ie.cid);ie.type===BitswapMessage.BlockPresenceType.Have?ne.addHave(se):ne.addDontHave(se)}),te.blocks.length>0?(await Promise.all(te.blocks.map(async ie=>{const se=await sha256$3.digest(ie),oe=CID.createV0(se);ne.addBlock(oe,ie)})),ne):(te.payload.length>0&&(await Promise.all(te.payload.map(async ie=>{if(ie.prefix==null||ie.data==null)return;const se=vd(ie.prefix),oe=se[0],ce=se[1],ae=se[2],le=ae===sha256$3.code?sha256$3:await ee?.getHasher(ae);if(le==null)throw new CodeError("Unknown hash algorithm","ERR_UNKNOWN_HASH_ALG");const ue=await le.digest(ie.data),he=CID.create(oe,ce,ue);ne.addBlock(he,ie.data)})),ne.setPendingBytes(te.pendingBytes)),ne)};static blockPresenceSize=E=>E.bytes.length+1;full;wantlist;blocks;blockPresences;pendingBytes;constructor(E){this.full=E,this.wantlist=new Map,this.blocks=new Map,this.blockPresences=new Map,this.pendingBytes=0}get empty(){return this.blocks.size===0&&this.wantlist.size===0&&this.blockPresences.size===0}addEntry(E,ee,te,re,ne){te==null&&(te=BitswapMessage.WantType.Block);const ie=E.toString(base58btc$1),se=this.wantlist.get(ie);se!=null?(se.wantType===te&&(se.priority=ee),re===!0&&(se.cancel=!!re),ne===!0&&(se.sendDontHave=!!ne),te===BitswapMessage.WantType.Block&&se.wantType===BitswapMessage.WantType.Have&&(se.wantType=te)):this.wantlist.set(ie,new BitswapMessageEntry(E,ee,te,re,ne))}addBlock(E,ee){const te=E.toString(base58btc$1);this.blocks.set(te,ee)}addHave(E){const ee=E.toString(base58btc$1);this.blockPresences.has(ee)||this.blockPresences.set(ee,BitswapMessage.BlockPresenceType.Have)}addDontHave(E){const ee=E.toString(base58btc$1);this.blockPresences.has(ee)||this.blockPresences.set(ee,BitswapMessage.BlockPresenceType.DontHave)}cancel(E){const ee=E.toString(base58btc$1);this.wantlist.delete(ee),this.addEntry(E,0,BitswapMessage.WantType.Block,!0,!1)}setPendingBytes(E){this.pendingBytes=E}serializeToBitswap100(){return Message$5.encode({wantlist:{entries:Array.from(this.wantlist.values()).map(E=>({block:E.cid.bytes,priority:Number(E.priority),cancel:!!E.cancel,wantType:Message$5.Wantlist.WantType.Block,sendDontHave:!1})),full:!!this.full},blocks:Array.from(this.blocks.values())})}serializeToBitswap110(){const E={wantlist:{entries:Array.from(this.wantlist.values()).map(ee=>({block:ee.cid.bytes,priority:Number(ee.priority),wantType:ee.wantType,cancel:!!ee.cancel,sendDontHave:!!ee.sendDontHave})),full:!!this.full},blockPresences:[],payload:[],pendingBytes:this.pendingBytes,blocks:[]};for(const[ee,te]of this.blocks.entries()){const re=CID.parse(ee),ne=re.version,ie=re.code,se=re.multihash.code,oe=re.multihash.digest.length,ce=varintEncoder([ne,ie,se,oe]);E.payload.push({prefix:ce,data:te})}for(const[ee,te]of this.blockPresences)E.blockPresences.push({cid:CID.parse(ee).bytes,type:te});return this.pendingBytes>0&&(E.pendingBytes=this.pendingBytes),Message$5.encode(E)}equals(E){return!(this.full!==E.full||this.pendingBytes!==E.pendingBytes||!isMapEqual(this.wantlist,E.wantlist)||!isMapEqual(this.blocks,E.blocks)||!isMapEqual(this.blockPresences,E.blockPresences))}get[Symbol.toStringTag](){const E=Array.from(this.wantlist.keys()),ee=Array.from(this.blocks.keys());return`BitswapMessage <full: ${this.full}, list: ${E}, blocks: ${ee}>`}}const WantType$1={Block:Message$5.Wantlist.WantType.Block,Have:Message$5.Wantlist.WantType.Have},sortBy=(J,E)=>Array.prototype.slice.call(E,0).sort((ee,te)=>{const re=J(ee),ne=J(te);return re<ne?-1:re>ne?1:0});class Wantlist{static Entry=WantListEntry;set;_stats;constructor(E,ee){this.set=ee!=null?trackedMap({name:"ipfs_bitswap_wantlist",metrics:ee.metrics}):new Map,this._stats=E}get length(){return this.set.size}add(E,ee,te){const re=E.toString(base58btc$1),ne=this.set.get(re);ne!=null?(ne.inc(),ne.priority=ee,ne.wantType===WantType$1.Have&&te===WantType$1.Block&&(ne.wantType=te)):(this.set.set(re,new WantListEntry(E,ee,te)),this._stats!=null&&this._stats.push(void 0,"wantListSize",1))}remove(E){const ee=E.toString(base58btc$1),te=this.set.get(ee);te!=null&&(te.dec(),!te.hasRefs()&&(this.set.delete(ee),this._stats!=null&&this._stats.push(void 0,"wantListSize",-1)))}removeForce(E){this.set.has(E)&&this.set.delete(E)}forEach(E){this.set.forEach(E)}entries(){return this.set.entries()}sortedEntries(){return new Map(sortBy(E=>E[1].key,Array.from(this.set.entries())))}contains(E){const ee=E.toString(base58btc$1);return this.set.has(ee)}get(E){const ee=E.toString(base58btc$1);return this.set.get(ee)}}class Ledger{partner;wantlist;exchangeCount;accounting;lastExchange;constructor(E){this.partner=E,this.wantlist=new Wantlist,this.exchangeCount=0,this.accounting={bytesSent:0,bytesRecv:0}}sentBytes(E){this.exchangeCount++,this.lastExchange=new Date().getTime(),this.accounting.bytesSent+=E}receivedBytes(E){this.exchangeCount++,this.lastExchange=new Date().getTime(),this.accounting.bytesRecv+=E}wants(E,ee,te){this.wantlist.add(E,ee,te)}cancelWant(E){this.wantlist.remove(E)}wantlistContains(E){return this.wantlist.get(E)}debtRatio(){return this.accounting.bytesSent/(this.accounting.bytesRecv+1)}}class SortedMap extends Map{_cmp;_keys;constructor(E,ee){super(),this._cmp=ee??this._defaultSort,this._keys=[];for(const[te,re]of E??[])this.set(te,re)}update(E){if(E<0||E>=this._keys.length)return;const ee=this._keys[E];this._keys.splice(E,1);const te=this._find(ee);this._keys.splice(te,0,ee)}set(E,ee){if(this.has(E)){const re=this.indexOf(E);this._keys.splice(re,1)}super.set(E,ee);const te=this._find(E);return this._keys.splice(te,0,E),this}clear(){super.clear(),this._keys=[]}delete(E){if(!this.has(E))return!1;const ee=this.indexOf(E);return this._keys.splice(ee,1),super.delete(E)}indexOf(E){if(!this.has(E))return-1;const ee=this._find(E);if(this._keys[ee]===E)return ee;for(let te=1;te<this._keys.length;te++){if(this._keys[ee+te]===E)return ee+te;if(this._keys[ee-te]===E)return ee-te}return-1}_find(E){let ee=0,te=this._keys.length;for(;ee<te;){const re=ee+te>>>1,ne=this._kCmp(this._keys[re],E);if(ne<0)ee=re+1;else if(ne>0)te=re;else return re}return ee}*keys(){for(const E of this._keys)yield E}*values(){for(const E of this._keys)yield this.get(E)}*entries(){for(const E of this._keys)yield[E,this.get(E)]}*[Symbol.iterator](){yield*this.entries()}forEach(E,ee=this){if(E!=null)for(const te of this._keys){const re=this.get(te);if(re==null)throw new Error("Value cannot be undefined");E.apply(ee,[[te,re]])}}_defaultSort(E,ee){return E[0]<ee[0]?-1:ee[0]<E[0]?1:0}_kCmp(E,ee){return this._cmp([E,this.get(E)],[ee,this.get(ee)])}}const DefaultTaskMerger$1={hasNewInfo(){return!1},merge(){}};class RequestQueue{_taskMerger;_byPeer;constructor(E=DefaultTaskMerger$1){this._taskMerger=E,this._byPeer=new SortedMap([],PeerTasks.compare)}pushTasks(E,ee){let te=this._byPeer.get(E.toString());te==null&&(te=new PeerTasks(E,this._taskMerger)),te.pushTasks(ee),this._byPeer.set(E.toString(),te)}popTasks(E){const ee=this._head();if(ee===void 0)return{tasks:[],pendingSize:0};const{tasks:te,pendingSize:re}=ee.popTasks(E);if(te.length===0)return{tasks:te,pendingSize:re};const ne=ee.peerId;return ee.isIdle()?this._byPeer.delete(ne.toString()):this._byPeer.update(0),{peerId:ne,tasks:te,pendingSize:re}}_head(){if(this._byPeer.size!==0)for(const[,E]of this._byPeer)return E}remove(E,ee){this._byPeer.get(ee.toString())?.remove(E)}tasksDone(E,ee){const te=this._byPeer.get(E.toString());if(te==null)return;const re=this._byPeer.indexOf(E.toString());for(const ne of ee)te.taskDone(ne);this._byPeer.update(re)}}class PeerTasks{peerId;_taskMerger;_activeTotalSize;_pending;_active;constructor(E,ee){this.peerId=E,this._taskMerger=ee,this._activeTotalSize=0,this._pending=new PendingTasks,this._active=new Set}pushTasks(E){for(const ee of E)this._pushTask(ee)}_pushTask(E){if(!this._taskHasMoreInfoThanActiveTasks(E))return;const ee=this._pending.get(E.topic);if(ee!=null){E.priority>ee.priority&&this._pending.updatePriority(E.topic,E.priority),this._taskMerger.merge(E,ee);return}this._pending.add(E)}_taskHasMoreInfoThanActiveTasks(E){const ee=[];for(const te of this._active)te.topic===E.topic&&ee.push(te);return ee.length===0?!0:this._taskMerger.hasNewInfo(E,ee)}popTasks(E){let ee=0;const te=[],re=this._pending.tasks();for(let ne=0;ne<re.length&&ee<E;ne++){const ie=re[ne];te.push(ie),ee+=ie.size,this._pending.delete(ie.topic),this._activeTotalSize+=ie.size,this._active.add(ie)}return{tasks:te,pendingSize:this._pending.totalSize}}taskDone(E){this._active.has(E)&&(this._activeTotalSize-=E.size,this._active.delete(E))}remove(E){this._pending.delete(E)}isIdle(){return this._pending.length===0&&this._active.size===0}static compare(E,ee){return E[1]._pending.length===0?1:ee[1]._pending.length===0?-1:E[1]._activeTotalSize===ee[1]._activeTotalSize?ee[1]._pending.length-E[1]._pending.length:E[1]._activeTotalSize-ee[1]._activeTotalSize}}class PendingTasks{_tasks;constructor(){this._tasks=new SortedMap([],this._compare)}get length(){return this._tasks.size}get totalSize(){return[...this._tasks.values()].reduce((E,ee)=>E+ee.task.size,0)}get(E){return this._tasks?.get(E)?.task}add(E){this._tasks.set(E.topic,{created:Date.now(),task:E})}delete(E){this._tasks.delete(E)}tasks(){return[...this._tasks.values()].map(E=>E.task)}updatePriority(E,ee){const te=this._tasks.get(E);if(te==null)return;const re=this._tasks.indexOf(E);te.task.priority=ee,this._tasks.update(re)}_compare(E,ee){return E[1].task.priority===ee[1].task.priority?E[1].created-ee[1].created:ee[1].task.priority-E[1].task.priority}}const DefaultTaskMerger={hasNewInfo(J,E){let ee=!1,te=!1;for(const re of E)re.data.haveBlock&&(ee=!0),re.data.isWantBlock&&(te=!0);return!!(!te&&J.data.isWantBlock||!ee&&J.data.haveBlock)},merge(J,E){const ee=J.data,te=E.data;!te.haveBlock&&ee.haveBlock&&(te.haveBlock=ee.haveBlock,te.blockSize=ee.blockSize),!te.isWantBlock&&ee.isWantBlock&&(te.isWantBlock=!0,(!te.haveBlock||ee.haveBlock)&&(te.haveBlock=ee.haveBlock,E.size=J.size)),te.isWantBlock&&te.haveBlock&&(E.size=te.blockSize)}},WantType=BitswapMessage.WantType,TARGET_MESSAGE_SIZE=16*1024,MAX_SIZE_REPLACE_HAS_WITH_BLOCK=1024;class DecisionEngine{_log;blockstore;network;_stats;_opts;ledgerMap;_running;_requestQueue;constructor(E,ee,te,re,ne,ie={}){this._log=logger(E,"engine"),this.blockstore=ee,this.network=te,this._stats=re,this._opts=this._processOpts(ie),this.ledgerMap=trackedMap({name:"ipfs_bitswap_ledger_map",metrics:ne.metrics}),this._running=!1,this._requestQueue=new RequestQueue(DefaultTaskMerger)}_processOpts(E){return{maxSizeReplaceHasWithBlock:MAX_SIZE_REPLACE_HAS_WITH_BLOCK,targetMessageSize:TARGET_MESSAGE_SIZE,...E}}_scheduleProcessTasks(){setTimeout(()=>{this._processTasks().catch(E=>{this._log.error("error processing stats",E)})})}async _processTasks(){if(!this._running)return;const{peerId:E,tasks:ee,pendingSize:te}=this._requestQueue.popTasks(this._opts.targetMessageSize);if(ee.length===0)return;const re=new BitswapMessage(!1);re.setPendingBytes(te);const ne=[],ie=new Map;for(const oe of ee){const ce=CID.parse(oe.topic);oe.data.haveBlock?oe.data.isWantBlock?(ne.push(ce),ie.set(oe.topic,oe.data)):re.addHave(ce):re.addDontHave(ce)}const se=await this._getBlocks(ne);for(const[oe,ce]of ie){const ae=CID.parse(oe),le=se.get(oe);le!=null?re.addBlock(ae,le):ce.sendDontHave&&re.addDontHave(ae)}if(re.empty){E!=null&&this._requestQueue.tasksDone(E,ee),this._scheduleProcessTasks();return}try{E!=null&&await this.network.sendMessage(E,re);for(const[oe,ce]of se.entries())E!=null&&this.messageSent(E,CID.parse(oe),ce)}catch(oe){this._log.error(oe)}E!=null&&this._requestQueue.tasksDone(E,ee),this._scheduleProcessTasks()}wantlistForPeer(E){const ee=E.toString(),te=this.ledgerMap.get(ee);return te!=null?te.wantlist.sortedEntries():new Map}ledgerForPeer(E){const ee=E.toString(),te=this.ledgerMap.get(ee);if(te!=null)return{peer:te.partner,value:te.debtRatio(),sent:te.accounting.bytesSent,recv:te.accounting.bytesRecv,exchanged:te.exchangeCount}}peers(){return Array.from(this.ledgerMap.values()).map(E=>E.partner)}receivedBlocks(E){if(E.length!==0){for(const ee of this.ledgerMap.values())for(const{cid:te,block:re}of E){const ne=ee.wantlistContains(te);if(ne==null)continue;const ie=re.length,se=this._sendAsBlock(ne.wantType,ie);let oe=ie;se||(oe=BitswapMessage.blockPresenceSize(ne.cid)),this._requestQueue.pushTasks(ee.partner,[{topic:ne.cid.toString(base58btc$1),priority:ne.priority,size:oe,data:{blockSize:ie,isWantBlock:se,haveBlock:!0,sendDontHave:!1}}])}this._scheduleProcessTasks()}}async messageReceived(E,ee){const te=this._findOrCreate(E);if(ee.empty)return;if(ee.full&&(te.wantlist=new Wantlist),this._updateBlockAccounting(ee.blocks,te),ee.wantlist.size===0){this._scheduleProcessTasks();return}const re=[],ne=[];ee.wantlist.forEach(ie=>{ie.cancel?(te.cancelWant(ie.cid),re.push(ie.cid)):(te.wants(ie.cid,ie.priority,ie.wantType),ne.push(ie))}),this._cancelWants(E,re),await this._addWants(E,ne),this._scheduleProcessTasks()}_cancelWants(E,ee){for(const te of ee)this._requestQueue.remove(te.toString(base58btc$1),E)}async _addWants(E,ee){const te=await this._getBlockSizes(ee.map(ne=>ne.cid)),re=[];for(const ne of ee){const ie=ne.cid.toString(base58btc$1),se=te.get(ie);if(se==null)ne.sendDontHave&&re.push({topic:ie,priority:ne.priority,size:BitswapMessage.blockPresenceSize(ne.cid),data:{isWantBlock:ne.wantType===WantType.Block,blockSize:0,haveBlock:!1,sendDontHave:ne.sendDontHave}});else{const oe=this._sendAsBlock(ne.wantType,se);let ce=se;oe||(ce=BitswapMessage.blockPresenceSize(ne.cid)),re.push({topic:ie,priority:ne.priority,size:ce,data:{isWantBlock:oe,blockSize:se,haveBlock:!0,sendDontHave:ne.sendDontHave}})}this._requestQueue.pushTasks(E,re)}}_sendAsBlock(E,ee){return E===WantType.Block||ee<=this._opts.maxSizeReplaceHasWithBlock}async _getBlockSizes(E){const ee=await this._getBlocks(E);return new Map([...ee].map(([te,re])=>[te,re.length]))}async _getBlocks(E){const ee=new Map;return await Promise.all(E.map(async te=>{try{const re=await this.blockstore.get(te);ee.set(te.toString(base58btc$1),re)}catch(re){re.code!=="ERR_NOT_FOUND"&&this._log.error("failed to query blockstore for %s: %s",te,re)}})),ee}_updateBlockAccounting(E,ee){for(const te of E.values())this._log("got block (%s bytes)",te.length),ee.receivedBytes(te.length)}messageSent(E,ee,te){const re=this._findOrCreate(E);re.sentBytes(te.length),re.wantlist.remove(ee)}numBytesSentTo(E){return this._findOrCreate(E).accounting.bytesSent}numBytesReceivedFrom(E){return this._findOrCreate(E).accounting.bytesRecv}peerDisconnected(E){this.ledgerMap.delete(E.toString())}_findOrCreate(E){const ee=E.toString(),te=this.ledgerMap.get(ee);if(te!=null)return te;const re=new Ledger(E);return this.ledgerMap.set(ee,re),this._stats!=null&&this._stats.push(ee,"peerCount",1),re}start(){this._running=!0}stop(){this._running=!1}}var timeBrowser=function J(){return Date.now()};const getTime=timeBrowser;class Retimer{constructor(E,ee,te){const re=this;this._started=getTime(),this._rescheduled=0,this._scheduled=ee,this._args=te,this._triggered=!1,this._timerWrapper=()=>{re._rescheduled>0?(re._scheduled=re._rescheduled-(getTime()-re._started),re._schedule(re._scheduled)):(re._triggered=!0,E.apply(null,re._args))},this._timer=setTimeout(this._timerWrapper,ee)}reschedule(E){E||(E=this._scheduled);const ee=getTime();ee+E-(this._started+this._scheduled)<0?(clearTimeout(this._timer),this._schedule(E)):this._triggered?this._schedule(E):(this._started=ee,this._rescheduled=E)}_schedule(E){this._triggered=!1,this._started=getTime(),this._rescheduled=0,this._scheduled=E,this._timer=setTimeout(this._timerWrapper,E)}clear(){clearTimeout(this._timer)}}function retimer$1(){if(typeof arguments[0]!="function")throw new Error("callback needed");if(typeof arguments[1]!="number")throw new Error("timeout needed");let J;if(arguments.length>0){J=new Array(arguments.length-2);for(var E=0;E<J.length;E++)J[E]=arguments[E+2]}return new Retimer(arguments[0],arguments[1],J)}var retimer_1=retimer$1;const{AbortController:AbortController$1}=globalThis,retimer=retimer_1;class TimeoutController extends AbortController$1{constructor(E){super(),this._ms=E,this._timer=retimer(()=>this.abort(),E),Object.setPrototypeOf(this,TimeoutController.prototype)}abort(){return this._timer.clear(),super.abort()}clear(){this._timer.clear()}reset(){this._timer.clear(),this._timer=retimer(()=>this.abort(),this._ms)}}var timeoutAbortController={TimeoutController};const maxProvidersPerRequest=3,kMaxPriority=Math.pow(2,31)-1,maxListeners=1e3,wantlistSendDebounceMs=1,BITSWAP100="/ipfs/bitswap/1.0.0",BITSWAP110="/ipfs/bitswap/1.1.0",BITSWAP120="/ipfs/bitswap/1.2.0",DEFAULT_MAX_INBOUND_STREAMS$2=1024,DEFAULT_MAX_OUTBOUND_STREAMS$2=1024,DEFAULT_INCOMING_STREAM_TIMEOUT=3e4;let Network$1=class{_log;_libp2p;_bitswap;_protocols;_stats;_running;_hashLoader;_maxInboundStreams;_maxOutboundStreams;_incomingStreamTimeout;_registrarIds;constructor(J,E,ee,te={}){this._log=logger(J.peerId,"network"),this._libp2p=J,this._bitswap=E,this._protocols=[BITSWAP100],te.b100Only!==!0&&(this._protocols.unshift(BITSWAP110),this._protocols.unshift(BITSWAP120)),this._stats=ee,this._running=!1,this._onPeerConnect=this._onPeerConnect.bind(this),this._onPeerDisconnect=this._onPeerDisconnect.bind(this),this._onConnection=this._onConnection.bind(this),this._hashLoader=te.hashLoader??{async getHasher(){throw new Error("Not implemented")}},this._maxInboundStreams=te.maxInboundStreams??DEFAULT_MAX_INBOUND_STREAMS$2,this._maxOutboundStreams=te.maxOutboundStreams??DEFAULT_MAX_OUTBOUND_STREAMS$2,this._incomingStreamTimeout=te.incomingStreamTimeout??DEFAULT_INCOMING_STREAM_TIMEOUT}async start(){this._running=!0,await this._libp2p.handle(this._protocols,this._onConnection,{maxInboundStreams:this._maxInboundStreams,maxOutboundStreams:this._maxOutboundStreams});const J=createTopology({onConnect:this._onPeerConnect,onDisconnect:this._onPeerDisconnect});this._registrarIds=[];for(const E of this._protocols)this._registrarIds.push(await this._libp2p.register(E,J));this._libp2p.getConnections().forEach(E=>{this._onPeerConnect(E.remotePeer)})}async stop(){if(this._running=!1,await this._libp2p.unhandle(this._protocols),this._registrarIds!=null){for(const J of this._registrarIds)this._libp2p.unregister(J);this._registrarIds=[]}}_onConnection(J){if(!this._running)return;const{stream:E,connection:ee}=J,te=new timeoutAbortController.TimeoutController(this._incomingStreamTimeout);Promise.resolve().then(async()=>{this._log("incoming new bitswap %s connection from %p",E.stat.protocol,ee.remotePeer),await pipe$1(abortableSource$1(E.source,te.signal),re=>decode$b(re),async re=>{for await(const ne of re){try{const ie=await BitswapMessage.deserialize(ne.subarray(),this._hashLoader);await this._bitswap._receiveMessage(ee.remotePeer,ie)}catch(ie){this._bitswap._receiveError(ie);break}te.reset()}})}).catch(re=>{this._log(re),E.abort(re)}).finally(()=>{te.clear(),E.close()})}_onPeerConnect(J){this._bitswap._onPeerConnected(J)}_onPeerDisconnect(J){this._bitswap._onPeerDisconnected(J)}findProviders(J,E={}){return E.onProgress?.(new CustomProgressEvent("bitswap:network:find-providers",J)),this._libp2p.contentRouting.findProviders(J,E)}async findAndConnect(J,E){await drain(take(map$1(this.findProviders(J,E),async ee=>this.connectTo(ee.id,E).catch(te=>{this._log.error(te)})),maxProvidersPerRequest)).catch(ee=>{this._log.error(ee)})}async provide(J,E={}){E.onProgress?.(new CustomProgressEvent("bitswap:network:provide",J)),await this._libp2p.contentRouting.provide(J,E)}async sendMessage(J,E,ee={}){if(!this._running)throw new Error("network isn't running");const te=J.toString();this._log("sendMessage to %s",te,E),ee.onProgress?.(new CustomProgressEvent("bitswap:network:send-wantlist",J)),await this._writeMessage(J,E,ee),this._updateSentStats(J,E.blocks)}async connectTo(J,E={}){if(!this._running)throw new Error("network isn't running");return E.onProgress?.(new CustomProgressEvent("bitswap:network:dial",J)),this._libp2p.dial(J,E)}_updateSentStats(J,E){const ee=J.toString();if(this._stats!=null){for(const te of E.values())this._stats.push(ee,"dataSent",te.length);this._stats.push(ee,"blocksSent",E.size)}}async _writeMessage(J,E,ee={}){const te=await this._libp2p.dialProtocol(J,[BITSWAP120,BITSWAP110,BITSWAP100]);try{let re;switch(te.stat.protocol){case BITSWAP100:re=E.serializeToBitswap100();break;case BITSWAP110:case BITSWAP120:re=E.serializeToBitswap110();break;default:throw new Error(`Unknown protocol: ${te.stat.protocol}`)}await pipe$1([re],ne=>encode$b(ne),te)}catch(re){ee.onProgress?.(new CustomProgressEvent("bitswap:network:send-wantlist:error",{peer:J,error:re})),this._log(re)}finally{te.close()}}};const unwantEvent=J=>`unwant:${toString$5(J.multihash.bytes,"base64")}`,blockEvent=J=>`block:${toString$5(J.multihash.bytes,"base64")}`;class Notifications extends EventEmitter$1{_log;constructor(E){super(),this.setMaxListeners(maxListeners),this._log=logger(E,"notif")}hasBlock(E,ee){const te=blockEvent(E);this._log(te),this.emit(te,ee)}async wantBlock(E,ee={}){if(E==null)throw new Error("Not a valid cid");const te=blockEvent(E),re=unwantEvent(E);return this._log(`wantBlock:${E}`),new Promise((ne,ie)=>{const se=()=>{this.removeListener(te,oe),ee.onProgress?.(new CustomProgressEvent("bitswap:want-block:unwant",E)),ie(new Error(`Block for ${E} unwanted`))},oe=ce=>{this.removeListener(re,se),ee.onProgress?.(new CustomProgressEvent("bitswap:want-block:block",E)),ne(ce)};this.once(re,se),this.once(te,oe),ee.signal?.addEventListener("abort",()=>{this.removeListener(te,oe),this.removeListener(re,se),ie(new Error(`Want for ${E} aborted`))})})}unwantBlock(E){const ee=unwantEvent(E);this._log(ee),this.emit(ee)}}var movingAverage={exports:{}};(function(J,E){const ee=Math.exp;J.exports=function(te){if(typeof te!="number")throw new Error("must provide a timespan to the moving average constructor");if(te<=0)throw new Error("must provide a timespan > 0 to the moving average constructor");let re,ne=0,ie=0,se=0,oe,ce={};function ae(le,ue){return 1-ee(-(le-ue)/te)}return ce.push=function(le,ue){if(oe){const he=ae(le,oe),pe=ue-re,de=he*pe;re=he*ue+(1-he)*re,ne=(1-he)*(ne+pe*de),ie=Math.sqrt(ne),se=re+he*pe}else re=ue;oe=le},ce.movingAverage=function(){return re},ce.variance=function(){return ne},ce.deviation=function(){return ie},ce.forecast=function(){return se},ce}})(movingAverage);var movingAverageExports=movingAverage.exports;const MovingAverage=getDefaultExportFromCjs(movingAverageExports);class Stat extends EventEmitter$1{_options;_queue;_stats;_frequencyLastTime;_frequencyAccumulators;_movingAverages;_enabled;_timeout;constructor(E,ee){super(),this._options=ee,this._queue=[],this._stats={},this._frequencyLastTime=Date.now(),this._frequencyAccumulators={},this._movingAverages={},this._update=this._update.bind(this),E.forEach(te=>{this._stats[te]=BigInt(0),this._movingAverages[te]={},this._options.movingAverageIntervals.forEach(re=>{(this._movingAverages[te][re]=MovingAverage(re)).push(this._frequencyLastTime,0)})}),this._enabled=this._options.enabled}enable(){this._enabled=!0}disable(){this._enabled=!1}stop(){this._timeout!=null&&clearTimeout(this._timeout)}get snapshot(){return Object.assign({},this._stats)}get movingAverages(){return Object.assign({},this._movingAverages)}push(E,ee){this._enabled&&(this._queue.push([E,ee,Date.now()]),this._resetComputeTimeout())}_resetComputeTimeout(){this._timeout!=null&&clearTimeout(this._timeout),this._timeout=setTimeout(this._update,this._nextTimeout())}_nextTimeout(){const E=this._queue.length/this._options.computeThrottleMaxQueueSize;return Math.max(this._options.computeThrottleTimeout*(1-E),0)}_update(){if(this._timeout=void 0,this._queue.length>0){let E;for(;this._queue.length>0;){const ee=E=this._queue.shift();ee!=null&&this._applyOp(ee)}E!=null&&this._updateFrequency(E[2]),this.emit("update",this._stats)}}_updateFrequency(E){const ee=E-this._frequencyLastTime;ee>0&&Object.keys(this._stats).forEach(te=>{this._updateFrequencyFor(te,ee,E)}),this._frequencyLastTime=E}_updateFrequencyFor(E,ee,te){const re=this._frequencyAccumulators[E]??0;this._frequencyAccumulators[E]=0;const ne=re/ee*1e3;let ie=this._movingAverages[E];ie==null&&(ie=this._movingAverages[E]={}),this._options.movingAverageIntervals.forEach(se=>{let oe=ie[se];oe==null&&(oe=ie[se]=MovingAverage(se)),oe.push(te,ne)})}_applyOp(E){const ee=E[0],te=E[1];if(typeof te!="number")throw new Error(`invalid increment number: ${te}`);Object.prototype.hasOwnProperty.call(this._stats,ee)||(this._stats[ee]=BigInt(0)),this._stats[ee]=BigInt(this._stats[ee])+BigInt(te),this._frequencyAccumulators[ee]==null&&(this._frequencyAccumulators[ee]=0),this._frequencyAccumulators[ee]+=te}}const defaultOptions$5={enabled:!1,computeThrottleTimeout:1e3,computeThrottleMaxQueueSize:1e3,movingAverageIntervals:[60*1e3,5*60*1e3,15*60*1e3]};class Stats extends EventEmitter$1{_initialCounters;_options;_enabled;_global;_peers;constructor(E,ee=[],te=defaultOptions$5){super();const re=Object.assign({},defaultOptions$5,te);if(typeof re.computeThrottleTimeout!="number")throw new Error("need computeThrottleTimeout");if(typeof re.computeThrottleMaxQueueSize!="number")throw new Error("need computeThrottleMaxQueueSize");this._initialCounters=ee,this._options=re,this._enabled=this._options.enabled,this._global=new Stat(ee,re),this._global.on("update",ne=>this.emit("update",ne)),this._peers=trackedMap({name:"ipfs_bitswap_stats_peers",metrics:E.metrics})}enable(){this._enabled=!0,this._options.enabled=!0,this._global.enable()}disable(){this._enabled=!1,this._options.enabled=!1,this._global.disable()}stop(){this._enabled=!1,this._global.stop();for(const E of this._peers)E[1].stop()}get snapshot(){return this._global.snapshot}get movingAverages(){return this._global.movingAverages}forPeer(E){const ee=E.toString();return this._peers.get(ee)}push(E,ee,te){if(this._enabled&&(this._global.push(ee,te),E!=null)){let re=this._peers.get(E);re==null&&(re=new Stat(this._initialCounters,this._options),this._peers.set(E,re)),re.push(ee,te)}}disconnected(E){const ee=E.toString(),te=this._peers.get(ee);te!=null&&(te.stop(),this._peers.delete(ee))}}var functionDebounce=debounce$2;function debounce$2(J,E,ee){var te=null,re=null,ne=function(){te&&(clearTimeout(te),re=null,te=null)},ie=function(){var oe=re;ne(),oe&&oe()},se=function(){if(!E)return J.apply(this,arguments);var oe=this,ce=arguments,ae=ee&&!te;if(ne(),re=function(){J.apply(oe,ce)},te=setTimeout(function(){if(te=null,!ae){var le=re;return re=null,le()}},E),ae)return re()};return se.cancel=ne,se.flush=ie,se}class MsgQueue{peerId;refcnt;network;_entries;_log;constructor(E,ee,te){this.peerId=ee,this.network=te,this.refcnt=1,this._entries=[],this._log=logger(E,"msgqueue"),this.sendEntries=functionDebounce(this.sendEntries.bind(this),wantlistSendDebounceMs)}addMessage(E,ee={}){E.empty||this.send(E,ee)}addEntries(E,ee={}){this._entries=this._entries.concat(E),this.sendEntries(ee)}sendEntries(E={}){if(this._entries.length===0)return;const ee=new BitswapMessage(!1);this._entries.forEach(te=>{te.cancel===!0?ee.cancel(te.cid):ee.addEntry(te.cid,te.priority)}),this._entries=[],this.addMessage(ee,E)}async send(E,ee={}){try{await this.network.connectTo(this.peerId,ee)}catch(te){this._log.error("cant connect to peer %p: %s",this.peerId,te.message);return}this._log("sending message to peer %p",this.peerId),this.network.sendMessage(this.peerId,E,ee).catch(te=>{this._log.error("send error",te)})}}class WantManager{peers;wantlist;network;_peerId;_log;constructor(E,ee,te,re){this.peers=trackedMap({name:"ipfs_bitswap_want_manager_peers",metrics:re.metrics}),this.wantlist=new Wantlist(te,re),this.network=ee,this._peerId=E,this._log=logger(E,"want")}_addEntries(E,ee,te,re={}){const ne=E.map((ie,se)=>new BitswapMessage.Entry(ie,kMaxPriority-se,BitswapMessage.WantType.Block,ee));ne.forEach(ie=>{ie.cancel?te===!0?this.wantlist.removeForce(ie.cid.toString(base58btc$1)):this.wantlist.remove(ie.cid):(this._log("adding to wantlist"),this.wantlist.add(ie.cid,ie.priority))});for(const ie of this.peers.values())ie.addEntries(ne,re)}_startPeerHandler(E){let ee=this.peers.get(E.toString());if(ee!=null){ee.refcnt++;return}ee=new MsgQueue(this._peerId,E,this.network);const te=new BitswapMessage(!0);for(const re of this.wantlist.entries())te.addEntry(re[1].cid,re[1].priority);return ee.addMessage(te),this.peers.set(E.toString(),ee),ee}_stopPeerHandler(E){const ee=this.peers.get(E.toString());ee!=null&&(ee.refcnt--,!(ee.refcnt>0)&&this.peers.delete(E.toString()))}wantBlocks(E,ee={}){this._addEntries(E,!1,!1,ee),ee.signal?.addEventListener("abort",()=>{this.cancelWants(E)})}unwantBlocks(E){this._log("unwant blocks: %s",E.length),this._addEntries(E,!0,!0)}cancelWants(E){this._log("cancel wants: %s",E.length),this._addEntries(E,!0)}connectedPeers(){return Array.from(this.peers.keys())}connected(E){this._startPeerHandler(E)}disconnected(E){this._stopPeerHandler(E)}start(){}stop(){this.peers.forEach(E=>{this.disconnected(E.peerId)})}}const hashLoader={async getHasher(){throw new Error("Not implemented")}},defaultOptions$4={maxInboundStreams:1024,maxOutboundStreams:1024,incomingStreamTimeout:3e4,hashLoader,statsEnabled:!1,statsComputeThrottleTimeout:1e3,statsComputeThrottleMaxQueueSize:1e3},statsKeys=["blocksReceived","dataReceived","dupBlksReceived","dupDataReceived","blocksSent","dataSent","providesBufferLength","wantListLength","peerCount"];class DefaultBitswap{_libp2p;_log;stats;network;blockstore;engine;wm;notifications;started;constructor(E,ee,te={}){this._libp2p=E,this._log=logger(this.peerId),te=Object.assign({},defaultOptions$4,te),this.stats=new Stats(E,statsKeys,{enabled:te.statsEnabled,computeThrottleTimeout:te.statsComputeThrottleTimeout,computeThrottleMaxQueueSize:te.statsComputeThrottleMaxQueueSize}),this.network=new Network$1(E,this,this.stats,{hashLoader:te.hashLoader,maxInboundStreams:te.maxInboundStreams,maxOutboundStreams:te.maxOutboundStreams,incomingStreamTimeout:te.incomingStreamTimeout}),this.blockstore=ee,this.engine=new DecisionEngine(this.peerId,ee,this.network,this.stats,E),this.wm=new WantManager(this.peerId,this.network,this.stats,E),this.notifications=new Notifications(this.peerId),this.started=!1}isStarted(){return this.started}get peerId(){return this._libp2p.peerId}async _receiveMessage(E,ee){try{await this.engine.messageReceived(E,ee)}catch{this._log("failed to receive message",ee)}if(ee.blocks.size===0)return;const te=[];for(const[re,ne]of ee.blocks.entries()){const ie=CID.parse(re);te.push({wasWanted:this.wm.wantlist.contains(ie),cid:ie,data:ne})}this.wm.cancelWants(te.filter(({wasWanted:re})=>re).map(({cid:re})=>re)),await Promise.all(te.map(async({cid:re,wasWanted:ne,data:ie})=>{await this._handleReceivedBlock(E,re,ie,ne)}))}async _handleReceivedBlock(E,ee,te,re){this._log("received block");const ne=await this.blockstore.has(ee);this._updateReceiveCounters(E.toString(),ee,te,ne),re&&await this.put(ee,te)}_updateReceiveCounters(E,ee,te,re){this.stats.push(E,"blocksReceived",1),this.stats.push(E,"dataReceived",te.length),re&&(this.stats.push(E,"dupBlksReceived",1),this.stats.push(E,"dupDataReceived",te.length))}_receiveError(E){this._log.error("ReceiveError",E)}_onPeerConnected(E){this.wm.connected(E)}_onPeerDisconnected(E){this.wm.disconnected(E),this.engine.peerDisconnected(E),this.stats.disconnected(E)}enableStats(){this.stats.enable()}disableStats(){this.stats.disable()}wantlistForPeer(E,ee){return this.engine.wantlistForPeer(E)}ledgerForPeer(E){return this.engine.ledgerForPeer(E)}async want(E,ee={}){const te=async(oe,ce)=>(this.wm.wantBlocks([oe],ce),this.notifications.wantBlock(oe,ce));let re=!1;const ne=async(oe,ce)=>{try{return await this.blockstore.get(oe,ce)}catch(ae){if(ae.code!=="ERR_NOT_FOUND")throw ae;return re||(re=!0,this.network.findAndConnect(oe,ce).catch(le=>{this._log.error(le)})),await te(oe,ce)}},ie=new AbortController,se=anySignal([ie.signal,ee.signal]);try{return await Promise.race([this.notifications.wantBlock(E,{...ee,signal:se}),ne(E,{...ee,signal:se})])}finally{ie.abort(),se.clear()}}unwant(E){const ee=Array.isArray(E)?E:[E];this.wm.unwantBlocks(ee),ee.forEach(te=>{this.notifications.unwantBlock(te)})}cancelWants(E){this.wm.cancelWants(Array.isArray(E)?E:[E])}async put(E,ee,te){await this.blockstore.put(E,ee),this.notify(E,ee)}async*putMany(E,ee){yield*this.blockstore.putMany(forEach(E,({cid:te,block:re})=>{this.notify(te,re)}),ee)}notify(E,ee,te={}){this.notifications.hasBlock(E,ee),this.engine.receivedBlocks([{cid:E,block:ee}]),this.network.provide(E,te).catch(re=>{this._log.error("Failed to provide: %s",re.message)})}getWantlist(){return this.wm.wantlist.entries()}get peers(){return this.engine.peers()}async start(){this.wm.start(),await this.network.start(),this.engine.start(),this.started=!0}async stop(){this.stats.stop(),this.wm.stop(),await this.network.stop(),this.engine.stop(),this.started=!1}}const createBitswap=(J,E,ee={})=>new DefaultBitswap(J,E,ee);class JSONEncoder extends Array{constructor(){super(),this.inRecursive=[]}prefix(E){const ee=this.inRecursive[this.inRecursive.length-1];ee&&(ee.type===Type.array&&(ee.elements++,ee.elements!==1&&E.push([44])),ee.type===Type.map&&(ee.elements++,ee.elements!==1&&(ee.elements%2===1?E.push([44]):E.push([58]))))}[Type.uint.major](E,ee){this.prefix(E);const te=String(ee.value),re=[];for(let ne=0;ne<te.length;ne++)re[ne]=te.charCodeAt(ne);E.push(re)}[Type.negint.major](E,ee){this[Type.uint.major](E,ee)}[Type.bytes.major](E,ee){throw new Error(`${encodeErrPrefix} unsupported type: Uint8Array`)}[Type.string.major](E,ee){this.prefix(E);const te=fromString(JSON.stringify(ee.value));E.push(te.length>32?asU8A(te):te)}[Type.array.major](E,ee){this.prefix(E),this.inRecursive.push({type:Type.array,elements:0}),E.push([91])}[Type.map.major](E,ee){this.prefix(E),this.inRecursive.push({type:Type.map,elements:0}),E.push([123])}[Type.tag.major](E,ee){}[Type.float.major](E,ee){if(ee.type.name==="break"){const ie=this.inRecursive.pop();if(ie){if(ie.type===Type.array)E.push([93]);else if(ie.type===Type.map)E.push([125]);else throw new Error("Unexpected recursive type; this should not happen!");return}throw new Error("Unexpected break; this should not happen!")}if(ee.value===void 0)throw new Error(`${encodeErrPrefix} unsupported type: undefined`);if(this.prefix(E),ee.type.name==="true"){E.push([116,114,117,101]);return}else if(ee.type.name==="false"){E.push([102,97,108,115,101]);return}else if(ee.type.name==="null"){E.push([110,117,108,108]);return}const te=String(ee.value),re=[];let ne=!1;for(let ie=0;ie<te.length;ie++)re[ie]=te.charCodeAt(ie),!ne&&(re[ie]===46||re[ie]===101||re[ie]===69)&&(ne=!0);ne||(re.push(46),re.push(48)),E.push(re)}}class Tokenizer{constructor(E,ee={}){this.pos=0,this.data=E,this.options=ee,this.modeStack=["value"],this.lastToken=""}done(){return this.pos>=this.data.length}ch(){return this.data[this.pos]}currentMode(){return this.modeStack[this.modeStack.length-1]}skipWhitespace(){let E=this.ch();for(;E===32||E===9||E===13||E===10;)E=this.data[++this.pos]}expect(E){if(this.data.length-this.pos<E.length)throw new Error(`${decodeErrPrefix} unexpected end of input at position ${this.pos}`);for(let ee=0;ee<E.length;ee++)if(this.data[this.pos++]!==E[ee])throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}, expected to find '${String.fromCharCode(...E)}'`)}parseNumber(){const E=this.pos;let ee=!1,te=!1;const re=se=>{for(;!this.done();){const oe=this.ch();if(se.includes(oe))this.pos++;else break}};if(this.ch()===45&&(ee=!0,this.pos++),this.ch()===48)if(this.pos++,this.ch()===46)this.pos++,te=!0;else return new Token(Type.uint,0,this.pos-E);if(re([48,49,50,51,52,53,54,55,56,57]),ee&&this.pos===E+1)throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}`);if(!this.done()&&this.ch()===46){if(te)throw new Error(`${decodeErrPrefix} unexpected token at position ${this.pos}`);te=!0,this.pos++,re([48,49,50,51,52,53,54,55,56,57])}!this.done()&&(this.ch()===101||this.ch()===69)&&(te=!0,this.pos++,!this.done()&&(this.ch()===43||this.ch()===45)&&this.pos++,re([48,49,50,51,52,53,54,55,56,57]));const ne=String.fromCharCode.apply(null,this.data.subarray(E,this.pos)),ie=parseFloat(ne);return te?new Token(Type.float,ie,this.pos-E):this.options.allowBigInt!==!0||Number.isSafeInteger(ie)?new Token(ie>=0?Type.uint:Type.negint,ie,this.pos-E):new Token(ie>=0?Type.uint:Type.negint,BigInt(ne),this.pos-E)}parseString(){if(this.ch()!==34)throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}; this shouldn't happen`);this.pos++;for(let ne=this.pos,ie=0;ne<this.data.length&&ie<65536;ne++,ie++){const se=this.data[ne];if(se===92||se<32||se>=128)break;if(se===34){const oe=String.fromCharCode.apply(null,this.data.subarray(this.pos,ne));return this.pos=ne+1,new Token(Type.string,oe,ie)}}const E=this.pos,ee=[],te=()=>{if(this.pos+4>=this.data.length)throw new Error(`${decodeErrPrefix} unexpected end of unicode escape sequence at position ${this.pos}`);let ne=0;for(let ie=0;ie<4;ie++){let se=this.ch();if(se>=48&&se<=57)se-=48;else if(se>=97&&se<=102)se=se-97+10;else if(se>=65&&se<=70)se=se-65+10;else throw new Error(`${decodeErrPrefix} unexpected unicode escape character at position ${this.pos}`);ne=ne*16+se,this.pos++}return ne},re=()=>{const ne=this.ch();let ie=null,se=ne>239?4:ne>223?3:ne>191?2:1;if(this.pos+se>this.data.length)throw new Error(`${decodeErrPrefix} unexpected unicode sequence at position ${this.pos}`);let oe,ce,ae,le;switch(se){case 1:ne<128&&(ie=ne);break;case 2:oe=this.data[this.pos+1],(oe&192)===128&&(le=(ne&31)<<6|oe&63,le>127&&(ie=le));break;case 3:oe=this.data[this.pos+1],ce=this.data[this.pos+2],(oe&192)===128&&(ce&192)===128&&(le=(ne&15)<<12|(oe&63)<<6|ce&63,le>2047&&(le<55296||le>57343)&&(ie=le));break;case 4:oe=this.data[this.pos+1],ce=this.data[this.pos+2],ae=this.data[this.pos+3],(oe&192)===128&&(ce&192)===128&&(ae&192)===128&&(le=(ne&15)<<18|(oe&63)<<12|(ce&63)<<6|ae&63,le>65535&&le<1114112&&(ie=le))}ie===null?(ie=65533,se=1):ie>65535&&(ie-=65536,ee.push(ie>>>10&1023|55296),ie=56320|ie&1023),ee.push(ie),this.pos+=se};for(;!this.done();){const ne=this.ch();let ie;switch(ne){case 92:if(this.pos++,this.done())throw new Error(`${decodeErrPrefix} unexpected string termination at position ${this.pos}`);switch(ie=this.ch(),this.pos++,ie){case 34:case 39:case 92:case 47:ee.push(ie);break;case 98:ee.push(8);break;case 116:ee.push(9);break;case 110:ee.push(10);break;case 102:ee.push(12);break;case 114:ee.push(13);break;case 117:ee.push(te());break;default:throw new Error(`${decodeErrPrefix} unexpected string escape character at position ${this.pos}`)}break;case 34:return this.pos++,new Token(Type.string,decodeCodePointsArray(ee),this.pos-E);default:if(ne<32)throw new Error(`${decodeErrPrefix} invalid control character at position ${this.pos}`);ne<128?(ee.push(ne),this.pos++):re()}}throw new Error(`${decodeErrPrefix} unexpected end of string at position ${this.pos}`)}parseValue(){switch(this.ch()){case 123:return this.modeStack.push("obj-start"),this.pos++,new Token(Type.map,1/0,1);case 91:return this.modeStack.push("array-start"),this.pos++,new Token(Type.array,1/0,1);case 34:return this.parseString();case 110:return this.expect([110,117,108,108]),new Token(Type.null,null,4);case 102:return this.expect([102,97,108,115,101]),new Token(Type.false,!1,5);case 116:return this.expect([116,114,117,101]),new Token(Type.true,!0,4);case 45:case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return this.parseNumber();default:throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}`)}}next(){switch(this.skipWhitespace(),this.currentMode()){case"value":return this.modeStack.pop(),this.parseValue();case"array-value":{if(this.modeStack.pop(),this.ch()===93)return this.pos++,this.skipWhitespace(),new Token(Type.break,void 0,1);if(this.ch()!==44)throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting array delimiter but found '${String.fromCharCode(this.ch())}'`);return this.pos++,this.modeStack.push("array-value"),this.skipWhitespace(),this.parseValue()}case"array-start":return this.modeStack.pop(),this.ch()===93?(this.pos++,this.skipWhitespace(),new Token(Type.break,void 0,1)):(this.modeStack.push("array-value"),this.skipWhitespace(),this.parseValue());case"obj-key":if(this.ch()===125)return this.modeStack.pop(),this.pos++,this.skipWhitespace(),new Token(Type.break,void 0,1);if(this.ch()!==44)throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting object delimiter but found '${String.fromCharCode(this.ch())}'`);this.pos++,this.skipWhitespace();case"obj-start":{if(this.modeStack.pop(),this.ch()===125)return this.pos++,this.skipWhitespace(),new Token(Type.break,void 0,1);const E=this.parseString();if(this.skipWhitespace(),this.ch()!==58)throw new Error(`${decodeErrPrefix} unexpected character at position ${this.pos}, was expecting key/value delimiter ':' but found '${String.fromCharCode(this.ch())}'`);return this.pos++,this.modeStack.push("obj-value"),E}case"obj-value":return this.modeStack.pop(),this.modeStack.push("obj-key"),this.skipWhitespace(),this.parseValue();default:throw new Error(`${decodeErrPrefix} unexpected parse state at position ${this.pos}; this shouldn't happen`)}}}function decode$1(J,E){return E=Object.assign({tokenizer:new Tokenizer(J,E)},E),decode$3(J,E)}const dagPbWalker={codec:code$1,async*walk(J){yield*decode$4(J).Links.map(E=>E.Hash)}},rawWalker={codec:code$2,async*walk(){}},CID_TAG=42,cborWalker={codec:113,async*walk(J){const E=[],ee=[];ee[CID_TAG]=te=>{if(te[0]!==0)throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");const re=CID.decode(te.subarray(1));return E.push(re),re},decode$3(J,{tags:ee}),yield*E}};class DagJsonTokenizer extends Tokenizer{tokenBuffer;constructor(E,ee){super(E,ee),this.tokenBuffer=[]}done(){return this.tokenBuffer.length===0&&super.done()}_next(){return this.tokenBuffer.length>0?this.tokenBuffer.pop():super.next()}next(){const E=this._next();if(E.type===Type.map){const ee=this._next();if(ee.type===Type.string&&ee.value==="/"){const te=this._next();if(te.type===Type.string){if(this._next().type!==Type.break)throw new Error("Invalid encoded CID form");return this.tokenBuffer.push(te),new Token(Type.tag,42,0)}if(te.type===Type.map){const re=this._next();if(re.type===Type.string&&re.value==="bytes"){const ne=this._next();if(ne.type===Type.string){for(let se=0;se<2;se++)if(this._next().type!==Type.break)throw new Error("Invalid encoded Bytes form");const ie=base64$4.decode(`m${ne.value}`);return new Token(Type.bytes,ie,ne.value.length)}this.tokenBuffer.push(ne)}this.tokenBuffer.push(re)}this.tokenBuffer.push(te)}this.tokenBuffer.push(ee)}return E}}const jsonWalker={codec:297,async*walk(J){const E=[],ee=[];ee[CID_TAG]=te=>{const re=CID.parse(te);return E.push(re),re},decode$1(J,{tags:ee,tokenizer:new DagJsonTokenizer(J,{tags:ee,allowIndefinite:!0,allowUndefined:!0,allowNaN:!0,allowInfinity:!0,allowBigInt:!0,strict:!1,rejectDuplicateMapKeys:!1})}),yield*E}},DEFAULT_DAG_WALKERS=[rawWalker,dagPbWalker,cborWalker,jsonWalker],DATASTORE_PIN_PREFIX="/pin/",DATASTORE_BLOCK_PREFIX="/pinned-block/",DATASTORE_ENCODING=base36$2,DAG_WALK_QUEUE_CONCURRENCY=1;function toDSKey(J){return J.version===0&&(J=J.toV1()),new Key(`${DATASTORE_PIN_PREFIX}${J.toString(DATASTORE_ENCODING)}`)}class PinsImpl{datastore;blockstore;dagWalkers;constructor(E,ee,te){this.datastore=E,this.blockstore=ee,this.dagWalkers={},[...DEFAULT_DAG_WALKERS,...te].forEach(re=>{this.dagWalkers[re.codec]=re})}async add(E,ee={}){const te=toDSKey(E);if(await this.datastore.has(te))throw new Error("Already pinned");const re=Math.round(ee.depth??1/0);if(re<0)throw new Error("Depth must be greater than or equal to 0");const ne=new PQueue({concurrency:DAG_WALK_QUEUE_CONCURRENCY});ne.add(async()=>{await this.#e(E,ne,oe=>{oe.pinnedBy.find(ce=>equals(ce,E.bytes))==null&&(oe.pinCount++,oe.pinnedBy.push(E.bytes))},{...ee,depth:re})});const ie=pDefer();ne.on("error",oe=>{ne.clear(),ie.reject(oe)}),await Promise.race([ne.onIdle(),ie.promise]);const se={depth:re,metadata:ee.metadata??{}};return await this.datastore.put(te,encode$1(se),ee),{cid:E,...se}}async#e(E,ee,te,re){if(re.depth===-1)return;const ne=this.dagWalkers[E.code];if(ne==null)throw new Error(`No dag walker found for cid codec ${E.code}`);const ie=await this.blockstore.get(E,re);await this.#t(E,te,re);for await(const se of ne.walk(ie))ee.add(async()=>{await this.#e(se,ee,te,{...re,depth:re.depth-1})})}async#t(E,ee,te){const re=new Key(`${DATASTORE_BLOCK_PREFIX}${DATASTORE_ENCODING.encode(E.multihash.bytes)}`);let ne={pinCount:0,pinnedBy:[]};try{ne=decode$3(await this.datastore.get(re,te))}catch(ie){if(ie.code!=="ERR_NOT_FOUND")throw ie}if(ee(ne),ne.pinCount===0&&await this.datastore.has(re)){await this.datastore.delete(re);return}await this.datastore.put(re,encode$1(ne),te),te.onProgress?.(new CustomProgressEvent("helia:pin:add",{detail:E}))}async rm(E,ee={}){const te=toDSKey(E),re=await this.datastore.get(te,ee),ne=decode$3(re);await this.datastore.delete(te,ee);const ie=new PQueue({concurrency:DAG_WALK_QUEUE_CONCURRENCY});return ie.add(async()=>{await this.#e(E,ie,se=>{se.pinCount--,se.pinnedBy=se.pinnedBy.filter(oe=>equals(oe,E.bytes))},{...ee,depth:ne.depth})}),await ie.onIdle(),{cid:E,...ne}}async*ls(E={}){for await(const{key:ee,value:te}of this.datastore.query({prefix:DATASTORE_PIN_PREFIX+(E.cid!=null?`${E.cid.toString(base36$2)}`:"")},E)){const re=CID.parse(ee.toString().substring(5),base36$2),ne=decode$3(te);yield{cid:re,...ne}}}async isPinned(E,ee={}){const te=new Key(`${DATASTORE_BLOCK_PREFIX}${DATASTORE_ENCODING.encode(E.multihash.bytes)}`);return this.datastore.has(te,ee)}}class BlockStorage{lock;child;pins;constructor(E,ee,te={}){this.child=E,this.pins=ee,this.lock=createMortice({singleProcess:te.holdGcLock})}unwrap(){return this.child}async put(E,ee,te={}){const re=await this.lock.readLock();try{return await this.child.put(E,ee,te)}finally{re()}}async*putMany(E,ee={}){const te=await this.lock.readLock();try{yield*this.child.putMany(E,ee)}finally{te()}}async get(E,ee={}){const te=await this.lock.readLock();try{return await this.child.get(E,ee)}finally{te()}}async*getMany(E,ee={}){const te=await this.lock.readLock();try{yield*this.child.getMany(E,ee)}finally{te()}}async delete(E,ee={}){const te=await this.lock.writeLock();try{if(await this.pins.isPinned(E))throw new Error("CID was pinned");await this.child.delete(E,ee)}finally{te()}}async*deleteMany(E,ee={}){const te=await this.lock.writeLock();try{const re=this;yield*this.child.deleteMany(async function*(){for await(const ne of E){if(await re.pins.isPinned(ne))throw new Error("CID was pinned");yield ne}}(),ee)}finally{te()}}async has(E,ee={}){const te=await this.lock.readLock();try{return await this.child.has(E,ee)}finally{te()}}async*getAll(E={}){const ee=await this.lock.readLock();try{yield*this.child.getAll(E)}finally{ee()}}}const DS_VERSION_KEY=new Key("/version"),CURRENT_VERSION=1;async function assertDatastoreVersionIsCurrent(J){if(!await J.has(DS_VERSION_KEY)){await J.put(DS_VERSION_KEY,fromString$5(`${CURRENT_VERSION}`));return}const E=await J.get(DS_VERSION_KEY),ee=toString$5(E);if(parseInt(ee,10)!==CURRENT_VERSION)throw new Error("Unknown datastore version, a datastore migration may be required")}class NetworkedStorage{child;bitswap;constructor(E,ee={}){this.child=E,this.bitswap=ee.bitswap}unwrap(){return this.child}async put(E,ee,te={}){return await this.child.has(E)?(te.onProgress?.(new CustomProgressEvent("blocks:put:duplicate",E)),E):(this.bitswap?.isStarted()===!0&&(te.onProgress?.(new CustomProgressEvent("blocks:put:bitswap:notify",E)),this.bitswap.notify(E,ee,te)),te.onProgress?.(new CustomProgressEvent("blocks:put:blockstore:put",E)),this.child.put(E,ee,te))}async*putMany(E,ee={}){const te=filter(E,async({cid:ne})=>{const ie=await this.child.has(ne);return ie&&ee.onProgress?.(new CustomProgressEvent("blocks:put-many:duplicate",ne)),!ie}),re=forEach(te,({cid:ne,block:ie})=>{ee.onProgress?.(new CustomProgressEvent("blocks:put-many:bitswap:notify",ne)),this.bitswap?.notify(ne,ie,ee)});ee.onProgress?.(new CustomProgressEvent("blocks:put-many:blockstore:put-many")),yield*this.child.putMany(re,ee)}async get(E,ee={}){if(ee.offline!==!0&&this.bitswap?.isStarted()!=null&&!await this.child.has(E)){ee.onProgress?.(new CustomProgressEvent("blocks:get:bitswap:get",E));const te=await this.bitswap.want(E,ee);return ee.onProgress?.(new CustomProgressEvent("blocks:get:blockstore:put",E)),await this.child.put(E,te,ee),te}return ee.onProgress?.(new CustomProgressEvent("blocks:get:blockstore:get",E)),this.child.get(E,ee)}async*getMany(E,ee={}){ee.onProgress?.(new CustomProgressEvent("blocks:get-many:blockstore:get-many")),yield*this.child.getMany(forEach(E,async te=>{if(ee.offline!==!0&&this.bitswap?.isStarted()===!0&&!await this.child.has(te)){ee.onProgress?.(new CustomProgressEvent("blocks:get-many:bitswap:get",te));const re=await this.bitswap.want(te,ee);ee.onProgress?.(new CustomProgressEvent("blocks:get-many:blockstore:put",te)),await this.child.put(te,re,ee)}}))}async delete(E,ee={}){ee.onProgress?.(new CustomProgressEvent("blocks:delete:blockstore:delete",E)),await this.child.delete(E,ee)}async*deleteMany(E,ee={}){ee.onProgress?.(new CustomProgressEvent("blocks:delete-many:blockstore:delete-many")),yield*this.child.deleteMany(async function*(){for await(const te of E)yield te}(),ee)}async has(E,ee={}){return this.child.has(E,ee)}async*getAll(E={}){E.onProgress?.(new CustomProgressEvent("blocks:get-all:blockstore:get-many")),yield*this.child.getAll(E)}}const log$G=logger$1("helia");class HeliaImpl{libp2p;blockstore;datastore;pins;#e;constructor(E){const ee=[sha256$3,sha512$1,identity$2,...E.hashers??[]];this.#e=createBitswap(E.libp2p,E.blockstore,{hashLoader:{getHasher:async re=>{const ne=ee.find(ie=>ie.code===re||ie.name===re);if(ne!=null)return ne;throw new Error(`Could not load hasher for code/name "${re}"`)}}});const te=new NetworkedStorage(E.blockstore,{bitswap:this.#e});this.pins=new PinsImpl(E.datastore,te,E.dagWalkers??[]),this.libp2p=E.libp2p,this.blockstore=new BlockStorage(te,this.pins,{holdGcLock:E.holdGcLock}),this.datastore=E.datastore}async start(){await assertDatastoreVersionIsCurrent(this.datastore),await this.#e?.start(),await this.libp2p.start()}async stop(){await this.libp2p.stop(),await this.#e?.stop()}async gc(E={}){const ee=await this.blockstore.lock.writeLock();try{const te=this,re=this.blockstore.unwrap();log$G("gc start"),await drain(re.deleteMany(async function*(){for await(const{cid:ne}of re.getAll())try{if(await te.pins.isPinned(ne,E))continue;yield ne,E.onProgress?.(new CustomProgressEvent("helia:gc:deleted",ne))}catch(ie){log$G.error("Error during gc",ie),E.onProgress?.(new CustomProgressEvent("helia:gc:error",ie))}}()))}finally{ee()}log$G("gc finished")}}function debounce$1(J,E){let ee;return function(){const te=function(){ee=void 0,J()};clearTimeout(ee),ee=setTimeout(te,E)}}const log$F=logger$1("libp2p:address-manager"),defaultAddressFilter=J=>J;function stripPeerId(J,E){const ee=J.getPeerId();return ee!=null&&peerIdFromString(ee).equals(E)&&(J=J.decapsulate(multiaddr(`/p2p/${E.toString()}`))),J}class DefaultAddressManager{components;listen;announce;observed;announceFilter;constructor(E,ee={}){const{listen:te=[],announce:re=[]}=ee;this.components=E,this.listen=te.map(ne=>ne.toString()),this.announce=new Set(re.map(ne=>ne.toString())),this.observed=new Map,this.announceFilter=ee.announceFilter??defaultAddressFilter,this._updatePeerStoreAddresses=debounce$1(this._updatePeerStoreAddresses.bind(this),1e3),E.events.addEventListener("transport:listening",()=>{this._updatePeerStoreAddresses()}),E.events.addEventListener("transport:close",()=>{this._updatePeerStoreAddresses()})}_updatePeerStoreAddresses(){const E=this.getAnnounceAddrs().concat(this.components.transportManager.getAddrs()).concat([...this.observed.entries()].filter(([ee,te])=>te.confident).map(([ee])=>multiaddr(ee))).map(ee=>ee.getPeerId()===this.components.peerId.toString()?ee.decapsulate(`/p2p/${this.components.peerId.toString()}`):ee);this.components.peerStore.patch(this.components.peerId,{multiaddrs:E}).catch(ee=>{log$F.error("error updating addresses",ee)})}getListenAddrs(){return Array.from(this.listen).map(E=>multiaddr(E))}getAnnounceAddrs(){return Array.from(this.announce).map(E=>multiaddr(E))}getObservedAddrs(){return Array.from(this.observed).map(([E])=>multiaddr(E))}addObservedAddr(E){E=stripPeerId(E,this.components.peerId);const ee=E.toString();this.observed.has(ee)||this.observed.set(ee,{confident:!1})}confirmObservedAddr(E){E=stripPeerId(E,this.components.peerId);const ee=E.toString(),te=(this.observed.get(ee)??{confident:!1}).confident;this.observed.set(ee,{confident:!0}),te||this._updatePeerStoreAddresses()}removeObservedAddr(E){E=stripPeerId(E,this.components.peerId);const ee=E.toString();this.observed.delete(ee)}getAddresses(){let E=this.getAnnounceAddrs().map(te=>te.toString());E.length===0&&(E=this.components.transportManager.getAddrs().map(te=>te.toString())),E=E.concat(Array.from(this.observed).filter(([te,re])=>re.confident).map(([te])=>te));const ee=new Set(E);return this.announceFilter(Array.from(ee).map(te=>multiaddr(te))).map(te=>te.protos().pop()?.path===!0||te.getPeerId()===this.components.peerId.toString()?te:te.encapsulate(`/p2p/${this.components.peerId.toString()}`))}}class DefaultComponents{components={};_started=!1;constructor(E={}){this.components={};for(const[ee,te]of Object.entries(E))this.components[ee]=te}isStarted(){return this._started}async _invokeStartableMethod(E){await Promise.all(Object.values(this.components).filter(ee=>isStartable(ee)).map(async ee=>{await ee[E]?.()}))}async beforeStart(){await this._invokeStartableMethod("beforeStart")}async start(){await this._invokeStartableMethod("start"),this._started=!0}async afterStart(){await this._invokeStartableMethod("afterStart")}async beforeStop(){await this._invokeStartableMethod("beforeStop")}async stop(){await this._invokeStartableMethod("stop"),this._started=!1}async afterStop(){await this._invokeStartableMethod("afterStop")}}const OPTIONAL_SERVICES=["metrics","connectionProtector"],NON_SERVICE_PROPERTIES=["components","isStarted","beforeStart","start","afterStart","beforeStop","stop","afterStop","then","_invokeStartableMethod"];function defaultComponents(J={}){const E=new DefaultComponents(J);return new Proxy(E,{get(ee,te,re){if(typeof te=="string"&&!NON_SERVICE_PROPERTIES.includes(te)){const ne=E.components[te];if(ne==null&&!OPTIONAL_SERVICES.includes(te))throw new CodeError(`${te} not set`,"ERR_SERVICE_MISSING");return ne}return Reflect.get(ee,te,re)},set(ee,te,re){return typeof te=="string"?E.components[te]=re:Reflect.set(ee,te,re),!0}})}function connectionGater(J={}){return{denyDialPeer:async()=>!1,denyDialMultiaddr:async E=>{const ee=E.stringTuples();return ee[0][0]===4||ee[0][0]===41?!!is_ip_private(`${ee[0][1]}`):!1},denyInboundConnection:async()=>!1,denyOutboundConnection:async()=>!1,denyInboundEncryptedConnection:async()=>!1,denyOutboundEncryptedConnection:async()=>!1,denyInboundUpgradedConnection:async()=>!1,denyOutboundUpgradedConnection:async()=>!1,filterMultiaddrForPeer:async()=>!0,...J}}var messages;(function(J){J.NOT_STARTED_YET="The libp2p node is not started yet",J.DHT_DISABLED="DHT is not available",J.PUBSUB_DISABLED="PubSub is not available",J.CONN_ENCRYPTION_REQUIRED="At least one connection encryption module is required",J.ERR_TRANSPORTS_REQUIRED="At least one transport module is required",J.ERR_PROTECTOR_REQUIRED="Private network is enforced, but no protector was provided",J.NOT_FOUND="Not found"})(messages||(messages={}));var codes$1;(function(J){J.DHT_DISABLED="ERR_DHT_DISABLED",J.ERR_PUBSUB_DISABLED="ERR_PUBSUB_DISABLED",J.PUBSUB_NOT_STARTED="ERR_PUBSUB_NOT_STARTED",J.DHT_NOT_STARTED="ERR_DHT_NOT_STARTED",J.CONN_ENCRYPTION_REQUIRED="ERR_CONN_ENCRYPTION_REQUIRED",J.ERR_TRANSPORTS_REQUIRED="ERR_TRANSPORTS_REQUIRED",J.ERR_PROTECTOR_REQUIRED="ERR_PROTECTOR_REQUIRED",J.ERR_PEER_DIAL_INTERCEPTED="ERR_PEER_DIAL_INTERCEPTED",J.ERR_CONNECTION_INTERCEPTED="ERR_CONNECTION_INTERCEPTED",J.ERR_INVALID_PROTOCOLS_FOR_STREAM="ERR_INVALID_PROTOCOLS_FOR_STREAM",J.ERR_CONNECTION_ENDED="ERR_CONNECTION_ENDED",J.ERR_CONNECTION_FAILED="ERR_CONNECTION_FAILED",J.ERR_NODE_NOT_STARTED="ERR_NODE_NOT_STARTED",J.ERR_ALREADY_ABORTED="ERR_ALREADY_ABORTED",J.ERR_TOO_MANY_ADDRESSES="ERR_TOO_MANY_ADDRESSES",J.ERR_NO_VALID_ADDRESSES="ERR_NO_VALID_ADDRESSES",J.ERR_RELAYED_DIAL="ERR_RELAYED_DIAL",J.ERR_DIALED_SELF="ERR_DIALED_SELF",J.ERR_DISCOVERED_SELF="ERR_DISCOVERED_SELF",J.ERR_DUPLICATE_TRANSPORT="ERR_DUPLICATE_TRANSPORT",J.ERR_ENCRYPTION_FAILED="ERR_ENCRYPTION_FAILED",J.ERR_HOP_REQUEST_FAILED="ERR_HOP_REQUEST_FAILED",J.ERR_INVALID_KEY="ERR_INVALID_KEY",J.ERR_INVALID_MESSAGE="ERR_INVALID_MESSAGE",J.ERR_INVALID_PARAMETERS="ERR_INVALID_PARAMETERS",J.ERR_INVALID_PEER="ERR_INVALID_PEER",J.ERR_MUXER_UNAVAILABLE="ERR_MUXER_UNAVAILABLE",J.ERR_NOT_FOUND="ERR_NOT_FOUND",J.ERR_TIMEOUT="ERR_TIMEOUT",J.ERR_TRANSPORT_UNAVAILABLE="ERR_TRANSPORT_UNAVAILABLE",J.ERR_TRANSPORT_DIAL_FAILED="ERR_TRANSPORT_DIAL_FAILED",J.ERR_UNSUPPORTED_PROTOCOL="ERR_UNSUPPORTED_PROTOCOL",J.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED="ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED",J.ERR_INVALID_MULTIADDR="ERR_INVALID_MULTIADDR",J.ERR_SIGNATURE_NOT_VALID="ERR_SIGNATURE_NOT_VALID",J.ERR_FIND_SELF="ERR_FIND_SELF",J.ERR_NO_ROUTERS_AVAILABLE="ERR_NO_ROUTERS_AVAILABLE",J.ERR_CONNECTION_NOT_MULTIPLEXED="ERR_CONNECTION_NOT_MULTIPLEXED",J.ERR_NO_DIAL_TOKENS="ERR_NO_DIAL_TOKENS",J.ERR_KEYCHAIN_REQUIRED="ERR_KEYCHAIN_REQUIRED",J.ERR_INVALID_CMS="ERR_INVALID_CMS",J.ERR_MISSING_KEYS="ERR_MISSING_KEYS",J.ERR_NO_KEY="ERR_NO_KEY",J.ERR_INVALID_KEY_NAME="ERR_INVALID_KEY_NAME",J.ERR_INVALID_KEY_TYPE="ERR_INVALID_KEY_TYPE",J.ERR_KEY_ALREADY_EXISTS="ERR_KEY_ALREADY_EXISTS",J.ERR_INVALID_KEY_SIZE="ERR_INVALID_KEY_SIZE",J.ERR_KEY_NOT_FOUND="ERR_KEY_NOT_FOUND",J.ERR_OLD_KEY_NAME_INVALID="ERR_OLD_KEY_NAME_INVALID",J.ERR_NEW_KEY_NAME_INVALID="ERR_NEW_KEY_NAME_INVALID",J.ERR_PASSWORD_REQUIRED="ERR_PASSWORD_REQUIRED",J.ERR_PEM_REQUIRED="ERR_PEM_REQUIRED",J.ERR_CANNOT_READ_KEY="ERR_CANNOT_READ_KEY",J.ERR_MISSING_PRIVATE_KEY="ERR_MISSING_PRIVATE_KEY",J.ERR_MISSING_PUBLIC_KEY="ERR_MISSING_PUBLIC_KEY",J.ERR_INVALID_OLD_PASS_TYPE="ERR_INVALID_OLD_PASS_TYPE",J.ERR_INVALID_NEW_PASS_TYPE="ERR_INVALID_NEW_PASS_TYPE",J.ERR_INVALID_PASS_LENGTH="ERR_INVALID_PASS_LENGTH",J.ERR_NOT_IMPLEMENTED="ERR_NOT_IMPLEMENTED",J.ERR_WRONG_PING_ACK="ERR_WRONG_PING_ACK",J.ERR_INVALID_RECORD="ERR_INVALID_RECORD",J.ERR_ALREADY_SUCCEEDED="ERR_ALREADY_SUCCEEDED",J.ERR_NO_HANDLER_FOR_PROTOCOL="ERR_NO_HANDLER_FOR_PROTOCOL",J.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS="ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS",J.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS="ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS",J.ERR_CONNECTION_DENIED="ERR_CONNECTION_DENIED",J.ERR_TRANSFER_LIMIT_EXCEEDED="ERR_TRANSFER_LIMIT_EXCEEDED"})(codes$1||(codes$1={}));const DefaultConfig={addresses:{listen:[],announce:[],noAnnounce:[],announceFilter:J=>J},connectionManager:{resolvers:{dnsaddr:dnsaddrResolver},addressSorter:publicAddressesFirst},transportManager:{faultTolerance:FaultTolerance.FATAL_ALL}};function validateConfig(J){const E=mergeOptions$9(DefaultConfig,J);if(E.transports==null||E.transports.length<1)throw new CodeError(messages.ERR_TRANSPORTS_REQUIRED,codes$1.ERR_TRANSPORTS_REQUIRED);if(E.connectionProtector===null&&globalThis.process?.env?.LIBP2P_FORCE_PNET!=null)throw new CodeError(messages.ERR_PROTECTOR_REQUIRED,codes$1.ERR_PROTECTOR_REQUIRED);return E}const log$E=logger$1("libp2p:get-peer");function getPeerAddress(J){if(isPeerId(J))return{peerId:J,multiaddrs:[]};Array.isArray(J)||(J=[J]);let E;if(J.length>0){const ee=J[0].getPeerId();E=ee==null?void 0:peerIdFromString(ee),J.forEach(te=>{if(!isMultiaddr(te))throw log$E.error("multiaddr %s was invalid",te),new CodeError("Invalid Multiaddr",codes$1.ERR_INVALID_MULTIADDR);const re=te.getPeerId();if(re==null){if(E!=null)throw new CodeError("Multiaddrs must all have the same peer id or have no peer id",codes$1.ERR_INVALID_PARAMETERS)}else{const ne=peerIdFromString(re);if(E==null||!E.equals(ne))throw new CodeError("Multiaddrs must all have the same peer id or have no peer id",codes$1.ERR_INVALID_PARAMETERS)}})}return{peerId:E,multiaddrs:J}}const DIAL_TIMEOUT=3e4,INBOUND_UPGRADE_TIMEOUT=3e4,MAX_PARALLEL_DIALS=100,MAX_PEER_ADDRS_TO_DIAL=25,MAX_PARALLEL_DIALS_PER_PEER=10,MIN_CONNECTIONS=50,MAX_CONNECTIONS=300,AUTO_DIAL_INTERVAL=5e3,AUTO_DIAL_CONCURRENCY=25,AUTO_DIAL_PRIORITY=0,INBOUND_CONNECTION_THRESHOLD=5,MAX_INCOMING_PENDING_CONNECTIONS=10,log$D=logger$1("libp2p:connection-manager:auto-dial"),defaultOptions$3={minConnections:MIN_CONNECTIONS,autoDialConcurrency:AUTO_DIAL_CONCURRENCY,autoDialPriority:AUTO_DIAL_PRIORITY,autoDialInterval:AUTO_DIAL_INTERVAL};class AutoDial{connectionManager;peerStore;queue;minConnections;autoDialPriority;autoDialIntervalMs;autoDialInterval;started;constructor(E,ee){this.connectionManager=E.connectionManager,this.peerStore=E.peerStore,this.minConnections=ee.minConnections??defaultOptions$3.minConnections,this.autoDialPriority=ee.autoDialPriority??defaultOptions$3.autoDialPriority,this.autoDialIntervalMs=ee.autoDialInterval??defaultOptions$3.autoDialInterval,this.started=!1,this.queue=new PQueue({concurrency:ee.autoDialConcurrency??defaultOptions$3.autoDialConcurrency}),this.queue.addListener("error",te=>{log$D.error("error during auto-dial",te)}),E.events.addEventListener("connection:close",()=>{this.autoDial().catch(te=>{log$D.error(te)})})}isStarted(){return this.started}start(){this.autoDialInterval=setInterval(()=>{this.autoDial().catch(E=>{log$D.error("error while autodialing",E)})},this.autoDialIntervalMs),this.started=!0}afterStart(){this.autoDial().catch(E=>{log$D.error("error while autodialing",E)})}stop(){this.queue.clear(),clearInterval(this.autoDialInterval),this.started=!1}async autoDial(){if(!this.started)return;const E=this.connectionManager.getConnectionsMap(),ee=E.size,te=new PeerSet(this.connectionManager.getDialQueue().map(oe=>oe.peerId).filter(Boolean));if(ee>=this.minConnections){log$D.trace("have enough connections %d/%d",ee,this.minConnections);return}log$D("not enough connections %d/%d - will dial peers to increase the number of connections",ee,this.minConnections);const re=await this.peerStore.all(),ne=re.filter(oe=>!(oe.addresses.length===0||E.has(oe.id)||te.has(oe.id))).sort(()=>Math.random()>.5?1:-1),ie=new PeerMap;for(const oe of ne)ie.has(oe.id)||ie.set(oe.id,[...oe.tags.values()].reduce((ce,ae)=>ce+ae.value,0));const se=ne.sort((oe,ce)=>{const ae=ie.get(oe.id)??0,le=ie.get(ce.id)??0;return ae>le?-1:ae<le?1:0});log$D("selected %d/%d peers to dial",se.length,re.length);for(const oe of se)this.queue.add(async()=>{const ce=this.connectionManager.getConnectionsMap().size;if(ce>=this.minConnections){log$D("got enough connections now %d/%d",ce,this.minConnections),this.queue.clear();return}log$D("connecting to a peerStore stored peer %p",oe.id),await this.connectionManager.openConnection(oe.id,{priority:this.autoDialPriority})}).catch(ce=>{log$D.error("could not connect to peerStore stored peer",ce)})}}const log$C=logger$1("libp2p:connection-manager:connection-pruner"),defaultOptions$2={maxConnections:MAX_CONNECTIONS,allow:[]};class ConnectionPruner{maxConnections;connectionManager;peerStore;allow;events;constructor(E,ee={}){this.maxConnections=ee.maxConnections??defaultOptions$2.maxConnections,this.allow=ee.allow??defaultOptions$2.allow,this.connectionManager=E.connectionManager,this.peerStore=E.peerStore,this.events=E.events,E.events.addEventListener("connection:open",()=>{this.maybePruneConnections().catch(te=>{log$C.error(te)})})}async maybePruneConnections(){const E=this.connectionManager.getConnections(),ee=E.length,te=Math.max(ee-this.maxConnections,0);if(log$C("checking max connections limit %d/%d",ee,this.maxConnections),ee<=this.maxConnections)return;log$C("max connections limit exceeded %d/%d, pruning %d connection(s)",ee,this.maxConnections,te);const re=new PeerMap;for(const se of E){const oe=se.remotePeer;if(!re.has(oe)){re.set(oe,0);try{const ce=await this.peerStore.get(oe);re.set(oe,[...ce.tags.values()].reduce((ae,le)=>ae+le.value,0))}catch(ce){ce.code!=="ERR_NOT_FOUND"&&log$C.error("error loading peer tags",ce)}}}const ne=E.sort((se,oe)=>{const ce=re.get(se.remotePeer)??0,ae=re.get(oe.remotePeer)??0;if(ce>ae)return 1;if(ce<ae)return-1;const le=se.stat.timeline.open,ue=oe.stat.timeline.open;return le<ue?1:le>ue?-1:0}),ie=[];for(const se of ne)if(log$C("too many connections open - closing a connection to %p",se.remotePeer),this.allow.some(oe=>se.remoteAddr.toString().startsWith(oe.toString()))||ie.push(se),ie.length===te)break;await Promise.all(ie.map(async se=>{try{await se.close()}catch(oe){log$C.error(oe)}})),this.events.safeDispatchEvent("connection:prune",{detail:ie})}}const log$B=logger$1("libp2p:connection-manager:utils");async function resolveMultiaddrs(J,E){if(!J.protoNames().includes("dnsaddr"))return[J];const ee=await resolveRecord(J,E),te=(await Promise.all(ee.map(async re=>resolveMultiaddrs(re,E)))).flat().reduce((re,ne)=>(re.find(ie=>ie.equals(ne))==null&&re.push(ne),re),[]);return log$B("resolved %s to",J,te.map(re=>re.toString())),te}async function resolveRecord(J,E){try{return J=multiaddr(J.toString()),await J.resolve(E)}catch(ee){return log$B.error(`multiaddr ${J.toString()} could not be resolved`,ee),[]}}function combineSignals(...J){const E=[];for(const te of J)if(te!=null){try{setMaxListeners?.(1/0,te)}catch{}E.push(te)}const ee=anySignal(E);try{setMaxListeners?.(1/0,ee)}catch{}return ee}const log$A=logger$1("libp2p:connection-manager:dial-queue"),defaultOptions$1={addressSorter:publicAddressesFirst,maxParallelDials:MAX_PARALLEL_DIALS,maxPeerAddrsToDial:MAX_PEER_ADDRS_TO_DIAL,maxParallelDialsPerPeer:MAX_PARALLEL_DIALS_PER_PEER,dialTimeout:DIAL_TIMEOUT,resolvers:{dnsaddr:dnsaddrResolver}};class DialQueue{pendingDials;queue;peerId;peerStore;connectionGater;transportManager;addressSorter;maxPeerAddrsToDial;maxParallelDialsPerPeer;dialTimeout;inProgressDialCount;pendingDialCount;shutDownController;constructor(E,ee={}){this.addressSorter=ee.addressSorter??defaultOptions$1.addressSorter,this.maxPeerAddrsToDial=ee.maxPeerAddrsToDial??defaultOptions$1.maxPeerAddrsToDial,this.maxParallelDialsPerPeer=ee.maxParallelDialsPerPeer??defaultOptions$1.maxParallelDialsPerPeer,this.dialTimeout=ee.dialTimeout??defaultOptions$1.dialTimeout,this.peerId=E.peerId,this.peerStore=E.peerStore,this.connectionGater=E.connectionGater,this.transportManager=E.transportManager,this.shutDownController=new AbortController;try{setMaxListeners?.(1/0,this.shutDownController.signal)}catch{}this.pendingDialCount=E.metrics?.registerMetric("libp2p_dialler_pending_dials"),this.inProgressDialCount=E.metrics?.registerMetric("libp2p_dialler_in_progress_dials"),this.pendingDials=[];for(const[te,re]of Object.entries(ee.resolvers??{}))resolvers$1.set(te,re);this.queue=new PQueue({concurrency:ee.maxParallelDials??defaultOptions$1.maxParallelDials}),this.queue.on("add",()=>{this.pendingDialCount?.update(this.queue.size),this.inProgressDialCount?.update(this.queue.pending)}),this.queue.on("active",()=>{this.pendingDialCount?.update(this.queue.size),this.inProgressDialCount?.update(this.queue.pending)}),this.queue.on("completed",()=>{this.pendingDialCount?.update(this.queue.size),this.inProgressDialCount?.update(this.queue.pending)}),this.queue.on("error",te=>{log$A.error("error in dial queue",te),this.pendingDialCount?.update(this.queue.size),this.inProgressDialCount?.update(this.queue.pending)}),this.queue.on("empty",()=>{this.pendingDialCount?.update(this.queue.size),this.inProgressDialCount?.update(this.queue.pending)}),this.queue.on("idle",()=>{this.pendingDialCount?.update(this.queue.size),this.inProgressDialCount?.update(this.queue.pending)})}stop(){this.shutDownController.abort()}async dial(E,ee={}){const{peerId:te,multiaddrs:re}=getPeerAddress(E),ne=re.map(ae=>({multiaddr:ae,isCertified:!1})),ie=this.createDialAbortControllers(ee.signal);let se;try{se=await this.calculateMultiaddrs(te,ne,{...ee,signal:ie})}catch(ae){throw ie.clear(),ae}const oe=this.pendingDials.find(ae=>!!(ae.peerId!=null&&te!=null&&ae.peerId.equals(te)||se.map(({multiaddr:le})=>le.toString()).join()===ae.multiaddrs.map(le=>le.toString()).join()));if(oe!=null)return log$A("joining existing dial target for %p",te),ie.clear(),oe.promise;log$A("creating dial target for",se.map(({multiaddr:ae})=>ae.toString()));const ce={id:randomId(),status:"queued",peerId:te,multiaddrs:se.map(({multiaddr:ae})=>ae)};return ce.promise=this.performDial(ce,{...ee,signal:ie}).finally(()=>{this.pendingDials=this.pendingDials.filter(ae=>ae.id!==ce.id),ie.clear()}).catch(ae=>{throw log$A.error("dial failed to %s",ce.multiaddrs.map(le=>le.toString()).join(", "),ae),ie.aborted?new CodeError(ae.message,codes$1.ERR_TIMEOUT):ae}),this.pendingDials.push(ce),ce.promise}createDialAbortControllers(E){const ee=anySignal([AbortSignal.timeout(this.dialTimeout),this.shutDownController.signal,E]);try{setMaxListeners?.(1/0,ee)}catch{}return ee}async calculateMultiaddrs(E,ee=[],te={}){if(E!=null){if(this.peerId.equals(E))throw new CodeError("Tried to dial self",codes$1.ERR_DIALED_SELF);if(await this.connectionGater.denyDialPeer?.(E)===!0)throw new CodeError("The dial request is blocked by gater.allowDialPeer",codes$1.ERR_PEER_DIAL_INTERCEPTED);if(ee.length===0){log$A("loading multiaddrs for %p",E);try{const ae=await this.peerStore.get(E);ee.push(...ae.addresses),log$A("loaded multiaddrs for %p",E,ee.map(({multiaddr:le})=>le.toString()))}catch(ae){if(ae.code!==codes$1.ERR_NOT_FOUND)throw ae}}}const re=(await Promise.all(ee.map(async ae=>{const le=await resolveMultiaddrs(ae.multiaddr,te);return le.length===1&&le[0].equals(ae.multiaddr)?ae:le.map(ue=>({multiaddr:ue,isCertified:!1}))}))).flat(),ne=re.filter(ae=>!!this.transportManager.transportForMultiaddr(ae.multiaddr)),ie=new Map;for(const ae of ne){const le=ae.multiaddr.toString(),ue=ie.get(le);if(ue!=null){ue.isCertified=ue.isCertified||ae.isCertified||!1;continue}ie.set(le,ae)}let se=[...ie.values()];if((se.length===0||se.length>this.maxPeerAddrsToDial)&&(log$A("addresses for %p before filtering",E??"unknown peer",re.map(({multiaddr:ae})=>ae.toString())),log$A("addresses for %p after filtering",E??"unknown peer",se.map(({multiaddr:ae})=>ae.toString()))),se.length===0)throw new CodeError("The dial request has no valid addresses",codes$1.ERR_NO_VALID_ADDRESSES);if(se.length>this.maxPeerAddrsToDial)throw new CodeError("dial with more addresses than allowed",codes$1.ERR_TOO_MANY_ADDRESSES);if(E!=null){const ae=`/p2p/${E.toString()}`;se=se.map(le=>{const ue=le.multiaddr.getPeerId();return le.multiaddr.protos().pop()?.path===!0?le:ue!==E.toString()?{multiaddr:le.multiaddr.encapsulate(ae),isCertified:le.isCertified}:le})}const oe=[];for(const ae of se)this.connectionGater.denyDialMultiaddr!=null&&await this.connectionGater.denyDialMultiaddr(ae.multiaddr)||oe.push(ae);const ce=oe.sort(this.addressSorter);if(ce.length===0)throw new CodeError("The connection gater denied all addresses in the dial request",codes$1.ERR_NO_VALID_ADDRESSES);return ce}async performDial(E,ee={}){const te=E.multiaddrs.map(()=>new AbortController);try{const re=new PQueue({concurrency:this.maxParallelDialsPerPeer});re.on("error",ie=>{log$A.error("error dialling",ie)});const ne=await Promise.any(E.multiaddrs.map(async(ie,se)=>{const oe=te[se];if(oe==null)throw new CodeError("dialAction did not come with an AbortController",codes$1.ERR_INVALID_PARAMETERS);const ce=combineSignals(oe.signal,ee.signal);ce.addEventListener("abort",()=>{log$A("dial to %s aborted",ie)});const ae=pDefer();return await re.add(async()=>{if(ce.aborted){log$A("dial to %s was aborted before reaching the head of the peer dial queue",ie),ae.reject(new AbortError$5);return}await this.queue.add(async()=>{try{if(ce.aborted){log$A("dial to %s was aborted before reaching the head of the dial queue",ie),ae.reject(new AbortError$5);return}E.status="active";const le=await this.transportManager.dial(ie,{...ee,signal:ce});if(oe.signal.aborted){log$A("multiple dials succeeded, closing superfluous connection"),le.close().catch(ue=>{log$A.error("error closing superfluous connection",ue)}),ae.reject(new AbortError$5);return}te[se]=void 0,te.forEach(ue=>{ue!==void 0&&ue.abort()}),log$A("dial to %s succeeded",ie),ae.resolve(le)}catch(le){log$A.error("error during dial of %s",ie,le),ae.reject(le)}},{...ee,signal:ce}).catch(le=>{ae.reject(le)})},{signal:ce}).catch(le=>{ae.reject(le)}).finally(()=>{ce.clear()}),ae.promise}));if(ne==null)throw new CodeError("successful dial led to empty object returned from peer dial queue",codes$1.ERR_TRANSPORT_DIAL_FAILED);return E.status="success",ne}catch(re){throw E.status="error",E.multiaddrs.length===1&&re.name==="AggregateError"?re.errors[0]:re}}}function randomId(){return`${parseInt(String(Math.random()*1e9),10).toString()}${Date.now()}`}const log$z=logger$1("libp2p:connection-manager"),DEFAULT_DIAL_PRIORITY=50,defaultOptions={minConnections:MIN_CONNECTIONS,maxConnections:MAX_CONNECTIONS,inboundConnectionThreshold:INBOUND_CONNECTION_THRESHOLD,maxIncomingPendingConnections:MAX_INCOMING_PENDING_CONNECTIONS,autoDialConcurrency:AUTO_DIAL_CONCURRENCY,autoDialPriority:AUTO_DIAL_PRIORITY};class DefaultConnectionManager{started;connections;allow;deny;maxIncomingPendingConnections;incomingPendingConnections;maxConnections;dialQueue;autoDial;connectionPruner;inboundConnectionRateLimiter;peerStore;metrics;events;constructor(E,ee={}){this.maxConnections=ee.maxConnections??defaultOptions.maxConnections;const te=ee.minConnections??defaultOptions.minConnections;if(this.maxConnections<te)throw new CodeError("Connection Manager maxConnections must be greater than minConnections",codes$1.ERR_INVALID_PARAMETERS);this.connections=new PeerMap,this.started=!1,this.peerStore=E.peerStore,this.metrics=E.metrics,this.events=E.events,this.onConnect=this.onConnect.bind(this),this.onDisconnect=this.onDisconnect.bind(this),this.events.addEventListener("connection:open",this.onConnect),this.events.addEventListener("connection:close",this.onDisconnect),this.allow=(ee.allow??[]).map(re=>multiaddr(re)),this.deny=(ee.deny??[]).map(re=>multiaddr(re)),this.incomingPendingConnections=0,this.maxIncomingPendingConnections=ee.maxIncomingPendingConnections??defaultOptions.maxIncomingPendingConnections,this.inboundConnectionRateLimiter=new rateLimiterFlexible.RateLimiterMemory({points:ee.inboundConnectionThreshold??defaultOptions.inboundConnectionThreshold,duration:1}),this.autoDial=new AutoDial({connectionManager:this,peerStore:E.peerStore,events:E.events},{minConnections:te,autoDialConcurrency:ee.autoDialConcurrency??defaultOptions.autoDialConcurrency,autoDialPriority:ee.autoDialPriority??defaultOptions.autoDialPriority}),this.connectionPruner=new ConnectionPruner({connectionManager:this,peerStore:E.peerStore,events:E.events},{maxConnections:this.maxConnections,allow:this.allow}),this.dialQueue=new DialQueue({peerId:E.peerId,metrics:E.metrics,peerStore:E.peerStore,transportManager:E.transportManager,connectionGater:E.connectionGater},{addressSorter:ee.addressSorter??publicAddressesFirst,maxParallelDials:ee.maxParallelDials??MAX_PARALLEL_DIALS,maxPeerAddrsToDial:ee.maxPeerAddrsToDial??MAX_PEER_ADDRS_TO_DIAL,dialTimeout:ee.dialTimeout??DIAL_TIMEOUT,resolvers:ee.resolvers??{dnsaddr:dnsaddrResolver}})}isStarted(){return this.started}async start(){this.metrics?.registerMetricGroup("libp2p_connection_manager_connections",{calculate:()=>{const E={inbound:0,outbound:0};for(const ee of this.connections.values())for(const te of ee)te.stat.direction==="inbound"?E.inbound++:E.outbound++;return E}}),this.metrics?.registerMetricGroup("libp2p_protocol_streams_total",{label:"protocol",calculate:()=>{const E={};for(const ee of this.connections.values())for(const te of ee)for(const re of te.streams){const ne=`${re.stat.direction} ${re.stat.protocol??"unnegotiated"}`;E[ne]=(E[ne]??0)+1}return E}}),this.metrics?.registerMetricGroup("libp2p_connection_manager_protocol_streams_per_connection_90th_percentile",{label:"protocol",calculate:()=>{const E={};for(const te of this.connections.values())for(const re of te){const ne={};for(const ie of re.streams){const se=`${ie.stat.direction} ${ie.stat.protocol??"unnegotiated"}`;ne[se]=(ne[se]??0)+1}for(const[ie,se]of Object.entries(ne))E[ie]=E[ie]??[],E[ie].push(se)}const ee={};for(let[te,re]of Object.entries(E)){re=re.sort((ie,se)=>ie-se);const ne=Math.floor(re.length*.9);ee[te]=re[ne]}return ee}}),this.autoDial.start(),this.started=!0,log$z("started")}async afterStart(){Promise.resolve().then(async()=>{const E=[];for(const ee of await this.peerStore.all())ee.tags.has(KEEP_ALIVE)&&E.push(ee.id);await Promise.all(E.map(async ee=>{await this.openConnection(ee).catch(te=>{log$z.error(te)})}))}).catch(E=>{log$z.error(E)}),this.autoDial.afterStart()}async stop(){this.dialQueue.stop(),this.autoDial.stop();const E=[];for(const ee of this.connections.values())for(const te of ee)E.push((async()=>{try{await te.close()}catch(re){log$z.error(re)}})());log$z("closing %d connections",E.length),await Promise.all(E),this.connections.clear(),log$z("stopped")}onConnect(E){this._onConnect(E).catch(ee=>{log$z.error(ee)})}async _onConnect(E){const{detail:ee}=E;if(!this.started){await ee.close();return}const te=ee.remotePeer,re=this.connections.get(te);let ne=!1;re!=null?re.push(ee):(ne=!0,this.connections.set(te,[ee])),te.publicKey!=null&&te.type==="RSA"&&await this.peerStore.patch(te,{publicKey:te.publicKey}),ne&&this.events.safeDispatchEvent("peer:connect",{detail:ee.remotePeer})}onDisconnect(E){const{detail:ee}=E;if(!this.started)return;const te=ee.remotePeer;let re=this.connections.get(te);re!=null&&re.length>1?(re=re.filter(ne=>ne.id!==ee.id),this.connections.set(te,re)):re!=null&&(this.connections.delete(te),this.events.safeDispatchEvent("peer:disconnect",{detail:ee.remotePeer}))}getConnections(E){if(E!=null)return this.connections.get(E)??[];let ee=[];for(const te of this.connections.values())ee=ee.concat(te);return ee}getConnectionsMap(){return this.connections}async openConnection(E,ee={}){if(!this.isStarted())throw new CodeError("Not started",codes$1.ERR_NODE_NOT_STARTED);const{peerId:te}=getPeerAddress(E);if(te!=null){log$z("dial %p",te);const se=this.getConnections(te);if(se.length>0)return log$z("had an existing connection to %p",te),se[0]}const re=await this.dialQueue.dial(E,{...ee,priority:ee.priority??DEFAULT_DIAL_PRIORITY});let ne=this.connections.get(re.remotePeer);ne==null&&(ne=[],this.connections.set(re.remotePeer,ne));let ie=!1;for(const se of ne)se.id===re.id&&(ie=!0);return ie||ne.push(re),re}async closeConnections(E){const ee=this.connections.get(E)??[];await Promise.all(ee.map(async te=>{await te.close()}))}async acceptIncomingConnection(E){if(this.deny.some(ee=>E.remoteAddr.toString().startsWith(ee.toString())))return log$z("connection from %s refused - connection remote address was in deny list",E.remoteAddr),!1;if(this.allow.some(ee=>E.remoteAddr.toString().startsWith(ee.toString())))return this.incomingPendingConnections++,!0;if(this.incomingPendingConnections===this.maxIncomingPendingConnections)return log$z("connection from %s refused - incomingPendingConnections exceeded by peer %s",E.remoteAddr),!1;if(E.remoteAddr.isThinWaistAddress()){const ee=E.remoteAddr.nodeAddress().address;try{await this.inboundConnectionRateLimiter.consume(ee,1)}catch{return log$z("connection from %s refused - inboundConnectionThreshold exceeded by host %s",ee,E.remoteAddr),!1}}return this.getConnections().length<this.maxConnections?(this.incomingPendingConnections++,!0):(log$z("connection from %s refused - maxConnections exceeded",E.remoteAddr),!1)}afterUpgradeInbound(){this.incomingPendingConnections--}getDialQueue(){return this.dialQueue.pendingDials}}async function*storeAddresses(J,E){yield*map$1(J,async ee=>(await E.merge(ee.id,{multiaddrs:ee.multiaddrs}),ee))}function uniquePeers(J){const E=new Set;return filter(J,ee=>E.has(ee.id.toString())?!1:(E.add(ee.id.toString()),!0))}async function*requirePeers(J,E=1){let ee=0;for await(const te of J)ee++,yield te;if(ee<E)throw new CodeError(`more peers required, seen: ${ee}  min: ${E}`,"NOT_FOUND")}class CompoundContentRouting{routers;started;components;constructor(E,ee){this.routers=ee.routers??[],this.started=!1,this.components=E}isStarted(){return this.started}async start(){this.started=!0}async stop(){this.started=!1}async*findProviders(E,ee={}){if(this.routers.length===0)throw new CodeError("No content routers available",codes$1.ERR_NO_ROUTERS_AVAILABLE);yield*pipe$1(merge$2(...this.routers.map(te=>te.findProviders(E,ee))),te=>storeAddresses(te,this.components.peerStore),te=>uniquePeers(te),te=>requirePeers(te))}async provide(E,ee={}){if(this.routers.length===0)throw new CodeError("No content routers available",codes$1.ERR_NO_ROUTERS_AVAILABLE);await Promise.all(this.routers.map(async te=>{await te.provide(E,ee)}))}async put(E,ee,te){if(!this.isStarted())throw new CodeError(messages.NOT_STARTED_YET,codes$1.DHT_NOT_STARTED);await Promise.all(this.routers.map(async re=>{await re.put(E,ee,te)}))}async get(E,ee){if(!this.isStarted())throw new CodeError(messages.NOT_STARTED_YET,codes$1.DHT_NOT_STARTED);return Promise.any(this.routers.map(async te=>te.get(E,ee)))}}const log$y=logger$1("libp2p:peer-routing");class DefaultPeerRouting{components;routers;constructor(E,ee){this.components=E,this.routers=ee.routers??[]}async findPeer(E,ee){if(this.routers.length===0)throw new CodeError("No peer routers available",codes$1.ERR_NO_ROUTERS_AVAILABLE);if(E.toString()===this.components.peerId.toString())throw new CodeError("Should not try to find self",codes$1.ERR_FIND_SELF);const te=await pipe$1(merge$2(...this.routers.map(re=>async function*(){try{yield await re.findPeer(E,ee)}catch(ne){log$y.error(ne)}}())),re=>filter(re,Boolean),re=>storeAddresses(re,this.components.peerStore),async re=>first(re));if(te!=null)return te;throw new CodeError(messages.NOT_FOUND,codes$1.ERR_NOT_FOUND)}async*getClosestPeers(E,ee){if(this.routers.length===0)throw new CodeError("No peer routers available",codes$1.ERR_NO_ROUTERS_AVAILABLE);yield*pipe$1(merge$2(...this.routers.map(te=>te.getClosestPeers(E,ee))),te=>storeAddresses(te,this.components.peerStore),te=>uniquePeers(te),te=>requirePeers(te))}}const log$x=logger$1("libp2p:registrar"),DEFAULT_MAX_INBOUND_STREAMS$1=32,DEFAULT_MAX_OUTBOUND_STREAMS$1=64;class DefaultRegistrar{topologies;handlers;components;constructor(E){this.topologies=new Map,this.handlers=new Map,this.components=E,this._onDisconnect=this._onDisconnect.bind(this),this._onPeerUpdate=this._onPeerUpdate.bind(this),this._onConnect=this._onConnect.bind(this),this.components.events.addEventListener("peer:disconnect",this._onDisconnect),this.components.events.addEventListener("peer:connect",this._onConnect),this.components.events.addEventListener("peer:update",this._onPeerUpdate)}getProtocols(){return Array.from(new Set([...this.handlers.keys()])).sort()}getHandler(E){const ee=this.handlers.get(E);if(ee==null)throw new CodeError(`No handler registered for protocol ${E}`,codes$1.ERR_NO_HANDLER_FOR_PROTOCOL);return ee}getTopologies(E){const ee=this.topologies.get(E);return ee==null?[]:[...ee.values()]}async handle(E,ee,te){if(this.handlers.has(E))throw new CodeError(`Handler already registered for protocol ${E}`,codes$1.ERR_PROTOCOL_HANDLER_ALREADY_REGISTERED);const re=mergeOptions$9.bind({ignoreUndefined:!0})({maxInboundStreams:DEFAULT_MAX_INBOUND_STREAMS$1,maxOutboundStreams:DEFAULT_MAX_OUTBOUND_STREAMS$1},te);this.handlers.set(E,{handler:ee,options:re}),await this.components.peerStore.merge(this.components.peerId,{protocols:[E]})}async unhandle(E){const ee=Array.isArray(E)?E:[E];ee.forEach(te=>{this.handlers.delete(te)}),await this.components.peerStore.patch(this.components.peerId,{protocols:ee})}async register(E,ee){if(!isTopology(ee))throw log$x.error("topology must be an instance of interfaces/topology"),new CodeError("topology must be an instance of interfaces/topology",codes$1.ERR_INVALID_PARAMETERS);const te=`${(Math.random()*1e9).toString(36)}${Date.now()}`;let re=this.topologies.get(E);return re==null&&(re=new Map,this.topologies.set(E,re)),re.set(te,ee),await ee.setRegistrar(this),te}unregister(E){for(const[ee,te]of this.topologies.entries())te.has(E)&&(te.delete(E),te.size===0&&this.topologies.delete(ee))}_onDisconnect(E){const ee=E.detail;this.components.peerStore.get(ee).then(te=>{for(const re of te.protocols){const ne=this.topologies.get(re);if(ne!=null)for(const ie of ne.values())ie.onDisconnect(ee)}}).catch(te=>{te.code!==codes$1.ERR_NOT_FOUND&&log$x.error("could not inform topologies of disconnecting peer %p",ee,te)})}_onConnect(E){const ee=E.detail;this.components.peerStore.get(ee).then(te=>{const re=this.components.connectionManager.getConnections(te.id)[0];if(re==null){log$x("peer %p connected but the connection manager did not have a connection",te);return}for(const ne of te.protocols){const ie=this.topologies.get(ne);if(ie!=null)for(const se of ie.values())se.onConnect(ee,re)}}).catch(te=>{te.code!==codes$1.ERR_NOT_FOUND&&log$x.error("could not inform topologies of connecting peer %p",ee,te)})}_onPeerUpdate(E){const{peer:ee,previous:te}=E.detail,re=(te?.protocols??[]).filter(ie=>!ee.protocols.includes(ie)),ne=ee.protocols.filter(ie=>!(te?.protocols??[]).includes(ie));for(const ie of re){const se=this.topologies.get(ie);if(se!=null)for(const oe of se.values())oe.onDisconnect(ee.id)}for(const ie of ne){const se=this.topologies.get(ie);if(se!=null)for(const oe of se.values()){const ce=this.components.connectionManager.getConnections(ee.id)[0];ce!=null&&oe.onConnect(ee.id,ce)}}}}const log$w=logger$1("libp2p:transports");class DefaultTransportManager{components;transports;listeners;faultTolerance;started;constructor(E,ee={}){this.components=E,this.started=!1,this.transports=new Map,this.listeners=trackedMap({name:"libp2p_transport_manager_listeners",metrics:this.components.metrics}),this.faultTolerance=ee.faultTolerance??FaultTolerance.FATAL_ALL}add(E){const ee=E[Symbol.toStringTag];if(ee==null)throw new CodeError("Transport must have a valid tag",codes$1.ERR_INVALID_KEY);if(this.transports.has(ee))throw new CodeError(`There is already a transport with the tag ${ee}`,codes$1.ERR_DUPLICATE_TRANSPORT);log$w("adding transport %s",ee),this.transports.set(ee,E),this.listeners.has(ee)||this.listeners.set(ee,[])}isStarted(){return this.started}start(){this.started=!0}async afterStart(){const E=this.components.addressManager.getListenAddrs();await this.listen(E)}async stop(){const E=[];for(const[ee,te]of this.listeners)for(log$w("closing listeners for %s",ee);te.length>0;){const re=te.pop();re!=null&&E.push(re.close())}await Promise.all(E),log$w("all listeners closed");for(const ee of this.listeners.keys())this.listeners.set(ee,[]);this.started=!1}async dial(E,ee){const te=this.transportForMultiaddr(E);if(te==null)throw new CodeError(`No transport available for address ${String(E)}`,codes$1.ERR_TRANSPORT_UNAVAILABLE);try{return await te.dial(E,{...ee,upgrader:this.components.upgrader})}catch(re){throw re.code==null&&(re.code=codes$1.ERR_TRANSPORT_DIAL_FAILED),re}}getAddrs(){let E=[];for(const ee of this.listeners.values())for(const te of ee)E=[...E,...te.getAddrs()];return E}getTransports(){return Array.of(...this.transports.values())}getListeners(){return Array.of(...this.listeners.values()).flat()}transportForMultiaddr(E){for(const ee of this.transports.values())if(ee.filter([E]).length>0)return ee}async listen(E){if(E==null||E.length===0){log$w("no addresses were provided for listening, this node is dial only");return}const ee=[];for(const[te,re]of this.transports.entries()){const ne=re.filter(E),ie=[];for(const se of ne){log$w("creating listener for %s on %s",te,se);const oe=re.createListener({upgrader:this.components.upgrader});let ce=this.listeners.get(te)??[];ce==null&&(ce=[],this.listeners.set(te,ce)),ce.push(oe),oe.addEventListener("listening",()=>{this.components.events.safeDispatchEvent("transport:listening",{detail:oe})}),oe.addEventListener("close",()=>{const ae=ce.findIndex(le=>le===oe);ce.splice(ae,1),this.components.events.safeDispatchEvent("transport:close",{detail:oe})}),ie.push(oe.listen(se))}if(ie.length===0){ee.push(te);continue}if((await Promise.allSettled(ie)).find(se=>se.status==="fulfilled")==null&&this.faultTolerance!==FaultTolerance.NO_FATAL)throw new CodeError(`Transport (${te}) could not listen on any available address`,codes$1.ERR_NO_VALID_ADDRESSES)}if(ee.length===this.transports.size){const te=`no valid addresses were provided for transports [${ee.join(", ")}]`;if(this.faultTolerance===FaultTolerance.FATAL_ALL)throw new CodeError(te,codes$1.ERR_NO_VALID_ADDRESSES);log$w(`libp2p in dial mode only: ${te}`)}}async remove(E){log$w("removing %s",E);for(const ee of this.listeners.get(E)??[])await ee.close();this.transports.delete(E),this.listeners.delete(E)}async removeAll(){const E=[];for(const ee of this.transports.keys())E.push(this.remove(ee));await Promise.all(E)}}const log$v=logger$1("libp2p:connection");class ConnectionImpl{id;remoteAddr;remotePeer;stat;tags;_newStream;_close;_getStreams;_closing;constructor(E){const{remoteAddr:ee,remotePeer:te,newStream:re,close:ne,getStreams:ie,stat:se}=E;this.id=`${parseInt(String(Math.random()*1e9)).toString(36)}${Date.now()}`,this.remoteAddr=ee,this.remotePeer=te,this.stat={...se,status:OPEN},this._newStream=re,this._close=ne,this._getStreams=ie,this.tags=[],this._closing=!1}[Symbol.toStringTag]="Connection";[symbol]=!0;get streams(){return this._getStreams()}async newStream(E,ee){if(this.stat.status===CLOSING)throw new CodeError("the connection is being closed","ERR_CONNECTION_BEING_CLOSED");if(this.stat.status===CLOSED)throw new CodeError("the connection is closed","ERR_CONNECTION_CLOSED");Array.isArray(E)||(E=[E]);const te=await this._newStream(E,ee);return te.stat.direction="outbound",te}addStream(E){E.stat.direction="inbound"}removeStream(E){}async close(){if(!(this.stat.status===CLOSED||this._closing)){this.stat.status=CLOSING;try{this.streams.forEach(E=>{E.close()})}catch(E){log$v.error(E)}this._closing=!0,await this._close(),this._closing=!1,this.stat.timeline.close=Date.now(),this.stat.status=CLOSED}}}function createConnection(J){return new ConnectionImpl(J)}const log$u=logger$1("libp2p:upgrader");function findIncomingStreamLimit(J,E){try{const{options:ee}=E.getHandler(J);return ee.maxInboundStreams}catch(ee){if(ee.code!==codes$1.ERR_NO_HANDLER_FOR_PROTOCOL)throw ee}return DEFAULT_MAX_INBOUND_STREAMS$1}function findOutgoingStreamLimit(J,E){try{const{options:ee}=E.getHandler(J);return ee.maxOutboundStreams}catch(ee){if(ee.code!==codes$1.ERR_NO_HANDLER_FOR_PROTOCOL)throw ee}return DEFAULT_MAX_OUTBOUND_STREAMS$1}function countStreams(J,E,ee){let te=0;return ee.streams.forEach(re=>{re.stat.direction===E&&re.stat.protocol===J&&te++}),te}class DefaultUpgrader{components;connectionEncryption;muxers;inboundUpgradeTimeout;events;constructor(E,ee){this.components=E,this.connectionEncryption=new Map,ee.connectionEncryption.forEach(te=>{this.connectionEncryption.set(te.protocol,te)}),this.muxers=new Map,ee.muxers.forEach(te=>{this.muxers.set(te.protocol,te)}),this.inboundUpgradeTimeout=ee.inboundUpgradeTimeout??INBOUND_UPGRADE_TIMEOUT,this.events=E.events}async shouldBlockConnection(E,ee,te){const re=this.components.connectionGater[te];if(re!==void 0&&await re(E,ee))throw new CodeError(`The multiaddr connection is blocked by gater.${te}`,codes$1.ERR_CONNECTION_INTERCEPTED)}async upgradeInbound(E,ee){if(!await this.components.connectionManager.acceptIncomingConnection(E))throw new CodeError("connection denied",codes$1.ERR_CONNECTION_DENIED);let te,re,ne,ie,se;const oe=anySignal([AbortSignal.timeout(this.inboundUpgradeTimeout)]);try{setMaxListeners?.(1/0,oe)}catch{}try{const ce=abortableDuplex(E,oe);if(E.source=ce.source,E.sink=ce.sink,await this.components.connectionGater.denyInboundConnection?.(E)===!0)throw new CodeError("The multiaddr connection is blocked by gater.acceptConnection",codes$1.ERR_CONNECTION_INTERCEPTED);this.components.metrics?.trackMultiaddrConnection(E),log$u("starting the inbound connection upgrade");let ae=E;if(ee?.skipProtection!==!0){const le=this.components.connectionProtector;le!=null&&(log$u("protecting the inbound connection"),ae=await le.protect(E))}try{if(te=ae,ee?.skipEncryption!==!0){({conn:te,remotePeer:re,protocol:se}=await this._encryptInbound(ae));const le={...ae,...te};await this.shouldBlockConnection(re,le,"denyInboundEncryptedConnection")}else{const le=E.remoteAddr.getPeerId();if(le==null)throw new CodeError("inbound connection that skipped encryption must have a peer id",codes$1.ERR_INVALID_MULTIADDR);const ue=peerIdFromString(le);se="native",re=ue}if(ne=te,ee?.muxerFactory!=null)ie=ee.muxerFactory;else if(this.muxers.size>0){const le=await this._multiplexInbound({...ae,...te},this.muxers);ie=le.muxerFactory,ne=le.stream}}catch(le){throw log$u.error("Failed to upgrade inbound connection",le),le}return await this.shouldBlockConnection(re,E,"denyInboundUpgradedConnection"),log$u("Successfully upgraded inbound connection"),this._createConnection({cryptoProtocol:se,direction:"inbound",maConn:E,upgradedConn:ne,muxerFactory:ie,remotePeer:re})}finally{this.components.connectionManager.afterUpgradeInbound(),oe.clear()}}async upgradeOutbound(E,ee){const te=E.remoteAddr.getPeerId();let re;te!=null&&(re=peerIdFromString(te),await this.shouldBlockConnection(re,E,"denyOutboundConnection"));let ne,ie,se,oe,ce;this.components.metrics?.trackMultiaddrConnection(E),log$u("Starting the outbound connection upgrade");let ae=E;if(ee?.skipProtection!==!0){const le=this.components.connectionProtector;le!=null&&(ae=await le.protect(E))}try{if(ne=ae,ee?.skipEncryption!==!0){({conn:ne,remotePeer:ie,protocol:oe}=await this._encryptOutbound(ae,re));const le={...ae,...ne};await this.shouldBlockConnection(ie,le,"denyOutboundEncryptedConnection")}else{if(re==null)throw new CodeError("Encryption was skipped but no peer id was passed",codes$1.ERR_INVALID_PEER);oe="native",ie=re}if(se=ne,ee?.muxerFactory!=null)ce=ee.muxerFactory;else if(this.muxers.size>0){const le=await this._multiplexOutbound({...ae,...ne},this.muxers);ce=le.muxerFactory,se=le.stream}}catch(le){throw log$u.error("Failed to upgrade outbound connection",le),await E.close(le),le}return await this.shouldBlockConnection(ie,E,"denyOutboundUpgradedConnection"),log$u("Successfully upgraded outbound connection"),this._createConnection({cryptoProtocol:oe,direction:"outbound",maConn:E,upgradedConn:se,muxerFactory:ce,remotePeer:ie})}_createConnection(E){const{cryptoProtocol:ee,direction:te,maConn:re,upgradedConn:ne,remotePeer:ie,muxerFactory:se}=E;let oe,ce,ae;se!=null&&(oe=se.createStreamMuxer({direction:te,onIncomingStream:he=>{ae!=null&&Promise.resolve().then(async()=>{const pe=this.components.registrar.getProtocols(),{stream:de,protocol:fe}=await handle(he,pe);if(log$u("%s: incoming stream opened on %s",te,fe),ae==null)return;const me=findIncomingStreamLimit(fe,this.components.registrar);if(countStreams(fe,"inbound",ae)===me){const _e=new CodeError(`Too many inbound protocol streams for protocol "${fe}" - limit ${me}`,codes$1.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS);throw he.abort(_e),_e}he.source=de.source,he.sink=de.sink,he.stat.protocol=fe,await this.components.peerStore.merge(ie,{protocols:[fe]}),ae.addStream(he),this.components.metrics?.trackProtocolStream(he,ae),this._onStream({connection:ae,stream:he,protocol:fe})}).catch(pe=>{log$u.error(pe),he.stat.timeline.close==null&&he.close()})},onStreamEnd:he=>{ae?.removeStream(he.id)}}),ce=async(he,pe={})=>{if(oe==null)throw new CodeError("Stream is not multiplexed",codes$1.ERR_MUXER_UNAVAILABLE);log$u("%s: starting new stream on %s",te,he);const de=await oe.newStream();try{if(pe.signal==null){log$u("No abort signal was passed while trying to negotiate protocols %s falling back to default timeout",he),pe.signal=AbortSignal.timeout(3e4);try{setMaxListeners?.(1/0,pe.signal)}catch{}}const{stream:fe,protocol:me}=await select$1(de,he,pe),_e=findOutgoingStreamLimit(me,this.components.registrar);if(countStreams(me,"outbound",ae)===_e){const be=new CodeError(`Too many outbound protocol streams for protocol "${me}" - limit ${_e}`,codes$1.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS);throw de.abort(be),be}return await this.components.peerStore.merge(ie,{protocols:[me]}),de.source=fe.source,de.sink=fe.sink,de.stat.protocol=me,this.components.metrics?.trackProtocolStream(de,ae),de}catch(fe){throw log$u.error("could not create new stream",fe),de.stat.timeline.close==null&&de.close(),fe.code!=null?fe:new CodeError(String(fe),codes$1.ERR_UNSUPPORTED_PROTOCOL)}},Promise.all([oe.sink(ne.source),ne.sink(oe.source)]).catch(he=>{log$u.error(he)}));const le=re.timeline;re.timeline=new Proxy(le,{set:(...he)=>(ae!=null&&he[1]==="close"&&he[2]!=null&&le.close==null&&(async()=>{try{ae.stat.status==="OPEN"&&await ae.close()}catch(pe){log$u.error(pe)}finally{this.events.safeDispatchEvent("connection:close",{detail:ae})}})().catch(pe=>{log$u.error(pe)}),Reflect.set(...he))}),re.timeline.upgraded=Date.now();const ue=()=>{throw new CodeError("connection is not multiplexed",codes$1.ERR_CONNECTION_NOT_MULTIPLEXED)};return ae=createConnection({remoteAddr:re.remoteAddr,remotePeer:ie,stat:{status:"OPEN",direction:te,timeline:re.timeline,multiplexer:oe?.protocol,encryption:ee},newStream:ce??ue,getStreams:()=>oe!=null?oe.streams:ue(),close:async()=>{await re.close(),oe?.close()}}),this.events.safeDispatchEvent("connection:open",{detail:ae}),ae}_onStream(E){const{connection:ee,stream:te,protocol:re}=E,{handler:ne}=this.components.registrar.getHandler(re);ne({connection:ee,stream:te})}async _encryptInbound(E){const ee=Array.from(this.connectionEncryption.keys());log$u("handling inbound crypto protocol selection",ee);try{const{stream:te,protocol:re}=await handle(E,ee,{writeBytes:!0}),ne=this.connectionEncryption.get(re);if(ne==null)throw new Error(`no crypto module found for ${re}`);return log$u("encrypting inbound connection..."),{...await ne.secureInbound(this.components.peerId,te),protocol:re}}catch(te){throw new CodeError(String(te),codes$1.ERR_ENCRYPTION_FAILED)}}async _encryptOutbound(E,ee){const te=Array.from(this.connectionEncryption.keys());log$u("selecting outbound crypto protocol",te);try{const{stream:re,protocol:ne}=await select$1(E,te,{writeBytes:!0}),ie=this.connectionEncryption.get(ne);if(ie==null)throw new Error(`no crypto module found for ${ne}`);return log$u("encrypting outbound connection to %p",ee),{...await ie.secureOutbound(this.components.peerId,re,ee),protocol:ne}}catch(re){throw new CodeError(String(re),codes$1.ERR_ENCRYPTION_FAILED)}}async _multiplexOutbound(E,ee){const te=Array.from(ee.keys());log$u("outbound selecting muxer %s",te);try{const{stream:re,protocol:ne}=await select$1(E,te,{writeBytes:!0});log$u("%s selected as muxer protocol",ne);const ie=ee.get(ne);return{stream:re,muxerFactory:ie}}catch(re){throw log$u.error("error multiplexing outbound stream",re),new CodeError(String(re),codes$1.ERR_MUXER_UNAVAILABLE)}}async _multiplexInbound(E,ee){const te=Array.from(ee.keys());log$u("inbound handling muxers %s",te);try{const{stream:re,protocol:ne}=await handle(E,te,{writeBytes:!0}),ie=ee.get(ne);return{stream:re,muxerFactory:ie}}catch(re){throw log$u.error("error multiplexing inbound stream",re),new CodeError(String(re),codes$1.ERR_MUXER_UNAVAILABLE)}}}const log$t=logger$1("libp2p");class Libp2pNode extends EventEmitter$3{peerId;peerStore;contentRouting;peerRouting;keychain;metrics;services;components;#e;constructor(E){super();const ee=new EventEmitter$3,te=ee.dispatchEvent.bind(ee);ee.dispatchEvent=oe=>{const ce=te(oe),ae=this.dispatchEvent(new CustomEvent$2(oe.type,{detail:oe.detail}));return ce||ae};try{setMaxListeners?.(1/0,ee)}catch{}this.#e=!1,this.peerId=E.peerId,this.services={};const re=this.components=defaultComponents({peerId:E.peerId,events:ee,datastore:E.datastore??new MemoryDatastore,connectionGater:connectionGater(E.connectionGater)});this.peerStore=this.configureComponent("peerStore",new PersistentPeerStore(re,{addressFilter:this.components.connectionGater.filterMultiaddrForPeer,...E.peerStore})),E.metrics!=null&&(this.metrics=this.configureComponent("metrics",E.metrics(this.components))),re.events.addEventListener("peer:update",oe=>{oe.detail.previous==null&&this.safeDispatchEvent("peer:discovery",{detail:oe.detail.peer})}),E.connectionProtector!=null&&this.configureComponent("connectionProtector",E.connectionProtector(re)),this.components.upgrader=new DefaultUpgrader(this.components,{connectionEncryption:(E.connectionEncryption??[]).map((oe,ce)=>this.configureComponent(`connection-encryption-${ce}`,oe(this.components))),muxers:(E.streamMuxers??[]).map((oe,ce)=>this.configureComponent(`stream-muxers-${ce}`,oe(this.components))),inboundUpgradeTimeout:E.connectionManager.inboundUpgradeTimeout}),this.configureComponent("transportManager",new DefaultTransportManager(this.components,E.transportManager)),this.configureComponent("connectionManager",new DefaultConnectionManager(this.components,E.connectionManager)),this.configureComponent("registrar",new DefaultRegistrar(this.components)),this.configureComponent("addressManager",new DefaultAddressManager(this.components,E.addresses));const ne=DefaultKeyChain.generateOptions();this.keychain=this.configureComponent("keyChain",new DefaultKeyChain(this.components,{...ne,...E.keychain}));const ie=(E.peerRouters??[]).map((oe,ce)=>this.configureComponent(`peer-router-${ce}`,oe(this.components)));this.peerRouting=this.components.peerRouting=this.configureComponent("peerRouting",new DefaultPeerRouting(this.components,{routers:ie}));const se=(E.contentRouters??[]).map((oe,ce)=>this.configureComponent(`content-router-${ce}`,oe(this.components)));if(this.contentRouting=this.components.contentRouting=this.configureComponent("contentRouting",new CompoundContentRouting(this.components,{routers:se})),(E.peerDiscovery??[]).forEach((oe,ce)=>{this.configureComponent(`peer-discovery-${ce}`,oe(this.components)).addEventListener("peer",ae=>{this.#t(ae)})}),E.transports.forEach((oe,ce)=>{this.components.transportManager.add(this.configureComponent(`transport-${ce}`,oe(this.components)))}),E.services!=null)for(const oe of Object.keys(E.services)){const ce=E.services[oe],ae=ce(this.components);if(ae==null){log$t.error("service factory %s returned null or undefined instance",oe);continue}this.services[oe]=ae,this.configureComponent(oe,ae),ae[contentRouting]!=null&&(log$t("registering service %s for content routing",oe),se.push(ae[contentRouting])),ae[peerRouting]!=null&&(log$t("registering service %s for peer routing",oe),ie.push(ae[peerRouting])),ae[peerDiscovery]!=null&&(log$t("registering service %s for peer discovery",oe),ae[peerDiscovery].addEventListener("peer",le=>{this.#t(le)}))}}configureComponent(E,ee){return ee==null&&log$t.error("component %s was null or undefined",E),this.components[E]=ee,ee}async start(){if(!this.#e){this.#e=!0,log$t("libp2p is starting"),(await this.keychain.listKeys()).find(E=>E.name==="self")==null&&(log$t("importing self key into keychain"),await this.keychain.importPeer("self",this.components.peerId));try{await this.components.beforeStart?.(),await this.components.start(),await this.components.afterStart?.(),this.safeDispatchEvent("start",{detail:this}),log$t("libp2p has started")}catch(E){throw log$t.error("An error occurred starting libp2p",E),await this.stop(),E}}}async stop(){this.#e&&(log$t("libp2p is stopping"),this.#e=!1,await this.components.beforeStop?.(),await this.components.stop(),await this.components.afterStop?.(),this.safeDispatchEvent("stop",{detail:this}),log$t("libp2p has stopped"))}isStarted(){return this.#e}getConnections(E){return this.components.connectionManager.getConnections(E)}getDialQueue(){return this.components.connectionManager.getDialQueue()}getPeers(){const E=new PeerSet;for(const ee of this.components.connectionManager.getConnections())E.add(ee.remotePeer);return Array.from(E)}async dial(E,ee={}){return this.components.connectionManager.openConnection(E,ee)}async dialProtocol(E,ee,te={}){if(ee==null)throw new CodeError("no protocols were provided to open a stream",codes$1.ERR_INVALID_PROTOCOLS_FOR_STREAM);if(ee=Array.isArray(ee)?ee:[ee],ee.length===0)throw new CodeError("no protocols were provided to open a stream",codes$1.ERR_INVALID_PROTOCOLS_FOR_STREAM);return(await this.dial(E,te)).newStream(ee,te)}getMultiaddrs(){return this.components.addressManager.getAddresses()}getProtocols(){return this.components.registrar.getProtocols()}async hangUp(E){isMultiaddr(E)&&(E=peerIdFromString(E.getPeerId()??"")),await this.components.connectionManager.closeConnections(E)}async getPublicKey(E,ee={}){if(log$t("getPublicKey %p",E),E.publicKey!=null)return E.publicKey;const te=await this.peerStore.get(E);if(te.id.publicKey!=null)return te.id.publicKey;const re=concat$4([fromString$5("/pk/"),E.multihash.digest]),ne=await this.contentRouting.get(re,ee);return unmarshalPublicKey(ne),await this.peerStore.patch(E,{publicKey:ne}),ne}async handle(E,ee,te){Array.isArray(E)||(E=[E]),await Promise.all(E.map(async re=>{await this.components.registrar.handle(re,ee,te)}))}async unhandle(E){Array.isArray(E)||(E=[E]),await Promise.all(E.map(async ee=>{await this.components.registrar.unhandle(ee)}))}async register(E,ee){return this.components.registrar.register(E,ee)}unregister(E){this.components.registrar.unregister(E)}#t(E){const{detail:ee}=E;if(ee.id.toString()===this.peerId.toString()){log$t.error(new Error(codes$1.ERR_DISCOVERED_SELF));return}this.components.peerStore.merge(ee.id,{multiaddrs:ee.multiaddrs,protocols:ee.protocols}).catch(te=>{log$t.error(te)})}}async function createLibp2pNode(J){if(J.peerId==null){const E=J.datastore;if(E!=null)try{const ee=new DefaultKeyChain({datastore:E},mergeOptions$9(DefaultKeyChain.generateOptions(),J.keychain));J.peerId=await ee.exportPeerId("self")}catch(ee){if(ee.code!=="ERR_NOT_FOUND")throw ee}}return J.peerId==null&&(J.peerId=await createEd25519PeerId()),new Libp2pNode(validateConfig(J))}async function createLibp2p$1(J){const E=await createLibp2pNode(J);return J.start!==!1&&await E.start(),E}class MessageCache{constructor(E,ee,te){this.gossip=E,this.msgs=new Map,this.history=[],this.notValidatedCount=0,this.msgIdToStrFn=te;for(let re=0;re<ee;re++)this.history[re]=[]}get size(){return this.msgs.size}put(E,ee,te=!1){const{msgIdStr:re}=E;return this.msgs.has(re)?!1:(this.msgs.set(re,{message:ee,validated:te,originatingPeers:new Set,iwantCounts:new Map}),this.history[0].push({...E,topic:ee.topic}),te||this.notValidatedCount++,!0)}observeDuplicate(E,ee){const te=this.msgs.get(E);te&&!te.validated&&te.originatingPeers.add(ee)}get(E){return this.msgs.get(this.msgIdToStrFn(E))?.message}getWithIWantCount(E,ee){const te=this.msgs.get(E);if(!te)return null;const re=(te.iwantCounts.get(ee)??0)+1;return te.iwantCounts.set(ee,re),{msg:te.message,count:re}}getGossipIDs(E){const ee=new Map;for(let te=0;te<this.gossip;te++)this.history[te].forEach(re=>{const ne=this.msgs.get(re.msgIdStr);if(ne&&ne.validated&&E.has(re.topic)){let ie=ee.get(re.topic);ie||(ie=[],ee.set(re.topic,ie)),ie.push(re.msgId)}});return ee}validate(E){const ee=this.msgs.get(E);if(!ee)return null;ee.validated||this.notValidatedCount--;const{message:te,originatingPeers:re}=ee;return ee.validated=!0,ee.originatingPeers=new Set,{message:te,originatingPeers:re}}shift(){this.history[this.history.length-1].forEach(E=>{const ee=this.msgs.get(E.msgIdStr);ee&&(this.msgs.delete(E.msgIdStr),ee.validated||this.notValidatedCount--)}),this.history.pop(),this.history.unshift([])}remove(E){const ee=this.msgs.get(E);return ee?(this.msgs.delete(E),ee):null}}var rpc$1={exports:{}},indexMinimal={},minimal$1={},longbits,hasRequiredLongbits;function requireLongbits(){if(hasRequiredLongbits)return longbits;hasRequiredLongbits=1,longbits=E;var J=requireMinimal$1();function E(ne,ie){this.lo=ne>>>0,this.hi=ie>>>0}var ee=E.zero=new E(0,0);ee.toNumber=function(){return 0},ee.zzEncode=ee.zzDecode=function(){return this},ee.length=function(){return 1};var te=E.zeroHash="\0\0\0\0\0\0\0\0";E.fromNumber=function(ne){if(ne===0)return ee;var ie=ne<0;ie&&(ne=-ne);var se=ne>>>0,oe=(ne-se)/4294967296>>>0;return ie&&(oe=~oe>>>0,se=~se>>>0,++se>4294967295&&(se=0,++oe>4294967295&&(oe=0))),new E(se,oe)},E.from=function(ne){if(typeof ne=="number")return E.fromNumber(ne);if(J.isString(ne))if(J.Long)ne=J.Long.fromString(ne);else return E.fromNumber(parseInt(ne,10));return ne.low||ne.high?new E(ne.low>>>0,ne.high>>>0):ee},E.prototype.toNumber=function(ne){if(!ne&&this.hi>>>31){var ie=~this.lo+1>>>0,se=~this.hi>>>0;return ie||(se=se+1>>>0),-(ie+se*4294967296)}return this.lo+this.hi*4294967296},E.prototype.toLong=function(ne){return J.Long?new J.Long(this.lo|0,this.hi|0,!!ne):{low:this.lo|0,high:this.hi|0,unsigned:!!ne}};var re=String.prototype.charCodeAt;return E.fromHash=function(ne){return ne===te?ee:new E((re.call(ne,0)|re.call(ne,1)<<8|re.call(ne,2)<<16|re.call(ne,3)<<24)>>>0,(re.call(ne,4)|re.call(ne,5)<<8|re.call(ne,6)<<16|re.call(ne,7)<<24)>>>0)},E.prototype.toHash=function(){return String.fromCharCode(this.lo&255,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,this.hi&255,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},E.prototype.zzEncode=function(){var ne=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^ne)>>>0,this.lo=(this.lo<<1^ne)>>>0,this},E.prototype.zzDecode=function(){var ne=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^ne)>>>0,this.hi=(this.hi>>>1^ne)>>>0,this},E.prototype.length=function(){var ne=this.lo,ie=(this.lo>>>28|this.hi<<4)>>>0,se=this.hi>>>24;return se===0?ie===0?ne<16384?ne<128?1:2:ne<2097152?3:4:ie<16384?ie<128?5:6:ie<2097152?7:8:se<128?9:10},longbits}var hasRequiredMinimal$1;function requireMinimal$1(){return hasRequiredMinimal$1||(hasRequiredMinimal$1=1,function(J){var E=J;E.asPromise=aspromise,E.base64=base64$3,E.EventEmitter=eventemitter,E.float=float,E.inquire=inquire_1,E.utf8=utf8$2,E.pool=pool_1,E.LongBits=requireLongbits(),E.isNode=!!(typeof commonjsGlobal<"u"&&commonjsGlobal&&commonjsGlobal.process&&commonjsGlobal.process.versions&&commonjsGlobal.process.versions.node),E.global=E.isNode&&commonjsGlobal||typeof window<"u"&&window||typeof self<"u"&&self||commonjsGlobal,E.emptyArray=Object.freeze?Object.freeze([]):[],E.emptyObject=Object.freeze?Object.freeze({}):{},E.isInteger=Number.isInteger||function(re){return typeof re=="number"&&isFinite(re)&&Math.floor(re)===re},E.isString=function(re){return typeof re=="string"||re instanceof String},E.isObject=function(re){return re&&typeof re=="object"},E.isset=E.isSet=function(re,ne){var ie=re[ne];return ie!=null&&re.hasOwnProperty(ne)?typeof ie!="object"||(Array.isArray(ie)?ie.length:Object.keys(ie).length)>0:!1},E.Buffer=function(){try{var re=E.inquire("buffer").Buffer;return re.prototype.utf8Write?re:null}catch{return null}}(),E._Buffer_from=null,E._Buffer_allocUnsafe=null,E.newBuffer=function(re){return typeof re=="number"?E.Buffer?E._Buffer_allocUnsafe(re):new E.Array(re):E.Buffer?E._Buffer_from(re):typeof Uint8Array>"u"?re:new Uint8Array(re)},E.Array=typeof Uint8Array<"u"?Uint8Array:Array,E.Long=E.global.dcodeIO&&E.global.dcodeIO.Long||E.global.Long||E.inquire("long"),E.key2Re=/^true|false|0|1$/,E.key32Re=/^-?(?:0|[1-9][0-9]*)$/,E.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,E.longToHash=function(re){return re?E.LongBits.from(re).toHash():E.LongBits.zeroHash},E.longFromHash=function(re,ne){var ie=E.LongBits.fromHash(re);return E.Long?E.Long.fromBits(ie.lo,ie.hi,ne):ie.toNumber(!!ne)};function ee(re,ne,ie){for(var se=Object.keys(ne),oe=0;oe<se.length;++oe)(re[se[oe]]===void 0||!ie)&&(re[se[oe]]=ne[se[oe]]);return re}E.merge=ee,E.lcFirst=function(re){return re.charAt(0).toLowerCase()+re.substring(1)};function te(re){function ne(ie,se){if(!(this instanceof ne))return new ne(ie,se);Object.defineProperty(this,"message",{get:function(){return ie}}),Error.captureStackTrace?Error.captureStackTrace(this,ne):Object.defineProperty(this,"stack",{value:new Error().stack||""}),se&&ee(this,se)}return(ne.prototype=Object.create(Error.prototype)).constructor=ne,Object.defineProperty(ne.prototype,"name",{get:function(){return re}}),ne.prototype.toString=function(){return this.name+": "+this.message},ne}E.newError=te,E.ProtocolError=te("ProtocolError"),E.oneOfGetter=function(re){for(var ne={},ie=0;ie<re.length;++ie)ne[re[ie]]=1;return function(){for(var se=Object.keys(this),oe=se.length-1;oe>-1;--oe)if(ne[se[oe]]===1&&this[se[oe]]!==void 0&&this[se[oe]]!==null)return se[oe]}},E.oneOfSetter=function(re){return function(ne){for(var ie=0;ie<re.length;++ie)re[ie]!==ne&&delete this[re[ie]]}},E.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},E._configure=function(){var re=E.Buffer;if(!re){E._Buffer_from=E._Buffer_allocUnsafe=null;return}E._Buffer_from=re.from!==Uint8Array.from&&re.from||function(ne,ie){return new re(ne,ie)},E._Buffer_allocUnsafe=re.allocUnsafe||function(ne){return new re(ne)}}}(minimal$1)),minimal$1}var writer,hasRequiredWriter;function requireWriter(){if(hasRequiredWriter)return writer;hasRequiredWriter=1,writer=oe;var J=requireMinimal$1(),E,ee=J.LongBits,te=J.base64,re=J.utf8;function ne(fe,me,_e){this.fn=fe,this.len=me,this.next=void 0,this.val=_e}function ie(){}function se(fe){this.head=fe.head,this.tail=fe.tail,this.len=fe.len,this.next=fe.states}function oe(){this.len=0,this.head=new ne(ie,0,0),this.tail=this.head,this.states=null}var ce=function(){return J.Buffer?function(){return(oe.create=function(){return new E})()}:function(){return new oe}};oe.create=ce(),oe.alloc=function(fe){return new J.Array(fe)},J.Array!==Array&&(oe.alloc=J.pool(oe.alloc,J.Array.prototype.subarray)),oe.prototype._push=function(fe,me,_e){return this.tail=this.tail.next=new ne(fe,me,_e),this.len+=me,this};function ae(fe,me,_e){me[_e]=fe&255}function le(fe,me,_e){for(;fe>127;)me[_e++]=fe&127|128,fe>>>=7;me[_e]=fe}function ue(fe,me){this.len=fe,this.next=void 0,this.val=me}ue.prototype=Object.create(ne.prototype),ue.prototype.fn=le,oe.prototype.uint32=function(fe){return this.len+=(this.tail=this.tail.next=new ue((fe=fe>>>0)<128?1:fe<16384?2:fe<2097152?3:fe<268435456?4:5,fe)).len,this},oe.prototype.int32=function(fe){return fe<0?this._push(he,10,ee.fromNumber(fe)):this.uint32(fe)},oe.prototype.sint32=function(fe){return this.uint32((fe<<1^fe>>31)>>>0)};function he(fe,me,_e){for(;fe.hi;)me[_e++]=fe.lo&127|128,fe.lo=(fe.lo>>>7|fe.hi<<25)>>>0,fe.hi>>>=7;for(;fe.lo>127;)me[_e++]=fe.lo&127|128,fe.lo=fe.lo>>>7;me[_e++]=fe.lo}oe.prototype.uint64=function(fe){var me=ee.from(fe);return this._push(he,me.length(),me)},oe.prototype.int64=oe.prototype.uint64,oe.prototype.sint64=function(fe){var me=ee.from(fe).zzEncode();return this._push(he,me.length(),me)},oe.prototype.bool=function(fe){return this._push(ae,1,fe?1:0)};function pe(fe,me,_e){me[_e]=fe&255,me[_e+1]=fe>>>8&255,me[_e+2]=fe>>>16&255,me[_e+3]=fe>>>24}oe.prototype.fixed32=function(fe){return this._push(pe,4,fe>>>0)},oe.prototype.sfixed32=oe.prototype.fixed32,oe.prototype.fixed64=function(fe){var me=ee.from(fe);return this._push(pe,4,me.lo)._push(pe,4,me.hi)},oe.prototype.sfixed64=oe.prototype.fixed64,oe.prototype.float=function(fe){return this._push(J.float.writeFloatLE,4,fe)},oe.prototype.double=function(fe){return this._push(J.float.writeDoubleLE,8,fe)};var de=J.Array.prototype.set?function(fe,me,_e){me.set(fe,_e)}:function(fe,me,_e){for(var be=0;be<fe.length;++be)me[_e+be]=fe[be]};return oe.prototype.bytes=function(fe){var me=fe.length>>>0;if(!me)return this._push(ae,1,0);if(J.isString(fe)){var _e=oe.alloc(me=te.length(fe));te.decode(fe,_e,0),fe=_e}return this.uint32(me)._push(de,me,fe)},oe.prototype.string=function(fe){var me=re.length(fe);return me?this.uint32(me)._push(re.write,me,fe):this._push(ae,1,0)},oe.prototype.fork=function(){return this.states=new se(this),this.head=this.tail=new ne(ie,0,0),this.len=0,this},oe.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new ne(ie,0,0),this.len=0),this},oe.prototype.ldelim=function(){var fe=this.head,me=this.tail,_e=this.len;return this.reset().uint32(_e),_e&&(this.tail.next=fe.next,this.tail=me,this.len+=_e),this},oe.prototype.finish=function(){for(var fe=this.head.next,me=this.constructor.alloc(this.len),_e=0;fe;)fe.fn(fe.val,me,_e),_e+=fe.len,fe=fe.next;return me},oe._configure=function(fe){E=fe,oe.create=ce(),E._configure()},writer}var writer_buffer,hasRequiredWriter_buffer;function requireWriter_buffer(){if(hasRequiredWriter_buffer)return writer_buffer;hasRequiredWriter_buffer=1,writer_buffer=ee;var J=requireWriter();(ee.prototype=Object.create(J.prototype)).constructor=ee;var E=requireMinimal$1();function ee(){J.call(this)}ee._configure=function(){ee.alloc=E._Buffer_allocUnsafe,ee.writeBytesBuffer=E.Buffer&&E.Buffer.prototype instanceof Uint8Array&&E.Buffer.prototype.set.name==="set"?function(re,ne,ie){ne.set(re,ie)}:function(re,ne,ie){if(re.copy)re.copy(ne,ie,0,re.length);else for(var se=0;se<re.length;)ne[ie++]=re[se++]}},ee.prototype.bytes=function(re){E.isString(re)&&(re=E._Buffer_from(re,"base64"));var ne=re.length>>>0;return this.uint32(ne),ne&&this._push(ee.writeBytesBuffer,ne,re),this};function te(re,ne,ie){re.length<40?E.utf8.write(re,ne,ie):ne.utf8Write?ne.utf8Write(re,ie):ne.write(re,ie)}return ee.prototype.string=function(re){var ne=E.Buffer.byteLength(re);return this.uint32(ne),ne&&this._push(te,ne,re),this},ee._configure(),writer_buffer}var reader,hasRequiredReader;function requireReader(){if(hasRequiredReader)return reader;hasRequiredReader=1,reader=ne;var J=requireMinimal$1(),E,ee=J.LongBits,te=J.utf8;function re(le,ue){return RangeError("index out of range: "+le.pos+" + "+(ue||1)+" > "+le.len)}function ne(le){this.buf=le,this.pos=0,this.len=le.length}var ie=typeof Uint8Array<"u"?function(le){if(le instanceof Uint8Array||Array.isArray(le))return new ne(le);throw Error("illegal buffer")}:function(le){if(Array.isArray(le))return new ne(le);throw Error("illegal buffer")},se=function(){return J.Buffer?function(le){return(ne.create=function(ue){return J.Buffer.isBuffer(ue)?new E(ue):ie(ue)})(le)}:ie};ne.create=se(),ne.prototype._slice=J.Array.prototype.subarray||J.Array.prototype.slice,ne.prototype.uint32=function(){var le=4294967295;return function(){if(le=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(le=(le|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(le=(le|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(le=(le|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(le=(le|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return le;if((this.pos+=5)>this.len)throw this.pos=this.len,re(this,10);return le}}(),ne.prototype.int32=function(){return this.uint32()|0},ne.prototype.sint32=function(){var le=this.uint32();return le>>>1^-(le&1)|0};function oe(){var le=new ee(0,0),ue=0;if(this.len-this.pos>4){for(;ue<4;++ue)if(le.lo=(le.lo|(this.buf[this.pos]&127)<<ue*7)>>>0,this.buf[this.pos++]<128)return le;if(le.lo=(le.lo|(this.buf[this.pos]&127)<<28)>>>0,le.hi=(le.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return le;ue=0}else{for(;ue<3;++ue){if(this.pos>=this.len)throw re(this);if(le.lo=(le.lo|(this.buf[this.pos]&127)<<ue*7)>>>0,this.buf[this.pos++]<128)return le}return le.lo=(le.lo|(this.buf[this.pos++]&127)<<ue*7)>>>0,le}if(this.len-this.pos>4){for(;ue<5;++ue)if(le.hi=(le.hi|(this.buf[this.pos]&127)<<ue*7+3)>>>0,this.buf[this.pos++]<128)return le}else for(;ue<5;++ue){if(this.pos>=this.len)throw re(this);if(le.hi=(le.hi|(this.buf[this.pos]&127)<<ue*7+3)>>>0,this.buf[this.pos++]<128)return le}throw Error("invalid varint encoding")}ne.prototype.bool=function(){return this.uint32()!==0};function ce(le,ue){return(le[ue-4]|le[ue-3]<<8|le[ue-2]<<16|le[ue-1]<<24)>>>0}ne.prototype.fixed32=function(){if(this.pos+4>this.len)throw re(this,4);return ce(this.buf,this.pos+=4)},ne.prototype.sfixed32=function(){if(this.pos+4>this.len)throw re(this,4);return ce(this.buf,this.pos+=4)|0};function ae(){if(this.pos+8>this.len)throw re(this,8);return new ee(ce(this.buf,this.pos+=4),ce(this.buf,this.pos+=4))}return ne.prototype.float=function(){if(this.pos+4>this.len)throw re(this,4);var le=J.float.readFloatLE(this.buf,this.pos);return this.pos+=4,le},ne.prototype.double=function(){if(this.pos+8>this.len)throw re(this,4);var le=J.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,le},ne.prototype.bytes=function(){var le=this.uint32(),ue=this.pos,he=this.pos+le;if(he>this.len)throw re(this,le);return this.pos+=le,Array.isArray(this.buf)?this.buf.slice(ue,he):ue===he?new this.buf.constructor(0):this._slice.call(this.buf,ue,he)},ne.prototype.string=function(){var le=this.bytes();return te.read(le,0,le.length)},ne.prototype.skip=function(le){if(typeof le=="number"){if(this.pos+le>this.len)throw re(this,le);this.pos+=le}else do if(this.pos>=this.len)throw re(this);while(this.buf[this.pos++]&128);return this},ne.prototype.skipType=function(le){switch(le){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(le=this.uint32()&7)!==4;)this.skipType(le);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+le+" at offset "+this.pos)}return this},ne._configure=function(le){E=le,ne.create=se(),E._configure();var ue=J.Long?"toLong":"toNumber";J.merge(ne.prototype,{int64:function(){return oe.call(this)[ue](!1)},uint64:function(){return oe.call(this)[ue](!0)},sint64:function(){return oe.call(this).zzDecode()[ue](!1)},fixed64:function(){return ae.call(this)[ue](!0)},sfixed64:function(){return ae.call(this)[ue](!1)}})},reader}var reader_buffer,hasRequiredReader_buffer;function requireReader_buffer(){if(hasRequiredReader_buffer)return reader_buffer;hasRequiredReader_buffer=1,reader_buffer=ee;var J=requireReader();(ee.prototype=Object.create(J.prototype)).constructor=ee;var E=requireMinimal$1();function ee(te){J.call(this,te)}return ee._configure=function(){E.Buffer&&(ee.prototype._slice=E.Buffer.prototype.slice)},ee.prototype.string=function(){var te=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+te,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+te,this.len))},ee._configure(),reader_buffer}var rpc={},service,hasRequiredService;function requireService(){if(hasRequiredService)return service;hasRequiredService=1,service=E;var J=requireMinimal$1();(E.prototype=Object.create(J.EventEmitter.prototype)).constructor=E;function E(ee,te,re){if(typeof ee!="function")throw TypeError("rpcImpl must be a function");J.EventEmitter.call(this),this.rpcImpl=ee,this.requestDelimited=!!te,this.responseDelimited=!!re}return E.prototype.rpcCall=function ee(te,re,ne,ie,se){if(!ie)throw TypeError("request must be specified");var oe=this;if(!se)return J.asPromise(ee,oe,te,re,ne,ie);if(!oe.rpcImpl){setTimeout(function(){se(Error("already ended"))},0);return}try{return oe.rpcImpl(te,re[oe.requestDelimited?"encodeDelimited":"encode"](ie).finish(),function(ce,ae){if(ce)return oe.emit("error",ce,te),se(ce);if(ae===null){oe.end(!0);return}if(!(ae instanceof ne))try{ae=ne[oe.responseDelimited?"decodeDelimited":"decode"](ae)}catch(le){return oe.emit("error",le,te),se(le)}return oe.emit("data",ae,te),se(null,ae)})}catch(ce){oe.emit("error",ce,te),setTimeout(function(){se(ce)},0);return}},E.prototype.end=function(ee){return this.rpcImpl&&(ee||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this},service}var hasRequiredRpc;function requireRpc(){return hasRequiredRpc||(hasRequiredRpc=1,function(J){var E=J;E.Service=requireService()}(rpc)),rpc}var roots,hasRequiredRoots;function requireRoots(){return hasRequiredRoots||(hasRequiredRoots=1,roots={}),roots}var hasRequiredIndexMinimal;function requireIndexMinimal(){return hasRequiredIndexMinimal||(hasRequiredIndexMinimal=1,function(J){var E=J;E.build="minimal",E.Writer=requireWriter(),E.BufferWriter=requireWriter_buffer(),E.Reader=requireReader(),E.BufferReader=requireReader_buffer(),E.util=requireMinimal$1(),E.rpc=requireRpc(),E.roots=requireRoots(),E.configure=ee;function ee(){E.util._configure(),E.Writer._configure(E.BufferWriter),E.Reader._configure(E.BufferReader)}ee()}(indexMinimal)),indexMinimal}var minimal,hasRequiredMinimal;function requireMinimal(){return hasRequiredMinimal||(hasRequiredMinimal=1,minimal=requireIndexMinimal()),minimal}(function(J){(function(E,ee){typeof commonjsRequire=="function"&&J&&J.exports&&(J.exports=ee(requireMinimal()))})(commonjsGlobal,function(E){var ee=E.Reader,te=E.Writer,re=E.util,ne=E.roots.default||(E.roots.default={});return ne.RPC=function(){function ie(oe){if(this.subscriptions=[],this.messages=[],oe)for(var ce=Object.keys(oe),ae=0;ae<ce.length;++ae)oe[ce[ae]]!=null&&(this[ce[ae]]=oe[ce[ae]])}ie.prototype.subscriptions=re.emptyArray,ie.prototype.messages=re.emptyArray,ie.prototype.control=null;var se;return Object.defineProperty(ie.prototype,"_control",{get:re.oneOfGetter(se=["control"]),set:re.oneOfSetter(se)}),ie.encode=function(oe,ce){if(ce||(ce=te.create()),oe.subscriptions!=null&&oe.subscriptions.length)for(var ae=0;ae<oe.subscriptions.length;++ae)ne.RPC.SubOpts.encode(oe.subscriptions[ae],ce.uint32(10).fork()).ldelim();if(oe.messages!=null&&oe.messages.length)for(var ae=0;ae<oe.messages.length;++ae)ne.RPC.Message.encode(oe.messages[ae],ce.uint32(18).fork()).ldelim();return oe.control!=null&&Object.hasOwnProperty.call(oe,"control")&&ne.RPC.ControlMessage.encode(oe.control,ce.uint32(26).fork()).ldelim(),ce},ie.decode=function(oe,ce){oe instanceof ee||(oe=ee.create(oe));for(var ae=ce===void 0?oe.len:oe.pos+ce,le=new ne.RPC;oe.pos<ae;){var ue=oe.uint32();switch(ue>>>3){case 1:le.subscriptions&&le.subscriptions.length||(le.subscriptions=[]),le.subscriptions.push(ne.RPC.SubOpts.decode(oe,oe.uint32()));break;case 2:le.messages&&le.messages.length||(le.messages=[]),le.messages.push(ne.RPC.Message.decode(oe,oe.uint32()));break;case 3:le.control=ne.RPC.ControlMessage.decode(oe,oe.uint32());break;default:oe.skipType(ue&7);break}}return le},ie.fromObject=function(oe){if(oe instanceof ne.RPC)return oe;var ce=new ne.RPC;if(oe.subscriptions){if(!Array.isArray(oe.subscriptions))throw TypeError(".RPC.subscriptions: array expected");ce.subscriptions=[];for(var ae=0;ae<oe.subscriptions.length;++ae){if(typeof oe.subscriptions[ae]!="object")throw TypeError(".RPC.subscriptions: object expected");ce.subscriptions[ae]=ne.RPC.SubOpts.fromObject(oe.subscriptions[ae])}}if(oe.messages){if(!Array.isArray(oe.messages))throw TypeError(".RPC.messages: array expected");ce.messages=[];for(var ae=0;ae<oe.messages.length;++ae){if(typeof oe.messages[ae]!="object")throw TypeError(".RPC.messages: object expected");ce.messages[ae]=ne.RPC.Message.fromObject(oe.messages[ae])}}if(oe.control!=null){if(typeof oe.control!="object")throw TypeError(".RPC.control: object expected");ce.control=ne.RPC.ControlMessage.fromObject(oe.control)}return ce},ie.toObject=function(oe,ce){ce||(ce={});var ae={};if((ce.arrays||ce.defaults)&&(ae.subscriptions=[],ae.messages=[]),oe.subscriptions&&oe.subscriptions.length){ae.subscriptions=[];for(var le=0;le<oe.subscriptions.length;++le)ae.subscriptions[le]=ne.RPC.SubOpts.toObject(oe.subscriptions[le],ce)}if(oe.messages&&oe.messages.length){ae.messages=[];for(var le=0;le<oe.messages.length;++le)ae.messages[le]=ne.RPC.Message.toObject(oe.messages[le],ce)}return oe.control!=null&&oe.hasOwnProperty("control")&&(ae.control=ne.RPC.ControlMessage.toObject(oe.control,ce),ce.oneofs&&(ae._control="control")),ae},ie.prototype.toJSON=function(){return this.constructor.toObject(this,E.util.toJSONOptions)},ie.SubOpts=function(){function oe(ae){if(ae)for(var le=Object.keys(ae),ue=0;ue<le.length;++ue)ae[le[ue]]!=null&&(this[le[ue]]=ae[le[ue]])}oe.prototype.subscribe=null,oe.prototype.topic=null;var ce;return Object.defineProperty(oe.prototype,"_subscribe",{get:re.oneOfGetter(ce=["subscribe"]),set:re.oneOfSetter(ce)}),Object.defineProperty(oe.prototype,"_topic",{get:re.oneOfGetter(ce=["topic"]),set:re.oneOfSetter(ce)}),oe.encode=function(ae,le){return le||(le=te.create()),ae.subscribe!=null&&Object.hasOwnProperty.call(ae,"subscribe")&&le.uint32(8).bool(ae.subscribe),ae.topic!=null&&Object.hasOwnProperty.call(ae,"topic")&&le.uint32(18).string(ae.topic),le},oe.decode=function(ae,le){ae instanceof ee||(ae=ee.create(ae));for(var ue=le===void 0?ae.len:ae.pos+le,he=new ne.RPC.SubOpts;ae.pos<ue;){var pe=ae.uint32();switch(pe>>>3){case 1:he.subscribe=ae.bool();break;case 2:he.topic=ae.string();break;default:ae.skipType(pe&7);break}}return he},oe.fromObject=function(ae){if(ae instanceof ne.RPC.SubOpts)return ae;var le=new ne.RPC.SubOpts;return ae.subscribe!=null&&(le.subscribe=!!ae.subscribe),ae.topic!=null&&(le.topic=String(ae.topic)),le},oe.toObject=function(ae,le){le||(le={});var ue={};return ae.subscribe!=null&&ae.hasOwnProperty("subscribe")&&(ue.subscribe=ae.subscribe,le.oneofs&&(ue._subscribe="subscribe")),ae.topic!=null&&ae.hasOwnProperty("topic")&&(ue.topic=ae.topic,le.oneofs&&(ue._topic="topic")),ue},oe.prototype.toJSON=function(){return this.constructor.toObject(this,E.util.toJSONOptions)},oe}(),ie.Message=function(){function oe(ae){if(ae)for(var le=Object.keys(ae),ue=0;ue<le.length;++ue)ae[le[ue]]!=null&&(this[le[ue]]=ae[le[ue]])}oe.prototype.from=null,oe.prototype.data=null,oe.prototype.seqno=null,oe.prototype.topic="",oe.prototype.signature=null,oe.prototype.key=null;var ce;return Object.defineProperty(oe.prototype,"_from",{get:re.oneOfGetter(ce=["from"]),set:re.oneOfSetter(ce)}),Object.defineProperty(oe.prototype,"_data",{get:re.oneOfGetter(ce=["data"]),set:re.oneOfSetter(ce)}),Object.defineProperty(oe.prototype,"_seqno",{get:re.oneOfGetter(ce=["seqno"]),set:re.oneOfSetter(ce)}),Object.defineProperty(oe.prototype,"_signature",{get:re.oneOfGetter(ce=["signature"]),set:re.oneOfSetter(ce)}),Object.defineProperty(oe.prototype,"_key",{get:re.oneOfGetter(ce=["key"]),set:re.oneOfSetter(ce)}),oe.encode=function(ae,le){return le||(le=te.create()),ae.from!=null&&Object.hasOwnProperty.call(ae,"from")&&le.uint32(10).bytes(ae.from),ae.data!=null&&Object.hasOwnProperty.call(ae,"data")&&le.uint32(18).bytes(ae.data),ae.seqno!=null&&Object.hasOwnProperty.call(ae,"seqno")&&le.uint32(26).bytes(ae.seqno),le.uint32(34).string(ae.topic),ae.signature!=null&&Object.hasOwnProperty.call(ae,"signature")&&le.uint32(42).bytes(ae.signature),ae.key!=null&&Object.hasOwnProperty.call(ae,"key")&&le.uint32(50).bytes(ae.key),le},oe.decode=function(ae,le){ae instanceof ee||(ae=ee.create(ae));for(var ue=le===void 0?ae.len:ae.pos+le,he=new ne.RPC.Message;ae.pos<ue;){var pe=ae.uint32();switch(pe>>>3){case 1:he.from=ae.bytes();break;case 2:he.data=ae.bytes();break;case 3:he.seqno=ae.bytes();break;case 4:he.topic=ae.string();break;case 5:he.signature=ae.bytes();break;case 6:he.key=ae.bytes();break;default:ae.skipType(pe&7);break}}if(!he.hasOwnProperty("topic"))throw re.ProtocolError("missing required 'topic'",{instance:he});return he},oe.fromObject=function(ae){if(ae instanceof ne.RPC.Message)return ae;var le=new ne.RPC.Message;return ae.from!=null&&(typeof ae.from=="string"?re.base64.decode(ae.from,le.from=re.newBuffer(re.base64.length(ae.from)),0):ae.from.length&&(le.from=ae.from)),ae.data!=null&&(typeof ae.data=="string"?re.base64.decode(ae.data,le.data=re.newBuffer(re.base64.length(ae.data)),0):ae.data.length&&(le.data=ae.data)),ae.seqno!=null&&(typeof ae.seqno=="string"?re.base64.decode(ae.seqno,le.seqno=re.newBuffer(re.base64.length(ae.seqno)),0):ae.seqno.length&&(le.seqno=ae.seqno)),ae.topic!=null&&(le.topic=String(ae.topic)),ae.signature!=null&&(typeof ae.signature=="string"?re.base64.decode(ae.signature,le.signature=re.newBuffer(re.base64.length(ae.signature)),0):ae.signature.length&&(le.signature=ae.signature)),ae.key!=null&&(typeof ae.key=="string"?re.base64.decode(ae.key,le.key=re.newBuffer(re.base64.length(ae.key)),0):ae.key.length&&(le.key=ae.key)),le},oe.toObject=function(ae,le){le||(le={});var ue={};return le.defaults&&(ue.topic=""),ae.from!=null&&ae.hasOwnProperty("from")&&(ue.from=le.bytes===String?re.base64.encode(ae.from,0,ae.from.length):le.bytes===Array?Array.prototype.slice.call(ae.from):ae.from,le.oneofs&&(ue._from="from")),ae.data!=null&&ae.hasOwnProperty("data")&&(ue.data=le.bytes===String?re.base64.encode(ae.data,0,ae.data.length):le.bytes===Array?Array.prototype.slice.call(ae.data):ae.data,le.oneofs&&(ue._data="data")),ae.seqno!=null&&ae.hasOwnProperty("seqno")&&(ue.seqno=le.bytes===String?re.base64.encode(ae.seqno,0,ae.seqno.length):le.bytes===Array?Array.prototype.slice.call(ae.seqno):ae.seqno,le.oneofs&&(ue._seqno="seqno")),ae.topic!=null&&ae.hasOwnProperty("topic")&&(ue.topic=ae.topic),ae.signature!=null&&ae.hasOwnProperty("signature")&&(ue.signature=le.bytes===String?re.base64.encode(ae.signature,0,ae.signature.length):le.bytes===Array?Array.prototype.slice.call(ae.signature):ae.signature,le.oneofs&&(ue._signature="signature")),ae.key!=null&&ae.hasOwnProperty("key")&&(ue.key=le.bytes===String?re.base64.encode(ae.key,0,ae.key.length):le.bytes===Array?Array.prototype.slice.call(ae.key):ae.key,le.oneofs&&(ue._key="key")),ue},oe.prototype.toJSON=function(){return this.constructor.toObject(this,E.util.toJSONOptions)},oe}(),ie.ControlMessage=function(){function oe(ce){if(this.ihave=[],this.iwant=[],this.graft=[],this.prune=[],ce)for(var ae=Object.keys(ce),le=0;le<ae.length;++le)ce[ae[le]]!=null&&(this[ae[le]]=ce[ae[le]])}return oe.prototype.ihave=re.emptyArray,oe.prototype.iwant=re.emptyArray,oe.prototype.graft=re.emptyArray,oe.prototype.prune=re.emptyArray,oe.encode=function(ce,ae){if(ae||(ae=te.create()),ce.ihave!=null&&ce.ihave.length)for(var le=0;le<ce.ihave.length;++le)ne.RPC.ControlIHave.encode(ce.ihave[le],ae.uint32(10).fork()).ldelim();if(ce.iwant!=null&&ce.iwant.length)for(var le=0;le<ce.iwant.length;++le)ne.RPC.ControlIWant.encode(ce.iwant[le],ae.uint32(18).fork()).ldelim();if(ce.graft!=null&&ce.graft.length)for(var le=0;le<ce.graft.length;++le)ne.RPC.ControlGraft.encode(ce.graft[le],ae.uint32(26).fork()).ldelim();if(ce.prune!=null&&ce.prune.length)for(var le=0;le<ce.prune.length;++le)ne.RPC.ControlPrune.encode(ce.prune[le],ae.uint32(34).fork()).ldelim();return ae},oe.decode=function(ce,ae){ce instanceof ee||(ce=ee.create(ce));for(var le=ae===void 0?ce.len:ce.pos+ae,ue=new ne.RPC.ControlMessage;ce.pos<le;){var he=ce.uint32();switch(he>>>3){case 1:ue.ihave&&ue.ihave.length||(ue.ihave=[]),ue.ihave.push(ne.RPC.ControlIHave.decode(ce,ce.uint32()));break;case 2:ue.iwant&&ue.iwant.length||(ue.iwant=[]),ue.iwant.push(ne.RPC.ControlIWant.decode(ce,ce.uint32()));break;case 3:ue.graft&&ue.graft.length||(ue.graft=[]),ue.graft.push(ne.RPC.ControlGraft.decode(ce,ce.uint32()));break;case 4:ue.prune&&ue.prune.length||(ue.prune=[]),ue.prune.push(ne.RPC.ControlPrune.decode(ce,ce.uint32()));break;default:ce.skipType(he&7);break}}return ue},oe.fromObject=function(ce){if(ce instanceof ne.RPC.ControlMessage)return ce;var ae=new ne.RPC.ControlMessage;if(ce.ihave){if(!Array.isArray(ce.ihave))throw TypeError(".RPC.ControlMessage.ihave: array expected");ae.ihave=[];for(var le=0;le<ce.ihave.length;++le){if(typeof ce.ihave[le]!="object")throw TypeError(".RPC.ControlMessage.ihave: object expected");ae.ihave[le]=ne.RPC.ControlIHave.fromObject(ce.ihave[le])}}if(ce.iwant){if(!Array.isArray(ce.iwant))throw TypeError(".RPC.ControlMessage.iwant: array expected");ae.iwant=[];for(var le=0;le<ce.iwant.length;++le){if(typeof ce.iwant[le]!="object")throw TypeError(".RPC.ControlMessage.iwant: object expected");ae.iwant[le]=ne.RPC.ControlIWant.fromObject(ce.iwant[le])}}if(ce.graft){if(!Array.isArray(ce.graft))throw TypeError(".RPC.ControlMessage.graft: array expected");ae.graft=[];for(var le=0;le<ce.graft.length;++le){if(typeof ce.graft[le]!="object")throw TypeError(".RPC.ControlMessage.graft: object expected");ae.graft[le]=ne.RPC.ControlGraft.fromObject(ce.graft[le])}}if(ce.prune){if(!Array.isArray(ce.prune))throw TypeError(".RPC.ControlMessage.prune: array expected");ae.prune=[];for(var le=0;le<ce.prune.length;++le){if(typeof ce.prune[le]!="object")throw TypeError(".RPC.ControlMessage.prune: object expected");ae.prune[le]=ne.RPC.ControlPrune.fromObject(ce.prune[le])}}return ae},oe.toObject=function(ce,ae){ae||(ae={});var le={};if((ae.arrays||ae.defaults)&&(le.ihave=[],le.iwant=[],le.graft=[],le.prune=[]),ce.ihave&&ce.ihave.length){le.ihave=[];for(var ue=0;ue<ce.ihave.length;++ue)le.ihave[ue]=ne.RPC.ControlIHave.toObject(ce.ihave[ue],ae)}if(ce.iwant&&ce.iwant.length){le.iwant=[];for(var ue=0;ue<ce.iwant.length;++ue)le.iwant[ue]=ne.RPC.ControlIWant.toObject(ce.iwant[ue],ae)}if(ce.graft&&ce.graft.length){le.graft=[];for(var ue=0;ue<ce.graft.length;++ue)le.graft[ue]=ne.RPC.ControlGraft.toObject(ce.graft[ue],ae)}if(ce.prune&&ce.prune.length){le.prune=[];for(var ue=0;ue<ce.prune.length;++ue)le.prune[ue]=ne.RPC.ControlPrune.toObject(ce.prune[ue],ae)}return le},oe.prototype.toJSON=function(){return this.constructor.toObject(this,E.util.toJSONOptions)},oe}(),ie.ControlIHave=function(){function oe(ae){if(this.messageIDs=[],ae)for(var le=Object.keys(ae),ue=0;ue<le.length;++ue)ae[le[ue]]!=null&&(this[le[ue]]=ae[le[ue]])}oe.prototype.topicID=null,oe.prototype.messageIDs=re.emptyArray;var ce;return Object.defineProperty(oe.prototype,"_topicID",{get:re.oneOfGetter(ce=["topicID"]),set:re.oneOfSetter(ce)}),oe.encode=function(ae,le){if(le||(le=te.create()),ae.topicID!=null&&Object.hasOwnProperty.call(ae,"topicID")&&le.uint32(10).string(ae.topicID),ae.messageIDs!=null&&ae.messageIDs.length)for(var ue=0;ue<ae.messageIDs.length;++ue)le.uint32(18).bytes(ae.messageIDs[ue]);return le},oe.decode=function(ae,le){ae instanceof ee||(ae=ee.create(ae));for(var ue=le===void 0?ae.len:ae.pos+le,he=new ne.RPC.ControlIHave;ae.pos<ue;){var pe=ae.uint32();switch(pe>>>3){case 1:he.topicID=ae.string();break;case 2:he.messageIDs&&he.messageIDs.length||(he.messageIDs=[]),he.messageIDs.push(ae.bytes());break;default:ae.skipType(pe&7);break}}return he},oe.fromObject=function(ae){if(ae instanceof ne.RPC.ControlIHave)return ae;var le=new ne.RPC.ControlIHave;if(ae.topicID!=null&&(le.topicID=String(ae.topicID)),ae.messageIDs){if(!Array.isArray(ae.messageIDs))throw TypeError(".RPC.ControlIHave.messageIDs: array expected");le.messageIDs=[];for(var ue=0;ue<ae.messageIDs.length;++ue)typeof ae.messageIDs[ue]=="string"?re.base64.decode(ae.messageIDs[ue],le.messageIDs[ue]=re.newBuffer(re.base64.length(ae.messageIDs[ue])),0):ae.messageIDs[ue].length&&(le.messageIDs[ue]=ae.messageIDs[ue])}return le},oe.toObject=function(ae,le){le||(le={});var ue={};if((le.arrays||le.defaults)&&(ue.messageIDs=[]),ae.topicID!=null&&ae.hasOwnProperty("topicID")&&(ue.topicID=ae.topicID,le.oneofs&&(ue._topicID="topicID")),ae.messageIDs&&ae.messageIDs.length){ue.messageIDs=[];for(var he=0;he<ae.messageIDs.length;++he)ue.messageIDs[he]=le.bytes===String?re.base64.encode(ae.messageIDs[he],0,ae.messageIDs[he].length):le.bytes===Array?Array.prototype.slice.call(ae.messageIDs[he]):ae.messageIDs[he]}return ue},oe.prototype.toJSON=function(){return this.constructor.toObject(this,E.util.toJSONOptions)},oe}(),ie.ControlIWant=function(){function oe(ce){if(this.messageIDs=[],ce)for(var ae=Object.keys(ce),le=0;le<ae.length;++le)ce[ae[le]]!=null&&(this[ae[le]]=ce[ae[le]])}return oe.prototype.messageIDs=re.emptyArray,oe.encode=function(ce,ae){if(ae||(ae=te.create()),ce.messageIDs!=null&&ce.messageIDs.length)for(var le=0;le<ce.messageIDs.length;++le)ae.uint32(10).bytes(ce.messageIDs[le]);return ae},oe.decode=function(ce,ae){ce instanceof ee||(ce=ee.create(ce));for(var le=ae===void 0?ce.len:ce.pos+ae,ue=new ne.RPC.ControlIWant;ce.pos<le;){var he=ce.uint32();switch(he>>>3){case 1:ue.messageIDs&&ue.messageIDs.length||(ue.messageIDs=[]),ue.messageIDs.push(ce.bytes());break;default:ce.skipType(he&7);break}}return ue},oe.fromObject=function(ce){if(ce instanceof ne.RPC.ControlIWant)return ce;var ae=new ne.RPC.ControlIWant;if(ce.messageIDs){if(!Array.isArray(ce.messageIDs))throw TypeError(".RPC.ControlIWant.messageIDs: array expected");ae.messageIDs=[];for(var le=0;le<ce.messageIDs.length;++le)typeof ce.messageIDs[le]=="string"?re.base64.decode(ce.messageIDs[le],ae.messageIDs[le]=re.newBuffer(re.base64.length(ce.messageIDs[le])),0):ce.messageIDs[le].length&&(ae.messageIDs[le]=ce.messageIDs[le])}return ae},oe.toObject=function(ce,ae){ae||(ae={});var le={};if((ae.arrays||ae.defaults)&&(le.messageIDs=[]),ce.messageIDs&&ce.messageIDs.length){le.messageIDs=[];for(var ue=0;ue<ce.messageIDs.length;++ue)le.messageIDs[ue]=ae.bytes===String?re.base64.encode(ce.messageIDs[ue],0,ce.messageIDs[ue].length):ae.bytes===Array?Array.prototype.slice.call(ce.messageIDs[ue]):ce.messageIDs[ue]}return le},oe.prototype.toJSON=function(){return this.constructor.toObject(this,E.util.toJSONOptions)},oe}(),ie.ControlGraft=function(){function oe(ae){if(ae)for(var le=Object.keys(ae),ue=0;ue<le.length;++ue)ae[le[ue]]!=null&&(this[le[ue]]=ae[le[ue]])}oe.prototype.topicID=null;var ce;return Object.defineProperty(oe.prototype,"_topicID",{get:re.oneOfGetter(ce=["topicID"]),set:re.oneOfSetter(ce)}),oe.encode=function(ae,le){return le||(le=te.create()),ae.topicID!=null&&Object.hasOwnProperty.call(ae,"topicID")&&le.uint32(10).string(ae.topicID),le},oe.decode=function(ae,le){ae instanceof ee||(ae=ee.create(ae));for(var ue=le===void 0?ae.len:ae.pos+le,he=new ne.RPC.ControlGraft;ae.pos<ue;){var pe=ae.uint32();switch(pe>>>3){case 1:he.topicID=ae.string();break;default:ae.skipType(pe&7);break}}return he},oe.fromObject=function(ae){if(ae instanceof ne.RPC.ControlGraft)return ae;var le=new ne.RPC.ControlGraft;return ae.topicID!=null&&(le.topicID=String(ae.topicID)),le},oe.toObject=function(ae,le){le||(le={});var ue={};return ae.topicID!=null&&ae.hasOwnProperty("topicID")&&(ue.topicID=ae.topicID,le.oneofs&&(ue._topicID="topicID")),ue},oe.prototype.toJSON=function(){return this.constructor.toObject(this,E.util.toJSONOptions)},oe}(),ie.ControlPrune=function(){function oe(ae){if(this.peers=[],ae)for(var le=Object.keys(ae),ue=0;ue<le.length;++ue)ae[le[ue]]!=null&&(this[le[ue]]=ae[le[ue]])}oe.prototype.topicID=null,oe.prototype.peers=re.emptyArray,oe.prototype.backoff=null;var ce;return Object.defineProperty(oe.prototype,"_topicID",{get:re.oneOfGetter(ce=["topicID"]),set:re.oneOfSetter(ce)}),Object.defineProperty(oe.prototype,"_backoff",{get:re.oneOfGetter(ce=["backoff"]),set:re.oneOfSetter(ce)}),oe.encode=function(ae,le){if(le||(le=te.create()),ae.topicID!=null&&Object.hasOwnProperty.call(ae,"topicID")&&le.uint32(10).string(ae.topicID),ae.peers!=null&&ae.peers.length)for(var ue=0;ue<ae.peers.length;++ue)ne.RPC.PeerInfo.encode(ae.peers[ue],le.uint32(18).fork()).ldelim();return ae.backoff!=null&&Object.hasOwnProperty.call(ae,"backoff")&&le.uint32(24).uint64(ae.backoff),le},oe.decode=function(ae,le){ae instanceof ee||(ae=ee.create(ae));for(var ue=le===void 0?ae.len:ae.pos+le,he=new ne.RPC.ControlPrune;ae.pos<ue;){var pe=ae.uint32();switch(pe>>>3){case 1:he.topicID=ae.string();break;case 2:he.peers&&he.peers.length||(he.peers=[]),he.peers.push(ne.RPC.PeerInfo.decode(ae,ae.uint32()));break;case 3:he.backoff=ae.uint64();break;default:ae.skipType(pe&7);break}}return he},oe.fromObject=function(ae){if(ae instanceof ne.RPC.ControlPrune)return ae;var le=new ne.RPC.ControlPrune;if(ae.topicID!=null&&(le.topicID=String(ae.topicID)),ae.peers){if(!Array.isArray(ae.peers))throw TypeError(".RPC.ControlPrune.peers: array expected");le.peers=[];for(var ue=0;ue<ae.peers.length;++ue){if(typeof ae.peers[ue]!="object")throw TypeError(".RPC.ControlPrune.peers: object expected");le.peers[ue]=ne.RPC.PeerInfo.fromObject(ae.peers[ue])}}return ae.backoff!=null&&(re.Long?(le.backoff=re.Long.fromValue(ae.backoff)).unsigned=!0:typeof ae.backoff=="string"?le.backoff=parseInt(ae.backoff,10):typeof ae.backoff=="number"?le.backoff=ae.backoff:typeof ae.backoff=="object"&&(le.backoff=new re.LongBits(ae.backoff.low>>>0,ae.backoff.high>>>0).toNumber(!0))),le},oe.toObject=function(ae,le){le||(le={});var ue={};if((le.arrays||le.defaults)&&(ue.peers=[]),ae.topicID!=null&&ae.hasOwnProperty("topicID")&&(ue.topicID=ae.topicID,le.oneofs&&(ue._topicID="topicID")),ae.peers&&ae.peers.length){ue.peers=[];for(var he=0;he<ae.peers.length;++he)ue.peers[he]=ne.RPC.PeerInfo.toObject(ae.peers[he],le)}return ae.backoff!=null&&ae.hasOwnProperty("backoff")&&(typeof ae.backoff=="number"?ue.backoff=le.longs===String?String(ae.backoff):ae.backoff:ue.backoff=le.longs===String?re.Long.prototype.toString.call(ae.backoff):le.longs===Number?new re.LongBits(ae.backoff.low>>>0,ae.backoff.high>>>0).toNumber(!0):ae.backoff,le.oneofs&&(ue._backoff="backoff")),ue},oe.prototype.toJSON=function(){return this.constructor.toObject(this,E.util.toJSONOptions)},oe}(),ie.PeerInfo=function(){function oe(ae){if(ae)for(var le=Object.keys(ae),ue=0;ue<le.length;++ue)ae[le[ue]]!=null&&(this[le[ue]]=ae[le[ue]])}oe.prototype.peerID=null,oe.prototype.signedPeerRecord=null;var ce;return Object.defineProperty(oe.prototype,"_peerID",{get:re.oneOfGetter(ce=["peerID"]),set:re.oneOfSetter(ce)}),Object.defineProperty(oe.prototype,"_signedPeerRecord",{get:re.oneOfGetter(ce=["signedPeerRecord"]),set:re.oneOfSetter(ce)}),oe.encode=function(ae,le){return le||(le=te.create()),ae.peerID!=null&&Object.hasOwnProperty.call(ae,"peerID")&&le.uint32(10).bytes(ae.peerID),ae.signedPeerRecord!=null&&Object.hasOwnProperty.call(ae,"signedPeerRecord")&&le.uint32(18).bytes(ae.signedPeerRecord),le},oe.decode=function(ae,le){ae instanceof ee||(ae=ee.create(ae));for(var ue=le===void 0?ae.len:ae.pos+le,he=new ne.RPC.PeerInfo;ae.pos<ue;){var pe=ae.uint32();switch(pe>>>3){case 1:he.peerID=ae.bytes();break;case 2:he.signedPeerRecord=ae.bytes();break;default:ae.skipType(pe&7);break}}return he},oe.fromObject=function(ae){if(ae instanceof ne.RPC.PeerInfo)return ae;var le=new ne.RPC.PeerInfo;return ae.peerID!=null&&(typeof ae.peerID=="string"?re.base64.decode(ae.peerID,le.peerID=re.newBuffer(re.base64.length(ae.peerID)),0):ae.peerID.length&&(le.peerID=ae.peerID)),ae.signedPeerRecord!=null&&(typeof ae.signedPeerRecord=="string"?re.base64.decode(ae.signedPeerRecord,le.signedPeerRecord=re.newBuffer(re.base64.length(ae.signedPeerRecord)),0):ae.signedPeerRecord.length&&(le.signedPeerRecord=ae.signedPeerRecord)),le},oe.toObject=function(ae,le){le||(le={});var ue={};return ae.peerID!=null&&ae.hasOwnProperty("peerID")&&(ue.peerID=le.bytes===String?re.base64.encode(ae.peerID,0,ae.peerID.length):le.bytes===Array?Array.prototype.slice.call(ae.peerID):ae.peerID,le.oneofs&&(ue._peerID="peerID")),ae.signedPeerRecord!=null&&ae.hasOwnProperty("signedPeerRecord")&&(ue.signedPeerRecord=le.bytes===String?re.base64.encode(ae.signedPeerRecord,0,ae.signedPeerRecord.length):le.bytes===Array?Array.prototype.slice.call(ae.signedPeerRecord):ae.signedPeerRecord,le.oneofs&&(ue._signedPeerRecord="signedPeerRecord")),ue},oe.prototype.toJSON=function(){return this.constructor.toObject(this,E.util.toJSONOptions)},oe}(),ie}(),ne})})(rpc$1);var rpcExports=rpc$1.exports;const cjs=getDefaultExportFromCjs(rpcExports),{RPC:RPC$1}=cjs,second$1=1e3,minute$1=60*second$1,FloodsubID="/floodsub/1.0.0",GossipsubIDv10="/meshsub/1.0.0",GossipsubIDv11="/meshsub/1.1.0",GossipsubD=6,GossipsubDlo=4,GossipsubDhi=12,GossipsubDscore=4,GossipsubDout=2,GossipsubHistoryLength=5,GossipsubHistoryGossip=3,GossipsubDlazy=6,GossipsubGossipFactor=.25,GossipsubGossipRetransmission=3,GossipsubHeartbeatInitialDelay=100,GossipsubHeartbeatInterval=second$1,GossipsubFanoutTTL=minute$1,GossipsubPrunePeers=16,GossipsubPruneBackoff=minute$1,GossipsubPruneBackoffTicks=15,GossipsubDirectConnectTicks=300,GossipsubDirectConnectInitialDelay=second$1,GossipsubOpportunisticGraftTicks=60,GossipsubOpportunisticGraftPeers=2,GossipsubGraftFloodThreshold=10*second$1,GossipsubMaxIHaveLength=5e3,GossipsubMaxIHaveMessages=10,GossipsubIWantFollowupTime=3*second$1,GossipsubSeenTTL=2*minute$1,TimeCacheDuration=120*1e3,ERR_TOPIC_VALIDATOR_REJECT="ERR_TOPIC_VALIDATOR_REJECT",ERR_TOPIC_VALIDATOR_IGNORE="ERR_TOPIC_VALIDATOR_IGNORE",ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE=0,ACCEPT_FROM_WHITELIST_MAX_MESSAGES=128,ACCEPT_FROM_WHITELIST_DURATION_MS=1e3,DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS=1e3;function shuffle(J){if(J.length<=1)return J;const E=()=>Math.floor(Math.random()*Math.floor(J.length));for(let ee=0;ee<J.length;ee++){const te=E(),re=J[ee];J[ee]=J[te],J[te]=re}return J}function messageIdToString(J){return toString$5(J,"base64")}const StrictSign="StrictSign",StrictNoSign="StrictNoSign";var TopicValidatorResult;(function(J){J.Accept="accept",J.Ignore="ignore",J.Reject="reject"})(TopicValidatorResult||(TopicValidatorResult={}));var SignaturePolicy;(function(J){J.StrictSign="StrictSign",J.StrictNoSign="StrictNoSign"})(SignaturePolicy||(SignaturePolicy={}));var PublishConfigType;(function(J){J[J.Signing=0]="Signing",J[J.Anonymous=1]="Anonymous"})(PublishConfigType||(PublishConfigType={}));var RejectReason;(function(J){J.Error="error",J.Ignore="ignore",J.Reject="reject",J.Blacklisted="blacklisted"})(RejectReason||(RejectReason={}));var ValidateError;(function(J){J.InvalidSignature="invalid_signature",J.InvalidSeqno="invalid_seqno",J.InvalidPeerId="invalid_peerid",J.SignaturePresent="signature_present",J.SeqnoPresent="seqno_present",J.FromPresent="from_present",J.TransformFailed="transform_failed"})(ValidateError||(ValidateError={}));var MessageStatus;(function(J){J.duplicate="duplicate",J.invalid="invalid",J.valid="valid"})(MessageStatus||(MessageStatus={}));function rejectReasonFromAcceptance(J){switch(J){case TopicValidatorResult.Ignore:return RejectReason.Ignore;case TopicValidatorResult.Reject:return RejectReason.Reject}}async function getPublishConfigFromPeerId(J,E){switch(J){case StrictSign:{if(!E)throw Error("Must provide PeerId");if(E.privateKey==null)throw Error("Cannot sign message, no private key present");if(E.publicKey==null)throw Error("Cannot sign message, no public key present");const ee=await unmarshalPrivateKey(E.privateKey);return{type:PublishConfigType.Signing,author:E,key:E.publicKey,privateKey:ee}}case StrictNoSign:return{type:PublishConfigType.Anonymous};default:throw new Error(`Unknown signature policy "${J}"`)}}const ERR_INVALID_PEER_SCORE_PARAMS="ERR_INVALID_PEER_SCORE_PARAMS",defaultPeerScoreParams={topics:{},topicScoreCap:10,appSpecificScore:()=>0,appSpecificWeight:10,IPColocationFactorWeight:-5,IPColocationFactorThreshold:10,IPColocationFactorWhitelist:new Set,behaviourPenaltyWeight:-10,behaviourPenaltyThreshold:0,behaviourPenaltyDecay:.2,decayInterval:1e3,decayToZero:.1,retainScore:3600*1e3},defaultTopicScoreParams={topicWeight:.5,timeInMeshWeight:1,timeInMeshQuantum:1,timeInMeshCap:3600,firstMessageDeliveriesWeight:1,firstMessageDeliveriesDecay:.5,firstMessageDeliveriesCap:2e3,meshMessageDeliveriesWeight:-1,meshMessageDeliveriesDecay:.5,meshMessageDeliveriesCap:100,meshMessageDeliveriesThreshold:20,meshMessageDeliveriesWindow:10,meshMessageDeliveriesActivation:5e3,meshFailurePenaltyWeight:-1,meshFailurePenaltyDecay:.5,invalidMessageDeliveriesWeight:-1,invalidMessageDeliveriesDecay:.3};function createPeerScoreParams(J={}){return{...defaultPeerScoreParams,...J,topics:J.topics?Object.entries(J.topics).reduce((E,[ee,te])=>(E[ee]=createTopicScoreParams(te),E),{}):{}}}function createTopicScoreParams(J={}){return{...defaultTopicScoreParams,...J}}function validatePeerScoreParams(J){for(const[E,ee]of Object.entries(J.topics))try{validateTopicScoreParams(ee)}catch(te){throw new CodeError(`invalid score parameters for topic ${E}: ${te.message}`,ERR_INVALID_PEER_SCORE_PARAMS)}if(J.topicScoreCap<0)throw new CodeError("invalid topic score cap; must be positive (or 0 for no cap)",ERR_INVALID_PEER_SCORE_PARAMS);if(J.appSpecificScore===null||J.appSpecificScore===void 0)throw new CodeError("missing application specific score function",ERR_INVALID_PEER_SCORE_PARAMS);if(J.IPColocationFactorWeight>0)throw new CodeError("invalid IPColocationFactorWeight; must be negative (or 0 to disable)",ERR_INVALID_PEER_SCORE_PARAMS);if(J.IPColocationFactorWeight!==0&&J.IPColocationFactorThreshold<1)throw new CodeError("invalid IPColocationFactorThreshold; must be at least 1",ERR_INVALID_PEER_SCORE_PARAMS);if(J.behaviourPenaltyWeight>0)throw new CodeError("invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)",ERR_INVALID_PEER_SCORE_PARAMS);if(J.behaviourPenaltyWeight!==0&&(J.behaviourPenaltyDecay<=0||J.behaviourPenaltyDecay>=1))throw new CodeError("invalid BehaviourPenaltyDecay; must be between 0 and 1",ERR_INVALID_PEER_SCORE_PARAMS);if(J.decayInterval<1e3)throw new CodeError("invalid DecayInterval; must be at least 1s",ERR_INVALID_PEER_SCORE_PARAMS);if(J.decayToZero<=0||J.decayToZero>=1)throw new CodeError("invalid DecayToZero; must be between 0 and 1",ERR_INVALID_PEER_SCORE_PARAMS)}function validateTopicScoreParams(J){if(J.topicWeight<0)throw new CodeError("invalid topic weight; must be >= 0",ERR_INVALID_PEER_SCORE_PARAMS);if(J.timeInMeshQuantum===0)throw new CodeError("invalid TimeInMeshQuantum; must be non zero",ERR_INVALID_PEER_SCORE_PARAMS);if(J.timeInMeshWeight<0)throw new CodeError("invalid TimeInMeshWeight; must be positive (or 0 to disable)",ERR_INVALID_PEER_SCORE_PARAMS);if(J.timeInMeshWeight!==0&&J.timeInMeshQuantum<=0)throw new CodeError("invalid TimeInMeshQuantum; must be positive",ERR_INVALID_PEER_SCORE_PARAMS);if(J.timeInMeshWeight!==0&&J.timeInMeshCap<=0)throw new CodeError("invalid TimeInMeshCap; must be positive",ERR_INVALID_PEER_SCORE_PARAMS);if(J.firstMessageDeliveriesWeight<0)throw new CodeError("invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)",ERR_INVALID_PEER_SCORE_PARAMS);if(J.firstMessageDeliveriesWeight!==0&&(J.firstMessageDeliveriesDecay<=0||J.firstMessageDeliveriesDecay>=1))throw new CodeError("invalid FirstMessageDeliveriesDecay; must be between 0 and 1",ERR_INVALID_PEER_SCORE_PARAMS);if(J.firstMessageDeliveriesWeight!==0&&J.firstMessageDeliveriesCap<=0)throw new CodeError("invalid FirstMessageDeliveriesCap; must be positive",ERR_INVALID_PEER_SCORE_PARAMS);if(J.meshMessageDeliveriesWeight>0)throw new CodeError("invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)",ERR_INVALID_PEER_SCORE_PARAMS);if(J.meshMessageDeliveriesWeight!==0&&(J.meshMessageDeliveriesDecay<=0||J.meshMessageDeliveriesDecay>=1))throw new CodeError("invalid MeshMessageDeliveriesDecay; must be between 0 and 1",ERR_INVALID_PEER_SCORE_PARAMS);if(J.meshMessageDeliveriesWeight!==0&&J.meshMessageDeliveriesCap<=0)throw new CodeError("invalid MeshMessageDeliveriesCap; must be positive",ERR_INVALID_PEER_SCORE_PARAMS);if(J.meshMessageDeliveriesWeight!==0&&J.meshMessageDeliveriesThreshold<=0)throw new CodeError("invalid MeshMessageDeliveriesThreshold; must be positive",ERR_INVALID_PEER_SCORE_PARAMS);if(J.meshMessageDeliveriesWindow<0)throw new CodeError("invalid MeshMessageDeliveriesWindow; must be non-negative",ERR_INVALID_PEER_SCORE_PARAMS);if(J.meshMessageDeliveriesWeight!==0&&J.meshMessageDeliveriesActivation<1e3)throw new CodeError("invalid MeshMessageDeliveriesActivation; must be at least 1s",ERR_INVALID_PEER_SCORE_PARAMS);if(J.meshFailurePenaltyWeight>0)throw new CodeError("invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)",ERR_INVALID_PEER_SCORE_PARAMS);if(J.meshFailurePenaltyWeight!==0&&(J.meshFailurePenaltyDecay<=0||J.meshFailurePenaltyDecay>=1))throw new CodeError("invalid MeshFailurePenaltyDecay; must be between 0 and 1",ERR_INVALID_PEER_SCORE_PARAMS);if(J.invalidMessageDeliveriesWeight>0)throw new CodeError("invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)",ERR_INVALID_PEER_SCORE_PARAMS);if(J.invalidMessageDeliveriesDecay<=0||J.invalidMessageDeliveriesDecay>=1)throw new CodeError("invalid InvalidMessageDeliveriesDecay; must be between 0 and 1",ERR_INVALID_PEER_SCORE_PARAMS)}const defaultPeerScoreThresholds={gossipThreshold:-10,publishThreshold:-50,graylistThreshold:-80,acceptPXThreshold:10,opportunisticGraftThreshold:20};function createPeerScoreThresholds(J={}){return{...defaultPeerScoreThresholds,...J}}function computeScore(J,E,ee,te){let re=0;Object.entries(E.topics).forEach(([ie,se])=>{const oe=ee.topics[ie];if(oe===void 0)return;let ce=0;if(se.inMesh){let he=se.meshTime/oe.timeInMeshQuantum;he>oe.timeInMeshCap&&(he=oe.timeInMeshCap),ce+=he*oe.timeInMeshWeight}let ae=se.firstMessageDeliveries;if(ae>oe.firstMessageDeliveriesCap&&(ae=oe.firstMessageDeliveriesCap),ce+=ae*oe.firstMessageDeliveriesWeight,se.meshMessageDeliveriesActive&&se.meshMessageDeliveries<oe.meshMessageDeliveriesThreshold){const he=oe.meshMessageDeliveriesThreshold-se.meshMessageDeliveries,pe=he*he;ce+=pe*oe.meshMessageDeliveriesWeight}const le=se.meshFailurePenalty;ce+=le*oe.meshFailurePenaltyWeight;const ue=se.invalidMessageDeliveries*se.invalidMessageDeliveries;ce+=ue*oe.invalidMessageDeliveriesWeight,re+=ce*oe.topicWeight}),ee.topicScoreCap>0&&re>ee.topicScoreCap&&(re=ee.topicScoreCap);const ne=ee.appSpecificScore(J);if(re+=ne*ee.appSpecificWeight,E.knownIPs.forEach(ie=>{if(ee.IPColocationFactorWhitelist.has(ie))return;const se=te.get(ie),oe=se?se.size:0;if(oe>ee.IPColocationFactorThreshold){const ce=oe-ee.IPColocationFactorThreshold,ae=ce*ce;re+=ae*ee.IPColocationFactorWeight}}),E.behaviourPenalty>ee.behaviourPenaltyThreshold){const ie=E.behaviourPenalty-ee.behaviourPenaltyThreshold,se=ie*ie;re+=se*ee.behaviourPenaltyWeight}return re}function Denque(J,ee){var ee=ee||{};this._head=0,this._tail=0,this._capacity=ee.capacity,this._capacityMask=3,this._list=new Array(4),Array.isArray(J)&&this._fromArray(J)}Denque.prototype.peekAt=function J(E){var ee=E;if(ee===(ee|0)){var te=this.size();if(!(ee>=te||ee<-te))return ee<0&&(ee+=te),ee=this._head+ee&this._capacityMask,this._list[ee]}};Denque.prototype.get=function J(E){return this.peekAt(E)};Denque.prototype.peek=function J(){if(this._head!==this._tail)return this._list[this._head]};Denque.prototype.peekFront=function J(){return this.peek()};Denque.prototype.peekBack=function J(){return this.peekAt(-1)};Object.defineProperty(Denque.prototype,"length",{get:function J(){return this.size()}});Denque.prototype.size=function J(){return this._head===this._tail?0:this._head<this._tail?this._tail-this._head:this._capacityMask+1-(this._head-this._tail)};Denque.prototype.unshift=function J(E){if(E===void 0)return this.size();var ee=this._list.length;return this._head=this._head-1+ee&this._capacityMask,this._list[this._head]=E,this._tail===this._head&&this._growArray(),this._capacity&&this.size()>this._capacity&&this.pop(),this._head<this._tail?this._tail-this._head:this._capacityMask+1-(this._head-this._tail)};Denque.prototype.shift=function J(){var E=this._head;if(E!==this._tail){var ee=this._list[E];return this._list[E]=void 0,this._head=E+1&this._capacityMask,E<2&&this._tail>1e4&&this._tail<=this._list.length>>>2&&this._shrinkArray(),ee}};Denque.prototype.push=function J(E){if(E===void 0)return this.size();var ee=this._tail;return this._list[ee]=E,this._tail=ee+1&this._capacityMask,this._tail===this._head&&this._growArray(),this._capacity&&this.size()>this._capacity&&this.shift(),this._head<this._tail?this._tail-this._head:this._capacityMask+1-(this._head-this._tail)};Denque.prototype.pop=function J(){var E=this._tail;if(E!==this._head){var ee=this._list.length;this._tail=E-1+ee&this._capacityMask;var te=this._list[this._tail];return this._list[this._tail]=void 0,this._head<2&&E>1e4&&E<=ee>>>2&&this._shrinkArray(),te}};Denque.prototype.removeOne=function J(E){var ee=E;if(ee===(ee|0)&&this._head!==this._tail){var te=this.size(),re=this._list.length;if(!(ee>=te||ee<-te)){ee<0&&(ee+=te),ee=this._head+ee&this._capacityMask;var ne=this._list[ee],ie;if(E<te/2){for(ie=E;ie>0;ie--)this._list[ee]=this._list[ee=ee-1+re&this._capacityMask];this._list[ee]=void 0,this._head=this._head+1+re&this._capacityMask}else{for(ie=te-1-E;ie>0;ie--)this._list[ee]=this._list[ee=ee+1+re&this._capacityMask];this._list[ee]=void 0,this._tail=this._tail-1+re&this._capacityMask}return ne}}};Denque.prototype.remove=function J(E,ee){var te=E,re,ne=ee;if(te===(te|0)&&this._head!==this._tail){var ie=this.size(),se=this._list.length;if(!(te>=ie||te<-ie||ee<1)){if(te<0&&(te+=ie),ee===1||!ee)return re=new Array(1),re[0]=this.removeOne(te),re;if(te===0&&te+ee>=ie)return re=this.toArray(),this.clear(),re;te+ee>ie&&(ee=ie-te);var oe;for(re=new Array(ee),oe=0;oe<ee;oe++)re[oe]=this._list[this._head+te+oe&this._capacityMask];if(te=this._head+te&this._capacityMask,E+ee===ie){for(this._tail=this._tail-ee+se&this._capacityMask,oe=ee;oe>0;oe--)this._list[te=te+1+se&this._capacityMask]=void 0;return re}if(E===0){for(this._head=this._head+ee+se&this._capacityMask,oe=ee-1;oe>0;oe--)this._list[te=te+1+se&this._capacityMask]=void 0;return re}if(te<ie/2){for(this._head=this._head+E+ee+se&this._capacityMask,oe=E;oe>0;oe--)this.unshift(this._list[te=te-1+se&this._capacityMask]);for(te=this._head-1+se&this._capacityMask;ne>0;)this._list[te=te-1+se&this._capacityMask]=void 0,ne--;E<0&&(this._tail=te)}else{for(this._tail=te,te=te+ee+se&this._capacityMask,oe=ie-(ee+E);oe>0;oe--)this.push(this._list[te++]);for(te=this._tail;ne>0;)this._list[te=te+1+se&this._capacityMask]=void 0,ne--}return this._head<2&&this._tail>1e4&&this._tail<=se>>>2&&this._shrinkArray(),re}}};Denque.prototype.splice=function J(E,ee){var te=E;if(te===(te|0)){var re=this.size();if(te<0&&(te+=re),!(te>re))if(arguments.length>2){var ne,ie,se,oe=arguments.length,ce=this._list.length,ae=2;if(!re||te<re/2){for(ie=new Array(te),ne=0;ne<te;ne++)ie[ne]=this._list[this._head+ne&this._capacityMask];for(ee===0?(se=[],te>0&&(this._head=this._head+te+ce&this._capacityMask)):(se=this.remove(te,ee),this._head=this._head+te+ce&this._capacityMask);oe>ae;)this.unshift(arguments[--oe]);for(ne=te;ne>0;ne--)this.unshift(ie[ne-1])}else{ie=new Array(re-(te+ee));var le=ie.length;for(ne=0;ne<le;ne++)ie[ne]=this._list[this._head+te+ee+ne&this._capacityMask];for(ee===0?(se=[],te!=re&&(this._tail=this._head+te+ce&this._capacityMask)):(se=this.remove(te,ee),this._tail=this._tail-le+ce&this._capacityMask);ae<oe;)this.push(arguments[ae++]);for(ne=0;ne<le;ne++)this.push(ie[ne])}return se}else return this.remove(te,ee)}};Denque.prototype.clear=function J(){this._head=0,this._tail=0};Denque.prototype.isEmpty=function J(){return this._head===this._tail};Denque.prototype.toArray=function J(){return this._copyArray(!1)};Denque.prototype._fromArray=function J(E){for(var ee=0;ee<E.length;ee++)this.push(E[ee])};Denque.prototype._copyArray=function J(E){var ee=[],te=this._list,re=te.length,ne;if(E||this._head>this._tail){for(ne=this._head;ne<re;ne++)ee.push(te[ne]);for(ne=0;ne<this._tail;ne++)ee.push(te[ne])}else for(ne=this._head;ne<this._tail;ne++)ee.push(te[ne]);return ee};Denque.prototype._growArray=function J(){this._head&&(this._list=this._copyArray(!0),this._head=0),this._tail=this._list.length,this._list.length<<=1,this._capacityMask=this._capacityMask<<1|1};Denque.prototype._shrinkArray=function J(){this._list.length>>>=1,this._capacityMask>>>=1};var denque=Denque;const Denque$1=getDefaultExportFromCjs(denque);var DeliveryRecordStatus;(function(J){J[J.unknown=0]="unknown",J[J.valid=1]="valid",J[J.invalid=2]="invalid",J[J.ignored=3]="ignored"})(DeliveryRecordStatus||(DeliveryRecordStatus={}));class MessageDeliveries{constructor(){this.records=new Map,this.queue=new Denque$1}ensureRecord(E){let ee=this.records.get(E);if(ee)return ee;ee={status:DeliveryRecordStatus.unknown,firstSeen:Date.now(),validated:0,peers:new Set},this.records.set(E,ee);const te={msgId:E,expire:Date.now()+TimeCacheDuration};return this.queue.push(te),ee}gc(){const E=Date.now();let ee=this.queue.peekFront();for(;ee&&ee.expire<E;)this.records.delete(ee.msgId),this.queue.shift(),ee=this.queue.peekFront()}clear(){this.records.clear(),this.queue.clear()}}function removeItemsFromSet(J,E,ee=()=>!0){const te=new Set;if(E<=0)return te;for(const re of J){if(te.size>=E)break;ee(re)&&(te.add(re),J.delete(re))}return te}function removeFirstNItemsFromSet(J,E){return removeItemsFromSet(J,E,()=>!0)}class MapDef extends Map{constructor(E){super(),this.getDefault=E}getOrDefault(E){let ee=super.get(E);return ee===void 0&&(ee=this.getDefault(),this.set(E,ee)),ee}}const log$s=logger$1("libp2p:gossipsub:score");class PeerScore{constructor(E,ee,te){this.params=E,this.metrics=ee,this.peerStats=new Map,this.peerIPs=new MapDef(()=>new Set),this.scoreCache=new Map,this.deliveryRecords=new MessageDeliveries,validatePeerScoreParams(E),this.scoreCacheValidityMs=te.scoreCacheValidityMs,this.computeScore=te.computeScore??computeScore}get size(){return this.peerStats.size}start(){if(this._backgroundInterval){log$s("Peer score already running");return}this._backgroundInterval=setInterval(()=>this.background(),this.params.decayInterval),log$s("started")}stop(){if(!this._backgroundInterval){log$s("Peer score already stopped");return}clearInterval(this._backgroundInterval),delete this._backgroundInterval,this.peerIPs.clear(),this.peerStats.clear(),this.deliveryRecords.clear(),log$s("stopped")}background(){this.refreshScores(),this.deliveryRecords.gc()}dumpPeerScoreStats(){return Object.fromEntries(Array.from(this.peerStats.entries()).map(([E,ee])=>[E,ee]))}refreshScores(){const E=Date.now(),ee=this.params.decayToZero;this.peerStats.forEach((te,re)=>{if(!te.connected){E>te.expire&&(this.removeIPsForPeer(re,te.knownIPs),this.peerStats.delete(re),this.scoreCache.delete(re));return}Object.entries(te.topics).forEach(([ne,ie])=>{const se=this.params.topics[ne];se!==void 0&&(ie.firstMessageDeliveries*=se.firstMessageDeliveriesDecay,ie.firstMessageDeliveries<ee&&(ie.firstMessageDeliveries=0),ie.meshMessageDeliveries*=se.meshMessageDeliveriesDecay,ie.meshMessageDeliveries<ee&&(ie.meshMessageDeliveries=0),ie.meshFailurePenalty*=se.meshFailurePenaltyDecay,ie.meshFailurePenalty<ee&&(ie.meshFailurePenalty=0),ie.invalidMessageDeliveries*=se.invalidMessageDeliveriesDecay,ie.invalidMessageDeliveries<ee&&(ie.invalidMessageDeliveries=0),ie.inMesh&&(ie.meshTime=E-ie.graftTime,ie.meshTime>se.meshMessageDeliveriesActivation&&(ie.meshMessageDeliveriesActive=!0)))}),te.behaviourPenalty*=this.params.behaviourPenaltyDecay,te.behaviourPenalty<ee&&(te.behaviourPenalty=0)})}score(E){this.metrics?.scoreFnCalls.inc();const ee=this.peerStats.get(E);if(!ee)return 0;const te=Date.now(),re=this.scoreCache.get(E);if(re&&re.cacheUntil>te)return re.score;this.metrics?.scoreFnRuns.inc();const ne=this.computeScore(E,ee,this.params,this.peerIPs),ie=te+this.scoreCacheValidityMs;return re?(this.metrics?.scoreCachedDelta.observe(Math.abs(ne-re.score)),re.score=ne,re.cacheUntil=ie):this.scoreCache.set(E,{score:ne,cacheUntil:ie}),ne}addPenalty(E,ee,te){const re=this.peerStats.get(E);re&&(re.behaviourPenalty+=ee,this.metrics?.onScorePenalty(te))}addPeer(E){const ee={connected:!0,expire:0,topics:{},knownIPs:new Set,behaviourPenalty:0};this.peerStats.set(E,ee)}addIP(E,ee){const te=this.peerStats.get(E);te&&te.knownIPs.add(ee),this.peerIPs.getOrDefault(ee).add(E)}removeIP(E,ee){const te=this.peerStats.get(E);te&&te.knownIPs.delete(ee);const re=this.peerIPs.get(ee);re&&(re.delete(E),re.size===0&&this.peerIPs.delete(ee))}removePeer(E){const ee=this.peerStats.get(E);if(ee){if(this.score(E)>0){this.removeIPsForPeer(E,ee.knownIPs),this.peerStats.delete(E);return}Object.entries(ee.topics).forEach(([te,re])=>{re.firstMessageDeliveries=0;const ne=this.params.topics[te].meshMessageDeliveriesThreshold;if(re.inMesh&&re.meshMessageDeliveriesActive&&re.meshMessageDeliveries<ne){const ie=ne-re.meshMessageDeliveries;re.meshFailurePenalty+=ie*ie}re.inMesh=!1,re.meshMessageDeliveriesActive=!1}),ee.connected=!1,ee.expire=Date.now()+this.params.retainScore}}graft(E,ee){const te=this.peerStats.get(E);if(te){const re=this.getPtopicStats(te,ee);re&&(re.inMesh=!0,re.graftTime=Date.now(),re.meshTime=0,re.meshMessageDeliveriesActive=!1)}}prune(E,ee){const te=this.peerStats.get(E);if(te){const re=this.getPtopicStats(te,ee);if(re){const ne=this.params.topics[ee].meshMessageDeliveriesThreshold;if(re.meshMessageDeliveriesActive&&re.meshMessageDeliveries<ne){const ie=ne-re.meshMessageDeliveries;re.meshFailurePenalty+=ie*ie}re.meshMessageDeliveriesActive=!1,re.inMesh=!1}}}validateMessage(E){this.deliveryRecords.ensureRecord(E)}deliverMessage(E,ee,te){this.markFirstMessageDelivery(E,te);const re=this.deliveryRecords.ensureRecord(ee),ne=Date.now();if(re.status!==DeliveryRecordStatus.unknown){log$s("unexpected delivery: message from %s was first seen %s ago and has delivery status %s",E,ne-re.firstSeen,DeliveryRecordStatus[re.status]);return}re.status=DeliveryRecordStatus.valid,re.validated=ne,re.peers.forEach(ie=>{ie!==E.toString()&&this.markDuplicateMessageDelivery(ie,te)})}rejectInvalidMessage(E,ee){this.markInvalidMessageDelivery(E,ee)}rejectMessage(E,ee,te,re){switch(re){case RejectReason.Error:this.markInvalidMessageDelivery(E,te);return;case RejectReason.Blacklisted:return}const ne=this.deliveryRecords.ensureRecord(ee);if(ne.status!==DeliveryRecordStatus.unknown){log$s("unexpected rejection: message from %s was first seen %s ago and has delivery status %d",E,Date.now()-ne.firstSeen,DeliveryRecordStatus[ne.status]);return}if(re===RejectReason.Ignore){ne.status=DeliveryRecordStatus.ignored,ne.peers.clear();return}ne.status=DeliveryRecordStatus.invalid,this.markInvalidMessageDelivery(E,te),ne.peers.forEach(ie=>{this.markInvalidMessageDelivery(ie,te)}),ne.peers.clear()}duplicateMessage(E,ee,te){const re=this.deliveryRecords.ensureRecord(ee);if(!re.peers.has(E))switch(re.status){case DeliveryRecordStatus.unknown:re.peers.add(E);break;case DeliveryRecordStatus.valid:re.peers.add(E),this.markDuplicateMessageDelivery(E,te,re.validated);break;case DeliveryRecordStatus.invalid:this.markInvalidMessageDelivery(E,te);break;case DeliveryRecordStatus.ignored:break}}markInvalidMessageDelivery(E,ee){const te=this.peerStats.get(E);if(te){const re=this.getPtopicStats(te,ee);re&&(re.invalidMessageDeliveries+=1)}}markFirstMessageDelivery(E,ee){const te=this.peerStats.get(E);if(te){const re=this.getPtopicStats(te,ee);if(re){let ne=this.params.topics[ee].firstMessageDeliveriesCap;re.firstMessageDeliveries=Math.min(ne,re.firstMessageDeliveries+1),re.inMesh&&(ne=this.params.topics[ee].meshMessageDeliveriesCap,re.meshMessageDeliveries=Math.min(ne,re.meshMessageDeliveries+1))}}}markDuplicateMessageDelivery(E,ee,te){const re=this.peerStats.get(E);if(re){const ne=te!==void 0?Date.now():0,ie=this.getPtopicStats(re,ee);if(ie&&ie.inMesh){const se=this.params.topics[ee];if(te!==void 0){const ce=ne-te,ae=ce>se.meshMessageDeliveriesWindow;if(this.metrics?.onDuplicateMsgDelivery(ee,ce,ae),ae)return}const oe=se.meshMessageDeliveriesCap;ie.meshMessageDeliveries=Math.min(oe,ie.meshMessageDeliveries+1)}}}removeIPsForPeer(E,ee){for(const te of ee){const re=this.peerIPs.get(te);re&&(re.delete(E),re.size===0&&this.peerIPs.delete(te))}}getPtopicStats(E,ee){let te=E.topics[ee];return te!==void 0?te:this.params.topics[ee]!==void 0?(te={inMesh:!1,graftTime:0,meshTime:0,firstMessageDeliveries:0,meshMessageDeliveries:0,meshMessageDeliveriesActive:!1,meshFailurePenalty:0,invalidMessageDeliveries:0},E.topics[ee]=te,te):null}}class IWantTracer{constructor(E,ee,te){this.gossipsubIWantFollowupMs=E,this.msgIdToStrFn=ee,this.metrics=te,this.promises=new Map,this.requestMsByMsg=new Map,this.requestMsByMsgExpire=10*E}get size(){return this.promises.size}get requestMsByMsgSize(){return this.requestMsByMsg.size}addPromise(E,ee){const te=Math.floor(Math.random()*ee.length),re=ee[te],ne=this.msgIdToStrFn(re);let ie=this.promises.get(ne);ie||(ie=new Map,this.promises.set(ne,ie));const se=Date.now();ie.has(E)||(ie.set(E,se+this.gossipsubIWantFollowupMs),this.metrics&&(this.metrics.iwantPromiseStarted.inc(1),this.requestMsByMsg.has(ne)||this.requestMsByMsg.set(ne,se)))}getBrokenPromises(){const E=Date.now(),ee=new Map;let te=0;return this.promises.forEach((re,ne)=>{re.forEach((ie,se)=>{ie<E&&(ee.set(se,(ee.get(se)??0)+1),re.delete(se),te++)}),re.size||this.promises.delete(ne)}),this.metrics?.iwantPromiseBroken.inc(te),ee}deliverMessage(E,ee=!1){this.trackMessage(E);const te=this.promises.get(E);te&&(this.promises.delete(E),this.metrics&&(this.metrics.iwantPromiseResolved.inc(1),ee&&this.metrics.iwantPromiseResolvedFromDuplicate.inc(1),this.metrics.iwantPromiseResolvedPeers.inc(te.size)))}rejectMessage(E,ee){switch(this.trackMessage(E),ee){case RejectReason.Error:return}this.promises.delete(E)}clear(){this.promises.clear()}prune(){const E=Date.now()-this.requestMsByMsgExpire;let ee=0;for(const[te,re]of this.requestMsByMsg.entries())if(re<E)this.requestMsByMsg.delete(te),ee++;else break;this.metrics?.iwantMessagePruned.inc(ee)}trackMessage(E){if(this.metrics){const ee=this.requestMsByMsg.get(E);ee!==void 0&&(this.metrics.iwantPromiseDeliveryTime.observe((Date.now()-ee)/1e3),this.requestMsByMsg.delete(E))}}}class SimpleTimeCache{constructor(E){this.entries=new Map,this.validityMs=E.validityMs}get size(){return this.entries.size}put(E,ee){return this.entries.has(E)?!0:(this.entries.set(E,{value:ee,validUntilMs:Date.now()+this.validityMs}),!1)}prune(){const E=Date.now();for(const[ee,te]of this.entries.entries())if(te.validUntilMs<E)this.entries.delete(ee);else break}has(E){return this.entries.has(E)}get(E){const ee=this.entries.get(E);return ee&&ee.validUntilMs>=Date.now()?ee.value:void 0}clear(){this.entries.clear()}}var MessageSource;(function(J){J.forward="forward",J.publish="publish"})(MessageSource||(MessageSource={}));var InclusionReason;(function(J){J.Fanout="fanout",J.Random="random",J.Subscribed="subscribed",J.Outbound="outbound",J.NotEnough="not_enough",J.Opportunistic="opportunistic"})(InclusionReason||(InclusionReason={}));var ChurnReason;(function(J){J.Dc="disconnected",J.BadScore="bad_score",J.Prune="prune",J.Unsub="unsubscribed",J.Excess="excess"})(ChurnReason||(ChurnReason={}));var ScorePenalty;(function(J){J.GraftBackoff="graft_backoff",J.BrokenPromise="broken_promise",J.MessageDeficit="message_deficit",J.IPColocation="IP_colocation"})(ScorePenalty||(ScorePenalty={}));var IHaveIgnoreReason;(function(J){J.LowScore="low_score",J.MaxIhave="max_ihave",J.MaxIasked="max_iasked"})(IHaveIgnoreReason||(IHaveIgnoreReason={}));var ScoreThreshold;(function(J){J.graylist="graylist",J.publish="publish",J.gossip="gossip",J.mesh="mesh"})(ScoreThreshold||(ScoreThreshold={}));function getMetrics(J,E,ee){return{protocolsEnabled:J.gauge({name:"gossipsub_protocol",help:"Status of enabled protocols",labelNames:["protocol"]}),topicSubscriptionStatus:J.gauge({name:"gossipsub_topic_subscription_status",help:"Status of our subscription to this topic",labelNames:["topicStr"]}),topicPeersCount:J.gauge({name:"gossipsub_topic_peer_count",help:"Number of peers subscribed to each topic",labelNames:["topicStr"]}),meshPeerCounts:J.gauge({name:"gossipsub_mesh_peer_count",help:"Number of peers in our mesh",labelNames:["topicStr"]}),meshPeerInclusionEvents:J.gauge({name:"gossipsub_mesh_peer_inclusion_events_total",help:"Number of times we include peers in a topic mesh for different reasons",labelNames:["topic","reason"]}),meshPeerChurnEvents:J.gauge({name:"gossipsub_peer_churn_events_total",help:"Number of times we remove peers in a topic mesh for different reasons",labelNames:["topic","reason"]}),peersPerProtocol:J.gauge({name:"gossipsub_peers_per_protocol_count",help:"Peers connected for each topic",labelNames:["protocol"]}),heartbeatDuration:J.histogram({name:"gossipsub_heartbeat_duration_seconds",help:"The time it takes to complete one iteration of the heartbeat",buckets:[.01,.1,1]}),heartbeatSkipped:J.gauge({name:"gossipsub_heartbeat_skipped",help:"Heartbeat run took longer than heartbeat interval so next is skipped"}),asyncValidationResult:J.gauge({name:"gossipsub_async_validation_result_total",help:"Message validation result for each topic",labelNames:["topic","acceptance"]}),asyncValidationMcacheHit:J.gauge({name:"gossipsub_async_validation_mcache_hit_total",help:"Async validation result reported by the user layer",labelNames:["hit"]}),peerReadStreamError:J.gauge({name:"gossipsub_peer_read_stream_err_count_total",help:"Peer read stream error"}),rpcRecvBytes:J.gauge({name:"gossipsub_rpc_recv_bytes_total",help:"RPC recv"}),rpcRecvCount:J.gauge({name:"gossipsub_rpc_recv_count_total",help:"RPC recv"}),rpcRecvSubscription:J.gauge({name:"gossipsub_rpc_recv_subscription_total",help:"RPC recv"}),rpcRecvMessage:J.gauge({name:"gossipsub_rpc_recv_message_total",help:"RPC recv"}),rpcRecvControl:J.gauge({name:"gossipsub_rpc_recv_control_total",help:"RPC recv"}),rpcRecvIHave:J.gauge({name:"gossipsub_rpc_recv_ihave_total",help:"RPC recv"}),rpcRecvIWant:J.gauge({name:"gossipsub_rpc_recv_iwant_total",help:"RPC recv"}),rpcRecvGraft:J.gauge({name:"gossipsub_rpc_recv_graft_total",help:"RPC recv"}),rpcRecvPrune:J.gauge({name:"gossipsub_rpc_recv_prune_total",help:"RPC recv"}),rpcDataError:J.gauge({name:"gossipsub_rpc_data_err_count_total",help:"RPC data error"}),rpcRecvError:J.gauge({name:"gossipsub_rpc_recv_err_count_total",help:"RPC recv error"}),rpcRecvNotAccepted:J.gauge({name:"gossipsub_rpc_rcv_not_accepted_total",help:"Total count of RPC dropped because acceptFrom() == false"}),rpcSentBytes:J.gauge({name:"gossipsub_rpc_sent_bytes_total",help:"RPC sent"}),rpcSentCount:J.gauge({name:"gossipsub_rpc_sent_count_total",help:"RPC sent"}),rpcSentSubscription:J.gauge({name:"gossipsub_rpc_sent_subscription_total",help:"RPC sent"}),rpcSentMessage:J.gauge({name:"gossipsub_rpc_sent_message_total",help:"RPC sent"}),rpcSentControl:J.gauge({name:"gossipsub_rpc_sent_control_total",help:"RPC sent"}),rpcSentIHave:J.gauge({name:"gossipsub_rpc_sent_ihave_total",help:"RPC sent"}),rpcSentIWant:J.gauge({name:"gossipsub_rpc_sent_iwant_total",help:"RPC sent"}),rpcSentGraft:J.gauge({name:"gossipsub_rpc_sent_graft_total",help:"RPC sent"}),rpcSentPrune:J.gauge({name:"gossipsub_rpc_sent_prune_total",help:"RPC sent"}),msgPublishCount:J.gauge({name:"gossipsub_msg_publish_count_total",help:"Total count of msg published by topic",labelNames:["topic"]}),msgPublishPeers:J.gauge({name:"gossipsub_msg_publish_peers_total",help:"Total count of peers that we publish a msg to",labelNames:["topic"]}),msgPublishPeersByGroup:J.gauge({name:"gossipsub_msg_publish_peers_by_group",help:"Total count of peers (by group) that we publish a msg to",labelNames:["topic","peerGroup"]}),msgPublishBytes:J.gauge({name:"gossipsub_msg_publish_bytes_total",help:"Total count of msg publish data.length bytes",labelNames:["topic"]}),msgForwardCount:J.gauge({name:"gossipsub_msg_forward_count_total",help:"Total count of msg forwarded by topic",labelNames:["topic"]}),msgForwardPeers:J.gauge({name:"gossipsub_msg_forward_peers_total",help:"Total count of peers that we forward a msg to",labelNames:["topic"]}),msgReceivedPreValidation:J.gauge({name:"gossipsub_msg_received_prevalidation_total",help:"Total count of recv msgs before any validation",labelNames:["topic"]}),msgReceivedError:J.gauge({name:"gossipsub_msg_received_error_total",help:"Total count of recv msgs error",labelNames:["topic"]}),msgReceivedStatus:J.gauge({name:"gossipsub_msg_received_status_total",help:"Tracks distribution of recv msgs by duplicate, invalid, valid",labelNames:["topic","status"]}),msgReceivedInvalid:J.gauge({name:"gossipsub_msg_received_invalid_total",help:"Tracks specific reason of invalid",labelNames:["topic","error"]}),duplicateMsgDeliveryDelay:J.histogram({name:"gossisub_duplicate_msg_delivery_delay_seconds",help:"Time since the 1st duplicated message validated",labelNames:["topic"],buckets:[.25*ee.maxMeshMessageDeliveriesWindowSec,.5*ee.maxMeshMessageDeliveriesWindowSec,1*ee.maxMeshMessageDeliveriesWindowSec,2*ee.maxMeshMessageDeliveriesWindowSec,4*ee.maxMeshMessageDeliveriesWindowSec]}),duplicateMsgLateDelivery:J.gauge({name:"gossisub_duplicate_msg_late_delivery_total",help:"Total count of late duplicate message delivery by topic, which triggers P3 penalty",labelNames:["topic"]}),duplicateMsgIgnored:J.gauge({name:"gossisub_ignored_published_duplicate_msgs_total",help:"Total count of published duplicate message ignored by topic",labelNames:["topic"]}),scoreFnCalls:J.gauge({name:"gossipsub_score_fn_calls_total",help:"Total times score() is called"}),scoreFnRuns:J.gauge({name:"gossipsub_score_fn_runs_total",help:"Total times score() call actually computed computeScore(), no cache"}),scoreCachedDelta:J.histogram({name:"gossipsub_score_cache_delta",help:"Delta of score between cached values that expired",buckets:[10,100,1e3]}),peersByScoreThreshold:J.gauge({name:"gossipsub_peers_by_score_threshold_count",help:"Current count of peers by score threshold",labelNames:["threshold"]}),score:J.avgMinMax({name:"gossipsub_score",help:"Avg min max of gossip scores",labelNames:["topic","p"]}),scoreWeights:J.avgMinMax({name:"gossipsub_score_weights",help:"Separate score weights",labelNames:["topic","p"]}),scorePerMesh:J.avgMinMax({name:"gossipsub_score_per_mesh",help:"Histogram of the scores for each mesh topic",labelNames:["topic"]}),scoringPenalties:J.gauge({name:"gossipsub_scoring_penalties_total",help:"A counter of the kind of penalties being applied to peers",labelNames:["penalty"]}),behaviourPenalty:J.histogram({name:"gossipsub_peer_stat_behaviour_penalty",help:"Current peer stat behaviour_penalty at each scrape",buckets:[.25*ee.behaviourPenaltyThreshold,.5*ee.behaviourPenaltyThreshold,1*ee.behaviourPenaltyThreshold,2*ee.behaviourPenaltyThreshold,4*ee.behaviourPenaltyThreshold]}),ihaveRcvIgnored:J.gauge({name:"gossipsub_ihave_rcv_ignored_total",help:"Total received IHAVE messages that we ignore for some reason",labelNames:["reason"]}),ihaveRcvMsgids:J.gauge({name:"gossipsub_ihave_rcv_msgids_total",help:"Total received IHAVE messages by topic",labelNames:["topic"]}),ihaveRcvNotSeenMsgids:J.gauge({name:"gossipsub_ihave_rcv_not_seen_msgids_total",help:"Total messages per topic we do not have, not actual requests",labelNames:["topic"]}),iwantRcvMsgids:J.gauge({name:"gossipsub_iwant_rcv_msgids_total",help:"Total received IWANT messages by topic",labelNames:["topic"]}),iwantRcvDonthaveMsgids:J.gauge({name:"gossipsub_iwant_rcv_dont_have_msgids_total",help:"Total requested messageIDs that we do not have"}),iwantPromiseStarted:J.gauge({name:"gossipsub_iwant_promise_sent_total",help:"Total count of started IWANT promises"}),iwantPromiseResolved:J.gauge({name:"gossipsub_iwant_promise_resolved_total",help:"Total count of resolved IWANT promises"}),iwantPromiseResolvedFromDuplicate:J.gauge({name:"gossipsub_iwant_promise_resolved_from_duplicate_total",help:"Total count of resolved IWANT promises from duplicate messages"}),iwantPromiseResolvedPeers:J.gauge({name:"gossipsub_iwant_promise_resolved_peers",help:"Total count of peers we have asked IWANT promises that are resolved"}),iwantPromiseBroken:J.gauge({name:"gossipsub_iwant_promise_broken",help:"Total count of broken IWANT promises"}),iwantMessagePruned:J.gauge({name:"gossipsub_iwant_message_pruned",help:"Total count of pruned IWANT messages"}),iwantPromiseDeliveryTime:J.histogram({name:"gossipsub_iwant_promise_delivery_seconds",help:"Histogram of delivery time of resolved IWANT promises",buckets:[.5*ee.gossipPromiseExpireSec,1*ee.gossipPromiseExpireSec,2*ee.gossipPromiseExpireSec,4*ee.gossipPromiseExpireSec]}),iwantPromiseUntracked:J.gauge({name:"gossip_iwant_promise_untracked",help:"Total count of untracked IWANT promise"}),cacheSize:J.gauge({name:"gossipsub_cache_size",help:"Unbounded cache sizes",labelNames:["cache"]}),mcacheSize:J.gauge({name:"gossipsub_mcache_size",help:"Current mcache msg count"}),mcacheNotValidatedCount:J.gauge({name:"gossipsub_mcache_not_validated_count",help:"Current mcache msg count not validated"}),fastMsgIdCacheCollision:J.gauge({name:"gossipsub_fastmsgid_cache_collision_total",help:"Total count of key collisions on fastmsgid cache put"}),newConnectionCount:J.gauge({name:"gossipsub_new_connection_total",help:"Total new connection by status",labelNames:["status"]}),topicStrToLabel:E,toTopic(te){return this.topicStrToLabel.get(te)??te},onJoin(te){this.topicSubscriptionStatus.set({topicStr:te},1),this.meshPeerCounts.set({topicStr:te},0)},onLeave(te){this.topicSubscriptionStatus.set({topicStr:te},0),this.meshPeerCounts.set({topicStr:te},0)},onAddToMesh(te,re,ne){const ie=this.toTopic(te);this.meshPeerInclusionEvents.inc({topic:ie,reason:re},ne)},onRemoveFromMesh(te,re,ne){const ie=this.toTopic(te);this.meshPeerChurnEvents.inc({topic:ie,reason:re},ne)},onReportValidationMcacheHit(te){this.asyncValidationMcacheHit.inc({hit:te?"hit":"miss"})},onReportValidation(te,re){const ne=this.toTopic(te);this.asyncValidationResult.inc({topic:ne,acceptance:re})},onScorePenalty(te){this.scoringPenalties.inc({penalty:te},1)},onIhaveRcv(te,re,ne){const ie=this.toTopic(te);this.ihaveRcvMsgids.inc({topic:ie},re),this.ihaveRcvNotSeenMsgids.inc({topic:ie},ne)},onIwantRcv(te,re){for(const[ne,ie]of te){const se=this.toTopic(ne);this.iwantRcvMsgids.inc({topic:se},ie)}this.iwantRcvDonthaveMsgids.inc(re)},onForwardMsg(te,re){const ne=this.toTopic(te);this.msgForwardCount.inc({topic:ne},1),this.msgForwardPeers.inc({topic:ne},re)},onPublishMsg(te,re,ne,ie){const se=this.toTopic(te);this.msgPublishCount.inc({topic:se},1),this.msgPublishBytes.inc({topic:se},ne*ie),this.msgPublishPeers.inc({topic:se},ne),this.msgPublishPeersByGroup.inc({topic:se,peerGroup:"direct"},re.direct),this.msgPublishPeersByGroup.inc({topic:se,peerGroup:"floodsub"},re.floodsub),this.msgPublishPeersByGroup.inc({topic:se,peerGroup:"mesh"},re.mesh),this.msgPublishPeersByGroup.inc({topic:se,peerGroup:"fanout"},re.fanout)},onMsgRecvPreValidation(te){const re=this.toTopic(te);this.msgReceivedPreValidation.inc({topic:re},1)},onMsgRecvError(te){const re=this.toTopic(te);this.msgReceivedError.inc({topic:re},1)},onMsgRecvResult(te,re){const ne=this.toTopic(te);this.msgReceivedStatus.inc({topic:ne,status:re})},onMsgRecvInvalid(te,re){const ne=this.toTopic(te),ie=re.reason===RejectReason.Error?re.error:re.reason;this.msgReceivedInvalid.inc({topic:ne,error:ie},1)},onDuplicateMsgDelivery(te,re,ne){if(this.duplicateMsgDeliveryDelay.observe(re/1e3),ne){const ie=this.toTopic(te);this.duplicateMsgLateDelivery.inc({topic:ie},1)}},onPublishDuplicateMsg(te){const re=this.toTopic(te);this.duplicateMsgIgnored.inc({topic:re},1)},onPeerReadStreamError(){this.peerReadStreamError.inc(1)},onRpcRecvError(){this.rpcRecvError.inc(1)},onRpcDataError(){this.rpcDataError.inc(1)},onRpcRecv(te,re){this.rpcRecvBytes.inc(re),this.rpcRecvCount.inc(1),te.subscriptions&&this.rpcRecvSubscription.inc(te.subscriptions.length),te.messages&&this.rpcRecvMessage.inc(te.messages.length),te.control&&(this.rpcRecvControl.inc(1),te.control.ihave&&this.rpcRecvIHave.inc(te.control.ihave.length),te.control.iwant&&this.rpcRecvIWant.inc(te.control.iwant.length),te.control.graft&&this.rpcRecvGraft.inc(te.control.graft.length),te.control.prune&&this.rpcRecvPrune.inc(te.control.prune.length))},onRpcSent(te,re){if(this.rpcSentBytes.inc(re),this.rpcSentCount.inc(1),te.subscriptions&&this.rpcSentSubscription.inc(te.subscriptions.length),te.messages&&this.rpcSentMessage.inc(te.messages.length),te.control){const ne=te.control.ihave?.length??0,ie=te.control.iwant?.length??0,se=te.control.graft?.length??0,oe=te.control.prune?.length??0;ne>0&&this.rpcSentIHave.inc(ne),ie>0&&this.rpcSentIWant.inc(ie),se>0&&this.rpcSentGraft.inc(se),oe>0&&this.rpcSentPrune.inc(oe),(ne>0||ie>0||se>0||oe>0)&&this.rpcSentControl.inc(1)}},registerScores(te,re){let ne=0,ie=0,se=0,oe=0;for(const ce of te)ce>=re.graylistThreshold&&ne++,ce>=re.publishThreshold&&ie++,ce>=re.gossipThreshold&&se++,ce>=0&&oe++;this.peersByScoreThreshold.set({threshold:ScoreThreshold.graylist},ne),this.peersByScoreThreshold.set({threshold:ScoreThreshold.publish},ie),this.peersByScoreThreshold.set({threshold:ScoreThreshold.gossip},se),this.peersByScoreThreshold.set({threshold:ScoreThreshold.mesh},oe),this.score.set(te)},registerScoreWeights(te){for(const[re,ne]of te.byTopic)this.scoreWeights.set({topic:re,p:"p1"},ne.p1w),this.scoreWeights.set({topic:re,p:"p2"},ne.p2w),this.scoreWeights.set({topic:re,p:"p3"},ne.p3w),this.scoreWeights.set({topic:re,p:"p3b"},ne.p3bw),this.scoreWeights.set({topic:re,p:"p4"},ne.p4w);this.scoreWeights.set({p:"p5"},te.p5w),this.scoreWeights.set({p:"p6"},te.p6w),this.scoreWeights.set({p:"p7"},te.p7w)},registerScorePerMesh(te,re){const ne=new Map;te.forEach((ie,se)=>{const oe=this.topicStrToLabel.get(se)??"unknown";let ce=ne.get(oe);ce||(ce=new Set,ne.set(oe,ce)),ie.forEach(ae=>ce?.add(ae))});for(const[ie,se]of ne){const oe=[];se.forEach(ce=>{oe.push(re.get(ce)??0)}),this.scorePerMesh.set({topic:ie},oe)}}}}const SignPrefix=fromString$5("libp2p-pubsub:");async function buildRawMessage(J,E,ee,te){switch(J.type){case PublishConfigType.Signing:{const re={from:J.author.toBytes(),data:te,seqno:randomBytes(8),topic:E,signature:void 0,key:void 0},ne=concat$4([SignPrefix,RPC$1.Message.encode(re).finish()]);re.signature=await J.privateKey.sign(ne),re.key=J.key;const ie={type:"signed",from:J.author,data:ee,sequenceNumber:BigInt(`0x${toString$5(re.seqno,"base16")}`),topic:E,signature:re.signature,key:re.key};return{raw:re,msg:ie}}case PublishConfigType.Anonymous:return{raw:{from:void 0,data:te,seqno:void 0,topic:E,signature:void 0,key:void 0},msg:{type:"unsigned",data:ee,topic:E}}}}async function validateToRawMessage(J,E){switch(J){case StrictNoSign:return E.signature!=null?{valid:!1,error:ValidateError.SignaturePresent}:E.seqno!=null?{valid:!1,error:ValidateError.SeqnoPresent}:E.key!=null?{valid:!1,error:ValidateError.FromPresent}:{valid:!0,message:{type:"unsigned",topic:E.topic,data:E.data??new Uint8Array(0)}};case StrictSign:{if(E.seqno==null)return{valid:!1,error:ValidateError.InvalidSeqno};if(E.seqno.length!==8)return{valid:!1,error:ValidateError.InvalidSeqno};if(E.signature==null)return{valid:!1,error:ValidateError.InvalidSignature};if(E.from==null)return{valid:!1,error:ValidateError.InvalidPeerId};let ee;try{ee=peerIdFromBytes(E.from)}catch{return{valid:!1,error:ValidateError.InvalidPeerId}}let te;if(E.key){if(te=unmarshalPublicKey(E.key),ee.publicKey!==void 0&&!equals(te.bytes,ee.publicKey))return{valid:!1,error:ValidateError.InvalidPeerId}}else{if(ee.publicKey==null)return{valid:!1,error:ValidateError.InvalidPeerId};te=unmarshalPublicKey(ee.publicKey)}const re={from:E.from,data:E.data,seqno:E.seqno,topic:E.topic,signature:void 0,key:void 0},ne=concat$4([SignPrefix,RPC$1.Message.encode(re).finish()]);return await te.verify(ne,E.signature)?{valid:!0,message:{type:"signed",from:ee,data:E.data??new Uint8Array(0),sequenceNumber:BigInt(`0x${toString$5(E.seqno,"base16")}`),topic:E.topic,signature:E.signature,key:E.key??marshalPublicKey(te)}}:{valid:!1,error:ValidateError.InvalidSignature}}}}const msgId=(J,E)=>{const ee=fromString$5(E.toString(16).padStart(16,"0"),"base16"),te=new Uint8Array(J.length+ee.length);return te.set(J,0),te.set(ee,J.length),te};function msgIdFnStrictSign(J){if(J.type!=="signed")throw new Error("expected signed message type");if(J.sequenceNumber==null)throw Error("missing seqno field");return msgId(J.from.toBytes(),J.sequenceNumber)}async function msgIdFnStrictNoSign(J){return await sha256$3.encode(J.data)}function computeScoreWeights(J,E,ee,te,re){let ne=0;const ie=new Map;if(Object.entries(E.topics).forEach(([ue,he])=>{const pe=re.get(ue)??"unknown",de=ee.topics[ue];if(de===void 0)return;let fe=ie.get(pe);fe||(fe={p1w:0,p2w:0,p3w:0,p3bw:0,p4w:0},ie.set(pe,fe));let me=0,_e=0,be=0,Ee=0,ve=0;if(he.inMesh){const $e=Math.max(he.meshTime/de.timeInMeshQuantum,de.timeInMeshCap);me+=$e*de.timeInMeshWeight}let we=he.firstMessageDeliveries;if(we>de.firstMessageDeliveriesCap&&(we=de.firstMessageDeliveriesCap),_e+=we*de.firstMessageDeliveriesWeight,he.meshMessageDeliveriesActive&&he.meshMessageDeliveries<de.meshMessageDeliveriesThreshold){const $e=de.meshMessageDeliveriesThreshold-he.meshMessageDeliveries,Pe=$e*$e;be+=Pe*de.meshMessageDeliveriesWeight}const ge=he.meshFailurePenalty;Ee+=ge*de.meshFailurePenaltyWeight;const Se=he.invalidMessageDeliveries*he.invalidMessageDeliveries;ve+=Se*de.invalidMessageDeliveriesWeight,ne+=(me+_e+be+Ee+ve)*de.topicWeight,fe.p1w+=me,fe.p2w+=_e,fe.p3w+=be,fe.p3bw+=Ee,fe.p4w+=ve}),ee.topicScoreCap>0&&ne>ee.topicScoreCap){ne=ee.topicScoreCap;const ue=ee.topicScoreCap/ne;for(const he of ie.values())he.p1w*=ue,he.p2w*=ue,he.p3w*=ue,he.p3bw*=ue,he.p4w*=ue}let se=0,oe=0,ce=0;const ae=ee.appSpecificScore(J);se+=ae*ee.appSpecificWeight,E.knownIPs.forEach(ue=>{if(ee.IPColocationFactorWhitelist.has(ue))return;const he=te.get(ue),pe=he?he.size:0;if(pe>ee.IPColocationFactorThreshold){const de=pe-ee.IPColocationFactorThreshold,fe=de*de;oe+=fe*ee.IPColocationFactorWeight}});const le=E.behaviourPenalty*E.behaviourPenalty;return ce+=le*ee.behaviourPenaltyWeight,ne+=se+oe+ce,{byTopic:ie,p5w:se,p6w:oe,p7w:ce,score:ne}}function computeAllPeersScoreWeights(J,E,ee,te,re){const ne={byTopic:new Map,p5w:[],p6w:[],p7w:[],score:[]};for(const ie of J){const se=E.get(ie);if(se){const oe=computeScoreWeights(ie,se,ee,te,re);for(const[ce,ae]of oe.byTopic){let le=ne.byTopic.get(ce);le||(le={p1w:[],p2w:[],p3w:[],p3bw:[],p4w:[]},ne.byTopic.set(ce,le)),le.p1w.push(ae.p1w),le.p2w.push(ae.p2w),le.p3w.push(ae.p3w),le.p3bw.push(ae.p3bw),le.p4w.push(ae.p4w)}ne.p5w.push(oe.p5w),ne.p6w.push(oe.p6w),ne.p7w.push(oe.p7w),ne.score.push(oe.score)}else ne.p5w.push(0),ne.p6w.push(0),ne.p7w.push(0),ne.score.push(0)}return ne}class OutboundStream{constructor(E,ee,te){this.rawStream=E,this.pushable=pushable({objectMode:!1}),this.closeController=new AbortController,this.maxBufferSize=te.maxBufferSize??1/0,pipe$1(abortableSource$1(this.pushable,this.closeController.signal,{returnOnAbort:!0}),re=>encode$b(re),this.rawStream).catch(ee)}get protocol(){return this.rawStream.stat.protocol}push(E){if(this.pushable.readableLength>this.maxBufferSize)throw Error(`OutboundStream buffer full, size > ${this.maxBufferSize}`);this.pushable.push(E)}close(){this.closeController.abort(),this.pushable.return(),this.rawStream.close()}}class InboundStream{constructor(E,ee={}){this.rawStream=E,this.closeController=new AbortController,this.source=abortableSource$1(pipe$1(this.rawStream,te=>decode$b(te,ee)),this.closeController.signal,{returnOnAbort:!0})}close(){this.closeController.abort(),this.rawStream.close()}}var minimalExports=requireMinimal();const protobuf=getDefaultExportFromCjs(minimalExports),defaultDecodeRpcLimits={maxSubscriptions:1/0,maxMessages:1/0,maxIhaveMessageIDs:1/0,maxIwantMessageIDs:1/0,maxControlMessages:1/0,maxPeerInfos:1/0};function decodeRpc(J,E){E={...E};const ee=protobuf.Reader.create(J),te=J.length,re=te===void 0?ee.len:ee.pos+te,ne={};for(;ee.pos<re;){const ie=ee.uint32();switch(ie>>>3){case 1:ne.subscriptions&&ne.subscriptions.length||(ne.subscriptions=[]),ne.subscriptions.length<E.maxSubscriptions?ne.subscriptions.push(decodeSubOpts(ee,ee.uint32())):ee.skipType(ie&7);break;case 2:ne.messages&&ne.messages.length||(ne.messages=[]),ne.messages.length<E.maxMessages?ne.messages.push(decodeMessage(ee,ee.uint32())):ee.skipType(ie&7);break;case 3:ne.control=decodeControlMessage(ee,ee.uint32(),E);break;default:ee.skipType(ie&7);break}}return ne}function decodeSubOpts(J,E){const ee=E===void 0?J.len:J.pos+E,te={};for(;J.pos<ee;){const re=J.uint32();switch(re>>>3){case 1:te.subscribe=J.bool();break;case 2:te.topic=J.string();break;default:J.skipType(re&7);break}}return te}function decodeMessage(J,E){const ee=E===void 0?J.len:J.pos+E,te={};for(;J.pos<ee;){const re=J.uint32();switch(re>>>3){case 1:te.from=J.bytes();break;case 2:te.data=J.bytes();break;case 3:te.seqno=J.bytes();break;case 4:te.topic=J.string();break;case 5:te.signature=J.bytes();break;case 6:te.key=J.bytes();break;default:J.skipType(re&7);break}}if(!te.topic)throw Error("missing required 'topic'");return te}function decodeControlMessage(J,E,ee){const te=E===void 0?J.len:J.pos+E,re={};for(;J.pos<te;){const ne=J.uint32();switch(ne>>>3){case 1:re.ihave&&re.ihave.length||(re.ihave=[]),re.ihave.length<ee.maxControlMessages?re.ihave.push(decodeControlIHave(J,J.uint32(),ee)):J.skipType(ne&7);break;case 2:re.iwant&&re.iwant.length||(re.iwant=[]),re.iwant.length<ee.maxControlMessages?re.iwant.push(decodeControlIWant(J,J.uint32(),ee)):J.skipType(ne&7);break;case 3:re.graft&&re.graft.length||(re.graft=[]),re.graft.length<ee.maxControlMessages?re.graft.push(decodeControlGraft(J,J.uint32())):J.skipType(ne&7);break;case 4:re.prune&&re.prune.length||(re.prune=[]),re.prune.length<ee.maxControlMessages?re.prune.push(decodeControlPrune(J,J.uint32(),ee)):J.skipType(ne&7);break;default:J.skipType(ne&7);break}}return re}function decodeControlIHave(J,E,ee){const te=E===void 0?J.len:J.pos+E,re={};for(;J.pos<te;){const ne=J.uint32();switch(ne>>>3){case 1:re.topicID=J.string();break;case 2:re.messageIDs&&re.messageIDs.length||(re.messageIDs=[]),ee.maxIhaveMessageIDs-- >0?re.messageIDs.push(J.bytes()):J.skipType(ne&7);break;default:J.skipType(ne&7);break}}return re}function decodeControlIWant(J,E,ee){const te=E===void 0?J.len:J.pos+E,re={};for(;J.pos<te;){const ne=J.uint32();switch(ne>>>3){case 1:re.messageIDs&&re.messageIDs.length||(re.messageIDs=[]),ee.maxIwantMessageIDs-- >0?re.messageIDs.push(J.bytes()):J.skipType(ne&7);break;default:J.skipType(ne&7);break}}return re}function decodeControlGraft(J,E){const ee=E===void 0?J.len:J.pos+E,te={};for(;J.pos<ee;){const re=J.uint32();switch(re>>>3){case 1:te.topicID=J.string();break;default:J.skipType(re&7);break}}return te}function decodeControlPrune(J,E,ee){const te=E===void 0?J.len:J.pos+E,re={};for(;J.pos<te;){const ne=J.uint32();switch(ne>>>3){case 1:re.topicID=J.string();break;case 2:re.peers&&re.peers.length||(re.peers=[]),ee.maxPeerInfos-- >0?re.peers.push(decodePeerInfo(J,J.uint32())):J.skipType(ne&7);break;case 3:re.backoff=J.uint64();break;default:J.skipType(ne&7);break}}return re}function decodePeerInfo(J,E){const ee=E===void 0?J.len:J.pos+E,te={};for(;J.pos<ee;){const re=J.uint32();switch(re>>>3){case 1:te.peerID=J.bytes();break;case 2:te.signedPeerRecord=J.bytes();break;default:J.skipType(re&7);break}}return te}var Protocol;(function(J){J[J.ip4=4]="ip4",J[J.ip6=41]="ip6"})(Protocol||(Protocol={}));function multiaddrToIPStr(J){for(const E of J.tuples())switch(E[0]){case Protocol.ip4:case Protocol.ip6:return convertToString(E[0],E[1])}return null}var GossipStatusCode;(function(J){J[J.started=0]="started",J[J.stopped=1]="stopped"})(GossipStatusCode||(GossipStatusCode={}));class GossipSub extends EventEmitter$3{constructor(E,ee={}){super(),this.multicodecs=[GossipsubIDv11,GossipsubIDv10],this.peers=new Set,this.streamsInbound=new Map,this.streamsOutbound=new Map,this.outboundInflightQueue=pushable({objectMode:!0}),this.direct=new Set,this.floodsubPeers=new Set,this.acceptFromWhitelist=new Map,this.topics=new Map,this.subscriptions=new Set,this.mesh=new Map,this.fanout=new Map,this.fanoutLastpub=new Map,this.gossip=new Map,this.control=new Map,this.peerhave=new Map,this.iasked=new Map,this.backoff=new Map,this.outbound=new Map,this.topicValidators=new Map,this.heartbeatTicks=0,this.directPeerInitial=null,this.status={code:GossipStatusCode.stopped},this.heartbeatTimer=null,this.runHeartbeat=()=>{const re=this.metrics?.heartbeatDuration.startTimer();this.heartbeat().catch(ne=>{this.log("Error running heartbeat",ne)}).finally(()=>{if(re?.(),this.status.code===GossipStatusCode.started){clearTimeout(this.status.heartbeatTimeout);let ne=this.opts.heartbeatInterval-(Date.now()-this.status.hearbeatStartMs)%this.opts.heartbeatInterval;ne<this.opts.heartbeatInterval*.25&&(ne+=this.opts.heartbeatInterval,this.metrics?.heartbeatSkipped.inc()),this.status.heartbeatTimeout=setTimeout(this.runHeartbeat,ne)}})};const te={fallbackToFloodsub:!0,floodPublish:!0,doPX:!1,directPeers:[],D:GossipsubD,Dlo:GossipsubDlo,Dhi:GossipsubDhi,Dscore:GossipsubDscore,Dout:GossipsubDout,Dlazy:GossipsubDlazy,heartbeatInterval:GossipsubHeartbeatInterval,fanoutTTL:GossipsubFanoutTTL,mcacheLength:GossipsubHistoryLength,mcacheGossip:GossipsubHistoryGossip,seenTTL:GossipsubSeenTTL,gossipsubIWantFollowupMs:GossipsubIWantFollowupTime,prunePeers:GossipsubPrunePeers,pruneBackoff:GossipsubPruneBackoff,graftFloodThreshold:GossipsubGraftFloodThreshold,opportunisticGraftPeers:GossipsubOpportunisticGraftPeers,opportunisticGraftTicks:GossipsubOpportunisticGraftTicks,directConnectTicks:GossipsubDirectConnectTicks,...ee,scoreParams:createPeerScoreParams(ee.scoreParams),scoreThresholds:createPeerScoreThresholds(ee.scoreThresholds)};if(this.components=E,this.decodeRpcLimits=te.decodeRpcLimits??defaultDecodeRpcLimits,this.globalSignaturePolicy=te.globalSignaturePolicy??StrictSign,te.fallbackToFloodsub&&this.multicodecs.push(FloodsubID),this.log=logger$1(te.debugName??"libp2p:gossipsub"),this.opts=te,this.direct=new Set(te.directPeers.map(re=>re.id.toString())),this.seenCache=new SimpleTimeCache({validityMs:te.seenTTL}),this.publishedMessageIds=new SimpleTimeCache({validityMs:te.seenTTL}),ee.msgIdFn)this.msgIdFn=ee.msgIdFn;else switch(this.globalSignaturePolicy){case StrictSign:this.msgIdFn=msgIdFnStrictSign;break;case StrictNoSign:this.msgIdFn=msgIdFnStrictNoSign;break}if(ee.fastMsgIdFn&&(this.fastMsgIdFn=ee.fastMsgIdFn,this.fastMsgIdCache=new SimpleTimeCache({validityMs:te.seenTTL})),this.msgIdToStrFn=ee.msgIdToStrFn??messageIdToString,this.mcache=ee.messageCache||new MessageCache(te.mcacheGossip,te.mcacheLength,this.msgIdToStrFn),ee.dataTransform&&(this.dataTransform=ee.dataTransform),ee.metricsRegister){if(!ee.metricsTopicStrToLabel)throw Error("Must set metricsTopicStrToLabel with metrics");const re=Math.max(...Object.values(te.scoreParams.topics).map(ie=>ie.meshMessageDeliveriesWindow),DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS),ne=getMetrics(ee.metricsRegister,ee.metricsTopicStrToLabel,{gossipPromiseExpireSec:this.opts.gossipsubIWantFollowupMs/1e3,behaviourPenaltyThreshold:te.scoreParams.behaviourPenaltyThreshold,maxMeshMessageDeliveriesWindowSec:re/1e3});ne.mcacheSize.addCollect(()=>this.onScrapeMetrics(ne));for(const ie of this.multicodecs)ne.protocolsEnabled.set({protocol:ie},1);this.metrics=ne}else this.metrics=null;this.gossipTracer=new IWantTracer(this.opts.gossipsubIWantFollowupMs,this.msgIdToStrFn,this.metrics),this.score=new PeerScore(this.opts.scoreParams,this.metrics,{scoreCacheValidityMs:te.heartbeatInterval}),this.maxInboundStreams=ee.maxInboundStreams,this.maxOutboundStreams=ee.maxOutboundStreams,this.allowedTopics=te.allowedTopics?new Set(te.allowedTopics):null}getPeers(){return[...this.peers.keys()].map(E=>peerIdFromString(E))}isStarted(){return this.status.code===GossipStatusCode.started}async start(){if(this.isStarted())return;this.log("starting"),this.publishConfig=await getPublishConfigFromPeerId(this.globalSignaturePolicy,this.components.peerId),this.outboundInflightQueue=pushable({objectMode:!0}),pipe$1(this.outboundInflightQueue,async ne=>{for await(const{peerId:ie,connection:se}of ne)await this.createOutboundStream(ie,se)}).catch(ne=>this.log.error("outbound inflight queue error",ne)),await Promise.all(this.opts.directPeers.map(async ne=>{await this.components.peerStore.merge(ne.id,{multiaddrs:ne.addrs})}));const E=this.components.registrar;await Promise.all(this.multicodecs.map(ne=>E.handle(ne,this.onIncomingStream.bind(this),{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams})));const ee=createTopology({onConnect:this.onPeerConnected.bind(this),onDisconnect:this.onPeerDisconnected.bind(this)}),te=await Promise.all(this.multicodecs.map(ne=>E.register(ne,ee))),re=setTimeout(this.runHeartbeat,GossipsubHeartbeatInitialDelay);this.status={code:GossipStatusCode.started,registrarTopologyIds:te,heartbeatTimeout:re,hearbeatStartMs:Date.now()+GossipsubHeartbeatInitialDelay},this.score.start(),this.directPeerInitial=setTimeout(()=>{Promise.resolve().then(async()=>{await Promise.all(Array.from(this.direct).map(async ne=>await this.connect(ne)))}).catch(ne=>{this.log(ne)})},GossipsubDirectConnectInitialDelay),this.log("started")}async stop(){if(this.log("stopping"),this.status.code!==GossipStatusCode.started)return;const{registrarTopologyIds:E}=this.status;this.status={code:GossipStatusCode.stopped};const ee=this.components.registrar;E.forEach(te=>ee.unregister(te)),this.outboundInflightQueue.end();for(const te of this.streamsOutbound.values())te.close();this.streamsOutbound.clear();for(const te of this.streamsInbound.values())te.close();this.streamsInbound.clear(),this.peers.clear(),this.subscriptions.clear(),this.heartbeatTimer&&(this.heartbeatTimer.cancel(),this.heartbeatTimer=null),this.score.stop(),this.mesh.clear(),this.fanout.clear(),this.fanoutLastpub.clear(),this.gossip.clear(),this.control.clear(),this.peerhave.clear(),this.iasked.clear(),this.backoff.clear(),this.outbound.clear(),this.gossipTracer.clear(),this.seenCache.clear(),this.fastMsgIdCache&&this.fastMsgIdCache.clear(),this.directPeerInitial&&clearTimeout(this.directPeerInitial),this.log("stopped")}dumpPeerScoreStats(){return this.score.dumpPeerScoreStats()}onIncomingStream({stream:E,connection:ee}){if(!this.isStarted())return;const te=ee.remotePeer;this.addPeer(te,ee.stat.direction,ee.remoteAddr),this.createInboundStream(te,E),this.outboundInflightQueue.push({peerId:te,connection:ee})}onPeerConnected(E,ee){this.metrics?.newConnectionCount.inc({status:ee.stat.status}),!(!this.isStarted()||ee.stat.status!=="OPEN")&&(this.addPeer(E,ee.stat.direction,ee.remoteAddr),this.outboundInflightQueue.push({peerId:E,connection:ee}))}onPeerDisconnected(E){this.log("connection ended %p",E),this.removePeer(E)}async createOutboundStream(E,ee){if(!this.isStarted())return;const te=E.toString();if(this.peers.has(te)&&!this.streamsOutbound.has(te))try{const re=new OutboundStream(await ee.newStream(this.multicodecs),ie=>this.log.error("outbound pipe error",ie),{maxBufferSize:this.opts.maxOutboundBufferSize});this.log("create outbound stream %p",E),this.streamsOutbound.set(te,re);const ne=re.protocol;ne===FloodsubID&&this.floodsubPeers.add(te),this.metrics?.peersPerProtocol.inc({protocol:ne},1),this.subscriptions.size>0&&(this.log("send subscriptions to",te),this.sendSubscriptions(te,Array.from(this.subscriptions),!0))}catch(re){this.log.error("createOutboundStream error",re)}}async createInboundStream(E,ee){if(!this.isStarted())return;const te=E.toString();if(!this.peers.has(te))return;const re=this.streamsInbound.get(te);re!==void 0&&(this.log("replacing existing inbound steam %s",te),re.close()),this.log("create inbound stream %s",te);const ne=new InboundStream(ee,{maxDataLength:this.opts.maxInboundDataLength});this.streamsInbound.set(te,ne),this.pipePeerReadStream(E,ne.source).catch(ie=>this.log(ie))}addPeer(E,ee,te){const re=E.toString();if(!this.peers.has(re)){this.log("new peer %p",E),this.peers.add(re),this.score.addPeer(re);const ne=multiaddrToIPStr(te);ne!==null?this.score.addIP(re,ne):this.log("Added peer has no IP in current address %s %s",re,te.toString()),this.outbound.has(re)||this.outbound.set(re,ee==="outbound")}}removePeer(E){const ee=E.toString();if(!this.peers.has(ee))return;this.log("delete peer %p",E),this.peers.delete(ee);const te=this.streamsOutbound.get(ee),re=this.streamsInbound.get(ee);te&&this.metrics?.peersPerProtocol.inc({protocol:te.protocol},-1),te?.close(),re?.close(),this.streamsOutbound.delete(ee),this.streamsInbound.delete(ee);for(const ne of this.topics.values())ne.delete(ee);for(const[ne,ie]of this.mesh)ie.delete(ee)===!0&&this.metrics?.onRemoveFromMesh(ne,ChurnReason.Dc,1);for(const ne of this.fanout.values())ne.delete(ee);this.floodsubPeers.delete(ee),this.gossip.delete(ee),this.control.delete(ee),this.outbound.delete(ee),this.score.removePeer(ee),this.acceptFromWhitelist.delete(ee)}get started(){return this.status.code===GossipStatusCode.started}getMeshPeers(E){const ee=this.mesh.get(E);return ee?Array.from(ee):[]}getSubscribers(E){const ee=this.topics.get(E);return(ee?Array.from(ee):[]).map(te=>peerIdFromString(te))}getTopics(){return Array.from(this.subscriptions)}async pipePeerReadStream(E,ee){try{await pipe$1(ee,async te=>{for await(const re of te)try{const ne=re.subarray(),ie=decodeRpc(ne,this.decodeRpcLimits);if(this.metrics?.onRpcRecv(ie,ne.length),this.opts.awaitRpcHandler)try{await this.handleReceivedRpc(E,ie)}catch(se){this.metrics?.onRpcRecvError(),this.log(se)}else this.handleReceivedRpc(E,ie).catch(se=>{this.metrics?.onRpcRecvError(),this.log(se)})}catch(ne){this.metrics?.onRpcDataError(),this.log(ne)}})}catch(te){this.metrics?.onPeerReadStreamError(),this.handlePeerReadStreamError(te,E)}}handlePeerReadStreamError(E,ee){this.log.error(E),this.onPeerDisconnected(ee)}async handleReceivedRpc(E,ee){if(!this.acceptFrom(E.toString())){this.log("received message from unacceptable peer %p",E),this.metrics?.rpcRecvNotAccepted.inc();return}const te=ee.subscriptions?ee.subscriptions.length:0,re=ee.messages?ee.messages.length:0;let ne=0,ie=0,se=0,oe=0;if(ee.control&&(ee.control.ihave&&(ne=ee.control.ihave.length),ee.control.iwant&&(ie=ee.control.iwant.length),ee.control.graft&&(se=ee.control.graft.length),ee.control.prune&&(oe=ee.control.prune.length)),this.log(`rpc.from ${E.toString()} subscriptions ${te} messages ${re} ihave ${ne} iwant ${ie} graft ${se} prune ${oe}`),ee.subscriptions&&ee.subscriptions.length>0){const ce=[];ee.subscriptions.forEach(ae=>{const le=ae.topic,ue=ae.subscribe===!0;if(le!=null){if(this.allowedTopics&&!this.allowedTopics.has(le))return;this.handleReceivedSubscription(E,le,ue),ce.push({topic:le,subscribe:ue})}}),this.dispatchEvent(new CustomEvent$2("subscription-change",{detail:{peerId:E,subscriptions:ce}}))}if(ee.messages)for(const ce of ee.messages){if(this.allowedTopics&&!this.allowedTopics.has(ce.topic))continue;const ae=this.handleReceivedMessage(E,ce).catch(le=>{this.metrics?.onMsgRecvError(ce.topic),this.log(le)});this.opts.awaitRpcMessageHandler&&await ae}ee.control&&await this.handleControlMessage(E.toString(),ee.control)}handleReceivedSubscription(E,ee,te){this.log("subscription update from %p topic %s",E,ee);let re=this.topics.get(ee);re==null&&(re=new Set,this.topics.set(ee,re)),te?re.add(E.toString()):re.delete(E.toString())}async handleReceivedMessage(E,ee){this.metrics?.onMsgRecvPreValidation(ee.topic);const te=await this.validateReceivedMessage(E,ee);switch(this.metrics?.onMsgRecvResult(ee.topic,te.code),te.code){case MessageStatus.duplicate:this.score.duplicateMessage(E.toString(),te.msgIdStr,ee.topic),this.gossipTracer.deliverMessage(te.msgIdStr,!0),this.mcache.observeDuplicate(te.msgIdStr,E.toString());return;case MessageStatus.invalid:if(te.msgIdStr){const re=te.msgIdStr;this.score.rejectMessage(E.toString(),re,ee.topic,te.reason),this.gossipTracer.rejectMessage(re,te.reason)}else this.score.rejectInvalidMessage(E.toString(),ee.topic);this.metrics?.onMsgRecvInvalid(ee.topic,te);return;case MessageStatus.valid:this.score.validateMessage(te.messageId.msgIdStr),this.gossipTracer.deliverMessage(te.messageId.msgIdStr),this.mcache.put(te.messageId,ee,!this.opts.asyncValidation),this.subscriptions.has(ee.topic)&&(!this.components.peerId.equals(E)||this.opts.emitSelf)&&(super.dispatchEvent(new CustomEvent$2("gossipsub:message",{detail:{propagationSource:E,msgId:te.messageId.msgIdStr,msg:te.msg}})),super.dispatchEvent(new CustomEvent$2("message",{detail:te.msg}))),this.opts.asyncValidation||this.forwardMessage(te.messageId.msgIdStr,ee,E.toString())}}async validateReceivedMessage(E,ee){const te=this.fastMsgIdFn?.(ee),re=te!==void 0?this.fastMsgIdCache?.get(te):void 0;if(re)return{code:MessageStatus.duplicate,msgIdStr:re};const ne=await validateToRawMessage(this.globalSignaturePolicy,ee);if(!ne.valid)return{code:MessageStatus.invalid,reason:RejectReason.Error,error:ne.error};const ie=ne.message;try{this.dataTransform&&(ie.data=this.dataTransform.inboundTransform(ee.topic,ie.data))}catch(le){return this.log("Invalid message, transform failed",le),{code:MessageStatus.invalid,reason:RejectReason.Error,error:ValidateError.TransformFailed}}const se=await this.msgIdFn(ie),oe=this.msgIdToStrFn(se),ce={msgId:se,msgIdStr:oe};if(te!==void 0&&this.fastMsgIdCache&&this.fastMsgIdCache.put(te,oe)&&this.metrics?.fastMsgIdCacheCollision.inc(),this.seenCache.has(oe))return{code:MessageStatus.duplicate,msgIdStr:oe};this.seenCache.put(oe);const ae=this.topicValidators.get(ee.topic);if(ae!=null){let le;try{le=await ae(E,ie)}catch(ue){const he=ue.code;he===ERR_TOPIC_VALIDATOR_IGNORE&&(le=TopicValidatorResult.Ignore),he===ERR_TOPIC_VALIDATOR_REJECT?le=TopicValidatorResult.Reject:le=TopicValidatorResult.Ignore}if(le!==TopicValidatorResult.Accept)return{code:MessageStatus.invalid,reason:rejectReasonFromAcceptance(le),msgIdStr:oe}}return{code:MessageStatus.valid,messageId:ce,msg:ie}}getScore(E){return this.score.score(E)}sendSubscriptions(E,ee,te){this.sendRpc(E,{subscriptions:ee.map(re=>({topic:re,subscribe:te}))})}async handleControlMessage(E,ee){if(ee===void 0)return;const te=ee.ihave?this.handleIHave(E,ee.ihave):[],re=ee.iwant?this.handleIWant(E,ee.iwant):[],ne=ee.graft?await this.handleGraft(E,ee.graft):[];if(ee.prune&&await this.handlePrune(E,ee.prune),!te.length&&!re.length&&!ne.length)return;const ie=this.sendRpc(E,{messages:re,control:{iwant:te,prune:ne}}),se=te[0]?.messageIDs;se&&(ie?this.gossipTracer.addPromise(E,se):this.metrics?.iwantPromiseUntracked.inc(1))}acceptFrom(E){if(this.direct.has(E))return!0;const ee=Date.now(),te=this.acceptFromWhitelist.get(E);if(te&&te.messagesAccepted<ACCEPT_FROM_WHITELIST_MAX_MESSAGES&&te.acceptUntil>=ee)return te.messagesAccepted+=1,!0;const re=this.score.score(E);return re>=ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE?this.acceptFromWhitelist.set(E,{messagesAccepted:0,acceptUntil:ee+ACCEPT_FROM_WHITELIST_DURATION_MS}):this.acceptFromWhitelist.delete(E),re>=this.opts.scoreThresholds.graylistThreshold}handleIHave(E,ee){if(!ee.length)return[];const te=this.score.score(E);if(te<this.opts.scoreThresholds.gossipThreshold)return this.log("IHAVE: ignoring peer %s with score below threshold [ score = %d ]",E,te),this.metrics?.ihaveRcvIgnored.inc({reason:IHaveIgnoreReason.LowScore}),[];const re=(this.peerhave.get(E)??0)+1;if(this.peerhave.set(E,re),re>GossipsubMaxIHaveMessages)return this.log("IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring",E,re),this.metrics?.ihaveRcvIgnored.inc({reason:IHaveIgnoreReason.MaxIhave}),[];const ne=this.iasked.get(E)??0;if(ne>=GossipsubMaxIHaveLength)return this.log("IHAVE: peer %s has already advertised too many messages (%d); ignoring",E,ne),this.metrics?.ihaveRcvIgnored.inc({reason:IHaveIgnoreReason.MaxIasked}),[];const ie=new Map;if(ee.forEach(({topicID:ce,messageIDs:ae})=>{if(!ce||!ae||!this.mesh.has(ce))return;let le=0;ae.forEach(ue=>{const he=this.msgIdToStrFn(ue);this.seenCache.has(he)||(ie.set(he,ue),le++)}),this.metrics?.onIhaveRcv(ce,ae.length,le)}),!ie.size)return[];let se=ie.size;se+ne>GossipsubMaxIHaveLength&&(se=GossipsubMaxIHaveLength-ne),this.log("IHAVE: Asking for %d out of %d messages from %s",se,ie.size,E);let oe=Array.from(ie.values());return shuffle(oe),oe=oe.slice(0,se),this.iasked.set(E,ne+se),[{messageIDs:oe}]}handleIWant(E,ee){if(!ee.length)return[];const te=this.score.score(E);if(te<this.opts.scoreThresholds.gossipThreshold)return this.log("IWANT: ignoring peer %s with score below threshold [score = %d]",E,te),[];const re=new Map,ne=new Map;let ie=0;return ee.forEach(({messageIDs:se})=>{se&&se.forEach(oe=>{const ce=this.msgIdToStrFn(oe),ae=this.mcache.getWithIWantCount(ce,E);if(ae==null){ie++;return}if(ne.set(ae.msg.topic,1+(ne.get(ae.msg.topic)??0)),ae.count>GossipsubGossipRetransmission){this.log("IWANT: Peer %s has asked for message %s too many times: ignoring request",E,oe);return}re.set(ce,ae.msg)})}),this.metrics?.onIwantRcv(ne,ie),re.size?(this.log("IWANT: Sending %d messages to %s",re.size,E),Array.from(re.values())):(this.log("IWANT: Could not provide any wanted messages to %s",E),[])}async handleGraft(E,ee){const te=[],re=this.score.score(E),ne=Date.now();let ie=this.opts.doPX;return ee.forEach(({topicID:se})=>{if(!se)return;const oe=this.mesh.get(se);if(!oe){ie=!1;return}if(oe.has(E))return;if(this.direct.has(E)){this.log("GRAFT: ignoring request from direct peer %s",E),te.push(se),ie=!1;return}const ce=this.backoff.get(se)?.get(E);if(typeof ce=="number"&&ne<ce){this.log("GRAFT: ignoring backed off peer %s",E),this.score.addPenalty(E,1,ScorePenalty.GraftBackoff),ie=!1;const ae=ce+this.opts.graftFloodThreshold-this.opts.pruneBackoff;ne<ae&&this.score.addPenalty(E,1,ScorePenalty.GraftBackoff),this.addBackoff(E,se),te.push(se);return}if(re<0){this.log("GRAFT: ignoring peer %s with negative score: score=%d, topic=%s",E,re,se),te.push(se),ie=!1,this.addBackoff(E,se);return}if(oe.size>=this.opts.Dhi&&!this.outbound.get(E)){te.push(se),this.addBackoff(E,se);return}this.log("GRAFT: Add mesh link from %s in %s",E,se),this.score.graft(E,se),oe.add(E),this.metrics?.onAddToMesh(se,InclusionReason.Subscribed,1)}),te.length?await Promise.all(te.map(se=>this.makePrune(E,se,ie))):[]}async handlePrune(E,ee){const te=this.score.score(E);for(const{topicID:re,backoff:ne,peers:ie}of ee){if(re==null)continue;const se=this.mesh.get(re);if(!se)return;if(this.log("PRUNE: Remove mesh link to %s in %s",E,re),this.score.prune(E,re),se.has(E)&&(se.delete(E),this.metrics?.onRemoveFromMesh(re,ChurnReason.Unsub,1)),typeof ne=="number"&&ne>0?this.doAddBackoff(E,re,ne*1e3):this.addBackoff(E,re),ie&&ie.length){if(te<this.opts.scoreThresholds.acceptPXThreshold){this.log("PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]",E,te,re);continue}await this.pxConnect(ie)}}}addBackoff(E,ee){this.doAddBackoff(E,ee,this.opts.pruneBackoff)}doAddBackoff(E,ee,te){let re=this.backoff.get(ee);re||(re=new Map,this.backoff.set(ee,re));const ne=Date.now()+te;(re.get(E)??0)<ne&&re.set(E,ne)}applyIwantPenalties(){this.gossipTracer.getBrokenPromises().forEach((E,ee)=>{this.log("peer %s didn't follow up in %d IWANT requests; adding penalty",ee,E),this.score.addPenalty(ee,E,ScorePenalty.BrokenPromise)})}clearBackoff(){if(this.heartbeatTicks%GossipsubPruneBackoffTicks!==0)return;const E=Date.now();this.backoff.forEach((ee,te)=>{ee.forEach((re,ne)=>{re<E&&ee.delete(ne)}),ee.size===0&&this.backoff.delete(te)})}async directConnect(){const E=[];this.direct.forEach(ee=>{this.streamsOutbound.has(ee)||E.push(ee)}),await Promise.all(E.map(async ee=>await this.connect(ee)))}async pxConnect(E){E.length>this.opts.prunePeers&&(shuffle(E),E=E.slice(0,this.opts.prunePeers));const ee=[];await Promise.all(E.map(async te=>{if(!te.peerID)return;const re=peerIdFromBytes(te.peerID),ne=re.toString();if(!this.peers.has(ne)){if(!te.signedPeerRecord){ee.push(ne);return}try{if(!await this.components.peerStore.consumePeerRecord(te.signedPeerRecord,re)){this.log("bogus peer record obtained through px: could not add peer record to address book");return}ee.push(ne)}catch{this.log("bogus peer record obtained through px: invalid signature or not a peer record")}}})),ee.length&&await Promise.all(ee.map(async te=>await this.connect(te)))}async connect(E){this.log("Initiating connection with %s",E);const ee=peerIdFromString(E),te=await this.components.connectionManager.openConnection(ee);for(const re of this.multicodecs)for(const ne of this.components.registrar.getTopologies(re))ne.onConnect(ee,te)}subscribe(E){if(this.status.code!==GossipStatusCode.started)throw new Error("Pubsub has not started");if(!this.subscriptions.has(E)){this.subscriptions.add(E);for(const ee of this.peers.keys())this.sendSubscriptions(ee,[E],!0)}this.join(E)}unsubscribe(E){if(this.status.code!==GossipStatusCode.started)throw new Error("Pubsub is not started");const ee=this.subscriptions.delete(E);if(this.log("unsubscribe from %s - am subscribed %s",E,ee),ee)for(const te of this.peers.keys())this.sendSubscriptions(te,[E],!1);this.leave(E)}join(E){if(this.status.code!==GossipStatusCode.started)throw new Error("Gossipsub has not started");if(this.mesh.has(E))return;this.log("JOIN %s",E),this.metrics?.onJoin(E);const ee=new Set,te=this.fanout.get(E);if(te&&(this.fanout.delete(E),this.fanoutLastpub.delete(E),te.forEach(re=>{!this.direct.has(re)&&this.score.score(re)>=0&&ee.add(re)}),this.metrics?.onAddToMesh(E,InclusionReason.Fanout,ee.size)),ee.size<this.opts.D){const re=ee.size;this.getRandomGossipPeers(E,this.opts.D,ne=>!ee.has(ne)&&!this.direct.has(ne)&&this.score.score(ne)>=0).forEach(ne=>{ee.add(ne)}),this.metrics?.onAddToMesh(E,InclusionReason.Random,ee.size-re)}this.mesh.set(E,ee),ee.forEach(re=>{this.log("JOIN: Add mesh link to %s in %s",re,E),this.sendGraft(re,E)})}leave(E){if(this.status.code!==GossipStatusCode.started)throw new Error("Gossipsub has not started");this.log("LEAVE %s",E),this.metrics?.onLeave(E);const ee=this.mesh.get(E);ee&&(Promise.all(Array.from(ee).map(async te=>(this.log("LEAVE: Remove mesh link to %s in %s",te,E),await this.sendPrune(te,E)))).catch(te=>{this.log("Error sending prunes to mesh peers",te)}),this.mesh.delete(E))}selectPeersToForward(E,ee,te){const re=new Set,ne=this.topics.get(E);ne&&(this.direct.forEach(se=>{ne.has(se)&&ee!==se&&!te?.has(se)&&re.add(se)}),this.floodsubPeers.forEach(se=>{ne.has(se)&&ee!==se&&!te?.has(se)&&this.score.score(se)>=this.opts.scoreThresholds.publishThreshold&&re.add(se)}));const ie=this.mesh.get(E);return ie&&ie.size>0&&ie.forEach(se=>{ee!==se&&!te?.has(se)&&re.add(se)}),re}selectPeersToPublish(E){const ee=new Set,te={direct:0,floodsub:0,mesh:0,fanout:0},re=this.topics.get(E);if(re)if(this.opts.floodPublish)re.forEach(ne=>{this.direct.has(ne)?(ee.add(ne),te.direct++):this.score.score(ne)>=this.opts.scoreThresholds.publishThreshold&&(ee.add(ne),te.floodsub++)});else{this.direct.forEach(ie=>{re.has(ie)&&(ee.add(ie),te.direct++)}),this.floodsubPeers.forEach(ie=>{re.has(ie)&&this.score.score(ie)>=this.opts.scoreThresholds.publishThreshold&&(ee.add(ie),te.floodsub++)});const ne=this.mesh.get(E);if(ne&&ne.size>0)ne.forEach(ie=>{ee.add(ie),te.mesh++});else{const ie=this.fanout.get(E);if(ie&&ie.size>0)ie.forEach(se=>{ee.add(se),te.fanout++});else{const se=this.getRandomGossipPeers(E,this.opts.D,oe=>this.score.score(oe)>=this.opts.scoreThresholds.publishThreshold);se.size>0&&(this.fanout.set(E,se),se.forEach(oe=>{ee.add(oe),te.fanout++}))}this.fanoutLastpub.set(E,Date.now())}}return{tosend:ee,tosendCount:te}}forwardMessage(E,ee,te,re){te&&this.score.deliverMessage(te,E,ee.topic);const ne=this.selectPeersToForward(ee.topic,te,re);ne.forEach(ie=>{this.sendRpc(ie,{messages:[ee]})}),this.metrics?.onForwardMsg(ee.topic,ne.size)}async publish(E,ee,te){const re=this.dataTransform?this.dataTransform.outboundTransform(E,ee):ee;if(this.publishConfig==null)throw Error("PublishError.Uninitialized");const{raw:ne,msg:ie}=await buildRawMessage(this.publishConfig,E,ee,re),se=await this.msgIdFn(ie),oe=this.msgIdToStrFn(se),ce=te?.ignoreDuplicatePublishError??this.opts.ignoreDuplicatePublishError;if(this.seenCache.has(oe)){if(ce)return this.metrics?.onPublishDuplicateMsg(E),{recipients:[]};throw Error("PublishError.Duplicate")}const{tosend:ae,tosendCount:le}=this.selectPeersToPublish(E),ue=this.opts.emitSelf===!0&&this.subscriptions.has(E),he=te?.allowPublishToZeroPeers??this.opts.allowPublishToZeroPeers;if(ae.size===0&&!he&&!ue)throw Error("PublishError.InsufficientPeers");this.seenCache.put(oe),this.mcache.put({msgId:se,msgIdStr:oe},ne,!0),this.publishedMessageIds.put(oe);for(const pe of ae)this.sendRpc(pe,{messages:[ne]})||ae.delete(pe);return this.metrics?.onPublishMsg(E,le,ae.size,ne.data!=null?ne.data.length:0),ue&&(ae.add(this.components.peerId.toString()),super.dispatchEvent(new CustomEvent$2("gossipsub:message",{detail:{propagationSource:this.components.peerId,msgId:oe,msg:ie}})),super.dispatchEvent(new CustomEvent$2("message",{detail:ie}))),{recipients:Array.from(ae.values()).map(pe=>peerIdFromString(pe))}}reportMessageValidationResult(E,ee,te){if(te===TopicValidatorResult.Accept){const re=this.mcache.validate(E);if(this.metrics?.onReportValidationMcacheHit(re!==null),re!=null){const{message:ne,originatingPeers:ie}=re;this.score.deliverMessage(ee.toString(),E,ne.topic),this.forwardMessage(E,re.message,ee.toString(),ie),this.metrics?.onReportValidation(ne.topic,te)}}else{const re=this.mcache.remove(E);if(this.metrics?.onReportValidationMcacheHit(re!==null),re){const ne=rejectReasonFromAcceptance(te),{message:ie,originatingPeers:se}=re;this.score.rejectMessage(ee.toString(),E,ie.topic,ne);for(const oe of se)this.score.rejectMessage(oe,E,ie.topic,ne);this.metrics?.onReportValidation(ie.topic,te)}}}sendGraft(E,ee){const te=[{topicID:ee}];this.sendRpc(E,{control:{graft:te}})}async sendPrune(E,ee){const te=[await this.makePrune(E,ee,this.opts.doPX)];this.sendRpc(E,{control:{prune:te}})}sendRpc(E,ee){const te=this.streamsOutbound.get(E);if(!te)return this.log(`Cannot send RPC to ${E} as there is no open stream to it available`),!1;const re=this.control.get(E);re&&(this.piggybackControl(E,ee,re),this.control.delete(E));const ne=this.gossip.get(E);ne&&(this.piggybackGossip(E,ee,ne),this.gossip.delete(E));const ie=RPC$1.encode(ee).finish();try{te.push(ie)}catch(se){return this.log.error(`Cannot send rpc to ${E}`,se),re&&this.control.set(E,re),ne&&this.gossip.set(E,ne),!1}return this.metrics?.onRpcSent(ee,ie.length),!0}piggybackControl(E,ee,te){if(te.graft){ee.control||(ee.control={}),ee.control.graft||(ee.control.graft=[]);for(const re of te.graft)re.topicID&&this.mesh.get(re.topicID)?.has(E)&&ee.control.graft.push(re)}if(te.prune){ee.control||(ee.control={}),ee.control.prune||(ee.control.prune=[]);for(const re of te.prune)re.topicID&&!this.mesh.get(re.topicID)?.has(E)&&ee.control.prune.push(re)}}piggybackGossip(E,ee,te){ee.control||(ee.control={}),ee.control.ihave=te}async sendGraftPrune(E,ee,te){const re=this.opts.doPX;for(const[ne,ie]of E){const se=ie.map(ae=>({topicID:ae}));let oe=[];const ce=ee.get(ne);ce&&(oe=await Promise.all(ce.map(async ae=>await this.makePrune(ne,ae,re&&!(te.get(ne)??!1)))),ee.delete(ne)),this.sendRpc(ne,{control:{graft:se,prune:oe}})}for(const[ne,ie]of ee){const se=await Promise.all(ie.map(async oe=>await this.makePrune(ne,oe,re&&!(te.get(ne)??!1))));this.sendRpc(ne,{control:{prune:se}})}}emitGossip(E){const ee=this.mcache.getGossipIDs(new Set(E.keys()));for(const[te,re]of E)this.doEmitGossip(te,re,ee.get(te)??[])}doEmitGossip(E,ee,te){if(!te.length||(shuffle(te),te.length>GossipsubMaxIHaveLength&&this.log("too many messages for gossip; will truncate IHAVE list (%d messages)",te.length),!ee.size))return;let re=this.opts.Dlazy;const ne=GossipsubGossipFactor*ee.size;let ie=ee;ne>re&&(re=ne),re>ie.size?re=ie.size:ie=shuffle(Array.from(ie)).slice(0,re),ie.forEach(se=>{let oe=te;te.length>GossipsubMaxIHaveLength&&(oe=shuffle(oe.slice()).slice(0,GossipsubMaxIHaveLength)),this.pushGossip(se,{topicID:E,messageIDs:oe})})}flush(){for(const[E,ee]of this.gossip.entries())this.gossip.delete(E),this.sendRpc(E,{control:{ihave:ee}});for(const[E,ee]of this.control.entries())this.control.delete(E),this.sendRpc(E,{control:{graft:ee.graft,prune:ee.prune}})}pushGossip(E,ee){this.log("Add gossip to %s",E);const te=this.gossip.get(E)||[];this.gossip.set(E,te.concat(ee))}async makePrune(E,ee,te){if(this.score.prune(E,ee),this.streamsOutbound.get(E).protocol===GossipsubIDv10)return{topicID:ee,peers:[]};const re=this.opts.pruneBackoff/1e3;if(!te)return{topicID:ee,peers:[],backoff:re};const ne=this.getRandomGossipPeers(ee,this.opts.prunePeers,se=>se!==E&&this.score.score(se)>=0),ie=await Promise.all(Array.from(ne).map(async se=>{const oe=peerIdFromString(se);let ce;try{ce=await this.components.peerStore.get(oe)}catch(ae){if(ae.code!=="ERR_NOT_FOUND")throw ae}return{peerID:oe.toBytes(),signedPeerRecord:ce?.peerRecordEnvelope}}));return{topicID:ee,peers:ie,backoff:re}}async heartbeat(){const{D:E,Dlo:ee,Dhi:te,Dscore:re,Dout:ne,fanoutTTL:ie}=this.opts;this.heartbeatTicks++;const se=new Map,oe=pe=>{let de=se.get(pe);return de===void 0&&(de=this.score.score(pe),se.set(pe,de)),de},ce=new Map,ae=new Map,le=new Map;this.clearBackoff(),this.peerhave.clear(),this.metrics?.cacheSize.set({cache:"iasked"},this.iasked.size),this.iasked.clear(),this.applyIwantPenalties(),this.heartbeatTicks%this.opts.directConnectTicks===0&&await this.directConnect(),this.fastMsgIdCache?.prune(),this.seenCache.prune(),this.gossipTracer.prune(),this.publishedMessageIds.prune();const ue=new Map;this.mesh.forEach((pe,de)=>{const fe=this.topics.get(de),me=new Set,_e=new Set;if(ue.set(de,_e),fe){const ve=shuffle(Array.from(fe)),we=this.backoff.get(de);for(const ge of ve){const Se=this.streamsOutbound.get(ge);if(Se&&this.multicodecs.includes(Se.protocol)&&!pe.has(ge)&&!this.direct.has(ge)){const $e=oe(ge);(!we||!we.has(ge))&&$e>=0&&me.add(ge),$e>=this.opts.scoreThresholds.gossipThreshold&&_e.add(ge)}}}const be=(ve,we)=>{this.log("HEARTBEAT: Remove mesh link to %s in %s",ve,de),this.addBackoff(ve,de),pe.delete(ve),oe(ve)>=this.opts.scoreThresholds.gossipThreshold&&_e.add(ve),this.metrics?.onRemoveFromMesh(de,we,1);const ge=ae.get(ve);ge?ge.push(de):ae.set(ve,[de])},Ee=(ve,we)=>{this.log("HEARTBEAT: Add mesh link to %s in %s",ve,de),this.score.graft(ve,de),pe.add(ve),_e.delete(ve),this.metrics?.onAddToMesh(de,we,1);const ge=ce.get(ve);ge?ge.push(de):ce.set(ve,[de])};if(pe.forEach(ve=>{const we=oe(ve);we<0&&(this.log("HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s",ve,we,de),be(ve,ChurnReason.BadScore),le.set(ve,!0))}),pe.size<ee){const ve=E-pe.size;removeFirstNItemsFromSet(me,ve).forEach(we=>{Ee(we,InclusionReason.NotEnough)})}if(pe.size>te){let ve=Array.from(pe);ve.sort((ge,Se)=>oe(Se)-oe(ge)),ve=ve.slice(0,re).concat(shuffle(ve.slice(re)));let we=0;if(ve.slice(0,E).forEach(ge=>{this.outbound.get(ge)&&we++}),we<ne){const ge=$e=>{const Pe=ve[$e];for(let Me=$e;Me>0;Me--)ve[Me]=ve[Me-1];ve[0]=Pe};if(we>0){let $e=we;for(let Pe=1;Pe<E&&$e>0;Pe++)this.outbound.get(ve[Pe])&&(ge(Pe),$e--)}let Se=E-we;for(let $e=E;$e<ve.length&&Se>0;$e++)this.outbound.get(ve[$e])&&(ge($e),Se--)}ve.slice(E).forEach(ge=>{be(ge,ChurnReason.Excess)})}if(pe.size>=ee){let ve=0;if(pe.forEach(we=>{this.outbound.get(we)&&ve++}),ve<ne){const we=ne-ve;removeItemsFromSet(me,we,ge=>this.outbound.get(ge)===!0).forEach(ge=>{Ee(ge,InclusionReason.Outbound)})}}if(this.heartbeatTicks%this.opts.opportunisticGraftTicks===0&&pe.size>1){const ve=Array.from(pe).sort((Se,$e)=>oe(Se)-oe($e)),we=Math.floor(pe.size/2),ge=oe(ve[we]);if(ge<this.opts.scoreThresholds.opportunisticGraftThreshold){const Se=this.opts.opportunisticGraftPeers,$e=removeItemsFromSet(me,Se,Pe=>oe(Pe)>ge);for(const Pe of $e)this.log("HEARTBEAT: Opportunistically graft peer %s on topic %s",Pe,de),Ee(Pe,InclusionReason.Opportunistic)}}});const he=Date.now();this.fanoutLastpub.forEach((pe,de)=>{pe+ie<he&&(this.fanout.delete(de),this.fanoutLastpub.delete(de))}),this.fanout.forEach((pe,de)=>{const fe=this.topics.get(de);pe.forEach(Ee=>{(!fe.has(Ee)||oe(Ee)<this.opts.scoreThresholds.publishThreshold)&&pe.delete(Ee)});const me=this.topics.get(de),_e=[],be=new Set;if(ue.set(de,be),me){const Ee=shuffle(Array.from(me));for(const ve of Ee){const we=this.streamsOutbound.get(ve);if(we&&this.multicodecs.includes(we.protocol)&&!pe.has(ve)&&!this.direct.has(ve)){const ge=oe(ve);ge>=this.opts.scoreThresholds.publishThreshold&&_e.push(ve),ge>=this.opts.scoreThresholds.gossipThreshold&&be.add(ve)}}}if(pe.size<E){const Ee=E-pe.size;_e.slice(0,Ee).forEach(ve=>{pe.add(ve),be?.delete(ve)})}}),this.emitGossip(ue),await this.sendGraftPrune(ce,ae,le),this.flush(),this.mcache.shift(),this.dispatchEvent(new CustomEvent$2("gossipsub:heartbeat"))}getRandomGossipPeers(E,ee,te=()=>!0){const re=this.topics.get(E);if(!re)return new Set;let ne=[];return re.forEach(ie=>{const se=this.streamsOutbound.get(ie);se&&this.multicodecs.includes(se.protocol)&&te(ie)&&ne.push(ie)}),ne=shuffle(ne),ee>0&&ne.length>ee&&(ne=ne.slice(0,ee)),new Set(ne)}onScrapeMetrics(E){E.mcacheSize.set(this.mcache.size),E.mcacheNotValidatedCount.set(this.mcache.notValidatedCount),E.cacheSize.set({cache:"direct"},this.direct.size),E.cacheSize.set({cache:"seenCache"},this.seenCache.size),E.cacheSize.set({cache:"fastMsgIdCache"},this.fastMsgIdCache?.size??0),E.cacheSize.set({cache:"publishedMessageIds"},this.publishedMessageIds.size),E.cacheSize.set({cache:"mcache"},this.mcache.size),E.cacheSize.set({cache:"score"},this.score.size),E.cacheSize.set({cache:"gossipTracer.promises"},this.gossipTracer.size),E.cacheSize.set({cache:"gossipTracer.requests"},this.gossipTracer.requestMsByMsgSize),E.cacheSize.set({cache:"topics"},this.topics.size),E.cacheSize.set({cache:"subscriptions"},this.subscriptions.size),E.cacheSize.set({cache:"mesh"},this.mesh.size),E.cacheSize.set({cache:"fanout"},this.fanout.size),E.cacheSize.set({cache:"peers"},this.peers.size),E.cacheSize.set({cache:"streamsOutbound"},this.streamsOutbound.size),E.cacheSize.set({cache:"streamsInbound"},this.streamsInbound.size),E.cacheSize.set({cache:"acceptFromWhitelist"},this.acceptFromWhitelist.size),E.cacheSize.set({cache:"gossip"},this.gossip.size),E.cacheSize.set({cache:"control"},this.control.size),E.cacheSize.set({cache:"peerhave"},this.peerhave.size),E.cacheSize.set({cache:"outbound"},this.outbound.size);let ee=0;for(const ie of this.backoff.values())ee+=ie.size;E.cacheSize.set({cache:"backoff"},ee);for(const[ie,se]of this.topics)E.topicPeersCount.set({topicStr:ie},se.size);for(const[ie,se]of this.mesh)E.meshPeerCounts.set({topicStr:ie},se.size);const te=[],re=new Map;E.behaviourPenalty.reset();for(const ie of this.peers.keys()){const se=this.score.score(ie);te.push(se),re.set(ie,se),E.behaviourPenalty.observe(this.score.peerStats.get(ie)?.behaviourPenalty??0)}E.registerScores(te,this.opts.scoreThresholds),E.registerScorePerMesh(this.mesh,re);const ne=computeAllPeersScoreWeights(this.peers.keys(),this.score.peerStats,this.score.params,this.score.peerIPs,E.topicStrToLabel);E.registerScoreWeights(ne)}}GossipSub.multicodec=GossipsubIDv11;function gossipsub(J={}){return E=>new GossipSub(E,J)}const ERR_INVALID_FRAME="ERR_INVALID_FRAME",ERR_UNREQUESTED_PING="ERR_UNREQUESTED_PING",ERR_NOT_MATCHING_PING="ERR_NOT_MATCHING_PING",ERR_STREAM_ALREADY_EXISTS="ERR_STREAM_ALREADY_EXISTS",ERR_DECODE_INVALID_VERSION="ERR_DECODE_INVALID_VERSION",ERR_BOTH_CLIENTS="ERR_BOTH_CLIENTS",ERR_RECV_WINDOW_EXCEEDED="ERR_RECV_WINDOW_EXCEEDED",PROTOCOL_ERRORS=new Set([ERR_INVALID_FRAME,ERR_UNREQUESTED_PING,ERR_NOT_MATCHING_PING,ERR_STREAM_ALREADY_EXISTS,ERR_DECODE_INVALID_VERSION,ERR_BOTH_CLIENTS,ERR_RECV_WINDOW_EXCEEDED]),ERR_INVALID_CONFIG="ERR_INVALID_CONFIG",ERR_MUXER_LOCAL_CLOSED="ERR_MUXER_LOCAL_CLOSED",ERR_MUXER_REMOTE_CLOSED="ERR_MUXER_REMOTE_CLOSED",ERR_STREAM_RESET$1="ERR_STREAM_RESET",ERR_STREAM_ABORT$1="ERR_STREAM_ABORT",ERR_MAX_OUTBOUND_STREAMS_EXCEEDED="ERROR_MAX_OUTBOUND_STREAMS_EXCEEDED",ERR_DECODE_IN_PROGRESS="ERR_DECODE_IN_PROGRESS",INITIAL_STREAM_WINDOW=256*1024,MAX_STREAM_WINDOW=16*1024*1024,defaultConfig={log:logger$1("libp2p:yamux"),enableKeepAlive:!0,keepAliveInterval:3e4,maxInboundStreams:1e3,maxOutboundStreams:1e3,initialStreamWindowSize:INITIAL_STREAM_WINDOW,maxStreamWindowSize:MAX_STREAM_WINDOW,maxMessageSize:64*1024};function verifyConfig(J){if(J.keepAliveInterval<=0)throw new CodeError("keep-alive interval must be positive",ERR_INVALID_CONFIG);if(J.maxInboundStreams<0)throw new CodeError("max inbound streams must be larger or equal 0",ERR_INVALID_CONFIG);if(J.maxOutboundStreams<0)throw new CodeError("max outbound streams must be larger or equal 0",ERR_INVALID_CONFIG);if(J.initialStreamWindowSize<INITIAL_STREAM_WINDOW)throw new CodeError("InitialStreamWindowSize must be larger or equal 256 kB",ERR_INVALID_CONFIG);if(J.maxStreamWindowSize<J.initialStreamWindowSize)throw new CodeError("MaxStreamWindowSize must be larger than the InitialStreamWindowSize",ERR_INVALID_CONFIG);if(J.maxStreamWindowSize>2**32-1)throw new CodeError("MaxStreamWindowSize must be less than equal MAX_UINT32",ERR_INVALID_CONFIG);if(J.maxMessageSize<1024)throw new CodeError("MaxMessageSize must be greater than a kilobyte",ERR_INVALID_CONFIG)}var FrameType;(function(J){J[J.Data=0]="Data",J[J.WindowUpdate=1]="WindowUpdate",J[J.Ping=2]="Ping",J[J.GoAway=3]="GoAway"})(FrameType||(FrameType={}));var Flag;(function(J){J[J.SYN=1]="SYN",J[J.ACK=2]="ACK",J[J.FIN=4]="FIN",J[J.RST=8]="RST"})(Flag||(Flag={}));const flagCodes=Object.values(Flag).filter(J=>typeof J!="string"),YAMUX_VERSION=0;var GoAwayCode;(function(J){J[J.NormalTermination=0]="NormalTermination",J[J.ProtocolError=1]="ProtocolError",J[J.InternalError=2]="InternalError"})(GoAwayCode||(GoAwayCode={}));const HEADER_LENGTH=12;function stringifyHeader(J){const E=flagCodes.filter(ee=>(J.flag&ee)===ee).map(ee=>Flag[ee]).join("|");return`streamID=${J.streamID} type=${FrameType[J.type]} flag=${E} length=${J.length}`}const twoPow24=2**24;function decodeHeader(J){if(J[0]!==YAMUX_VERSION)throw new CodeError("Invalid frame version",ERR_DECODE_INVALID_VERSION);return{type:J[1],flag:(J[2]<<8)+J[3],streamID:J[4]*twoPow24+(J[5]<<16)+(J[6]<<8)+J[7],length:J[8]*twoPow24+(J[9]<<16)+(J[10]<<8)+J[11]}}let Decoder$1=class{source;buffer;frameInProgress;constructor(J){this.source=returnlessSource(J),this.buffer=new Uint8ArrayList,this.frameInProgress=!1}async*emitFrames(){for await(const J of this.source)for(this.buffer.append(J);;){const E=this.readHeader();if(E===void 0)break;const{type:ee,length:te}=E;ee===FrameType.Data?(this.frameInProgress=!0,yield{header:E,readData:this.readBytes.bind(this,te)}):yield{header:E}}}readHeader(){if(this.frameInProgress)throw new CodeError("decoding frame already in progress",ERR_DECODE_IN_PROGRESS);if(this.buffer.length<HEADER_LENGTH)return;const J=decodeHeader(this.buffer.subarray(0,HEADER_LENGTH));return this.buffer.consume(HEADER_LENGTH),J}async readBytes(J){if(this.buffer.length<J){for await(const ee of this.source)if(this.buffer.append(ee),this.buffer.length>=J)break}const E=this.buffer.sublist(0,J);return this.buffer.consume(J),this.frameInProgress=!1,E}};function returnlessSource(J){if(J[Symbol.iterator]!==void 0){const E=J[Symbol.iterator]();return E.return=void 0,{[Symbol.iterator](){return E}}}else if(J[Symbol.asyncIterator]!==void 0){const E=J[Symbol.asyncIterator]();return E.return=void 0,{[Symbol.asyncIterator](){return E}}}else throw new Error("a source must be either an iterable or an async iterable")}function encodeHeader(J){const E=new Uint8Array(HEADER_LENGTH);return E[1]=J.type,E[2]=J.flag>>>8,E[3]=J.flag,E[4]=J.streamID>>>24,E[5]=J.streamID>>>16,E[6]=J.streamID>>>8,E[7]=J.streamID,E[8]=J.length>>>24,E[9]=J.length>>>16,E[10]=J.length>>>8,E[11]=J.length,E}var StreamState;(function(J){J[J.Init=0]="Init",J[J.SYNSent=1]="SYNSent",J[J.SYNReceived=2]="SYNReceived",J[J.Established=3]="Established",J[J.Finished=4]="Finished"})(StreamState||(StreamState={}));var HalfStreamState;(function(J){J[J.Open=0]="Open",J[J.Closed=1]="Closed",J[J.Reset=2]="Reset"})(HalfStreamState||(HalfStreamState={}));class YamuxStream{id;name;stat;metadata;state;readState;writeState;sourceInput;source;sink;config;log;_id;sendWindowCapacity;sendWindowCapacityUpdate;recvWindow;recvWindowCapacity;epochStart;getRTT;abortController;sendFrame;onStreamEnd;constructor(E){this.config=E.config,this.log=E.log,this._id=E.id,this.id=String(E.id),this.name=E.name,this.stat={direction:E.direction,timeline:{open:Date.now()}},this.metadata={},this.state=E.state,this.readState=HalfStreamState.Open,this.writeState=HalfStreamState.Open,this.sendWindowCapacity=INITIAL_STREAM_WINDOW,this.recvWindow=this.config.initialStreamWindowSize,this.recvWindowCapacity=this.recvWindow,this.epochStart=Date.now(),this.getRTT=E.getRTT,this.abortController=new AbortController,this.sendFrame=E.sendFrame,this.onStreamEnd=E.onStreamEnd,this.sourceInput=pushable({onEnd:ee=>{ee!=null?this.log?.error("stream source ended id=%s",this._id,ee):this.log?.trace("stream source ended id=%s",this._id),this.closeRead()}}),this.source=this.createSource(),this.sink=async ee=>{if(this.writeState!==HalfStreamState.Open)throw new Error("stream closed for writing");ee=abortableSource$1(ee,this.abortController.signal,{returnOnAbort:!0});try{for await(let te of ee)for(;te.length!==0;){this.sendWindowCapacity===0&&await this.waitForSendWindowCapacity();const re=Math.min(this.sendWindowCapacity,this.config.maxMessageSize-HEADER_LENGTH,te.length);this.sendData(te.subarray(0,re)),this.sendWindowCapacity-=re,te=te.subarray(re)}}catch(te){this.log?.error("stream sink error id=%s",this._id,te)}finally{this.log?.trace("stream sink ended id=%s",this._id),this.closeWrite()}}}async*createSource(){try{for await(const E of this.sourceInput)this.sendWindowUpdate(),yield E}catch(E){if(E.code!==ERR_STREAM_ABORT$1)throw this.log?.error("stream source error id=%s",this._id,E),E}}close(){this.log?.trace("stream close id=%s",this._id),this.closeRead(),this.closeWrite()}closeRead(){this.state!==StreamState.Finished&&this.readState===HalfStreamState.Open&&(this.log?.trace("stream close read id=%s",this._id),this.readState=HalfStreamState.Closed,this.sourceInput.end(),this.writeState!==HalfStreamState.Open&&this.finish())}closeWrite(){this.state!==StreamState.Finished&&this.writeState===HalfStreamState.Open&&(this.log?.trace("stream close write id=%s",this._id),this.writeState=HalfStreamState.Closed,this.sendClose(),this.abortController.abort(),this.readState!==HalfStreamState.Open&&this.finish())}abort(E){switch(this.state){case StreamState.Finished:return;case StreamState.Init:break;case StreamState.SYNSent:case StreamState.SYNReceived:case StreamState.Established:this.sendReset();break;default:throw new Error("unreachable")}E!=null?this.log?.error("stream abort id=%s error=%s",this._id,E):this.log?.trace("stream abort id=%s",this._id),this.onReset(new CodeError(String(E)??"stream aborted",ERR_STREAM_ABORT$1))}reset(){this.state!==StreamState.Finished&&(this.log?.trace("stream reset id=%s",this._id),this.onReset(new CodeError("stream reset",ERR_STREAM_RESET$1)))}onReset(E){this.writeState===HalfStreamState.Open&&(this.writeState=HalfStreamState.Reset),this.readState===HalfStreamState.Open&&(this.readState=HalfStreamState.Reset),this.state=StreamState.Finished,this.sourceInput.end(E),this.abortController.abort(),this.finish()}async waitForSendWindowCapacity(){if(this.abortController.signal.aborted)throw new CodeError("stream aborted",ERR_STREAM_ABORT$1);if(this.sendWindowCapacity>0)return;let E;const ee=()=>{E(new CodeError("stream aborted",ERR_STREAM_ABORT$1))};this.abortController.signal.addEventListener("abort",ee),await new Promise((te,re)=>{this.sendWindowCapacityUpdate=()=>{this.abortController.signal.removeEventListener("abort",ee),te(void 0)},E=re})}handleWindowUpdate(E){this.log?.trace("stream received window update id=%s",this._id),this.processFlags(E.flag);const ee=this.sendWindowCapacity;this.sendWindowCapacity+=E.length,ee===0&&E.length>0&&this.sendWindowCapacityUpdate?.()}async handleData(E,ee){if(this.log?.trace("stream received data id=%s",this._id),this.processFlags(E.flag),this.recvWindowCapacity<E.length)throw new CodeError("receive window exceeded",ERR_RECV_WINDOW_EXCEEDED,{available:this.recvWindowCapacity,recv:E.length});const te=await ee();this.recvWindowCapacity-=E.length,this.sourceInput.push(te)}processFlags(E){(E&Flag.ACK)===Flag.ACK&&this.state===StreamState.SYNSent&&(this.state=StreamState.Established),(E&Flag.FIN)===Flag.FIN&&this.closeRead(),(E&Flag.RST)===Flag.RST&&this.reset()}finish(){this.log?.trace("stream finished id=%s",this._id),this.state=StreamState.Finished,this.stat.timeline.close=Date.now(),this.onStreamEnd()}getSendFlags(){switch(this.state){case StreamState.Init:return this.state=StreamState.SYNSent,Flag.SYN;case StreamState.SYNReceived:return this.state=StreamState.Established,Flag.ACK;default:return 0}}sendWindowUpdate(){const E=this.getSendFlags(),ee=Date.now(),te=this.getRTT();if(E===0&&te>0&&ee-this.epochStart<te*4&&(this.recvWindow=Math.min(this.recvWindow*2,this.config.maxStreamWindowSize)),this.recvWindowCapacity>=this.recvWindow&&E===0)return;const re=this.recvWindow-this.recvWindowCapacity;this.recvWindowCapacity=this.recvWindow,this.epochStart=ee,this.sendFrame({type:FrameType.WindowUpdate,flag:E,streamID:this._id,length:re})}sendData(E){const ee=this.getSendFlags();this.sendFrame({type:FrameType.Data,flag:ee,streamID:this._id,length:E.length},E)}sendClose(){const E=this.getSendFlags()|Flag.FIN;this.sendFrame({type:FrameType.WindowUpdate,flag:E,streamID:this._id,length:0})}sendReset(){this.sendFrame({type:FrameType.WindowUpdate,flag:Flag.RST,streamID:this._id,length:0})}}const YAMUX_PROTOCOL_ID="/yamux/1.0.0";class Yamux{protocol=YAMUX_PROTOCOL_ID;_init;constructor(E={}){this._init=E}createStreamMuxer(E){return new YamuxMuxer({...this._init,...E})}}class YamuxMuxer{protocol=YAMUX_PROTOCOL_ID;source;sink;_init;config;log;closeController;nextStreamID;_streams;nextPingID;activePing;rtt;client;localGoAway;remoteGoAway;numInboundStreams;numOutboundStreams;onIncomingStream;onStreamEnd;constructor(E){this._init=E,this.client=E.direction==="outbound",this.config={...defaultConfig,...E},this.log=this.config.log,verifyConfig(this.config),this.closeController=new AbortController,this.onIncomingStream=E.onIncomingStream,this.onStreamEnd=E.onStreamEnd,this._streams=new Map,this.source=pushable({onEnd:ee=>{this.log?.trace("muxer source ended"),this.close(ee)}}),this.sink=async ee=>{let te;this._init.signal!=null&&(te=anySignal([this.closeController.signal,this._init.signal])),ee=abortableSource$1(ee,te??this.closeController.signal,{returnOnAbort:!0});let re,ne;try{const ie=new Decoder$1(ee);await pipe$1(ie.emitFrames.bind(ie),async se=>{for await(const{header:oe,readData:ce}of se)await this.handleFrame(oe,ce)}),re=GoAwayCode.NormalTermination}catch(ie){const se=ie.code;PROTOCOL_ERRORS.has(se)?(this.log?.error("protocol error in sink",ie),re=GoAwayCode.ProtocolError):(this.log?.error("internal error in sink",ie),re=GoAwayCode.InternalError),ne=ie}finally{te?.clear()}this.log?.trace("muxer sink ended"),this.close(ne,re)},this.numInboundStreams=0,this.numOutboundStreams=0,this.nextStreamID=this.client?1:2,this.nextPingID=0,this.rtt=0,this.log?.trace("muxer created"),this.config.enableKeepAlive&&this.keepAliveLoop().catch(ee=>this.log?.error("keepalive error: %s",ee))}get streams(){return Array.from(this._streams.values())}newStream(E){if(this.remoteGoAway!==void 0)throw new CodeError("muxer closed remotely",ERR_MUXER_REMOTE_CLOSED);if(this.localGoAway!==void 0)throw new CodeError("muxer closed locally",ERR_MUXER_LOCAL_CLOSED);const ee=this.nextStreamID;if(this.nextStreamID+=2,this.numOutboundStreams>=this.config.maxOutboundStreams)throw new CodeError("max outbound streams exceeded",ERR_MAX_OUTBOUND_STREAMS_EXCEEDED);this.log?.trace("new outgoing stream id=%s",ee);const te=this._newStream(ee,E,StreamState.Init,"outbound");return this._streams.set(ee,te),this.numOutboundStreams++,te.sendWindowUpdate(),te}async ping(){if(this.remoteGoAway!==void 0)throw new CodeError("muxer closed remotely",ERR_MUXER_REMOTE_CLOSED);if(this.localGoAway!==void 0)throw new CodeError("muxer closed locally",ERR_MUXER_LOCAL_CLOSED);if(this.activePing===void 0){let E=()=>{};this.activePing={id:this.nextPingID++,promise:new Promise((re,ne)=>{const ie=()=>{ne(new CodeError("muxer closed locally",ERR_MUXER_LOCAL_CLOSED))};this.closeController.signal.addEventListener("abort",ie,{once:!0}),E=()=>{this.closeController.signal.removeEventListener("abort",ie),re()}}),resolve:E};const ee=Date.now();this.sendPing(this.activePing.id);try{await this.activePing.promise}finally{delete this.activePing}const te=Date.now();this.rtt=te-ee}else await this.activePing.promise;return this.rtt}getRTT(){return this.rtt}close(E,ee){if(!this.closeController.signal.aborted){if(ee=ee??(E===void 0?GoAwayCode.InternalError:GoAwayCode.NormalTermination),E!=null?this.log?.error("muxer close reason=%s error=%s",GoAwayCode[ee],E):this.log?.trace("muxer close reason=%s",GoAwayCode[ee]),E===void 0)for(const te of this._streams.values())te.close();else for(const te of this._streams.values())te.abort(E);this.sendGoAway(ee),this._closeMuxer()}}isClosed(){return this.closeController.signal.aborted}_closeMuxer(){this.closeController.abort(),this.source.end()}_newStream(E,ee,te,re){if(this._streams.get(E)!=null)throw new CodeError("Stream already exists",ERR_STREAM_ALREADY_EXISTS,{id:E});const ne=new YamuxStream({id:E,name:ee,state:te,direction:re,sendFrame:this.sendFrame.bind(this),onStreamEnd:()=>{this.closeStream(E),this.onStreamEnd?.(ne)},log:this.log,config:this.config,getRTT:this.getRTT.bind(this)});return ne}closeStream(E){this.client===(E%2===0)?this.numInboundStreams--:this.numOutboundStreams--,this._streams.delete(E)}async keepAliveLoop(){const E=new Promise((ee,te)=>{this.closeController.signal.addEventListener("abort",te,{once:!0})});for(this.log?.trace("muxer keepalive enabled interval=%s",this.config.keepAliveInterval);;){let ee;try{await Promise.race([E,new Promise(te=>{ee=setTimeout(te,this.config.keepAliveInterval)})]),this.ping().catch(te=>this.log?.error("ping error: %s",te))}catch{clearInterval(ee);return}}}async handleFrame(E,ee){const{streamID:te,type:re,length:ne}=E;if(this.log?.trace("received frame %s",stringifyHeader(E)),te===0)switch(re){case FrameType.Ping:{this.handlePing(E);return}case FrameType.GoAway:{this.handleGoAway(ne);return}default:throw new CodeError("Invalid frame type",ERR_INVALID_FRAME,{header:E})}else switch(E.type){case FrameType.Data:case FrameType.WindowUpdate:{await this.handleStreamMessage(E,ee);return}default:throw new CodeError("Invalid frame type",ERR_INVALID_FRAME,{header:E})}}handlePing(E){if(E.flag===Flag.SYN)this.log?.trace("received ping request pingId=%s",E.length),this.sendPing(E.length,Flag.ACK);else if(E.flag===Flag.ACK)this.log?.trace("received ping response pingId=%s",E.length),this.handlePingResponse(E.length);else throw new CodeError("Invalid frame flag",ERR_INVALID_FRAME,{header:E})}handlePingResponse(E){if(this.activePing===void 0)throw new CodeError("ping not requested",ERR_UNREQUESTED_PING);if(this.activePing.id!==E)throw new CodeError("ping doesn't match our id",ERR_NOT_MATCHING_PING);this.activePing.resolve()}handleGoAway(E){this.log?.trace("received GoAway reason=%s",GoAwayCode[E]??"unknown"),this.remoteGoAway=E;for(const ee of this._streams.values())ee.reset();this._closeMuxer()}async handleStreamMessage(E,ee){const{streamID:te,flag:re,type:ne}=E;(re&Flag.SYN)===Flag.SYN&&this.incomingStream(te);const ie=this._streams.get(te);if(ie===void 0){if(ne===FrameType.Data){if(this.log?.("discarding data for stream id=%s",te),ee===void 0)throw new Error("unreachable");await ee()}else this.log?.("frame for missing stream id=%s",te);return}switch(ne){case FrameType.WindowUpdate:{ie.handleWindowUpdate(E);return}case FrameType.Data:{if(ee===void 0)throw new Error("unreachable");await ie.handleData(E,ee);return}default:throw new Error("unreachable")}}incomingStream(E){if(this.client!==(E%2===0))throw new CodeError("both endpoints are clients",ERR_BOTH_CLIENTS);if(this._streams.has(E))return;if(this.log?.trace("new incoming stream id=%s",E),this.localGoAway!==void 0){this.sendFrame({type:FrameType.WindowUpdate,flag:Flag.RST,streamID:E,length:0});return}if(this.numInboundStreams>=this.config.maxInboundStreams){this.log?.("maxIncomingStreams exceeded, forcing stream reset"),this.sendFrame({type:FrameType.WindowUpdate,flag:Flag.RST,streamID:E,length:0});return}const ee=this._newStream(E,void 0,StreamState.SYNReceived,"inbound");this.numInboundStreams++,this._streams.set(E,ee),this.onIncomingStream?.(ee)}sendFrame(E,ee){if(this.log?.trace("sending frame %s",stringifyHeader(E)),E.type===FrameType.Data){if(ee===void 0)throw new CodeError("invalid frame",ERR_INVALID_FRAME);this.source.push(encodeHeader(E)),this.source.push(ee)}else this.source.push(encodeHeader(E))}sendPing(E,ee=Flag.SYN){ee===Flag.SYN?this.log?.trace("sending ping request pingId=%s",E):this.log?.trace("sending ping response pingId=%s",E),this.sendFrame({type:FrameType.Ping,flag:ee,streamID:0,length:E})}sendGoAway(E=GoAwayCode.NormalTermination){this.log?.("sending GoAway reason=%s",GoAwayCode[E]),this.localGoAway=E,this.sendFrame({type:FrameType.GoAway,flag:0,streamID:0,length:E})}}function yamux(J={}){return()=>new Yamux(J)}async function*browserReadableStreamToIt(J,E={}){const ee=J.getReader();try{for(;;){const te=await ee.read();if(te.done)return;yield te.value}}finally{E.preventCancel!==!0&&await ee.cancel(),ee.releaseLock()}}var browser$1={exports:{}},parse_browser=J=>async function*(){const E=/\r?\n/,ee=new TextDecoder("utf8");let te="";for await(let re of J){typeof re=="string"&&(re=new TextEncoder().encode(re)),te+=ee.decode(re,{stream:!0});const ne=te.split(E);te=ne.pop();for(let ie=0;ie<ne.length;ie++)yield JSON.parse(ne[ie])}te+=ee.decode(),te&&(yield JSON.parse(te))}(),stringify=J=>async function*(){for await(const E of J)yield JSON.stringify(E)+`
`}();browser$1.exports=parse_browser;browser$1.exports.parse=parse_browser;browser$1.exports.stringify=stringify;var browserExports=browser$1.exports;const ndjson=getDefaultExportFromCjs(browserExports),log$r=logger$1("ipni-content-routing"),defaultValues$1={concurrentRequests:4,timeout:3e4};class IpniContentRouting{started;httpQueue;shutDownController;clientUrl;timeout;constructor(E,ee={}){log$r("enabled IPNI routing via",E),this.started=!1,this.shutDownController=new AbortController,this.httpQueue=new PQueue({concurrency:ee.concurrentRequests??defaultValues$1.concurrentRequests}),this.clientUrl=E instanceof URL?E:new URL(E),this.timeout=ee.timeout??defaultValues$1.timeout}isStarted(){return this.started}start(){this.started=!0}stop(){this.httpQueue.clear(),this.shutDownController.abort(),this.started=!1}async*findProviders(E,ee={}){log$r("findProviders starts: %c",E);const te=anySignal([this.shutDownController.signal,ee.signal,AbortSignal.timeout(this.timeout)]),re=pDefer(),ne=pDefer();this.httpQueue.add(async()=>(re.resolve(),ne.promise));try{await re.promise;const ie=`${this.clientUrl}cid/${E.toString()}?cascade=ipfs-dht`,se=await fetch(ie,{headers:{Accept:"application/x-ndjson"},signal:te});if(se.body==null)throw new CodeError("IPNI response had no body","ERR_BAD_RESPONSE");for await(const oe of ndjson(browserReadableStreamToIt(se.body)))oe.Metadata==="gBI="&&(yield this.mapEvent(oe))}catch(ie){log$r.error("findProviders errored:",ie)}finally{te.clear(),ne.resolve(),log$r("findProviders finished: %c",E)}}mapEvent(E){const ee=peerIdFromString(E.Provider.ID),te=[];for(const re of E.Provider.Addrs){const ne=multiaddr(re);te.push(ne)}return{id:ee,multiaddrs:te,protocols:[]}}async provide(){}async put(){}async get(){throw new CodeError("Not found","ERR_NOT_FOUND")}}function ipniContentRouting(J,E={}){return()=>new IpniContentRouting(J,E)}function bestRecord(J,E,ee){if(ee.length===0){const ne="No records given";throw new CodeError(ne,"ERR_NO_RECORDS_RECEIVED")}const te=toString$5(E).split("/");if(te.length<3){const ne="Record key does not have a selector function";throw new CodeError(ne,"ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY")}const re=J[te[1].toString()];if(re==null){const ne=`Unrecognized key prefix: ${te[1]}`;throw new CodeError(ne,"ERR_UNRECOGNIZED_KEY_PREFIX")}return ee.length===1?0:re(E,ee)}function publickKey(J,E){return 0}const selectors={pk:publickKey};async function verifyRecord(J,E){const ee=E.key,te=toString$5(ee).split("/");if(te.length<3)return;const re=J[te[1].toString()];if(re==null){const ne="Invalid record keytype";throw new CodeError(ne,"ERR_INVALID_RECORD_KEY_TYPE")}await re(ee,E.value)}const validatePublicKeyRecord=async(J,E)=>{if(!(J instanceof Uint8Array))throw new CodeError('"key" must be a Uint8Array',"ERR_INVALID_RECORD_KEY_NOT_BUFFER");if(J.byteLength<5)throw new CodeError("invalid public key record","ERR_INVALID_RECORD_KEY_TOO_SHORT");if(toString$5(J.subarray(0,4))!=="/pk/")throw new CodeError("key was not prefixed with /pk/","ERR_INVALID_RECORD_KEY_BAD_PREFIX");const ee=J.slice(4),te=await sha256$3.digest(E);if(!equals(ee,te.bytes))throw new CodeError("public key does not match passed in key","ERR_INVALID_RECORD_HASH_MISMATCH")},validators={pk:validatePublicKeyRecord},second=1e3,minute=60*second,hour=60*minute,MAX_RECORD_AGE=36*hour,LAN_PREFIX="/lan",PROTOCOL_PREFIX$1="/ipfs",PROTOCOL_DHT="/kad/1.0.0",RECORD_KEY_PREFIX="/dht/record",PROVIDER_KEY_PREFIX="/dht/provider",PROVIDERS_LRU_CACHE_SIZE=256,PROVIDERS_VALIDITY=24*hour,PROVIDERS_CLEANUP_INTERVAL=hour,K=20,ALPHA=3,QUERY_SELF_INTERVAL=Number(5*minute),QUERY_SELF_INITIAL_INTERVAL=Number(Number(second)),QUERY_SELF_TIMEOUT=Number(5*second),TABLE_REFRESH_INTERVAL=Number(5*minute),TABLE_REFRESH_QUERY_TIMEOUT=Number(30*second),DEFAULT_QUERY_TIMEOUT=Number(30*second);var Record$1;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{re.lengthDelimited!==!1&&te.fork(),ee.key!=null&&ee.key.byteLength>0&&(te.uint32(10),te.bytes(ee.key)),ee.value!=null&&ee.value.byteLength>0&&(te.uint32(18),te.bytes(ee.value)),ee.timeReceived!=null&&ee.timeReceived!==""&&(te.uint32(42),te.string(ee.timeReceived)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={key:new Uint8Array(0),value:new Uint8Array(0),timeReceived:""},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.key=ee.bytes();break;case 2:re.value=ee.bytes();break;case 5:re.timeReceived=ee.string();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage$1(ee,J.codec())})(Record$1||(Record$1={}));function toRFC3339(J){const E=J.getUTCFullYear(),ee=String(J.getUTCMonth()+1).padStart(2,"0"),te=String(J.getUTCDate()).padStart(2,"0"),re=String(J.getUTCHours()).padStart(2,"0"),ne=String(J.getUTCMinutes()).padStart(2,"0"),ie=String(J.getUTCSeconds()).padStart(2,"0"),se=J.getUTCMilliseconds(),oe=String(se*1e3*1e3).padStart(9,"0");return`${E}-${ee}-${te}T${re}:${ne}:${ie}.${oe}Z`}function parseRFC3339$1(J){const E=new RegExp("(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"),ee=String(J).trim().match(E);if(ee==null)throw new Error("Invalid format");const te=parseInt(ee[1],10),re=parseInt(ee[2],10)-1,ne=parseInt(ee[3],10),ie=parseInt(ee[4],10),se=parseInt(ee[5],10),oe=parseInt(ee[6],10),ce=parseInt(ee[7].slice(0,-6),10);return new Date(Date.UTC(te,re,ne,ie,se,oe,ce))}class Libp2pRecord{constructor(E,ee,te){if(!(E instanceof Uint8Array))throw new Error("key must be a Uint8Array");if(!(ee instanceof Uint8Array))throw new Error("value must be a Uint8Array");this.key=E,this.value=ee,this.timeReceived=te}serialize(){return Record$1.encode(this.prepareSerialize())}prepareSerialize(){return{key:this.key,value:this.value,timeReceived:toRFC3339(this.timeReceived)}}static deserialize(E){const ee=Record$1.decode(E);return new Libp2pRecord(ee.key,ee.value,new Date(ee.timeReceived))}static fromDeserialized(E){const ee=parseRFC3339$1(E.timeReceived);if(E.key==null)throw new Error("key missing from deserialized object");if(E.value==null)throw new Error("value missing from deserialized object");return new Libp2pRecord(E.key,E.value,ee)}}var Record;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{re.lengthDelimited!==!1&&te.fork(),ee.key!=null&&(te.uint32(10),te.bytes(ee.key)),ee.value!=null&&(te.uint32(18),te.bytes(ee.value)),ee.author!=null&&(te.uint32(26),te.bytes(ee.author)),ee.signature!=null&&(te.uint32(34),te.bytes(ee.signature)),ee.timeReceived!=null&&(te.uint32(42),te.string(ee.timeReceived)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.key=ee.bytes();break;case 2:re.value=ee.bytes();break;case 3:re.author=ee.bytes();break;case 4:re.signature=ee.bytes();break;case 5:re.timeReceived=ee.string();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage$1(ee,J.codec())})(Record||(Record={}));var Message$4;(function(J){(function(re){re.PUT_VALUE="PUT_VALUE",re.GET_VALUE="GET_VALUE",re.ADD_PROVIDER="ADD_PROVIDER",re.GET_PROVIDERS="GET_PROVIDERS",re.FIND_NODE="FIND_NODE",re.PING="PING"})(J.MessageType||(J.MessageType={}));let E;(function(re){re[re.PUT_VALUE=0]="PUT_VALUE",re[re.GET_VALUE=1]="GET_VALUE",re[re.ADD_PROVIDER=2]="ADD_PROVIDER",re[re.GET_PROVIDERS=3]="GET_PROVIDERS",re[re.FIND_NODE=4]="FIND_NODE",re[re.PING=5]="PING"})(E||(E={})),function(re){re.codec=()=>enumeration(E)}(J.MessageType||(J.MessageType={})),function(re){re.NOT_CONNECTED="NOT_CONNECTED",re.CONNECTED="CONNECTED",re.CAN_CONNECT="CAN_CONNECT",re.CANNOT_CONNECT="CANNOT_CONNECT"}(J.ConnectionType||(J.ConnectionType={}));let ee;(function(re){re[re.NOT_CONNECTED=0]="NOT_CONNECTED",re[re.CONNECTED=1]="CONNECTED",re[re.CAN_CONNECT=2]="CAN_CONNECT",re[re.CANNOT_CONNECT=3]="CANNOT_CONNECT"})(ee||(ee={})),function(re){re.codec=()=>enumeration(ee)}(J.ConnectionType||(J.ConnectionType={})),function(re){let ne;re.codec=()=>(ne==null&&(ne=message((ie,se,oe={})=>{if(oe.lengthDelimited!==!1&&se.fork(),ie.id!=null&&(se.uint32(10),se.bytes(ie.id)),ie.addrs!=null)for(const ce of ie.addrs)se.uint32(18),se.bytes(ce);ie.connection!=null&&(se.uint32(24),J.ConnectionType.codec().encode(ie.connection,se)),oe.lengthDelimited!==!1&&se.ldelim()},(ie,se)=>{const oe={addrs:[]},ce=se==null?ie.len:ie.pos+se;for(;ie.pos<ce;){const ae=ie.uint32();switch(ae>>>3){case 1:oe.id=ie.bytes();break;case 2:oe.addrs.push(ie.bytes());break;case 3:oe.connection=J.ConnectionType.codec().decode(ie);break;default:ie.skipType(ae&7);break}}return oe})),ne),re.encode=ie=>encodeMessage(ie,re.codec()),re.decode=ie=>decodeMessage$1(ie,re.codec())}(J.Peer||(J.Peer={}));let te;J.codec=()=>(te==null&&(te=message((re,ne,ie={})=>{if(ie.lengthDelimited!==!1&&ne.fork(),re.type!=null&&(ne.uint32(8),J.MessageType.codec().encode(re.type,ne)),re.clusterLevelRaw!=null&&(ne.uint32(80),ne.int32(re.clusterLevelRaw)),re.key!=null&&(ne.uint32(18),ne.bytes(re.key)),re.record!=null&&(ne.uint32(26),ne.bytes(re.record)),re.closerPeers!=null)for(const se of re.closerPeers)ne.uint32(66),J.Peer.codec().encode(se,ne);if(re.providerPeers!=null)for(const se of re.providerPeers)ne.uint32(74),J.Peer.codec().encode(se,ne);ie.lengthDelimited!==!1&&ne.ldelim()},(re,ne)=>{const ie={closerPeers:[],providerPeers:[]},se=ne==null?re.len:re.pos+ne;for(;re.pos<se;){const oe=re.uint32();switch(oe>>>3){case 1:ie.type=J.MessageType.codec().decode(re);break;case 10:ie.clusterLevelRaw=re.int32();break;case 2:ie.key=re.bytes();break;case 3:ie.record=re.bytes();break;case 8:ie.closerPeers.push(J.Peer.codec().decode(re,re.uint32()));break;case 9:ie.providerPeers.push(J.Peer.codec().decode(re,re.uint32()));break;default:re.skipType(oe&7);break}}return ie})),te),J.encode=re=>encodeMessage(re,J.codec()),J.decode=re=>decodeMessage$1(re,J.codec())})(Message$4||(Message$4={}));const MESSAGE_TYPE=Message$4.MessageType,CONNECTION_TYPE=Message$4.ConnectionType,MESSAGE_TYPE_LOOKUP=Object.keys(MESSAGE_TYPE);let Message$3=class jt{type;key;clusterLevelRaw;closerPeers;providerPeers;record;constructor(E,ee,te){if(!(ee instanceof Uint8Array))throw new Error("Key must be a Uint8Array");this.type=E,this.key=ee,this.clusterLevelRaw=te,this.closerPeers=[],this.providerPeers=[],this.record=void 0}get clusterLevel(){const E=this.clusterLevelRaw-1;return E<0?0:E}set clusterLevel(E){this.clusterLevelRaw=E}serialize(){return Message$4.encode({key:this.key,type:this.type,clusterLevelRaw:this.clusterLevelRaw,closerPeers:this.closerPeers.map(toPbPeer),providerPeers:this.providerPeers.map(toPbPeer),record:this.record==null?void 0:this.record.serialize().subarray()})}static deserialize(E){const ee=Message$4.decode(E),te=new jt(ee.type??Message$4.MessageType.PUT_VALUE,ee.key??Uint8Array.from([]),ee.clusterLevelRaw??0);return te.closerPeers=ee.closerPeers.map(fromPbPeer),te.providerPeers=ee.providerPeers.map(fromPbPeer),ee.record?.length!=null&&(te.record=Libp2pRecord.deserialize(ee.record)),te}};function toPbPeer(J){return{id:J.id.toBytes(),addrs:(J.multiaddrs??[]).map(E=>E.bytes),connection:CONNECTION_TYPE.CONNECTED}}function fromPbPeer(J){if(J.id==null)throw new Error("Invalid peer in message");return{id:peerIdFromBytes(J.id),multiaddrs:(J.addrs??[]).map(E=>multiaddr(E)),protocols:[]}}function sendQueryEvent(J,E={}){const ee={...J,name:"SEND_QUERY",type:0,messageName:J.type,messageType:MESSAGE_TYPE_LOOKUP.indexOf(J.type.toString())};return E.onProgress?.(new CustomEvent$2("kad-dht:query:send-query",{detail:ee})),ee}function peerResponseEvent(J,E={}){const ee={...J,name:"PEER_RESPONSE",type:1,messageName:J.messageType,closer:J.closer!=null?J.closer:[],providers:J.providers!=null?J.providers:[]};return E.onProgress?.(new CustomEvent$2("kad-dht:query:peer-response",{detail:ee})),ee}function finalPeerEvent(J,E={}){const ee={...J,name:"FINAL_PEER",type:2};return E.onProgress?.(new CustomEvent$2("kad-dht:query:final-peer",{detail:ee})),ee}function queryErrorEvent(J,E={}){const ee={...J,name:"QUERY_ERROR",type:3};return E.onProgress?.(new CustomEvent$2("kad-dht:query:query-error",{detail:ee})),ee}function providerEvent(J,E={}){const ee={...J,name:"PROVIDER",type:4};return E.onProgress?.(new CustomEvent$2("kad-dht:query:provider",{detail:ee})),ee}function valueEvent(J,E={}){const ee={...J,name:"VALUE",type:5};return E.onProgress?.(new CustomEvent$2("kad-dht:query:value",{detail:ee})),ee}function dialPeerEvent(J,E={}){const ee={...J,name:"DIAL_PEER",type:7};return E.onProgress?.(new CustomEvent$2("kad-dht:query:dial-peer",{detail:ee})),ee}const PK_PREFIX=fromString$5("/pk/");function removePrivateAddresses(J){return{...J,multiaddrs:J.multiaddrs.filter(E=>{const[[ee,te]]=E.stringTuples();if(ee===53||ee===54||ee===55)return te!=="localhost";if(ee!==4&&ee!==6||te==null)return!1;const re=is_ip_private(te);return re==null?!0:!re})}}function removePublicAddresses(J){return{...J,multiaddrs:J.multiaddrs.filter(E=>{const[[ee,te]]=E.stringTuples();return te==="localhost"?!0:ee!==4&&ee!==6||te==null?!1:is_ip_private(te)??!1})}}async function convertBuffer(J){return(await sha256$3.digest(J)).digest}async function convertPeerId(J){return convertBuffer(J.toBytes())}function bufferToRecordKey(J){return new Key(`${RECORD_KEY_PREFIX}/${toString$5(J,"base32")}`,!1)}function keyForPublicKey(J){return concat$4([PK_PREFIX,J.toBytes()])}function isPublicKeyKey(J){return toString$5(J.subarray(0,4))==="/pk/"}function fromPublicKeyKey(J){return peerIdFromBytes(J.subarray(4))}function createPutRecord(J,E){const ee=new Date;return new Libp2pRecord(J,E,ee).serialize()}function debounce(J,E=100){let ee;return()=>{clearTimeout(ee),ee=setTimeout(()=>{J()},E)}}class ContentFetching{log;components;validators;selectors;peerRouting;queryManager;network;constructor(E,ee){const{validators:te,selectors:re,peerRouting:ne,queryManager:ie,network:se,lan:oe}=ee;this.components=E,this.log=logger$1(`libp2p:kad-dht:${oe?"lan":"wan"}:content-fetching`),this.validators=te,this.selectors=re,this.peerRouting=ne,this.queryManager=ie,this.network=se}async putLocal(E,ee){const te=bufferToRecordKey(E);await this.components.datastore.put(te,ee)}async getLocal(E){this.log("getLocal %b",E);const ee=bufferToRecordKey(E);this.log("fetching record for key %k",ee);const te=await this.components.datastore.get(ee);this.log("found %k in local datastore",ee);const re=Libp2pRecord.deserialize(te);return await verifyRecord(this.validators,re),re}async*sendCorrectionRecord(E,ee,te,re={}){this.log("sendCorrection for %b",E);const ne=createPutRecord(E,te);for(const{value:ie,from:se}of ee){if(equals(ie,te)){this.log("record was ok");continue}if(this.components.peerId.equals(se)){try{const ae=bufferToRecordKey(E);this.log(`Storing corrected record for key ${ae.toString()}`),await this.components.datastore.put(ae,ne.subarray())}catch(ae){this.log.error("Failed error correcting self",ae)}continue}let oe=!1;const ce=new Message$3(MESSAGE_TYPE.PUT_VALUE,E,0);ce.record=Libp2pRecord.deserialize(ne);for await(const ae of this.network.sendRequest(se,ce,re))ae.name==="PEER_RESPONSE"&&ae.record!=null&&equals(ae.record.value,Libp2pRecord.deserialize(ne).value)&&(oe=!0),yield ae;oe||(yield queryErrorEvent({from:se,error:new CodeError("value not put correctly","ERR_PUT_VALUE_INVALID")},re)),this.log.error("Failed error correcting entry")}}async*put(E,ee,te={}){this.log("put key %b value %b",E,ee);const re=createPutRecord(E,ee),ne=bufferToRecordKey(E);this.log(`storing record for key ${ne.toString()}`),await this.components.datastore.put(ne,re.subarray()),yield*pipe$1(this.peerRouting.getClosestPeers(E,{signal:te.signal}),ie=>map$1(ie,se=>async()=>{if(se.name!=="FINAL_PEER")return[se];const oe=[],ce=new Message$3(MESSAGE_TYPE.PUT_VALUE,E,0);ce.record=Libp2pRecord.deserialize(re),this.log("send put to %p",se.peer.id);for await(const ae of this.network.sendRequest(se.peer.id,ce,te))oe.push(ae),ae.name==="PEER_RESPONSE"&&(ae.record!=null&&equals(ae.record.value,Libp2pRecord.deserialize(re).value)||oe.push(queryErrorEvent({from:se.peer.id,error:new CodeError("value not put correctly","ERR_PUT_VALUE_INVALID")},te)));return oe}),ie=>parallel(ie,{ordered:!1,concurrency:ALPHA}),async function*(ie){for await(const se of ie)yield*se})}async*get(E,ee={}){this.log("get %b",E);const te=[];for await(const se of this.getMany(E,ee))se.name==="VALUE"&&te.push(se),yield se;if(te.length===0)return;const re=te.map(se=>se.value);let ne=0;try{ne=bestRecord(this.selectors,E,re)}catch(se){if(se.code!=="ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY")throw se}const ie=re[ne];if(this.log("GetValue %b %b",E,ie),ie==null)throw new CodeError("best value was not found","ERR_NOT_FOUND");yield*this.sendCorrectionRecord(E,te,ie,ee),yield te[ne]}async*getMany(E,ee={}){this.log("getMany values for %b",E);try{const ne=await this.getLocal(E);yield valueEvent({value:ne.value,from:this.components.peerId},ee)}catch(ne){this.log("error getting local value for %b",E,ne)}const te=this,re=async function*({peer:ne,signal:ie}){for await(const se of te.peerRouting.getValueOrPeers(ne,E,{signal:ie}))yield se,se.name==="PEER_RESPONSE"&&se.record!=null&&(yield valueEvent({from:ne,value:se.record.value},ee))};yield*this.queryManager.run(E,re,ee)}}class ContentRouting{log;components;network;peerRouting;queryManager;routingTable;providers;constructor(E,ee){const{network:te,peerRouting:re,queryManager:ne,routingTable:ie,providers:se,lan:oe}=ee;this.components=E,this.log=logger$1(`libp2p:kad-dht:${oe?"lan":"wan"}:content-routing`),this.network=te,this.peerRouting=re,this.queryManager=ne,this.routingTable=ie,this.providers=se}async*provide(E,ee,te={}){this.log("provide %s",E),await this.providers.addProvider(E,this.components.peerId);const re=new Message$3(MESSAGE_TYPE.ADD_PROVIDER,E.multihash.bytes,0);re.providerPeers=[{id:this.components.peerId,multiaddrs:ee,protocols:[]}];let ne=0;const ie=se=>async()=>{if(se.name!=="FINAL_PEER")return[se];const oe=[];this.log("putProvider %s to %p",E,se.peer.id);try{this.log("sending provider record for %s to %p",E,se.peer.id);for await(const ce of this.network.sendMessage(se.peer.id,re,te))ce.name==="PEER_RESPONSE"&&(this.log("sent provider record for %s to %p",E,se.peer.id),ne++),oe.push(ce)}catch(ce){this.log.error("error sending provide record to peer %p",se.peer.id,ce),oe.push(queryErrorEvent({from:se.peer.id,error:ce},te))}return oe};yield*pipe$1(this.peerRouting.getClosestPeers(E.multihash.bytes,te),se=>map$1(se,oe=>ie(oe)),se=>parallel(se,{ordered:!1,concurrency:ALPHA}),async function*(se){for await(const oe of se)yield*oe}),this.log("sent provider records to %d peers",ne)}async*findProviders(E,ee){const te=this.routingTable.kBucketSize,re=E.multihash.bytes,ne=this;this.log("findProviders %c",E);const ie=await this.providers.getProviders(E);if(ie.length>0){const ce=[];for(const ae of ie.slice(0,te))try{const le=await this.components.peerStore.get(ae);ce.push({id:ae,multiaddrs:le.addresses.map(({multiaddr:ue})=>ue),protocols:le.protocols})}catch(le){if(le.code!=="ERR_NOT_FOUND")throw le;this.log("no peer store entry for %p",ae)}yield peerResponseEvent({from:this.components.peerId,messageType:MESSAGE_TYPE.GET_PROVIDERS,providers:ce},ee),yield providerEvent({from:this.components.peerId,providers:ce},ee)}if(ie.length>=te)return;const se=async function*({peer:ce,signal:ae}){const le=new Message$3(MESSAGE_TYPE.GET_PROVIDERS,re,0);yield*ne.network.sendRequest(ce,le,{...ee,signal:ae})},oe=new Set(ie.map(ce=>ce.toString()));for await(const ce of this.queryManager.run(re,se,ee))if(yield ce,ce.name==="PEER_RESPONSE"){this.log("Found %d provider entries for %c and %d closer peers",ce.providers.length,E,ce.closer.length);const ae=[];for(const le of ce.providers)oe.has(le.id.toString())||(oe.add(le.id.toString()),ae.push(le));if(ae.length>0&&(yield providerEvent({from:ce.from,providers:ae},ee)),oe.size===te)return}}}class Network extends EventEmitter$3{log;protocol;running;components;constructor(E,ee){super();const{protocol:te,lan:re}=ee;this.components=E,this.log=logger$1(`libp2p:kad-dht:${re?"lan":"wan"}:network`),this.running=!1,this.protocol=te}async start(){this.running||(this.running=!0)}async stop(){this.running=!1}isStarted(){return this.running}async*sendRequest(E,ee,te={}){if(this.running){this.log("sending %s to %p",ee.type,E),yield dialPeerEvent({peer:E},te),yield sendQueryEvent({to:E,type:ee.type},te);try{const re=await(await this.components.connectionManager.openConnection(E,te)).newStream(this.protocol,te),ne=await this._writeReadMessage(re,ee.serialize(),te);yield peerResponseEvent({from:E,messageType:ne.type,closer:ne.closerPeers,providers:ne.providerPeers,record:ne.record},te)}catch(re){yield queryErrorEvent({from:E,error:re},te)}finally{}}}async*sendMessage(E,ee,te={}){if(this.running){this.log("sending %s to %p",ee.type,E),yield dialPeerEvent({peer:E},te),yield sendQueryEvent({to:E,type:ee.type},te);try{const re=await(await this.components.connectionManager.openConnection(E,te)).newStream(this.protocol,te);await this._writeMessage(re,ee.serialize(),te),yield peerResponseEvent({from:E,messageType:ee.type},te)}catch(re){yield queryErrorEvent({from:E,error:re},te)}finally{}}}async _writeMessage(E,ee,te){te.signal!=null&&(E=abortableDuplex(E,te.signal)),await pipe$1([ee],re=>encode$b(re),E,drain)}async _writeReadMessage(E,ee,te){te.signal!=null&&(E=abortableDuplex(E,te.signal));const re=await pipe$1([ee],ie=>encode$b(ie),E,ie=>decode$b(ie),async ie=>{const se=await first(ie);if(se!=null)return se;throw new CodeError("No message received","ERR_NO_MESSAGE_RECEIVED")}),ne=Message$3.deserialize(re);return ne.closerPeers.forEach(ie=>{this.dispatchEvent(new CustomEvent$2("peer",{detail:ie}))}),ne.providerPeers.forEach(ie=>{this.dispatchEvent(new CustomEvent$2("peer",{detail:ie}))}),ne}}class PeerDistanceList{originDhtKey;capacity;peerDistances;constructor(E,ee){this.originDhtKey=E,this.capacity=ee,this.peerDistances=[]}get length(){return this.peerDistances.length}get peers(){return this.peerDistances.map(E=>E.peerId)}async add(E){if(this.peerDistances.find(re=>re.peerId.equals(E))!=null)return;const ee=await convertPeerId(E),te={peerId:E,distance:xor(this.originDhtKey,ee)};this.peerDistances.push(te),this.peerDistances.sort((re,ne)=>compare$1(re.distance,ne.distance)),this.peerDistances=this.peerDistances.slice(0,this.capacity)}async anyCloser(E){if(E.length===0)return!1;if(this.length===0)return!0;const ee=await Promise.all(E.map(convertPeerId)),te=this.peerDistances[this.peerDistances.length-1].distance;for(const re of ee){const ne=xor(this.originDhtKey,re);if(compare$1(ne,te)<0)return!0}return!1}}class PeerRouting{components;log;routingTable;network;validators;queryManager;constructor(E,ee){const{routingTable:te,network:re,validators:ne,queryManager:ie,lan:se}=ee;this.components=E,this.routingTable=te,this.network=re,this.validators=ne,this.queryManager=ie,this.log=logger$1(`libp2p:kad-dht:${se?"lan":"wan"}:peer-routing`)}async findPeerLocal(E){let ee;const te=await this.routingTable.find(E);if(te!=null){this.log("findPeerLocal found %p in routing table",E);try{ee=await this.components.peerStore.get(te)}catch(re){if(re.code!=="ERR_NOT_FOUND")throw re}}if(ee==null)try{ee=await this.components.peerStore.get(E)}catch(re){if(re.code!=="ERR_NOT_FOUND")throw re}if(ee!=null)return this.log("findPeerLocal found %p in peer store",E),{id:ee.id,multiaddrs:ee.addresses.map(re=>re.multiaddr),protocols:[]}}async*_getValueSingle(E,ee,te={}){const re=new Message$3(MESSAGE_TYPE.GET_VALUE,ee,0);yield*this.network.sendRequest(E,re,te)}async*getPublicKeyFromNode(E,ee={}){const te=keyForPublicKey(E);for await(const re of this._getValueSingle(E,te,ee))if(yield re,re.name==="PEER_RESPONSE"&&re.record!=null){const ne=await peerIdFromKeys(marshalPublicKey({bytes:re.record.value}));if(!ne.equals(E))throw new CodeError("public key does not match id","ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID");if(ne.publicKey==null)throw new CodeError("public key missing","ERR_PUBLIC_KEY_MISSING");yield valueEvent({from:E,value:ne.publicKey},ee)}throw new CodeError(`Node not responding with its public key: ${E.toString()}`,"ERR_INVALID_RECORD")}async*findPeer(E,ee={}){this.log("findPeer %p",E);const te=await this.findPeerLocal(E);if(te!=null){this.log("found local"),yield finalPeerEvent({from:this.components.peerId,peer:te},ee);return}const re=this,ne=async function*({peer:se,signal:oe}){const ce=new Message$3(MESSAGE_TYPE.FIND_NODE,E.toBytes(),0);for await(const ae of re.network.sendRequest(se,ce,{...ee,signal:oe}))if(yield ae,ae.name==="PEER_RESPONSE"){const le=ae.closer.find(ue=>ue.id.equals(E));le!=null&&(yield finalPeerEvent({from:ae.from,peer:le},ee))}};let ie=!1;for await(const se of this.queryManager.run(E.toBytes(),ne,ee))se.name==="FINAL_PEER"&&(ie=!0),yield se;ie||(yield queryErrorEvent({from:this.components.peerId,error:new CodeError("Not found","ERR_NOT_FOUND")},ee))}async*getClosestPeers(E,ee={}){this.log("getClosestPeers to %b",E);const te=await convertBuffer(E),re=this.routingTable.closestPeers(te),ne=this,ie=new PeerDistanceList(te,this.routingTable.kBucketSize);await Promise.all(re.map(async oe=>{await ie.add(oe)}));const se=async function*({peer:oe,signal:ce}){ne.log("closerPeersSingle %s from %p",toString$5(E,"base32"),oe);const ae=new Message$3(MESSAGE_TYPE.FIND_NODE,E,0);yield*ne.network.sendRequest(oe,ae,{...ee,signal:ce})};for await(const oe of this.queryManager.run(E,se,ee))yield oe,oe.name==="PEER_RESPONSE"&&await Promise.all(oe.closer.map(async ce=>{await ie.add(ce.id)}));this.log("found %d peers close to %b",ie.length,E);for(const oe of ie.peers)try{const ce=await this.components.peerStore.get(oe);yield finalPeerEvent({from:this.components.peerId,peer:{id:oe,multiaddrs:ce.addresses.map(({multiaddr:ae})=>ae),protocols:ce.protocols}},ee)}catch(ce){if(ce.code!=="ERR_NOT_FOUND")throw ce}}async*getValueOrPeers(E,ee,te={}){for await(const re of this._getValueSingle(E,ee,te)){if(re.name==="PEER_RESPONSE"&&re.record!=null)try{await this._verifyRecordOnline(re.record)}catch{const ne="invalid record received, discarded";this.log(ne),yield queryErrorEvent({from:re.from,error:new CodeError(ne,"ERR_INVALID_RECORD")},te);continue}yield re}}async _verifyRecordOnline(E){if(E.timeReceived==null)throw new CodeError("invalid record received","ERR_INVALID_RECORD");await verifyRecord(this.validators,new Libp2pRecord(E.key,E.value,E.timeReceived))}async getCloserPeersOffline(E,ee){const te=await convertBuffer(E),re=this.routingTable.closestPeers(te),ne=[];for(const ie of re)if(!ie.equals(ee))try{const se=await this.components.peerStore.get(ie);ne.push({id:ie,multiaddrs:se.addresses.map(({multiaddr:oe})=>oe),protocols:se.protocols})}catch(se){if(se.code!=="ERR_NOT_FOUND")throw se}return ne.length>0?this.log("getCloserPeersOffline found %d peer(s) closer to %b than %p",ne.length,E,ee):this.log("getCloserPeersOffline could not find peer closer to %b than %p",E,ee),ne}}var hashlru=function(J){if(!J)throw Error("hashlru must have a max value, of type number, greater than 0");var E=0,ee=Object.create(null),te=Object.create(null);function re(ne,ie){ee[ne]=ie,E++,E>=J&&(E=0,te=ee,ee=Object.create(null))}return{has:function(ne){return ee[ne]!==void 0||te[ne]!==void 0},remove:function(ne){ee[ne]!==void 0&&(ee[ne]=void 0),te[ne]!==void 0&&(te[ne]=void 0)},get:function(ne){var ie=ee[ne];if(ie!==void 0)return ie;if((ie=te[ne])!==void 0)return re(ne,ie),ie},set:function(ne,ie){ee[ne]!==void 0?ee[ne]=ie:re(ne,ie)},clear:function(){ee=Object.create(null),te=Object.create(null)}}};const cache=getDefaultExportFromCjs(hashlru),log$q=logger$1("libp2p:kad-dht:providers");class Providers{components;cache;cleanupInterval;provideValidity;syncQueue;started;cleaner;constructor(E,ee={}){const{cacheSize:te,cleanupInterval:re,provideValidity:ne}=ee;this.components=E,this.cleanupInterval=re??PROVIDERS_CLEANUP_INTERVAL,this.provideValidity=ne??PROVIDERS_VALIDITY,this.cache=cache(te??PROVIDERS_LRU_CACHE_SIZE),this.syncQueue=new PQueue({concurrency:1}),this.started=!1}isStarted(){return this.started}async start(){this.started||(this.started=!0,this.cleaner=setInterval(()=>{this._cleanup().catch(E=>{log$q.error(E)})},this.cleanupInterval))}async stop(){this.started=!1,this.cleaner!=null&&(clearInterval(this.cleaner),this.cleaner=void 0)}async _cleanup(){await this.syncQueue.add(async()=>{const E=Date.now();let ee=0,te=0;const re=new Map,ne=this.components.datastore.batch(),ie=this.components.datastore.query({prefix:PROVIDER_KEY_PREFIX});for await(const se of ie)try{const{cid:oe,peerId:ce}=parseProviderKey(se.key),ae=readTime(se.value).getTime(),le=Date.now(),ue=le-ae,he=ue>this.provideValidity;if(log$q("comparing: %d - %d = %d > %d %s",le,ae,ue,this.provideValidity,he?"(expired)":""),he){te++,ne.delete(se.key);const pe=re.get(oe)??new Set;pe.add(ce),re.set(oe,pe)}ee++}catch(oe){log$q.error(oe.message)}re.size>0?(log$q("deleting %d / %d entries",te,ee),await ne.commit()):log$q("nothing to delete");for(const[se,oe]of re){const ce=makeProviderKey(se),ae=this.cache.get(ce);if(ae!=null){for(const le of oe)ae.delete(le);ae.size===0?this.cache.remove(ce):this.cache.set(ce,ae)}}log$q("Cleanup successful (%dms)",Date.now()-E)})}async _getProvidersMap(E){const ee=makeProviderKey(E);let te=this.cache.get(ee);return te==null&&(te=await loadProviders(this.components.datastore,E),this.cache.set(ee,te)),te}async addProvider(E,ee){await this.syncQueue.add(async()=>{log$q("%p provides %s",ee,E);const te=await this._getProvidersMap(E);log$q("loaded %s provs",te.size);const re=new Date;te.set(ee.toString(),re);const ne=makeProviderKey(E);this.cache.set(ne,te),await writeProviderEntry(this.components.datastore,E,ee,re)})}async getProviders(E){return this.syncQueue.add(async()=>(log$q("get providers for %s",E),[...(await this._getProvidersMap(E)).keys()].map(ee=>peerIdFromString(ee))),{throwOnTimeout:!0})}}function makeProviderKey(J){const E=typeof J=="string"?J:toString$5(J.multihash.bytes,"base32");return`${PROVIDER_KEY_PREFIX}/${E}`}async function writeProviderEntry(J,E,ee,te){const re=[makeProviderKey(E),"/",ee.toString()].join(""),ne=new Key(re),ie=Uint8Array.from(varint$4.encode(te.getTime()));await J.put(ne,ie)}function parseProviderKey(J){const E=J.toString().split("/");if(E.length!==5)throw new Error(`incorrectly formatted provider entry key in datastore: ${J.toString()}`);return{cid:E[3],peerId:E[4]}}async function loadProviders(J,E){const ee=new Map,te=J.query({prefix:makeProviderKey(E)});for await(const re of te){const{peerId:ne}=parseProviderKey(re.key);ee.set(ne,readTime(re.value))}return ee}function readTime(J){return new Date(varint$4.decode(J))}const MAX_XOR=BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF");async function*queryPath(J){const{key:E,startingPeer:ee,ourPeerId:te,signal:re,query:ne,alpha:ie,pathIndex:se,numPaths:oe,cleanUp:ce,queryFuncTimeout:ae,log:le,peersSeen:ue}=J,he=new PQueue({concurrency:ie}),pe=await convertBuffer(E);function de(fe,me){if(fe==null)return;ue.add(fe);const _e=BigInt("0x"+toString$5(xor(me,pe),"base16"));he.add(async()=>{const be=[re];ae!=null&&be.push(AbortSignal.timeout(ae));const Ee=anySignal(be);try{for await(const ve of ne({key:E,peer:fe,signal:Ee,pathIndex:se,numPaths:oe})){if(Ee.aborted)return;if(ve.name==="PEER_RESPONSE")for(const we of ve.closer){if(ue.has(we.id)){le("already seen %p in query",we.id);continue}if(te.equals(we.id)){le("not querying ourselves");continue}const ge=await convertPeerId(we.id);if(BigInt("0x"+toString$5(xor(ge,pe),"base16"))>_e){le("skipping %p as they are not closer to %b than %p",we.id,E,fe);continue}le("querying closer peer %p",we.id),de(we.id,ge)}he.emit("completed",ve)}}catch(ve){if(!re.aborted)return queryErrorEvent({from:fe,error:ve},J)}finally{Ee.clear()}},{priority:MAX_XOR-_e}).catch(be=>{le.error(be)})}de(ee,await convertPeerId(ee)),yield*toGenerator(he,re,ce,le)}async function*toGenerator(J,E,ee,te){let re=pDefer(),ne=!0;const ie=[],se=()=>{ne&&(te("clean up queue, results %d, queue size %d, pending tasks %d",ie.length,J.size,J.pending),ne=!1,J.clear(),ie.splice(0,ie.length))};for(J.on("completed",oe=>{ie.push(oe),re.resolve()}),J.on("error",oe=>{te("queue error",oe),se(),re.reject(oe)}),J.on("idle",()=>{te("queue idle"),ne=!1,re.resolve()}),E.addEventListener("abort",()=>{te("abort queue");const oe=ne;se(),oe&&re.reject(new CodeError("Query aborted","ERR_QUERY_ABORTED"))}),ee.addEventListener("cleanup",()=>{se(),re.resolve()});ne;)for(await re.promise,re=pDefer();ie.length>0;){const oe=ie.shift();oe!=null&&(yield oe)}yield*ie}class QueryManager{components;lan;disjointPaths;alpha;shutDownController;running;queries;metrics;routingTable;initialQuerySelfHasRun;constructor(E,ee){const{lan:te=!1,disjointPaths:re=K,alpha:ne=ALPHA}=ee;this.components=E,this.disjointPaths=re??K,this.running=!1,this.alpha=ne??ALPHA,this.lan=te,this.queries=0,this.initialQuerySelfHasRun=ee.initialQuerySelfHasRun,this.routingTable=ee.routingTable,this.shutDownController=new AbortController;try{setMaxListeners?.(1/0,this.shutDownController.signal)}catch{}}isStarted(){return this.running}async start(){this.running=!0,this.components.metrics!=null&&this.metrics==null&&(this.metrics={runningQueries:this.components.metrics.registerMetric(`libp2p_kad_dht_${this.lan?"lan":"wan"}_running_queries`),queryTime:this.components.metrics.registerMetric(`libp2p_kad_dht_${this.lan?"lan":"wan"}_query_time_seconds`)})}async stop(){this.running=!1,this.shutDownController.abort()}async*run(E,ee,te={}){if(!this.running)throw new Error("QueryManager not started");const re=this.metrics?.queryTime.timer();if(te.signal==null){te.signal=AbortSignal.timeout(DEFAULT_QUERY_TIMEOUT);try{setMaxListeners?.(1/0,te.signal)}catch{}}const ne=anySignal([this.shutDownController.signal,te.signal]);try{setMaxListeners?.(1/0,ne)}catch{}const ie=logger$1(`libp2p:kad-dht:${this.lan?"lan":"wan"}:query:`+toString$5(E,"base58btc")),se=Date.now(),oe=new EventEmitter$3;try{te.isSelfQuery!==!0&&this.initialQuerySelfHasRun!=null&&(ie("waiting for initial query-self query before continuing"),await Promise.race([new Promise((pe,de)=>{ne.addEventListener("abort",()=>{de(new AbortError$5("Query was aborted before self-query ran"))})}),this.initialQuerySelfHasRun.promise]),this.initialQuerySelfHasRun=void 0),ie("query:start"),this.queries++,this.metrics?.runningQueries.update(this.queries);const ce=await convertBuffer(E),ae=this.routingTable.closestPeers(ce),le=ae.slice(0,Math.min(this.disjointPaths,ae.length));if(ae.length===0){ie.error("Running query with no peers");return}const ue=new PeerSet,he=le.map((pe,de)=>queryPath({key:E,startingPeer:pe,ourPeerId:this.components.peerId,signal:ne,query:ee,pathIndex:de,numPaths:le.length,alpha:this.alpha,cleanUp:oe,queryFuncTimeout:te.queryFuncTimeout,log:ie,peersSeen:ue,onProgress:te.onProgress}));for await(const pe of merge$2(...he))yield pe,pe.name==="QUERY_ERROR"&&ie("error",pe.error)}catch(ce){if(!(!this.running&&ce.code==="ERR_QUERY_ABORTED"))throw ce}finally{ne.clear(),this.queries--,this.metrics?.runningQueries.update(this.queries),re?.(),oe.dispatchEvent(new CustomEvent$2("cleanup")),ie("query:done in %dms",Date.now()-se)}}}function isAsyncIterable(J){return J[Symbol.asyncIterator]!=null}function length(J){if(isAsyncIterable(J))return(async()=>{let E=0;for await(const ee of J)E++;return E})();{let E=0;for(const ee of J)E++;return E}}const normalizeEmitter=J=>{const E=J.on||J.addListener||J.addEventListener,ee=J.off||J.removeListener||J.removeEventListener;if(!E||!ee)throw new TypeError("Emitter is not compatible");return{addListener:E.bind(J),removeListener:ee.bind(J)}};function pEventMultiple(J,E,ee){let te;const re=new Promise((ne,ie)=>{if(ee={rejectionEvents:["error"],multiArgs:!1,resolveImmediately:!1,...ee},!(ee.count>=0&&(ee.count===Number.POSITIVE_INFINITY||Number.isInteger(ee.count))))throw new TypeError("The `count` option should be at least 0 or more");const se=[E].flat(),oe=[],{addListener:ce,removeListener:ae}=normalizeEmitter(J),le=(...he)=>{const pe=ee.multiArgs?he:he[0];ee.filter&&!ee.filter(pe)||(oe.push(pe),ee.count===oe.length&&(te(),ne(oe)))},ue=he=>{te(),ie(he)};te=()=>{for(const he of se)ae(he,le);for(const he of ee.rejectionEvents)ae(he,ue)};for(const he of se)ce(he,le);for(const he of ee.rejectionEvents)ce(he,ue);ee.resolveImmediately&&ne(oe)});if(re.cancel=te,typeof ee.timeout=="number"){const ne=pTimeout$1(re,ee.timeout);return ne.cancel=te,ne}return re}function pEvent(J,E,ee){typeof ee=="function"&&(ee={filter:ee}),ee={...ee,count:1,resolveImmediately:!1};const te=pEventMultiple(J,E,ee),re=te.then(ne=>ne[0]);return re.cancel=te.cancel,re}class QuerySelf{log;components;peerRouting;routingTable;count;interval;initialInterval;queryTimeout;started;timeoutId;controller;initialQuerySelfHasRun;querySelfPromise;constructor(E,ee){const{peerRouting:te,lan:re,count:ne,interval:ie,queryTimeout:se,routingTable:oe}=ee;this.components=E,this.log=logger$1(`libp2p:kad-dht:${re?"lan":"wan"}:query-self`),this.started=!1,this.peerRouting=te,this.routingTable=oe,this.count=ne??K,this.interval=ie??QUERY_SELF_INTERVAL,this.initialInterval=ee.initialInterval??QUERY_SELF_INITIAL_INTERVAL,this.queryTimeout=se??QUERY_SELF_TIMEOUT,this.initialQuerySelfHasRun=ee.initialQuerySelfHasRun}isStarted(){return this.started}start(){this.started||(this.started=!0,clearTimeout(this.timeoutId),this.timeoutId=setTimeout(()=>{this.querySelf().catch(E=>{this.log.error("error running self-query",E)})},this.initialInterval))}stop(){this.started=!1,this.timeoutId!=null&&clearTimeout(this.timeoutId),this.controller!=null&&this.controller.abort()}async querySelf(){if(!this.started){this.log("skip self-query because we are not started");return}if(this.querySelfPromise!=null)return this.log("joining existing self query"),this.querySelfPromise.promise;if(this.querySelfPromise=pDefer(),this.routingTable.size===0&&await pEvent(this.routingTable,"peer:add"),this.started){this.controller=new AbortController;const E=anySignal([this.controller.signal,AbortSignal.timeout(this.queryTimeout)]);try{setMaxListeners?.(1/0,E)}catch{}try{this.log("run self-query, look for %d peers timing out after %dms",this.count,this.queryTimeout);const ee=await pipe$1(this.peerRouting.getClosestPeers(this.components.peerId.toBytes(),{signal:E,isSelfQuery:!0}),te=>take(te,this.count),async te=>length(te));this.log("self-query ran successfully - found %d peers",ee),this.initialQuerySelfHasRun!=null&&(this.initialQuerySelfHasRun.resolve(),this.initialQuerySelfHasRun=void 0)}catch(ee){this.log.error("self-query error",ee)}finally{E.clear()}}this.querySelfPromise.resolve(),this.querySelfPromise=void 0,this.started&&(this.timeoutId=setTimeout(()=>{this.querySelf().catch(E=>{this.log.error("error running self-query",E)})},this.interval))}}function arrayEquals(J,E){if(J===E)return!0;if(J.length!==E.length)return!1;for(let ee=0,te=J.length;ee<te;++ee)if(J[ee]!==E[ee])return!1;return!0}function createNode(){return{contacts:[],dontSplit:!1,left:null,right:null}}function ensureInt8(J,E){if(!(E instanceof Uint8Array))throw new TypeError(J+" is not a Uint8Array")}class KBucket extends EventEmitter$3{localNodeId;root;numberOfNodesPerKBucket;numberOfNodesToPing;distance;arbiter;constructor(E){super(),this.localNodeId=E.localNodeId,this.numberOfNodesPerKBucket=E.numberOfNodesPerKBucket??20,this.numberOfNodesToPing=E.numberOfNodesToPing??3,this.distance=E.distance??KBucket.distance,this.arbiter=E.arbiter??KBucket.arbiter,ensureInt8("option.localNodeId as parameter 1",this.localNodeId),this.root=createNode()}static arbiter(E,ee){return(E.vectorClock??0)>(ee.vectorClock??0)?E:ee}static distance(E,ee){let te=0,re=0;const ne=Math.min(E.length,ee.length),ie=Math.max(E.length,ee.length);for(;re<ne;++re)te=te*256+(E[re]^ee[re]);for(;re<ie;++re)te=te*256+255;return te}add(E){ensureInt8("contact.id",E?.id);let ee=0,te=this.root;for(;te.contacts===null;)te=this._determineNode(te,E.id,ee++);const re=this._indexOf(te,E.id);return re>=0?(this._update(te,re,E),this):te.contacts.length<this.numberOfNodesPerKBucket?(te.contacts.push(E),this.safeDispatchEvent("added",{detail:E}),this):te.dontSplit?(this.safeDispatchEvent("ping",{detail:{oldContacts:te.contacts.slice(0,this.numberOfNodesToPing),newContact:E}}),this):(this._split(te,ee),this.add(E))}closest(E,ee=1/0){if(ensureInt8("id",E),!Number.isInteger(ee)&&ee!==1/0||ee<=0)throw new TypeError("n is not positive number");let te=[];for(let re=[this.root],ne=0;re.length>0&&te.length<ee;){const ie=re.pop();if(ie!=null)if(ie.contacts===null){const se=this._determineNode(ie,E,ne++);re.push(ie.left===se?ie.right:ie.left),re.push(se)}else te=te.concat(ie.contacts)}return te.map(re=>({distance:this.distance(re.id,E),contact:re})).sort((re,ne)=>re.distance-ne.distance).slice(0,ee).map(re=>re.contact)}count(){let E=0;for(const ee=[this.root];ee.length>0;){const te=ee.pop();te!=null&&(te.contacts===null?ee.push(te.right,te.left):E+=te.contacts.length)}return E}_determineNode(E,ee,te){const re=te>>3,ne=te%8;return ee.length<=re&&ne!==0?E.left:ee[re]&1<<7-ne?E.right:E.left}get(E){ensureInt8("id",E);let ee=0,te=this.root;for(;te.contacts===null;)te=this._determineNode(te,E,ee++);const re=this._indexOf(te,E);return re>=0?te.contacts[re]:void 0}_indexOf(E,ee){for(let te=0;te<E.contacts.length;++te)if(arrayEquals(E.contacts[te].id,ee))return te;return-1}remove(E){ensureInt8("the id as parameter 1",E);let ee=0,te=this.root;for(;te.contacts===null;)te=this._determineNode(te,E,ee++);const re=this._indexOf(te,E);if(re>=0){const ne=te.contacts.splice(re,1)[0];this.safeDispatchEvent("removed",{detail:ne})}return this}_split(E,ee){E.left=createNode(),E.right=createNode();for(const ne of E.contacts)this._determineNode(E,ne.id,ee).contacts.push(ne);E.contacts=null;const te=this._determineNode(E,this.localNodeId,ee),re=E.left===te?E.right:E.left;re.dontSplit=!0}toArray(){let E=[];for(const ee=[this.root];ee.length>0;){const te=ee.pop();te!=null&&(te.contacts===null?ee.push(te.right,te.left):E=E.concat(te.contacts))}return E}*toIterable(){for(const E=[this.root];E.length>0;){const ee=E.pop();ee!=null&&(ee.contacts===null?E.push(ee.right,ee.left):yield*ee.contacts)}}_update(E,ee,te){if(!arrayEquals(E.contacts[ee].id,te.id))throw new Error("wrong index for _update");const re=E.contacts[ee],ne=this.arbiter(re,te);ne===re&&re!==te||(E.contacts.splice(ee,1),E.contacts.push(ne),this.safeDispatchEvent("updated",{detail:{incumbent:re,selection:ne}}))}}const KAD_CLOSE_TAG_NAME="kad-close",KAD_CLOSE_TAG_VALUE=50,KBUCKET_SIZE=20,PING_TIMEOUT=1e4,PING_CONCURRENCY=10;class RoutingTable extends EventEmitter$3{kBucketSize;kb;pingQueue;log;components;lan;pingTimeout;pingConcurrency;running;protocol;tagName;tagValue;metrics;constructor(E,ee){super();const{kBucketSize:te,pingTimeout:re,lan:ne,pingConcurrency:ie,protocol:se,tagName:oe,tagValue:ce}=ee;this.components=E,this.log=logger$1(`libp2p:kad-dht:${ne?"lan":"wan"}:routing-table`),this.kBucketSize=te??KBUCKET_SIZE,this.pingTimeout=re??PING_TIMEOUT,this.pingConcurrency=ie??PING_CONCURRENCY,this.lan=ne,this.running=!1,this.protocol=se,this.tagName=oe??KAD_CLOSE_TAG_NAME,this.tagValue=ce??KAD_CLOSE_TAG_VALUE;const ae=()=>{this.metrics?.pingQueueSize.update(this.pingQueue.size),this.metrics?.pingRunning.update(this.pingQueue.pending)};this.pingQueue=new PQueue({concurrency:this.pingConcurrency}),this.pingQueue.addListener("add",ae),this.pingQueue.addListener("next",ae),this._onPing=this._onPing.bind(this)}isStarted(){return this.running}async start(){this.running=!0,this.components.metrics!=null&&(this.metrics={routingTableSize:this.components.metrics.registerMetric(`libp2p_kad_dht_${this.lan?"lan":"wan"}_routing_table_size`),pingQueueSize:this.components.metrics.registerMetric(`libp2p_kad_dht_${this.lan?"lan":"wan"}_ping_queue_size`),pingRunning:this.components.metrics.registerMetric(`libp2p_kad_dht_${this.lan?"lan":"wan"}_ping_running`)});const E=new KBucket({localNodeId:await convertPeerId(this.components.peerId),numberOfNodesPerKBucket:this.kBucketSize,numberOfNodesToPing:1});this.kb=E,E.addEventListener("ping",this._onPing),this._tagPeers(E)}async stop(){this.running=!1,this.pingQueue.clear(),this.kb=void 0}_tagPeers(E){let ee=new PeerSet;const te=debounce(()=>{const re=new PeerSet(E.closest(E.localNodeId,KBUCKET_SIZE).map(se=>se.peer)),ne=re.difference(ee),ie=ee.difference(re);Promise.resolve().then(async()=>{for(const se of ne)await this.components.peerStore.merge(se,{tags:{[this.tagName]:{value:this.tagValue}}});for(const se of ie)await this.components.peerStore.merge(se,{tags:{[this.tagName]:void 0}})}).catch(se=>{this.log.error("Could not update peer tags",se)}),ee=re});E.addEventListener("added",re=>{te(),this.safeDispatchEvent("peer:add",{detail:re.detail.peer})}),E.addEventListener("removed",re=>{te(),this.safeDispatchEvent("peer:remove",{detail:re.detail.peer})})}_onPing(E){const{oldContacts:ee,newContact:te}=E.detail;this.pingQueue.add(async()=>{if(!this.running)return;let re=0;try{await Promise.all(ee.map(async ne=>{try{const ie={signal:AbortSignal.timeout(this.pingTimeout)};this.log("pinging old contact %p",ne.peer),(await(await this.components.connectionManager.openConnection(ne.peer,ie)).newStream(this.protocol,ie)).close(),re++}catch(ie){this.running&&this.kb!=null&&(this.log.error("could not ping peer %p",ne.peer,ie),this.log("evicting old contact after ping failed %p",ne.peer),this.kb.remove(ne.id))}finally{this.metrics?.routingTableSize.update(this.size)}})),this.running&&re<ee.length&&this.kb!=null&&(this.log("adding new contact %p",te.peer),this.kb.add(te))}catch(ne){this.log.error("could not process k-bucket ping event",ne)}}).catch(re=>{this.log.error("could not process k-bucket ping event",re)})}get size(){return this.kb==null?0:this.kb.count()}async find(E){const ee=await convertPeerId(E),te=this.closestPeer(ee);if(te!=null&&E.equals(te))return te}closestPeer(E){const ee=this.closestPeers(E,1);if(ee.length>0)return ee[0]}closestPeers(E,ee=this.kBucketSize){return this.kb==null?[]:this.kb.closest(E,ee).map(te=>te.peer)}async add(E){if(this.kb==null)throw new Error("RoutingTable is not started");const ee=await convertPeerId(E);this.kb.add({id:ee,peer:E}),this.log("added %p with kad id %b",E,ee),this.metrics?.routingTableSize.update(this.size)}async remove(E){if(this.kb==null)throw new Error("RoutingTable is not started");const ee=await convertPeerId(E);this.kb.remove(ee),this.metrics?.routingTableSize.update(this.size)}}const GENERATED_PREFIXES=[77591,22417,43971,28421,740,29829,71467,228973,196661,78537,27689,36431,44415,14362,19456,106025,96308,2882,49509,21149,87173,131409,75844,23676,121838,30291,17492,2953,7564,110620,129477,127283,53113,72417,165166,109690,21200,102125,24049,71504,90342,25307,72039,26812,26715,32264,133800,71161,88956,171987,51779,24425,16671,30251,186294,247761,14202,2121,8465,35024,4876,85917,169730,3638,256836,96184,943,18678,6583,52907,35807,112254,214097,18796,11595,9243,23554,887,268203,382004,24590,111335,11625,16619,29039,102425,69006,97976,92362,32552,63717,41433,128974,137630,59943,10019,13986,35430,33665,108037,43799,43280,38195,29078,58629,18265,14425,46832,235538,40830,77881,110717,58937,3463,325358,51300,47623,117252,19007,10170,20540,91237,294813,4951,79841,56232,36270,128547,69209,66275,100156,32063,73531,34439,80937,28892,44466,88595,216307,32583,49620,16605,82127,45807,21630,78726,20235,40163,111007,96926,5567,72083,21665,58844,39419,179767,48328,42662,51550,5251,37811,49608,81056,50854,55513,20922,18891,197409,164656,32593,71449,220474,58919,85682,67854,13758,35066,3565,61905,214793,119572,141419,21504,10302,27354,67003,46131,32668,15165,64871,34450,17821,2757,11452,34189,5160,12257,85523,560,53385,65887,119549,135620,312353,115979,122356,10867,193231,124537,54783,90675,120791,4715,142253,50943,17271,43358,25331,4917,120566,34580,12878,33786,160528,32523,4869,301307,104817,81491,23276,8832,97911,31265,52065,7998,49622,9715,43998,34091,84587,20664,69041,29419,53205,10838,58288,116145,6185,5154,141795,35924,21307,144738,43730,12085,8279,10002,119,133779,199668,72938,31768,39176,67875,38453,9700,44144,4121,116048,41733,12868,82669,92308,128,34262,11332,7712,90764,36141,13553,71312,77470,117314,96549,49135,23602,54468,28605,6327,62308,17171,67531,21319,14105,894,107722,46157,8503,51069,100472,45138,15246,14577,35609,191464,1757,13364,161349,32067,91705,81144,52339,5408,91066,21983,14157,100545,4372,26630,129112,1423,29676,213626,4397,88436,99190,6877,49958,26122,114348,60661,29818,293118,50042,179738,16400,163423,89627,31040,43973,36638,45952,5153,1894,109322,1898,134021,12402,112077,68309,190269,69866,31938,107383,11522,105232,11248,14868,39852,71707,186525,16530,38162,106212,11700,5130,16608,26998,59586,108399,230033,43683,48135,82179,2073,5015,196684,189293,16378,23452,8301,35640,11632,214551,29240,57644,33137,91949,55157,52384,117313,5090,17717,89668,49363,82238,241035,66216,29066,184088,97206,62820,26595,4241,135635,173672,8202,459,71355,146294,29587,3008,135385,141203,14803,6634,45094,69362,50925,546,51884,62011,83296,234584,44515,56050,89476,87751,19373,12691,149923,19794,13833,35846,87557,58339,2884,19145,25647,12224,11024,77338,64608,122297,53025,7205,36189,36294,170779,21750,7739,173883,75192,35664,224240,113121,30181,26267,27036,117827,92015,106516,55628,203549,67949,60462,60844,35911,20457,1820,920,19773,8738,73173,181993,38521,98254,76257,46008,92796,5384,26868,151566,22124,2411,15919,186872,180021,28099,152961,78811,80237,62352,102653,74259,184890,16792,123702,224945,29940,19512,75283,14059,112691,92811,233329,20411,138569,53341,109802,50600,134528,66747,5529,166531,31578,64732,67189,1596,126357,967,167999,206598,109752,119431,207825,78791,91938,10301,27311,24233,252343,28831,32812,66002,112267,90895,8786,8095,16824,22866,21813,60507,174833,19549,130985,117051,52110,6938,81923,123864,38061,919,18680,53534,46739,112893,161529,85429,26761,11900,81121,91968,15390,217947,56524,1713,6654,37089,85630,138866,61850,16491,75577,16884,98296,73523,6140,44645,6062,36366,29844,57946,37932,42472,5266,20834,19309,33753,127182,134259,35810,41805,45878,312001,14881,47757,49251,120050,44252,3708,25856,107864,120347,1228,36550,41682,34496,47025,8393,173365,246526,12894,161607,35670,90785,126572,2095,124731,157033,58694,554,12786,9642,4817,16136,47864,174698,66992,4639,69284,10625,40710,27763,51738,30404,264105,137904,109882,52487,42824,57514,2740,10479,146799,107390,16586,88038,174951,9410,16185,44158,5568,40658,46108,12763,97385,26175,108859,664,230732,67470,46663,14395,50750,141320,93140,15361,47997,55784,6791,307840,118569,107326,18056,58281,260415,54691,8790,73332,45633,7511,45674,143373,14031,11799,94491,35646,96544,14560,26049,32983,25791,83814,42094,231370,63955,139212,2359,169908,3108,183486,105867,28197,32941,124968,26402,88267,149768,23053,3078,19091,52924,25383,19209,111548,97361,3959,24880,235061,9099,24921,161254,151405,20508,7159,34381,20133,11434,74036,19974,34769,36585,1076,22454,17354,38727,235160,111547,96454,117448,156940,91330,37299,7310,26915,117060,51369,22620,61861,322264,106850,111694,15091,2624,40345,300446,177064,1707,27389,54792,327783,132669,183543,59003,17744,20603,151134,106923,53084,71803,279424,319816,11579,21946,16728,38274,72711,5085,83391,88646,40159,25027,34680,10752,12988,54126,30365,18338,100445,230674,44874,84974,143877,123253,139372,28082,91477,144002,13096,219729,46016,50029,42377,14601,6660,58244,58978,23918,88206,113611,64452,17541,41032,10942,12021,49189,10978,40175,37156,10947,71709,106894,112538,57007,137486,150608,152719,40615,7746,279716,13101,19524,28708,40578,72320,1096,182051,94527,51275,22833,45164,81917,77519,48508,5421,140302,37845,149830,5587,27579,5357,428725,248187,6326,206760,39814,32585,89923,44341,288753,284443,96368,31201,94189,119504,20359,52073,103216,179,27934,32801,96035,34111,34309,101326,18198,20704,210266,37643,27880,141873,106e3,19414,56614,167714,66483,107885,86602,4379,20796,75467,4987,5017,118857,26003,34308,114428,29198,6686,29697,73632,3739,69795,16798,41504,7207,30722,21436,36735,28067,28545,3239,11221,36031,41889,100010,19247,317673,29495,174554,6424,129725,53845,94986,7955,59676,2604,191497,19735,102214,62954,23844,11872,179525,261436,34492,428,78404,142035,16747,17246,27578,37021,33672,57944,26056,135760,2369,61674,122066,31327,19374,157065,40553,130982,69619,71290,38855,72100,92903,95940,51422,165999,65713,57873,50726,7288,20272,2081,42326,22624,81120,57914,79352,19447,1684,72302,11774,302559,161481,96396,13692,414988,3721,79066,56627,46883,21150,11747,12184,5856,113458,176117,84416,52079,27933,3354,59765,141359,2212,216309,2555,23458,196722,142463,45701,44548,28798,19418,215,29916,9396,10574,114226,84475,13520,18694,34056,4524,90302,62930,13539,19407,77209,7728,38088,9535,2263,23875,183945,17750,26274,67172,10585,28042,22199,7478,51331,66030,26774,192929,31434,25850,50197,52926,178158,4679,181256,70184,229600,9959,105594,72158,73974,2726,35085,78087,23284,35568,51713,155676,5401,27254,11966,17569,223253,71993,103357,111477,55722,30504,26034,46774,35392,36285,214814,41143,163465,1051,16094,81044,6636,76489,179102,20712,39178,35683,125177,54219,30617,52994,25324,50123,2543,87529,58995,10688,125199,12388,60158,125481,131646,7642,133350,65874,3438,97277,101450,10075,56344,116821,50778,60547,98016,106135,13859,14255,16300,77373,173521,8285,45932,37426,4054,114295,55947,7703,39114,52,51119,128135,19714,60715,9554,50492,88180,2823,118271,52993,122625,97919,23859,37895,25040,33614,32102,20431,3577,9275,15686,43031,157741,110358,1884,40291,125391,13736,5008,64881,87336,77381,70711,43032,49155,118587,70494,4318,10168,30126,12580,10524,280104,104001,145413,2862,84140,6603,106005,13566,12780,11251,42830,571,179910,82443,13146,469,42714,32591,265217,424024,92553,54721,134100,6007,15242,114681,59030,16718,85465,200214,85982,55174,165013,23493,56964,82529,109150,32706,27568,82442,5350,14976,13165,44890,60021,21343,33978,17264,4655,22328,27819,75730,16567,55483,14510,17926,45827,150609,3704,7385,272531,161543,76904,122163,52405,2039,19165,41623,14423,228354,3369,176360,85491,7122,35789,303724,4465,13628,2233,55311,118771,20713,10006,221519,45115,71021,35650,29775,7337,10864,20665,21142,1746,15080,1624,32449,10905,105743,229797,7701,3940,22997,178467,57208,389057,39683,59403,63344,63125,54847,69691,18336,56448,3362,37202,18282,29648,138224,35867,10495,5911,28814,26653,31514,176702,26550,45621,11734,4525,40543,73944,121080,27858,155561,14887,44670,30742,8796,107455,113472,56369,75581,183777,240095,133699,153299,8768,160464,26058,49078,103971,21875,71486,44888,17156,9678,89541,123019,102337,3972,83930,21245,87852,109660,287918,183019,686,10100,39177,283941,11274,24736,26793,26214,25995,77011,141580,4070,23742,46285,46632,30700,26669,19056,35951,115575,174034,56097,35463,87425,24575,44245,38701,82317,85922,281616,100333,147697,61503,7730,84330,8530,59917,61597,17173,9092,32658,90288,193136,39023,20381,56654,31132,7779,1919,1375,117128,30819,11169,40938,23935,115201,101155,151034,4835,11231,74550,89388,59951,91704,107312,167882,115062,12732,72738,88703,464019,158267,57995,60496,737,14371,123867,4174,243339,159946,7568,16025,134556,110916,38103,191,80226,88794,29688,27230,10454,76308,57647,77409,113483,66864,14745,19808,12023,46583,84805,16015,17102,2231,20611,3547,95740,250131,34559,108894,8498,15853,159169,148920,20942,2813,93160,45188,210613,45531,52587,149062,39782,28194,57849,60965,84954,89766,84453,100927,16501,27658,165311,103841,54192,207341,19558,20084,319622,5672,205467,98462,61849,36279,13609,147177,24726,165015,209489,59591,31157,6551,117580,75060,141146,277310,21072,22023,106474,63041,137443,122965,68371,5383,42146,98961,113467,30863,23794,4843,99630,30392,82679,13699,241612,33601,93146,24319,18643,32155,95669,40440,15333,34089,67799,142144,58245,38633,114531,117400,77861,188726,5507,2568,8853,10987,107222,2663,2421,11530,13345,30075,41785,118661,104786,17459,12490,16281,71936,193555,17431,5944,71758,26485,77317,20803,367167,158,7362,93430,11735,172445,46002,11532,54482,930,62911,2235,23004,179236,4764,101859,208113,22477,55163,95579,14098,67320,162556,90709,156949,3826,57492,4025,34092,87442,104565,6718,186015,28214,14209,10039,107186,233912,58877,81637,55265,39828,6194,145813,50831,105849,4974,88319,122296,10272,197216,95714,51540,72418,23324,91555,8743,140452,250249,51666,34124,7229,38592,129641,78169,174242,22464,149964,51450,14034,10026,95376,26190,120062,14401,8700,265,31386,143573,7203,229889,61567,4227,140981,2466,72052,10787,10062,30958,6099,38471,30103,23202,208101,70847,467,58934,32271,32984,36637,24107,30771,17109,73353,13650,2098,157040,67366,66904,106018,265380,107238,18535,44025,32681,144983,62505,91295,56120,3082,77508,10322,63023,36700,81885,224127,16721,45023,239261,111272,13852,7866,149243,204199,32309,22084,42029,38316,126644,104973,14406,43454,67322,61310,15789,40285,24026,181047,6301,70927,23319,115823,27248,66693,115875,278566,63007,146844,56841,59007,87368,180001,22370,42114,80605,12022,10374,308,25079,14689,12618,63368,7936,264973,212291,136713,95999,105801,18965,32075,48700,52230,35119,96912,32992,8586,16606,101333,101812,14969,39930,759,193090,27387,42914,12937,5058,62646,64528,38624,25743,37502,3716,4435,30352,178687,26461,132611,42002,138442,35833,59582,16345,8048,60319,49349,309,47800,49739,90482,26405,34470,63786,32479,85028,39866,47846,11649,23934,29466,2816,42864,31828,7410,74885,49632,47629,111801,90749,19536,18767,105764,59606,21223,10746,76298,22220,39408,7190,79654,64856,11602,82156,272765,17079,70089,245473,51813,184407,384678,1576,122249,5064,27481,6188,25790,74361,27541,318284,45430,31488,620,93579,45723,192118,22670,51913,4162,70244,35966,26397,16199,50899,209613,121702,287507,2993,36101,132229,67345,33062,76295,118628,78705,52316,34375,107083,107454,44863,127561,33964,3073,154010,190914,55967,39074,6272,31047,5550,41123,26154,98638,47110,19998,148091,50229,31329,59900,195442,19106,61347,73497,70015,682,45850,25776,38022,148951,6288,37411,232526,109277,27286,32342,9262,5220,16651,23175,46740,129438,78614,121925,66914,88710,127952,5563,21500,34521,10739,14863,191006,62956,17359,16749,67027,56284,69134,43301,35039,58883,54466,60823,404451,75743,59856,86979,7923,34273,83785,32142,7693,268986,197428,282681,17049,22346,22990,92245,107180,3357,37104,96724,49153,7683,31197,43267,82231,164276,23696,20848,188364,22309,24821,158707,1018,22514,70922,27792,45589,59709,10765,736,35218,63479,51987,24275,63588,55361,92929,81964,4658,20122,12330,44058,13065,311456,72224,8337,211229,38979,22590,138478,52757,32595,133600,8838,31549,94412,43391,90056,1585,94802,127271,6223,31889,137038,132910,2165,57616,230152,6080,10748,36737,74579,134062,50525,180532,119270,34556,76155,82394,52595,29258,31435,87820,67996,26943,183878,38007,2410,13526,180297,69856,3503,187396,167700,7838,16701,9199,56267,3661,37407,65994,23767,5708,62508,221700,67088,86978,46776,84434,32088,5612,9149,88244,21685,95151,46750,189612,2979,506311,2594,3628,40074,105039,78243,28523,6651,38058,71999,30992,12764,68261,108991,6165,26450,61961,13400,22426,7490,60890,109623,2070,12958,50355,67979,257096,7213,42578,52121,35716,65461,7516,124758,39268,302,64712,14977,1467,219452,2840,34229,11121,21602,19270,63574,8024,1532,17331,79839,78885,52029,180767,57957,6069,91265,61380,55767,8927,32881,287603,22149,35029,68876,6428,199567,46926,13412,104132,21434,366616,45060,110046,81924,128910,45886,52821,130416,29416,77342,21762,67329,121432,79924,11724,38625,81006,102033,28338,13326,3250,82056,82526,38212,21112,12382,111495,3263,7414,86274,93490,40844,30224,45212,24019,48411,71367,24941,76729,57776,3769,38114,202019,197745,31953,237533,33270,201580,255648,100798,44741,32241,98468,106931,10085,15090,170358,33154,66787,18819,69760,25061,234005,82660,6295,131975,16874,9076,4094,25005,17740,40908,19533,220019,44330,99792,50040,19619,13950,55228,24423,31253,95308,103177,184795,28590,82285,5059,3210,75525,49894,70007,56178,10580,36051,139681,21617,98736,3555,106306,164189,37352,63915,47824,24883,145530,61904,28444,11483,19837,145446,30420,112972,85939,11835,191233,2262,20705,58630,1753,148334,1197,144714,6887,11223,107667,60879,77914,4151,57417,81594,96681,169430,1784,20444,95138,254041,27038,596,7117,72808,13759,3353,126776,21074,55322,27081,36942,39547,139830,179275,4453,713,8722,71399,19204,25785,22794,23923,104114,11291,25458,102309,88396,75288,230440,206396,104551,58447,130857,37247,94734,31548,176529,226077,65159,20104,10096,66881,94191,237909,27109,37404,1520,27421,25220,113003,23423,24884,50585,6286,231877,150800,11789,3226,90004,60642,5053,202400,61442,132531,175329,57138,30116,103847,9973,75367,16452,32360,59119,21246,10191,164804,23305,61051,37348,154530,13214,5468,50403,66754,130976,50559,80515,14436,155492,84017,5472,43107,41240,2890,90431,70188,382,76234,48040,50211,281038,237007,32115,142178,1536,22761,96429,1811,31243,1679,49143,55209,17402,235054,61494,7462,77030,34925,87609,78002,9499,9027,73289,201078,101379,63544,27666,5469,10642,30029,49816,132979,95620,58086,351930,116300,2110,2043,30845,6154,11279,16727,4122,2277,27281,4971,3650,39060,61970,65951,39674,75686,38151,11370,130809,177895,32665,63725,122267,7857,39618,118483,44792,157755,178624,136994,24260,41308,22471,12404,21707,12486,30473,52781,50246,20247,39065,909,56825,103158,128603,31542,1089,41935,32744,12428,37963,84420,33134,72921,208449,42622,168151,127335,147107,46699,38216,12591,94342,85814,31423,24944,2605,87542,67473,192551,4496,56321,91819,17630,6300,256183,114569,202090,33209,35289,34897,24967,40520,43470,5344,10199,34810,14283,10381,10017,62923,49924,23233,64539,13051,35686,19698,11570,135555,120868,44924,87065,52318,52335,47586,140906,245885,109834,78668,9065,46990,25258,72022,61243,40838,4545,146387,10537,11557,17470,36930,68104,46711,24264,79401,81043,18225,120488,24746,84338,81652,28266,13776,21878,46973,1047,230465,73357,95777,24973,210160,62210,58404,110633,169651,6937,41870,9909,26822,191062,76553,27519,96256,239070,2478,205678,67955,58532,20601,50120,19148,78501,195724,110740,8249,109665,27446,30568,57631,31425,49752,32820,65504,50079,3663,102256,219898,23849,211315,14645,4359,91767,9528,12449,49366,7941,49763,107848,8930,27086,50686,9744,10447,81935,39513,46514,1670,29229,6172,22312,137280,97759,9806,14445,22976,56458,73391,34983,93760,174219,52573,33149,59747,2429,136277,75123,165263,91040,7446,57632,48633,97140,246081,84766,151684,79918,93268,120346,54059,54875,77858,32996,103590,45276,11968,19600,25849,17159,132907,42828,16817,4913,99462,103303,27395,5737,74184,20749,21160,14377,77062,131403,158735,10999,27799,77785,9320,34366,51593,61070,33746,47048,29268,36675,30262,53297,9832,82e3,20188,122292,39917,7331,18160,68301,185935,134830,15031,4935,10004,165845,185534,46923,30109,44134,122631,18874,22903,112790,26561,18549,348902,82871,140345,255565,135390,63556,103747,145055,179600,145662,296111,61661,211987,23952,52342,126343,48450,32919,44277,82185,9591,62139,205363,376969,394874,108461,18040,120885,14798,39863,16571,16794,58271,81025,55206,14640,118656,6361,44092,85970,6262,153863,108244,180200,72264,79947,38044,10050,5735,61221,80712,5471,115689,11391,11661,184257,20010,60116,30320,19327,134598,45455,27542,18004,125092,452272,1549,91523,46567,180063,156026,2608,11174,58848,37788,65907,80194,30490,5786,40775,119519,106241,11323,156297,8425,61495,2617,29675,2425,59886,112582,49142,59618,4863,50597,86710,50650,168632,27693,85641,83643,18993,25768,84284,28090,93592,36627,312804,43381,9887,9402,100931,97165,3311,173330,66805,28935,4963,184460,3201,78102,19126,21607,37496,24938,22615,16153,32862,134792,153318,61120,6067,2812,12826,12792,23825,37559,64662,202250,102694,155488,85881,149193,46233,65383,15521,106982,11358,176786,25752,39717,34208,24510,32464,77742,39371,72028,138229,60688,71386,102834,132477,2208,11548,63670,271279,28351,30338,38620,32491,99845,143885,152266,13252,2825,178663,108097,1775,78201,14897,113573,163346,62292,171129,22183,96598,38733,64971,166776,117445,9968,146393,44677,74867,20908,97328,12761,25656,26785,9148,112344,26115,99176,110121,22437,49547,6180,79320,5835,31392,43328,33377,75870,119860,69497,80273,7325,155219,43167,111173,28347,20222,3763,71752,55041,47252,14618,28088,15012,97805,194698,54636,2036,41349,6173,96604,61530,51859,43782,13361,24334,22668,24792,7070,23441,16789,3209,36211,208475,26242,32880,122181,182407,21444,31060,88459,29929,77907,12716,10934,97005,20599,31690,8403,58445,30303,22700,10336,86731,103115,337709,72556,46788,112566,47684,67089,53548,36874,56487,41387,125985,26893,40071,106683,73712,18787,40105,72992,67246,137276,50802,36790,70328,138827,22466,39263,183295,29858,50975,9322,57397,10654,24364,30383,55799,41600,23584,127295,296610,129078,143558,244131,86397,36049,1085,80677,3820,108139,5476,34767,24683,7758,13060,7239,131671,250593,59556,103392,29810,4188,252323,39404,116877,7651,43600,40338,13554,157253,39196,25978,144387,61211,234,50104,6129,10449,93777,9240,356378,274148,4439,72970,3724,147770,78680,62570,115877,40027,40547,36817,224392,64609,34795,165027,67440,2477,37206,23431,50754,164797,46018,94995,170982,27051,7957,22767,3674,27900,56419,18930,60701,41302,2692,84749,339721,61996,111094,80221,50129,1045,8153,62945,19202,8250,37208,37418,32560,79477,41106,88569,33963,36693,5892,30570,1581,66471,49647,11922,160717,29442,5643,114865,82962,95982,132098,22633,22838,94726,54556,28566,205039,162340,33216,16849,35847,221339,94851,26533,71469,1805,3804,12935,45483,71020,36310,65381,192960,34240,35165,59773,1248,46954,155332,96864,4246,388800,16129,57133,74592,44807,442014,38203,42574,80818,91592,26377,36424,65760,977,77387,22628,147610,28018,30561,98454,6969,119628,63648,18170,36854,26601,64018,22027,37279,51395,152934,21153,9430,58760,194742,5330,55115,34158,28917,174111,13171,122326,1526,43896,66094,25325,4234,148354,11450,275,18999,112191,44365,22723,68409,8733,57746,96565,75007,14196,108844,29475,88599,177563,100792,106156,86323,93726,14248,135341,194131,40126,47099,14779,8272,39597,95983,171398,65882,28052,10393,47213,40689,22120,72212,106829,34964,109146,753,648,21660,30047,17527,181025,5619,145357,4085,216883,9359,186951,24779,53931,24545,36197,223296,62628,168101,4243,107313,30321,26642,13049,51059,31027,107912,807,73550,26551,84369,122422,165872,49754,74213,234264,33151,52014,33100,87183,22365,52500,40013,23302,5652,72723,21404,26107,48434,587,94049,168493,96418,32871,70860,31709,25128,443,71597,166253,15670,70994,26341,133675,28280,75491,54756,47955,56028,26182,11952,113272,472197,64640,110753,17919,337,50642,22576,142,87371,53391,93210,126694,15285,19642,85667,14148,1506,42092,52962,33243,11970,20734,135843,57044,58880,13002,219134,22876,64754,232519,4257,43120,321573,24799,64526,124728,52579,81472,70831,276848,17403,74359,23021,182101,74597,23744,148267,12055,7976,5349,11772,67540,167347,65318,18720,127832,108238,22828,90233,9987,259080,118185,73209,79270,13775,90100,137742,90799,70569,15699,19961,9087,67475,57872,39731,8810,134897,131868,146849,19898,3334,2281,167061,91073,60356,467742,74712,188,53179,137679,92769,29241,9537,132595,80119,1041,88962,5976,40171,44911,102859,139059,104558,98987,47761,19272,71472,113864,175377,73338,10857,23402,23758,1591,139864,5644,4076,118760,16427,134198,18853,20291,100849,37423,22038,36677,19071,195521,57445,11069,31869,55718,66882,148490,44,41296,75242,49704,166810,9906,20943,122258,49112,105667,15969,10344,6408,187694,21399,72742,58970,14867,14376,81889,41856,23225,15042,56993,16074,131389,74276,72407,53875,383108,53597,37363,68993,44854,122548,430927,198279,38430,80409,12245,2981,628,2818,17760,37437,238229,7968,46892,2200,3730,34190,65983,37959,112291,87850,70827,6522,20750,73913,111621,41652,19587,2780,58668,25916,85259,18200,168962,95781,42445,102050,7776,57662,103313,47742,96358,41964,66174,100396,29069,204735,19679,27978,7479,40264,22534,61183,36081,107436,58223,14680,23002,101311,24716,124108,12908,5646,31750,40380,14215,232799,102772,14122,96775,61398,50917,12096,149880,67833,598749,124194,155871,49216,790,14677,65319,56917,7440,145744,95701,12206,49405,129269,76199,45732,9767,11058,9047,210885,11051,7392,26307,2130,8132,147526,20802,232698,115660,50060,59789,57344,107623,80343,112676,23291,9866,160971,34032,118291,15719,59730,164911,28975,2659,58046,78480,21854,66209,53863,109085,116045,29021,46481,107552,22130,18764,70254,31272,11300,52460,43933,84738,20721,53869,190840,79673,105300,7561,321817,66924,13940,33281,101046,183181,32176,71878,5678,62924,79535,56646,40303,19559,27703,93042,73368,42187,3670,37376,46440,7023,36816,109628,20680,5940,276440,275233,170848,112093,136996,14984,20226,111441,77693,112960,48577,39370,55707,50314,123404,26570,54281,61372,123391,4857,35928,246740,132507,106646,44241,7196,92258,9825,37688,51197,303141,5590,15476,132986,10955,85782,34486,26696,7991,28813,18858,39546,11703,11365,38185,5716,93555,11925,40121,60002,6985,10976,171384,3887,43394,13337,56346,6381,252336,39573,75042,53711,1028,31781,44295,95925,131713,7214,68125,43571,70954,213234,1628,8760,13391,65485,17320,56038,1710,25248,60803,57399,19839,3870,326,281556,50945,72400,21460,316244,75619,56246,98775,481,13513,55765,50427,7388,123519,32929,57908,27124,61316,101097,57467,30228,48792,10788,20402,37318,50526,155730,34456,158065,145305,17832,43733,64052,4506,35072,205355,177028,184004,187081,68616,35938,83703,10367,36892,93186,260137,51934,89970,4985,23445,26755,21558,7948,78741,23376,124405,85594,68596,57536,49351,12619,56593,132668,99924,109728,71844,71935,196018,65464,17617,14987,89701,143773,33997,8687,22701,33258,2914,4436,72108,85610,9671,49067,2327,82988,1361,1672,44033,35777,30269,24057,10605,82236,616,15793,13919,47249,112086,116698,9484,80207,90574,33304,68624,93127,56101,42210,160929,4827,38995,38095,4701,125119,5027,33680,9236,231236,14135,87837,23318,70261,78893,30151,81482,14332,1084,74256,27532,46644,79185,3148,62615,6981,55672,31668,36825,1849,14536,37446,14738,23779,43058,162749,72199,1168,21346,5592,85932,85302,9668,18351,57135,150360,2080,228015,77953,34670,119302,151751,31009,106725,84265,45214,59289,74178,113071,263206,111009,4021,44449,188119,192629,123592,392506,292847,114487,12831,205858,9852,20780,79648,75767,357014,97721,18166,21005,67950,33226,204009,16536,2987,11335,66717,144910,47950,17262,55060,15063,2934,51038,26775,178497,66008,3427,49433,128592,20036,157553,63861,3089,23015,51210,28696,35933,49942,71135,231518,99620,17248,21835,176536,20676,16944,38700,165831,233253,295625,36723,13023,52745,10907,19423,67972,125868,95473,82875,1183,108455,52685,33417,64095,21433,52438,33191,127809,44505,211823,7810,2752,95548,162031,7185,91196,47563,61721,33359,17897,23682,42806,178101,22874,49707,199897,75419,82456,8618,11171,79712,116847,18783,44190,46564,5346,59046,95032,7893,14916,3214,26800,24172,121453,34362,10250,17408,18888,4840,68696,22831,13162,36005,32512,14800,62357,41723,45046,27247,37486,5372,2564,34261,298500,66509,133920,89138,31305,117697,19097,108304,81386,84106,23802,46411,63304,946,51417,41777,41041,19501,115864,60743,294354,37955,94165,18116,1156,17937,20645,57114,90804,58042,48643,92288,9861,2557,88546,61333,101008,12853,5148,87856,4152,144503,73841,18718,9789,147565,10846,42085,12789,30223,8993,56352,67203,2448,28215,6052,23540,126319,75933,36689,80235,23231,23561,21383,38800,77548,102798,21234,31468,158608,46188,63960,191679,8051,67014,11185,170078,42186,28827,34777,41930,212079,12421,34750,24111,110344,73918,45171,70826,141949,40063,23979,24254,37309,26724,27179,24718,83648,54938,14591,17425,29525,102675,48975,48654,12316,8929,60640,41709,50168,63264,89812,50716,48632,38755,138583,160123,55579,71829,24230,233277,46322,39650,166388,34718,24108,98252,7031,106695,62498,18258,35062,217827,78731,34824,33354,19520,60852,2432,60224,8587,2836,62955,702,20227,42285,40560,95592,62486,11094,53035,143291,18842,46177,77994,1770,9657,107422,172915,32655,128716,25886,25164,156740,119928,165875,85817,11007,89110,33956,12652,65156,180266,8494,36889,19958,20955,96,1264,118288,135769,44754,86671,5632,19026,168220,289120,33569,93821,66144,70635,7687,5642,2714,55445,56636,71545,184182,93133,7332,37389,12643,52315,22729,11014,158742,17050,152889,50178,34601,41945,52136,9948,26914,63548,95721,115951,40759,8960,158258,38938,49232,48325,42234,81523,253019,66128,40978,20048,238048,38760,62928,122560,118532,43687,137472,163689,26680,9878,17448,51035,16211,60834,36749,29178,14241,59868,150086,2305,26477,42422,34342,165341,83279,33894,14257,29928,12743,13957,125571,89134,66712,10952,16507,147839,30146,7249,16565,45399,39874,114565,215780,31990,230881,171477,102,196546,44538,10880,84948,281705,86651,10617,31395,2342,453658,43569,60561,132901,21845,17727,58556,258242,22262,58728,4008,77997,11806,37431,30599,81375,109137,185787,114085,217292,97453,169085,30593,60212,11544,102056,65580,2384,91655,4855,95725,7295,157994,16228,20669,53276,141590,105246,17334,25440,76067,17967,39321,38911,11362,28559,63807,21627,26468,85816,40120,1025,15234,58319,69516,66512,124548,75845,78873,22137,46681,51242,85683,32909,76747,35555,43396,101465,1765,73094,1077,2962,39028,66777,57831,42048,15828,13962,36041,63657,52412,5242,58846,2141,5506,219012,134451,3936,182230,17558,17153,152237,22621,49377,170216,35257,68233,65374,6510,11126,212151,7184,2480,22517,3437,33073,30156,16557,3768,55067,86829,91e3,12350,148650,66017,79424,70885,49066,28250,21369,51213,34533,11510,3258,18176,18465,84413,6315,36411,163765,4346,356,107618,598,13727,285026,162695,8749,14583,7132,63521,184253,32378,25991,5604,30961,53675,4874,84693,5086,34811,26978,56564,7904,33519,51221,113942,69253,6664,125563,22055,220680,102008,742,51930,19494,176108,44424,35123,13025,75685,11759,74335,22250,181453,131147,16984,132115,154311,11991,76452,52609,85351,196,30969,9198,74919,2529,56838,71779,29187,116304,3504,62330,41190,86153,28393,254926,104228,105189,13264,84359,3574,12415,8534,57147,10175,188174,59504,60932,66318,16407,107921,17638,99103,49278,28403,39786,145865,8462,3558,43406,142271,29139,21989,36552,93955,72365,7176,13556,106185,37957,321774,17782,129017,51154,27938,24952,1935,39366,2791,33489,41582,56078,24558,9311,5449,218786,27808,190429,68013,36020,86003,29735,3404,87348,119357,115714,2324,86796,81973,40992,43376,93621,28784,16808,36367,2517,2909,191926,24978,55303,53308,205724,60068,3098,21375,64784,23949,26579,63121,12319,80145,39967,97861,6757,70143,67642,37082,34698,69140,122883,46151,62187,80934,429,19437,135071,137885,222647,13331,154065,327,61778,74257,40116,37493,14855,85079,237641,42342,102164,199965,71204,4662,29368,5042,113914,122214,8955,13149,102503,43173,5659,163787,69003,307084,63392,171080,21390,81918,86666,36622,24126,28887,5736,28054,207170,163428,79891,346467,95363,38980,111806,80828,9200,19288,294896,114468,87405,111715,141705,7015,72754,68463,48738,243147,33397,101210,37051,98801,82847,20397,4940,185559,18716,54718,83491,11725,40803,1128,12128,23060,5174,7745,67007,46701,1571,27807,180186,256996,18975,16837,7877,212758,250379,15440,87954,57755,24719,124057,83461,258,50864,8874,29038,71289,31627,15429,9005,4061,113851,107716,82819,13651,79656,117851,17539,111446,12938,39724,190787,4352,15402,21070,62708,8539,23777,73853,13552,38810,86117,16285,56400,1718,75342,142863,29033,378,110113,180321,32586,23606,26393,160984,207987,23783,8406,16904,24596,47274,11693,46539,60524,78595,48423,31718,20170,9009,146268,15183,191060,172765,1349,138436,37365,10970,40509,225817,20021,70394,152138,21541,66559,66544,89352,2725,17258,91345,7313,3815,115868,8660,40362,4071,103524,39388,118275,21950,6549,38226,32754,209574,29201,43495,18028,20296,40597,18370,47520,202450,24134,2219,8195,69545,38041,136934,46374,19041,159811,84865,58620,846,98749,13569,30714,97246,32186,4479,27355,92973,35214,151491,75963,37631,1561,27200,238083,23182,60756,12291,25766,39355,102333,87362,65741,59906,19538,201575,48772,102938,24438,292580,39964,66366,9004,61379,50548,37622,38732,28379,68180,76622,17488,69849,5963,7219,48143,43413,55358,540,58691,29506,19245,52193,48621,5518,13048,118625,44755,191081,42061,89197,2259,60665,66994,71210,51232,3585,142096,55024,7892,8345,58653,463307,65658,64319,137941,136323,53499,12746,43492,6978,95163,29925,60175,5128,7352,41463,184756,121146,20473,18426,4598,5309,54580,14277,121151,10691,56711,43880,63409,76682,11830,172218,264898,32632,66536,81062,31649,25788,92774,60222,11100,63159,9432,224657,25240,53613,152,138620,163829,2397,85345,12501,37507,64932,38575,43522,65789,80198,78796,35226,3851,108891,73311,3060,28391,93671,39663,46142,30982,66041,37281,68157,26553,71872,81142,211527,39747,118119,22695,2859,11066,20232,168911,7933,197005,17066,111071,44434,133994,120798,12766,227798,45756,132852,29917,36076,55352,65281,129800,41958,18944,84678,18580,168093,132621,39997,54092,27740,32354,3770,114118,103242,43918,15899,18574,145944,3190,123469,219903,24169,100571,62403,16776,92779,14535,17168,16475,14304,37231,1712,28218,242754,61688,28980,1318,51359,222657,99200,67989,31772,23932,35351,201251,49041,27306,19128,40135,3986,77333,19649,120683,151927,21081,7076,78375,77501,101599,8011,89585,96715,58179,5378,102138,106793,26051,217276,4197,16297,27014,46721,13322,22806,5278,29629,70632,9647,71519,58818,40603,128530,8903,36770,56900,31483,26935,43845,34265,34920,87658,6114,84767,64250,47318,50720,19264,162514,33357,13117,6705,46696,75032,71054,87004,42035,69138,11903,99854,102328,19611,34525,69312,6431,49842,101600,133178,108751,41829,89939,225664,48916,99556,9195,130387,5960,36857,116724,53518,94002,39077,53996,6945,22261,64291,8314,152785,57588,16522,9091,5048,87671,35441,39509,1945,12423,158923,178413,37549,14095,1475,73188,62878,4819,24012,68534,42606,4010,120809,57497,59564,101758,103718,32701,80116,12345,95834,46918,21468,53213,15665,31200,3867,5140,96013,250744,21016,10069,13968,35449,180829,27683,39704,59956,22893,3115,26293,32785,75934,62445,141162,62720,2018,83638,19949,114012,95006,3330,99829,130935,309272,9565,55874,121727,37017,23586,319858,40970,27602,8625,112329,61060,100088,118525,25922,16232,1907,60671,51583,44553,80993,5262,94679,8676,940,20736,11823,3020,16476,12340,152600,97416,3703,25744,66826,16245,16876,46446,84798,74227,176020,45192,61955,75496,23946,23626,40372,26036,6149,11822,30582,16541,41914,82385,232823,40921,80773,14930,3631,7517,39619,4348,36180,126106,138939,62611,1477,113512,47321,25052,14546,118881,29060,23589,128322,36795,18401,137921,104699,267929,36194,172791,18113,4766,188215,30083,332586,94089,5805,77909,22194,68234,154976,43220,40660,70001,184893,138095,11128,103010,22663,5108,212615,8485,5565,49222,54614,26530,42639,16319,55062,152662,105595,21114,22216,10294,68158,10436,86950,7206,62115,3977,3657,59874,456,118617,18156,106663,112229,80992,17442,8217,55551,5133,34344,251927,51153,39364,201321,7816,66803,23057,156724,145664,14276,95705,979,2796,6875,13429,212525,50602,26276,28284,3424,19465,52397,46963,31420,51399,206476,92317,48851,637,100820,83349,10317,60227,21972,6908,282439,32857,224767,95629,83882,42106,87338,69757,29840,68709,37665,45244,114577,49188,175943,54009,186746,106158,70168,3358,234002,50555,9221,129338,9562,20118,32923,78479,118280,65752,4977,10474,102174,60947,129006,10570,83451,8598,8078,159367,123785,80438,16742,5905,5281,181513,42402,6977,163136,93179,42191,14968,50421,112401,105440,33456,57347,121611,4221,94954,36517,24046,27796,6255,33394,72990,135408,116627,1233,57874,25654,95419,68156,401399,313338,55208,45573,93124,119251,47200,38196,11909,130667,45391,73904,64964,167846,4137,115606,52036,62214,7969,160925,7187,1132,134835,40309,73195,64494,80472,444841,61111,26500,45323,40743,53625,52797,22659,15631,29739,36706,28841,39147,102836,26794,10536,14845,87305,45874,12241,127587,83833,57183,79722,30844,41304,84655,20825,92500,3722,25655,27811,10157,81634,31362,34088,92487,70123,22190,185100,72658,139035,192523,88241,2078,230490,44528,85638,100198,22088,29982,291233,241062,13865,4445,137791,37835,107218,31726,19718,38234,72528,23046,19177,66695,5109,17251,28077,5617,21554,47839,72425,133825,1486,73065,181275,141508,21768,62971,63082,2512,34200,9904,120309,6392,91243,68416,268253,41199,116757,138551,185526,41246,28986,4093,19057,17295,4148,245766,122360,35356,112075,20301,75441,10998,7977,19769,62922,937,63547,100196,26427,157820,20983,236696,22935,8140,90315,156004,47204,140973,7726,45097,52725,22636,23436,257282,105247,522,88389,216031,202204,46812,211666,19693,68828,81691,45925,11256,30292,372,5236,167826,88328,232776,151611,5360,82104,18841,80393,25465,18285,20320,72377,31730,33160,45803,38715,27705,37379,24163,18360,103586,4015,32305,269494,91252,20080,36567,54650,7797,57073,12650,31164,42209,6375,261663,105528,81661,106002,2800,5375,17247,43151,4442,15727,194619,100855,144898,62320,78465,39929,16454,1967,28311,61363,17219,9395,8745,121445,76939,80385,162380,22009,54191,44248,16299,122830,48151,74429,78291,64755,14238,44966,2511,17712,67954,93583,829,105899,49935,84750,11591,33185,85447,42717,27409,208542,28965,62052,52525,5597,25694,65594,16343,63224,276188,12475,9331,127507,38522,57287,24128,133161,79723,105548,133695,48917,27558,43278,46520,13778,141954,110785,83366,17715,46317,105763,66298,147013,41086,94180,16478,220447,44611,730,19722,78975,117889,125643,26254,16574,18480,65006,15806,38549,246418,46052,36056,8440,34984,30170,3163,59800,4458,115442,4283,41970,33507,104078,1653,22,121158,276486,3655,6338,24048,133421,23641,2161,24422,36006,8086,10675,181474,12307,29514,59143,14729,52509,87128,122470,19446,80852,33314,24573,119864,14237,9652,57779,6612,51851,15284,98871,90581,124466,156831,21190,22015,71380,161906,87247,69201,18392,17908,108470,72962,40719,14338,17911,95260,43339,20610,78916,20710,72451,11315,31448,17263,58853,178878,48111,116002,45497,80506,82605,85880,36300,121755,25215,36118,301929,88728,405223,276136,553,34704,212438,49970,78329,922,20711,25036,257130,38295,145369,18128,15385,30829,55656,48345,8012,3561,28004,122041,192900,58338,112508,41085,29976,87040,47117,23905,4336,92061,138880,97407,42083,172121,6256,25192,172671,5,93568,1420,12677,31605,56743,40620,6015,78415,231077,31298,80026,13902,19048,24924,170586,32955,176119,87859,36731,6773,27711,24658,26475,115216,133207,93250,95820,88522,8317,5714,124047,55219,86860,19677,23961,22928,162209,8904,225992,359835,56084,96201,29392,96558,86071,93643,55114,13347,8183,95129,82012,2017,123336,34219,115554,157159,47747,101684,41008,18735,193781,104151,226906,7552,179874,124113,31159,21162,44010,14771,51268,166128,31382,73124,77438,92830,205709,12113,1292,38937,13114,1334,2118,15597,69581,14449,21934,76618,48728,67038,14967,51495,24243,87736,147249,26720,11119,46063,43749,5843,44147,152629,133428,65703,14269,45604,57982,28672,55616,45957,8438,95433,37698,220862,132034,39456,61870,4161,26501,73560,56418,9845,4654,20916,10456,88920,119358,9015,65931,96507,48029,38534,21676,109081,43078,34943,25089,6131,28766,23665,5477,10255,16695,67,45778,42443,42770,29534,23733,100513,62617,42630,48746,14191,43753,50295,26007,8792,57243,43119,54725,164253,58250,112304,131796,25165,4651,3188,24831,47748,3705,19540,13211,102095,5593,18699,23666,32005,117571,33541,60584,74573,86311,99443,25172,27222,168938,7143,11853,53560,18834,19960,86522,28217,53266,117700,72989,34323,18721,66450,34346,74056,47217,202002,46269,9429,68582,75458,37823,82843,96652,32549,145144,27958,19820,158086,31955,201406,135379,31207,192545,12950,51704,9094,248263,76147,64028,110009,79407,89345,99284,223492,47966,26848,15359,201137,2861,110507,71231,72297,31851,118777,71039,151051,240855,16333,50766,14727,7939,4149,80908,418780,88378,59276,1327,7284,38576,79814,65820,42199,84860,49574,62596,12396,70598,40117,8648,7994,16836,7630,14047,359699,106878,525,29037,28064,13380,11675,50669,74216,103539,180314,27449,56299,172344,19274,7301,246099,32043,19422,36506,129317,6806,30140,4614,46639,66926,932,86600,6322,27847,233103,10541,39025,34887,3517,12972,26220,2031,66561,115015,48658,47596,12714,33845,3893,16165,35237,89983,14769,11962,147224,47018,29977,27979,5552,82338,86023,131368,1218,24853,237840,132193,15455,40873,3668,65351,53388,15229,59889,272245,47934,11858,34347,18038,90853,86981,300602,19343,114181,29362,84921,6095,106059,79472,38015,1206,48741,6208,8e4,21916,17423,6002,108083,24479,34931,56661,9511,26995,100694,163853,35997,81254,58321,18919,171890,86877,91341,74503,70477,53412,7027,59281,39892,131302,5864,15947,61301,67466,162369,47956,27874,35624,282324,21270,111847,102548,41482,30955,116737,28264,8592,55458,22301,75090,29821,30697,51709,3041,19208,8038,24634,30467,87509,126428,19389,18814,152686,20701,83474,45832,80891,105808,11378,153223,120770,98186,150633,49838,9141,12755,30962,5260,74490,21256,31678,65062,33326,289838,187831,20595,89768,2805,58535,10844,70085,12090,2451,138068,98544,24461,4511,6754,41684,28203,3383,65355,82833,30161,83924,234361,128424,28921,222594,33975,125491,34069,11508,67464,144226,41850,98703,34371,7901,21254,38398,65651,23549,53883,213340,123269,12028,71764,177701,28758,2623,68395,11549,15232,68603,9660,63116,36079,57093,31198,20475,48467,89984,35619,186847,107469,31389,43631,73867,41949,68841,114250,1605,30564,63403,17588,27680,99533,12641,70325,50428,73426,78379,11855,91651,72081,91720,60198,15743,12065,83398,140046,6761,46598,45900,5068,886,62448,148968,37347,19405,9680,15819,43496,63370,75667,163700,37639,3633,22774,34341,183131,134335,37200,23915,7054,14194,12970,26438,13350,285521,25594,8219,104410,91039,168804,138480,149734,15907,33818,61132,60082,4622,110187,56736,13551,73571,3945,73463,65498,17758,263266,17593,2710,27585,54469,38200,45367,63754,28881,3473,12791,98287,31895,65787,4463,94536,24951,36332,59901,28803,52130,86403,7668,181822,74831,18977,9850,177206,145485,109798,7292,31421,26280,77211,58511,12507,127004,11113,147,8729,56208,43066,79926,129937,31345,83947,39915,46146,98763,42566,1337,13192,18323,105163,80570,117753,16555,72883,11077,159438,40764,70933,83329,26066,12276,72059,21655,173836,126713,69454,153482,91585,70644,102558,110483,6764,127864,190133,3961,101798,20945,71138,82402,90884,69669,44753,923,16939,59700,164258,25969,27082,31399,43846,6306,246093,51342,6153,151581,202801,182731,56475,162188,89426,141356,14355,121815,27536,28023,65257,77523,106668,127314,24947,12790,38796,169698,23555,10725,44573,183083,42088,62716,43265,105958,32050,44067,50118,1668,3874,6243,318411,16599,1691,94999,52378,28671,216728,123258,2059,34969,69225,5913,136280,171443,141515,91662,22175,135282,80020,92270,1663,4808,4482,3495,34691,5226,109830,108512,17342,107488,11606,123190,100247,29666,146527,113014,15794,30894,13224,39585,243192,22351,9903,7836,47699,11078,25468,122291,48821,26780,122679,75521,81450,630,4895,92900,55074,74293,17441,3563,111657,103102,51613,12318,52370,36191,68245,34269,40445,41354,122901,168604,182500,62012,42557,11259,24428,115113,86345,12362,3909,78430,86852,134602,20459,47853,93879,22577,7659,3688,38555,13349,17381,56715,91639,12493,10895,92438,3142,37057,28928,2004,36427,32268,34222,209974,10432,67436,41989,173518,107930,27079,62729,30908,55558,5828,45031,14902,53546,8204,144263,60255,14520,88212,86582,109589,69356,8064,47449,8505,66558,16886,4844,52817,111260,215129,12941,91118,650,20770,6273,73089,40618,62790,2873,35002,14023,97208,19386,102646,36993,143736,135457,35385,113601,17893,32627,84439,100619,56016,6581,57264,172160,45452,111710,203627,70131,24100,322787,1996,35665,70078,22358,90922,83658,4097,63200,58499,14542,99153,52159,6615,12414,63415,31986,16823,1579,65405,137809,8841,16898,48082,259,33014,42375,12260,179850,73667,91389,98882,29532,17311,326251,41092,5928,20742,44964,48019,43505,9317,49265,6643,192712,48424,163487,19861,20113,70848,31928,105333,23685,78563,14638,54755,7158,24142,44018,20774,125255,20331,24280,10163,1285,2336,39851,4299,117269,46714,63816,87779,159624,11731,9971,990,137317,108831,50994,74554,162680,23640,131597,146962,170620,34829,91205,21184,1913,63616,18427,93136,156592,17519,67565,115882,138220,78622,88535,18115,2711,33554,109492,54298,971,24914,25863,36363,45715,27099,194995,14299,178181,111488,72395,322385,157719,130787,11897,81843,83999,11369,49280,118604,40922,61332,110343,53407,75639,40582,300440,54722,25637,13694,48248,48278,194521,56203,52779,48783,72627,10953,376,16733,280238,26351,230789,15132,25168,137270,3588,63704,73376,94031,74284,19443,159557,9697,39901,13351,119050,15406,146455,3460,29556,75195,37673,102524,92329,47289,98413,15311,100684,56345,7116,95480,11590,7200,167,23610,58426,17730,136656,27944,53151,2701,8824,103124,3017,90744,113588,53216,79736,65940,26931,498,29568,80540,143543,21292,1740,59268,16561,180816,42323,50174,40890,52866,10703,57169,4700,17191,4424,93511,49698,166650,26972,48631,165169,82879,69326,202970,4007,2376,231325,139592,22119,62851,37504,68816,58345,67398,186643,43331,277416,53749,15746,23102,17432,4793,151138,48822,54265,48203,198688,14305,54287,2291,18018,113378,123260,7180,97549,87027,120085,2920,76080,8190,102005,5641,64580,14955,59802,54028,58884,19367,81779,412567,85957,97053,103637,78871,29364,27637,141728,4767,30686,112738,130146,42745,12730,105040,14844,232,210944,36581,152317,135543,29744,3129,55647,58149,46319,27265,17499,28005,59948,7170,34138,5702,293047,110892,408,91760,218674,18469,46095,81403,14389,4610,35672,73060,11006,74848,104820,118143,190357,20043,105358,141735,5115,27093,45924,123073,52599,29433,9616,238350,78610,24851,58858,26769,31969,24613,18294,4982,32735,39639,143563,112073,202205,12567,4873,88601,44897,81503,101648,81362,34662,85277,17574,48173,21435,221188,40215,39576,80786,26544,64668,81841,10731,37733,247986,149188,127703,495,18382,54388,72446,43071,30974,198723,89608,41360,190,33045,8386,31658,19992,237838,119015,137622,50890,100913,6460,116233,267230,26621,104129,65114,14190,41542,14888,85962,23342,23041,26453,43725,71809,45186,4770,46452,53894,56616,221286,18973,9038,109299,55365,19366,26863,18808,60909,69353,41738,83463,12100,68561,72860,3980,13796,49340,12332,31311,27418,4255,53430,18976,45523,510,14224,30477,26581,4530,3651,101663,139840,22709,150861,31996,63923,120623,262522,3076,10528,2929,14672,130238,18087,9816,121894,100308,25085,55111,14565,18952,53293,2042,369988,23674,61789,133529,28783,108293,35477,47119,36448,71049,40015,33055,78598,198442,1833,159937,40654,77444,189245,113153,8621,18599,38553,35223,166072,2375,11659,21786,89523,6032,12116,63046,159398,18454,3678,32521,47626,11411,103527,38896,42946,15696,26370,10185,8413,37080,165583,4331,63555,14907,72220,50056,6623,62236,36565,49783,10049,17503,100581,55951,146244,24724,9626,17969,25524,109300,173965,99994,101056,46459,43647,53737,277968,8347,123521,74858,33829,44762,77574,877,81377,222525,123532,30602,43881,53145,2973,16284,81940,61281,127044,63620,9875,14756,114829,19032,9202,52759,119141,23928,120551,19607,3599,33401,76821,73233,117430,39968,36539,7071,5446,121735,194059,15206,45283,6706,15603,65615,1207,165723,92275,34773,104447,8396,32353,205240,164323,13600,60555,79205,25532,22907,33410,57480,107111,69630,32137,47832,70913,33161,20321,2371,117348,10714,86246,1625,11763,17900,268,78457,99175,97940,101092,86660,32221,14041,128504,125080,53744,124263,31017,13897,403,31859,21964,5633,111630,5547,77329,17961,18241,84995,25984,12983,67491,62168,47262,5241,297,51191,7351,8967,147212,82060,16821,782,11033,82431,62957,5026,43459,77963,203477,53528,6247,191852,87774,74164,215654,13467,1522,219964,28589,244104,16242,117821,67725,72570,156792,17186,15979,26990,44128,193014,35276,57125,16212,166451,68017,6905,77608,16364,53777,75921,76426,37975,26203,269296,64099,84122,12077,38533,830,4407,20139,963,43028,38902,42911,37503,83343,85045,16979,1165,60835,137387,58380,86990,110066,134540,56331,193845,81238,17922,163093,38744,110641,12502,56404,34862,26865,125964,12965,111648,25547,7771,27196,136980,9555,29551,107158,57885,18831,37705,35505,101742,13970,102109,62548,124657,23328,11124,89592,146376,248050,6241,22033,18337,80685,29898,11908,216623,67721,106162,146610,21377,15085,91552,42041,62560,122532,125336,102365,121537,142559,29693,223919,11515,110495,18776,22494,5895,185059,103592,229351,51220,100102,37027,257855,29359,54123,36066,106493,12244,79258,32002,432,56205,94836,90182,6726,14762,29391,48938,26864,38083,60364,3310,60192,14766,205567,57504,110760,22649,24666,46333,21517,3430,13135,28873,27052,158809,11597,20529,6695,23138,22960,37137,45574,6545,305877,43423,26153,24769,59844,14501,10430,134352,56169,13213,103432,49523,35181,13435,12408,129475,64620,230854,77390,51990,15653,83248,33466,44571,117828,51481,2187,10559,68019,18021,54895,48247,18354,33737,4554,108595,37288,39767,116707,9175,3726,108877,21616,83684,49862,1938,8543,276466,20134,108498,48770,102254,31914,131520,185291,100559,51890,209,19526,76471,50544,71814,99351,8172,198526,28816,20419,9109,98389,136777,76479,75596,30635,165417,48216,120220,25955,211071,39314,24308,32164,2559,146280,43403,9233,17947,90585,1786,86920,125662,2457,64741,32152,32918,122882,78538,44001,31723,56426,23375,103172,88177,145697,52506,49319,68016,31664,41488,18486,110400,7030,28241,986,109199,19900,42147,56864,65287,49183,7858,24e3,30453,840,16673,25907,68916,89927,6309,158335,36407,199737,130464,13137,59603,201778,195292,21015,42466,179062,172561,89492,11075,180407,31868,72493,20998,60217,9865,19530,39274,130266,54539,21623,12535,13505,40641,73375,4087,85633,2153,3117,70680,55788,92096,47509,98493,37490,271936,151475,3032,16171,96642,34106,78425,125761,19591,3366,19316,54508,24183,50786,194248,91528,33253,34622,108355,41741,705,3814,3883,108929,13203,67831,10142,59754,68208,29128,84820,56880,38794,24972,48571,40821,40476,18137,164254,24064,236309,79181,11282,395,39169,2013,51587,28551,9645,701,109513,115899,113566,12762,62045,58322,103726,41343,40866,244102,143816,2490,70346,40973,52618,15412,30720,104315,38917,42027,93676,17513,107418,20706,123890,13399,97727,24044,87962,65606,44250,98044,65276,74790,101473,19350,91570,1326,87790,172042,7577,100813,86896,85891,41512,108130,27794,14875,71431,12835,156250,58135,3759,22476,42176,115873,34686,56523,73643,108505,51491,20838,12721,32863,45700,29496,13700,34294,55360,29206,155942,123812,7706,163234,203,132720,49358,144431,8130,175788,35818,3270,76832,25710,54095,97274,28779,94621,74396,19092,128242,58067,20885,14670,93255,15107,63291,23654,126900,129421,59294,262659,9798,3251,67344,28600,44629,50672,29072,26999,31526,23183,49175,165843,175455,17282,175411,32022,45989,30298,90690,78118,83156,23749,35636,31317,7069,80381,94561,133756,14960,97404,6138,41065,78041,32843,16601,34123,9559,146529,123377,96395,54441,42012,84257,123541,10745,22139,106459,11720,150883,172651,154996,110538,4728,53447,25704,2009,71152,119354,21166,66604,1429,216162,8637,122250,63520,27180,29172,36124,276428,107787,77184,4680,14952,104903,24418,14793,51561,52931,8371,26342,48526,7118,92066,67280,40653,8847,34597,105438,14198,50163,61188,146286,50315,41205,170829,161496,585,197359,95056,1687,365794,91349,48507,5804,49263,5146,104902,96365,117343,132222,46084,96919,16875,8073,262381,79982,52663,13928,16056,153908,15145,109256,132308,18763,24904,167644,13618,40750,18686,147124,114709,150038,52849,2938,12568,48617,8778,5459,44202,44591,74914,17183,248689,13878,7822,80060,23116,194037,18487,2067,7798,43077,33678,244028,31320,74273,2794,19466,8218,36280,183997,48124,19416,29656,19280,98734,7715,18311,30701,133602,150307,126956,7378,2933,79903,13178,12593,86571,26604,92446,13574,44205,65699,427599,21118,8245,14407,27877,47936,33542,7916,26460,117762,21596,37818,2249,127359,209394,60044,47677,308089,36791,154971,31417,6998,150042,174360,12255,43009,29335,48739,3912,101398,53340,2580,146939,151295,45360,125275,15273,45383,27456,48761,23314,8750,60801,85823,104759,27894,123685,66968,39480,26917,55290,83305,2696,98390,57569,145853,340733,4919,20024,52268,30884,7413,203685,70989,112855,4129,50536,349518,68205,332641,159581,135361,236026,37563,176404,64899,6578,122033,63871,1850,85234,82089,66124,74145,121098,107351,12687,36881,117334,13136,14698,85933,93866,18047,32620,310,15094,46e3,88451,23632,36645,27940,87618,80520,58892,20976,27702,140090,96075,67841,103292,238964,87778,107338,17019,83427,67522,7302,8261,47570,116787,8730,80484,61772,174422,56005,131193,52875,14588,28471,59817,9586,15720,158155,51307,109734,15196,11025,59331,3884,52626,102602,84797,25158,27314,4437,20488,76214,189248,35023,114952,157376,2827,62439,102878,129749,36405,10329,109339,108633,36662,1254,13267,5470,87105,58004,15397,10434,159667,21864,52022,179464,3013,32147,31496,116832,18494,105502,129227,107267,50033,13481,9954,24267,22141,16257,116154,36185,950,115685,11305,176708,2048,178671,112573,287867,162328,497663,95170,50979,193861,50987,30368,136257,31830,46549,15119,169876,23788,17462,249887,57377,1949,35448,14791,43769,210091,3783,34612,282103,88380,245190,5457,20491,98908,11402,86899,117916,16028,162584,60644,320177,156096,31065,55876,22e3,77655,9992,23397,13757,317623,63978,215255,2443,17648,93231,27388,104529,93807,55505,140477,12046,112040,70887,40152,94365,112353,25063,114679,266061,71248,119555,15589,2244,617,14129,211431,70110,100652,7777,4383,85911,89221,21010,120615,58357,86405,37554,41647,18,15143,69662,60491,14714,186134,148344,42347,5410,168175,44535,42449,343894,129417,99682,20659,27272,140483,63455,222159,17536,13722,42637,62324,11976,114691,148109,2283,32057,182393,4295,147364,33705,2075,44303,30274,28331,63740,69740,29148,10346,44862,33716,73937,153333,12930,38784,247159,2515,41053,20256,83368,256189,54639,115240,5096,24661,175419,153552,26516,141,138176,63885,34115,47222,55709,2765,28479,38875,236608,12229,22921,77291,54426,45388,2860,57787,114579,295139,105782,17826,71066,19119,54364,69385,16568,12323,28057,33346,34919,124763,155533,101386,31644,8627,49001,303600,29868,63213,9103,77280,71333,9696,138789,37059,24823,5057,21352,32368,114208,56803,19424,10445,58514,8661,209508,26187,171838,10460,63454,14016,122504,41328,21329,46618,32493,38225,7855,31763,7945,29876,8734,6438,24205,97490,139977,130740,47323,33195,85390,57194,13813,60600,21313,96251,7699,27584,170521,139271,1363,4402,336738,129223,84983,69150,13147,3590,163929,207225,155260,55916,20288,4503,8398,98490,11773,27512,37113,84976,86558,28365,11756,116005,182148,13733,115313,47644,67208,85069,9347,14995,226141,14704,101835,41159,35314,13113,63526,214039,29978,50446,83339,17440,129441,72522,118641,97816,24907,73844,15717,118884,167255,96509,162793,30847,36849,51297,78974,77793,10427,1873,2972,9999,35074,28190,64297,146836,46298,60038,163007,108919,61219,2403,75022,127339,4233,110389,69022,9833,128097,88016,79390,222936,22570,94657,28462,56956,38803,81536,30474,152794,19566,16481,147408,74574,81895,20731,1918,1366,76367,187321,54494,24366,21690,61696,33283,107477,77499,31112,414383,74362,18463,218441,120929,59848,258629,201924,69269,454,19989,13054,59894,3623,58908,20681,35723,78523,102680,38988,184112,108087,50944,132704,52966,21699,18860,96349,201411,82697,85395,95658,5093,6427,177894,44191,32755,26961,155739,6249,31310,81030,26574,84311,120155,86730,113535,7424,48888,13516,45747,98098,20077,183995,81945,43210,26704,40420,75831,45648,11180,6855,57927,65528,124096,34851,2598,156633,107572,127352,38169,123845,60142,62722,105584,232364,23211,68120,1601,22169,89299,747,258039,80572,7258,152249,11862,101204,8834,121434,33761,19175,133142,46343,40178,48723,3589,41977,30210,38868,62257,10087,82658,87827,90646,16415,47552,351723,28298,72225,91146,272760,1701,11295,1652,109651,300747,51863,198800,29446,11794,32345,37538,22356,33102,37590,113544,37970,11478,179743,25454,103417,59905,221970,105196,145604,7817,164809,102360,16974,75840,255333,56902,6659,1954,645,59400,67769,7689,18675,5215,13793,20536,27852,3387,29523,259718,16860,94625,43143,29245,15848,233581,22685,63631,78557,22836,133302,84513,1348,51826,47129,98836,58284,1830,1749,94642,10933,6145,12506,10975,13879,103781,144434,10268,28409,32346,52968,121567,107374,77268,23686,35097,10501,155275,15303,47136,21102,168741,55332,90385,15996,84817,681,137803,25054,142275,6163,38175,8056,124296,240642,65621,4934,178205,16101,62803,60964,18230,100622,76465,44689,14545,9543,47514,16852,93380,28048,12047,107106,37575,101485,77047,57326,34819,96137,76916,6469,46264,115983,75768,87668,69942,13027,165,8373,114231,26434,52844,42799,182044,23580,146254,38081,43236,33883,146220,382894,14606,46035,36481,166621,35417,95382,2957,59384,60428,36358,66343,75378,22267,22950,83528,17577,56474,25285,4619,179691,75355,95836,53295,34588,171410,4487,14679,84208,44015,18562,109133,54101,11531,86052,174479,303157,28095,9953,35642,14564,39802,16145,77606,117406,53038,121117,53624,22062,1212,7632,127157,237292,189087,10478,127345,102515,181997,86752,87623,10966,121602,68783,68681,83042,114380,138349,191305,67176,50085,39016,1427,42384,1412,67118,122616,72389,25260,2237,13576,137346,19938,20304,2191,68759,5373,61364,238507,75814,23931,69565,38993,131741,38364,12528,87762,5679,129853,5310,186831,32653,90338,260176,389531,108118,26843,43985,50175,30563,25106,56965,18130,140428,4542,165503,117991,24219,229605,1819,129663,1240,3797,76093,18398,71339,51919,93043,27175,47060,216257,6483,35051,1217,16512,80798,129064,13225,69339,8548,237079,72298,2575,34280,51379,117910,55671,53345,247552,29486,39328,140821,34681,57045,60177,5004,90269,78522,2479,322607,48474,61296,13057,31558,4678,59271,6699,27044,31988,35944,12503,83480,4389,136508,3781,114121,70279,4488,155829,42214,2898,68191,75695,305850,45041,74344,106509,30087,17429,93292,12477,290,23080,114802,35714,18751,26554,105424,17775,2144,2412,100610,65192,113975,52975,180272,135050,129815,76238,106483,21440,63186,4260,46189,9711,28249,4169,23429,23390,8324,141585,63809,67668,38457,38063,39226,59972,1189,203916,62368,14403,16949,61767,85801,1739,40147,35049,76757,33124,62102,15780,103593,103009,53484,22952,67973,114645,6566,5245,50462,7601,8288,3513,194571,80276,1908,54592,5124,58571,2513,6800,273997,193904,1119,17991,117245,2508,129156,82366,26278,71465,63341,56943,39662,106116,94966,156875,9736,2204,122308,94418,27134,1280,24539,49022,45314,3764,50904,46424,30699,28087,293839,9400,33646,40165,822,147499,50263,116179,29085,11863,31314,5578,17797,5104,12454,1604,15342,219206,10232,67800,94261,25872,13565,90339,78971,75377,26649,41184,47695,11514,35369,20767,14227,41953,309396,148270,147938,33074,14453,27499,109019,39018,25738,240196,158931,52820,8612,95853,21524,137010,84901,70869,70021,116794,48404,38771,6732,1070,70990,187297,49140,5238,576,3564,253975,16027,16483,2811,37775,19034,25259,4053,2e3,70083,95774,19713,33431,92703,91314,42381,288770,48194,95985,3991,77418,13406,241328,245086,56533,35275,62725,9246,51924,70181,95331,16163,31410,79016,39312,120878,119371,275987,80124,27712,9186,220,23598,146167,85209,68238,282190,57048,31273,30555,80913,17594,75779,59160,135002,101219,189377,29225,96735,60126,62522,104e3,27620,86814,17240,147533,11001,5425,43682,410,49460,87270,69480,46315,59448,1816,76201,9431,11788,87960,29063,65539,47347,11678,33846,7008,196704,9895,6753,8633,120892,59970,572824,115934,6646,202559,892,48351,37611,251282,57823,67263,57750,26527,34485,90747,7685,88370,6144,64182,1709,41969,21458,62327,181657,49247,225330,122600,114574,107124,85361,111833,63243,71420,15655,191178,72430,18063,51425,54002,12364,53225,86557,18193,97580,41232,138398,67821,128724,8944,233212,101353,52099,42127,14006,120107,32789,32132,3498,18123,33758,56058,5779,128760,59888,98869,18445,84702,51911,13234,218379,20093,39031,8074,70195,20708,23462,24355,131384,60189,26390,10403,41060,7140,10781,49410,42261,87202,82566,41663,43105,60276,2768,5733,74176,28329,2297,145430,131632,83615,122915,105441,655,224102,5284,136426,67763,16294,188511,32538,61049,27893,3394,13951,159099,28542,17930,145360,9492,190122,32285,78855,26440,13570,58648,73908,4239,124561,2444,74172,53131,11468,10794,73566,11623,35343,64710,30481,4163,10328,38309,29901,10538,154377,76132,92405,24839,11679,3465,13449,11637,7824,2337,57754,1260,14458,41118,19878,38661,13416,159180,37074,163164,54137,28627,52134,184900,8520,40385,29546,30502,22386,66527,107458,6850,24022,47983,30603,35083,8934,304066,39500,9,28261,33026,77251,9374,44833,116312,34990,29236,63563,125639,135405,165398,159055,55690,88141,69643,236964,31983,25572,20436,36746,60896,31850,16179,11828,5888,3043,66368,9750,31167,7915,53111,36430,1333,64344,93659,20061,60596,180191,51630,6792,30244,43509,101058,22409,420,44210,109783,43223,27030,72477,72831,32679,29235,7675,47556,12258,39907,149412,84926,118247,24692,71717,105038,86009,45941,41189,89453,29856,52543,30627,226798,67303,59230,67415,34408,1367,99685,16867,128419,52147,4111,125381,117881,16173,44093,102224,31575,23234,24870,83790,127407,239098,3200,994,1255,100903,242275,117266,55116,38205,16140,29662,11307,40414,208793,123355,56470,4862,75600,30119,58218,70828,24075,26974,7802,192353,4851,5475,78720,66596,3409,28573,64396,30381,30690,59859,88256,5406,99945,103064,34463,37727,24238,86643,60088,4057,23741,5967,162904,38240,28356,93858,25510,122879,6897,3278,7057,11971,4400,35461,211413,21395,59615,39471,87233,55795,128426,3051,22470,41950,14705,3974,180108,80476,78442,204996,91987,15634,67610,139015,142373,35611,51134,10387,4353,153456,57749,181039,14183,68447,151532,21107,36452,20551,3186,46247,46383,129666,88736,140662,146243,2066,8360,7978,64818,106963,17896,47801,10723,114821,223295,74192,3293,3393,16987,74064,11277,91622,4270,29828,27951,387869,103235,1374,61988,120083,477,145892,128378,11779,211263,61354,18221,17869,46530,83061,108538,157981,90608,67199,95080,49064,195814,12302,66307,10348,231346,160732,112859,63633,146558,21271,31037,198802,47622,12862,95710,3910,77850,73961,85585,34752,61e3,4082,24595,103679,71107,8208,79568,150019,16615,24961,139857,32664,197366,4559,54735,32696,4126,162019,75698,13916,70108,159638,19834,9349,24675,175560,49643,18206,52459,27992,10809,88865,401975,133172,29e3,34558,30915,3658,25834,42430,36562,125265,18182,10155,40149,97082,208980,19575,60853,90529,66545,9600,789,46420,2317,88593,55595,98980,115302,5742,169155,1073,177901,3472,11189,63711,78643,65472,50459,127979,93,42202,67053,21720,157650,11145,141378,42033,22824,85705,79114,35584,15974,1510,54172,28562,12451,104226,19190,97151,73024,20948,5151,81741,21499,29006,84183,198074,54003,45120,170125,26240,35177,28389,64863,79974,60778,176915,232183,45342,2038,80253,41564,40703,32689,5430,100689,5366,23007,134279,14266,26712,73993,24934,64242,52113,102887,61801,46415,201049,54251,62133,122757,164883,30815,139966,2319,30842,766,13362,10287,134518,86111,81665,82440,28333,43019,18963,8804,161944,23439,102144,101145,80029,39052,248708,30350,117340,11878,128467,974,138625,63961,5237,74778,61834,67040,43814,13690,65947,33809,232476,115258,181745,28824,94013,9510,10246,93722,81976,7217,114383,3493,16014,69045,72692,12145,80981,9507,6692,1620,60820,330444,35474,33962,4797,7053,295463,46445,27026,12491,77988,49524,35675,90947,29114,166705,101385,133782,32704,6186,84595,176031,185623,45966,151302,63069,1699,107491,947,15458,74452,196212,6046,10498,12163,10239,35191,243951,9277,9090,29539,54460,22820,26514,112549,60372,51753,48756,21812,70861,260326,41,44222,10441,16961,48148,138771,216194,5914,52153,53400,212036,56519,26245,10117,45888,15294,138019,90913,26368,43842,42111,23348,6082,194845,161089,156206,51546,11647,30759,302912,262094,8635,78876,26535,35283,54183,31183,85484,147873,12989,5197,6356,72894,65347,20150,27370,73787,1493,45918,12366,190217,20724,13858,10981,67449,81213,7553,14115,72242,271517,11842,48310,88743,143726,22177,3290,243231,58452,62937,12592,1654,40066,33477,13751,9921,128442,15868,7106,75236,83773,10775,36938,10482,170465,17368,17469,161508,32752,98340,800,19824,264456,3901,87319,2867,26782,9630,113102,185815,24197,44584,86366,40224,3636,140916,31731,267731,9567,53678,72984,29389,27963,17106,50282,284911,60170,8322,12608,23374,89652,5268,39044,229766,8869,151350,31436,177342,12269,183212,120418,116270,2843,78888,69192,7865,184099,1086,129897,18383,70508,20242,18508,229924,124569,35749,50589,55626,9884,83115,40971,30671,18135,14452,38861,17844,201826,5549,26413,17189,13561,38539,10679,143331,3314,36785,171194,49685,187713,67506,4618,104039,17060,195080,50648,33159,19238,67559,134840,28599,157523,17130,38064,117398,94355,31918,13575,34538,40326,13997,3494,348283,62481,26862,3603,104426,244363,153709,112487,304612,199674,41239,35545,54869,293005,28223,26277,26899,4533,18518,15492,38587,80488,70485,160395,263,60162,11382,222152,4696,250751,51921,182609,10707,48463,46243,1227,49111,111564,46502,33342,56846,68541,63559,858,139927,16654,229375,76759,26478,33205,95828,23399,92945,2637,35630,28470,143992,50214,14174,21456,166191,65665,1711,21594,78019,97599,111701,36,147151,110246,189022,43021,30397,40757,131935,42065,73335,48039,26596,28984,15102,2361,7421,202167,69744,43766,52826,3642,83304,33873,75140,63169,192389,36551,92748,13039,123959,233220,21738,84447,77230,20228,187852,19095,25799,92136,108774,29237,53947,2299,118106,2687,8830,42331,202924,33667,2023,73763,30704,19363,19779,16737,35629,48081,24068,101013,162338,291912,13749,24745,328289,167679,70086,48299,23306,16732,17801,43322,54589,3586,63653,43624,53474,925,109177,251316,43805,13082,19511,86565,142182,92461,17117,101033,103319,64589,4022,4351,235897,5352,82705,107142,46391,156084,5860,61365,10558,13045,7717,18357,33922,12590,33065,6928,46993,783,46937,67846,8952,26295,6107,119656,18799,17458,50747,4229,179559,112727,118080,20683,41464,125468,51560,49749,44231,7359,35339,62988,136487,67015,5208,29150,24956,105186,48858,6143,18097,6972,16404,73489,58742,97196,36357,164616,5834,32267,13746,147733,15113,132091,34127,106298,39729,106426,22294,9780,15602,36213,71502,42808,66802,599,60755,5851,39120,67363,108623,126368,72770,91263,32486,30596,151717,7951,52002,43103,11768,68942,40901,39344,24037,127500,116890,48403,16926,86750,17745,48648,159545,34460,58419,5634,114317,67865,31462,23352,24010,98185,125708,69686,68337,13610,26271,70691,2980,4768,27225,102402,75453,28106,8104,6931,1176,6274,6475,112635,22498,6176,238686,26832,28893,90319,14441,15682,15087,39517,45270,109134,104440,45965,47645,81772,7876,52683,87720,12898,4505,185665,2769,113401,15664,57592,105229,137381,97059,119268,6876,43309,33886,128363,35476,144249,67013,143587,83367,25703,91436,59347,53236,2289,16519,19844,46309,58558,99834,23313,218816,231303,36388,51333,183535,109792,139277,54306,90139,18235,8275,32710,37677,82464,86025,92204,88842,117723,37570,128723,234242,76350,73795,34896,148247,58424,11105,11744,45746,63372,17118,49772,199520,81902,38004,22911,33752,3125,1995,53792,4689,26909,108150,146062,69674,41811,161444,84855,8999,28561,16731,93937,3189,21967,24890,22943,1356,145300,51569,28802,517,118679,31703,40607,48098,108854,25003,10233,73969,177495,5248,24516,215347,146192,48712,60626,69188,40735,5866,586,101541,6509,47590,52129,5969,222045,110933,25733,24223,65339,62812,2414,155418,35819,16022,78423,43138,20995,128255,240673,46745,236093,72176,57085,97841,61248,107,36068,193177,105427,55726,215229,20446,47228,100420,87091,14429,121708,23605,21157,187721,21880,2997,203976,99166,95068,25877,7724,98925,83401,4829,13182,18229,13718,239662,38653,116505,153497,30589,89029,38962,181302,43853,78872,180301,4786,248240,7401,106136,112590,77745,19731,60880,77789,125748,135487,5975,48627,34084,12419,215770,47557,254582,10364,106495,21856,67539,88981,38805,21428,48732,42316,12149,16078,52808,25327,51322,33850,51147,12253,122354,46077,56483,254553,115417,81834,150991,94662,86668,7381,12841,100650,18218,15741,22372,68294,50705,15535,84660,61887,22553,72299,31361,24824,17743,46820,64288,31582,77006,111674,116384,30760,80920,86149,77192,51979,79691,60342,122805,103800,240873,160744,233114,78962,54920,8608,3484,316104,72548,24337,5088,230040,21926,10172,36838,26,86221,83458,102176,12062,17571,41929,41170,28428,68239,41750,103930,2634,18313,53019,34825,97837,63115,24606,73157,152474,14715,91439,37033,109806,140259,30668,174760,380,135597,95673,136073,65073,134249,13829,17279,122305,4420,46444,10237,64848,203623,70728,10349,182885,65075,24519,25783,40318,34139,22222,63394,55266,102764,41422,20126,65100,90408,53640,35128,48932,11192,38935,96839,34782,39492,19396,41332,6250,5511,19492,51304,25936,104466,54099,73771,86115,5080,7669,30891,111700,13931,25276,72289,135447,14820,258641,25265,31005,281179,75286,393,95359,14623,13584,6680,101227,80173,44933,76666,54542,13244,39348,458,25379,109451,134348,81143,6959,65554,12027,51311,8716,57589,140731,28467,23316,17272,30458,25980,55229,77197,83798,28302,114784,7428,34548,26241,14712,39336,103304,18928,54080,12870,334,87722,15208,16895,142098,114262,39820,83913,57817,28682,7721,14900,108672,11250,62246,42849,415188,1724,26555,24549,25505,26443,107450,145899,61035,43528,6901,60726,65906,267741,21338,147590,42079,18924,73017,135236,15393,5206,4026,84185,1531,5988,113890,82647,303391,7386,69844,71611,189865,76523,31877,13315,19314,198575,32821,1928,67641,25913,104475,103489,3297,70391,18406,15446,113347,19295,93790,27856,1792,167471,116449,8541,4408,41757,63233,25765,86680,64501,27034,24816,34975,6079,4486,49693,36229,16917,21581,62426,27862,11612,54284,35702,194034,355,24277,48262,87411,70504,310164,118018,12516,47559,43502,57433,107139,9290,66533,80863,14634,34312,91725,28606,21342,67241,72355,43244,375789,37402,174015,105070,8342,44167,67494,1890,16365,11723,271002,1865,47918,8350,45564,27742,25110,125803,8553,49504,81925,62211,4534,15491,19011,80373,206920,667,102405,128623,245524,5553,113309,192739,65766,19567,22832,261958,29679,21293,71134,20962,105123,24721,860,21752,33448,18372,157167,94822,35770,173224,232737,75729,28937,46828,28062,25453,5207,140366,36665,30652,6169,67920,150458,92040,23186,184604,92330,20891,176492,49427,27828,38305,42495,143982,49560,25503,90043,29747,65328,47830,12932,11068,77721,9003,25213,94205,140426,46090,89945,138173,192691,33329,112232,129905,35709,27514,1841,19957,31411,127476,53572,17497,173549,55063,175135,19841,69314,5192,237921,117660,150697,4060,273045,50414,98940,65348,153665,164423,58804,156695,48994,213928,86036,28608,8355,39574,34540,16927,135680,18374,151587,10830,53805,16878,16623,4282,48030,8537,14986,46102,13062,72897,72,33050,108227,39451,45935,651,113320,40535,95176,57450,48843,5003,19019,10407,211163,3848,1068,4988,32091,30095,41692,15099,43602,107434,50744,7627,171349,16313,150832,352665,207750,33937,38256,51091,156e3,87889,90663,84175,24908,114900,50365,31494,83829,5398,169342,47521,54818,18935,8356,43094,41212,174536,10082,92550,6678,60614,23355,69721,14796,34149,128830,58187,3179,208,40325,28399,225029,401412,51150,31580,207268,6657,10993,69818,64282,289845,23308,12961,38447,6681,52944,31855,2572,47646,120728,179148,37240,45196,218274,4816,3695,21961,50084,35209,18073,51452,27004,6100,33941,1377,84831,171214,85,141510,9078,99227,32610,6417,11718,49868,65579,87902,73018,49062,46280,61742,21512,40862,107733,15941,29168,157765,144919,14487,5767,158014,140070,7241,573,71584,16921,223566,40331,179473,35081,47926,140885,41508,52104,59180,42310,32811,29048,123517,102413,80208,10104,14746,12649,153641,126022,37965,113017,4171,83,142592,2809,6362,50416,71323,116894,260776,16204,1524,5760,30351,12658,20703,54403,36083,45408,74772,4946,14485,50759,111222,10890,2195,167147,92962,130534,16283,177256,35016,15472,210156,151187,73922,117691,43250,52051,37392,24811,24358,30830,5775,818,21969,1476,127322,151783,58392,31021,106913,65215,89407,90802,28531,11690,20234,95249,44602,37256,18707,11928,5161,4410,26571,51903,49768,22008,25252,65780,209499,68769,203726,13249,137363,48845,86823,6658,5674,31881,1083,1823,108676,34518,166752,13791,14287,91576,91429,8665,11529,26401,16191,91972,30964,5254,28486,54697,79613,66520,18447,22870,45203,194466,22822,51703,12278,76716,44595,73455,33546,12235,144843,36154,51247,11116,33040,3180,225753,60864,1972,28469,12891,28879,10338,144157,56294,353058,38302,41447,87532,110616,27065,168438,6557,1213,50804,144643,24817,2390,136531,38174,247513,16190,4059,122791,131994,137430,39506,57650,16305,5188,54309,106128,20628,88071,67394,395446,250285,66176,91254,1399,114196,43915,60230,44853,27206,106353,43013,18733,345105,226453,51202,16607,57106,117175,35492,10476,89598,127439,15187,39624,13688,61570,10615,31111,59370,6238,175252,32143,224492,41388,95408,34384,148238,78307,38959,9340,160091,61443,15737,11216,41244,170,38299,102443,113097,26382,14027,33707,3957,76300,66160,19431,18900,6952,1717,108656,82206,188021,257335,27295,43999,41210,31777,46956,57457,12657,11489,15697,48060,204748,53583,82422,284790,30503,137341,8120,19615,220311,15991,10217,63424,9808,67431,70976,98221,4491,15177,28535,144789,751,13230,2394,1504,33977,132104,30316,22230,931,97193,185240,24826,22687,174322,15307,22988,1390,188745,180325,29580,59068,74903,18994,29195,79,15436,7622,38462,11566,138710,44828,45774,37768,99236,68137,84083,19282,22698,17134,74807,126662,173497,46248,16938,119735,3212,28292,213652,49013,9975,32180,45660,86250,4801,68788,95490,77482,113751,11994,44624,94452,46839,128497,100316,5798,58588,73184,202987,65417,37790,88524,1606,43156,97964,105717,34947,11203,100060,37742,130074,93653,107799,94311,196106,41347,8035,10780,16390,27883,118236,167395,1979,25006,19375,31628,18916,144723,78502,114047,103107,86492,107686,5844,20934,206963,23556,22591,16562,146333,20167,10471,117434,33085,2863,9740,36669,41849,37271,22790,18209,28979,8231,12952,54408,21731,25130,45208,55748,138120,75826,414,29593,9925,292865,25999,683,123149,7036,92159,86055,61827,103680,23176,54918,58466,57578,13305,5709,86479,16697,31064,17660,200919,10770,49793,33423,32370,52047,16488,62555,6459,8426,83493,7763,59725,82812,18628,67760,79405,68557,9612,7673,28102,56517,69620,171797,32458,29541,15870,81109,32080,207644,71495,21202,11039,91036,61230,2810,130800,32260,4613,60590,37112,75214,33979,126402,155062,30642,63875,12810,194463,82799,47664,16725,36685,43367,61099,449,172150,102867,21691,301838,36745,7130,18671,57316,34852,38034,54182,35578,65900,99486,19771,3456,2658,16914,99866,28390,28109,8262,21147,34353,20006,4228,137085,1675,203023,283196,198286,214375,163329,290603,152574,40471,83506,30068,14730,23177,131539,34759,27668,32178,71896,104799,116305,85430,119262,42860,25160,8911,23428,49437,105322,6519,16203,6349,74711,1230,38045,8540,75165,44736,25909,51026,317034,4984,32281,91312,27060,44431,17817,45363,155937,239085,35697,59784,91993,29531,126740,213757,76560,167776,285273,24262,8237,65030,41160,74437,48804,118916,13159,37842,1031,75349,1478,11655,108777,23435,277425,101734,67469,70231,124711,43532,28514,65526,54956,1e3,21882,17728,25302,40952,52214,149632,1999,2111,3259,63362,89961,220561,39777,26335,9063,10572,12416,34551,34623,38604,24723,5947,15588,69927,66252,119177,69173,46629,28714,70715,212408,20521,406913,74380,11716,50659,50862,37009,88460,130101,7210,53853,538,65120,151950,55806,163748,52837,13153,21100,16674,64536,6091,138201,44837,58547,3723,163,2177,32288,85454,34033,8497,14282,25742,10535,10741,79559,117493,243787,49337,100718,79495,40139,42956,7551,55433,15421,31509,23034,45081,547,61176,53434,328001,8470,36263,30145,4519,74173,53935,11845,73774,60211,78025,3,4102,73782,109293,315332,48412,26683,13714,6865,20128,18490,104141,325,39470,171970,115860,15707,7268,73301,74336,31370,2368,111827,107757,136231,142844,97138,96638,84053,38691,23801,1588,10573,122098,77039,240,186135,146101,11996,18143,112963,46171,155836,348769,47795,121213,116266,132515,3344,144804,31286,99187,255838,129694,35894,48779,55235,148582,71967,65282,15174,13920,47080,6147,108242,157593,125025,7136,1286,28957,127956,28402,98813,20805,7532,109417,40610,5041,32958,15142,18408,108596,33543,50517,27748,80114,233434,91447,487,37094,100048,30541,43477,10639,89862,155868,37667,8726,60684,237903,73408,99589,12190,38739,97348,3914,13594,2680,149016,13907,30171,28343,23530,115225,61104,35821,147679,14337,4297,244282,24085,326976,56428,7851,21303,131620,71446,83253,68692,111870,5224,15813,38197,49026,45057,13660,3306,76345,40671,27905,91072,996,68527,62085,91351,122634,55109,168209,2024,27560,112707,17352,8306,167115,169921,166958,5031,46020,11844,67284,19130,76185,6920,32849,5450,14610,22451,21002,17392,31872,66682,84796,13709,40210,59898,12029,8719,53564,21462,91884,21647,88379,194428,12754,37797,132826,160016,22567,54383,53186,77611,31107,8339,4694,19185,90355,23597,17222,140675,28442,23668,55977,9128,61555,28774,155229,17658,9390,24379,69357,15752,127381,239631,62460,93181,55913,45133,140155,18676,25249,33164,29581,82837,67223,22362,29975,7317,52813,1943,29613,20012,207130,49617,49651,5636,15334,36313,29226,28084,95247,72072,19e3,224932,15811,114,32127,38097,37508,88507,37225,27359,91626,12193,69279,20608,11055,88156,92808,2152,57259,55275,72789,24475,104414,1708,9882,3818,48661,66897,1631,34806,227930,85815,87753,18321,250664,72733,25107,206797,50891,8082,196411,92596,96764,152823,65514,22819,387277,62176,51225,40329,15563,189,3659,73670,64357,51793,275136,33482,86653,74615,67058,11318,125720,15388,22388,8267,1730,102663,170910,40784,7144,85373,13040,7088,94309,583,44224,140424,77439,18496,164026,36578,4722,9151,5824,63365,26510,35199,40500,79277,32495,44614,35233,9566,203293,152144,7097,2330,183480,98629,13423,330887,44130,68600,30939,97829,31012,345465,56747,94879,4939,160027,149761,99423,46099,32251,15332,8761,96094,128555,5763,235318,222223,55729,30241,55420,201746,3987,81382,8259,49325,23287,7719,24633,251100,92311,18591,110533,64759,170260,393860,7175,21144,132887,3593,75346,101277,91109,16387,259187,11627,57459,173829,44694,55780,49797,89192,120443,62622,3904,14814,23887,1027,112258,64955,99800,11132,66353,36202,48624,18158,88481,96882,43059,11040,2455,7077,21651,181159,99126,100434,61388,68186,19161,110468,120052,8819,55324,41494,7014,37689,3618,87729,92615,207943,9823,128657,12587,15857,6379,67628,51216,71775,157617,63244,1503,3864,218754,110864,5769,21492,7243,1192,87921,85529,31512,18537,42698,35350,73510,84474,34301,8991,21013,35034,566,38832,19838,35586,37216,39413,55006,12178,59742,856,84563,6900,25632,17437,49786,30723,13847,70845,4044,7843,23944,235976,55530,48942,6518,20939,73769,192653,52936,95207,23895,132542,142982,22632,87452,48042,54018,178468,10728,26230,23559,363,81269,142012,5718,346258,31456,84333,246476,51018,66692,101804,120570,39962,30373,70593,2864,60541,19425,54209,104092,7201,31545,48018,25865,15442,46257,40443,8328,6451,111782,47527,97754,33046,470,245116,31095,39,91934,87208,73470,36708,36521,12801,70624,36272,8892,79768,12427,55454,103756,5908,52390,62962,22720,141138,94634,41689,128402,126390,6628,106394,35527,134394,82727,254651,194502,148064,89549,3202,28359,957,21954,27906,49840,142747,8307,24206,48978,1186,71728,133038,71474,91306,6333,110959,74600,70387,18983,62609,56057,22970,1147,135850,1321,28834,3578,59715,102227,32827,81415,99952,55636,257598,390,22702,35701,85872,402916,39216,189795,14929,19467,10112,144422,61514,5279,63421,134686,41436,8424,51925,10598,132295,124416,4604,194739,210929,57866,31829,51626,50007,9976,91878,61906,56168,81906,60918,61859,40017,23059,16887,40927,62064,12785,32893,32913,21782,93965,20169,44387,79084,38463,11457,93950,27127,157050,2697,337088,5116,54128,48255,33279,8821,27352,25515,124022,65710,28906,38557,33390,1722,104435,72215,38551,12094,30978,25113,6671,37355,175109,42862,98024,65406,221276,59624,118012,64637,78760,86697,21426,1639,40350,12584,67193,84144,31396,7863,143011,69629,63112,9454,28666,65798,46372,134721,6314,51402,30837,151922,2847,38676,38008,92823,136245,17540,5504,109295,205242,37606,5211,214892,1586,20670,208711,137743,19328,40652,16995,20023,14657,154919,34422,12996,13918,38221,47690,16398,2959,37680,89122,6721,198469,91876,172043,83898,101992,26084,94570,3635,76958,22853,76497,38266,176590,168403,44464,142840,79180,184594,1984,41806,83147,11985,6546,366068,59732,24533,271505,8736,39084,222992,93429,28962,58985,86665,8432,30028,14548,32439,54424,165029,55175,27458,69046,121277,46168,33732,20661,24581,135574,123110,37556,79260,72611,16957,12939,46162,58238,44907,72936,253758,41324,32518,96480,11949,124438,65280,43256,34107,53533,43531,37037,28366,45970,32741,173438,6121,194202,62969,26355,30314,58370,28455,1848,50519,82830,90393,21761,295490,10936,256940,133568,44050,20269,4089,27457,21610,219460,36743,14821,101388,52005,13124,30979,140816,167362,26054,18458,60789,34917,40447,26606,33422,9066,3452,83614,5761,20263,137238,25038,91310,101,52322,74548,42572,38084,214054,186568,31802,17665,30620,141936,37730,14420,4265,187218,49640,188208,51441,55388,96452,66659,40869,42039,60967,221027,19234,178581,29105,96050,9165,196118,157335,3738,40354,117436,2965,34136,59659,15570,50843,230035,31444,71260,43886,18316,5387,38500,168508,17406,32174,8828,103373,143806,90367,3560,18719,122310,16508,26719,2541,105429,6645,37998,73190,10591,235916,49737,87112,233941,53188,32193,79154,4544,52905,126477,7580,63501,57314,3216,31337,6541,103083,60846,49,9756,15481,1355,43840,14319,13743,27486,10222,73114,230718,418644,16706,6674,279748,23058,45273,295831,86306,2743,5535,88773,21829,35253,120938,31153,3169,16839,42847,8751,80974,33942,36867,35514,16485,26474,77775,56877,5391,48346,3882,108713,31403,27804,55248,26235,43821,136104,40118,175507,28034,203908,18732,1788,34030,106427,36958,54359,7251,44936,15356,69139,455,157915,22173,140291,50348,43275,82066,49621,54952,15216,36226,96695,66855,6936,1987,8227,196087,4631,68827,99004,47541,110265,17953,147605,110242,58520,31312,38724,329975,642,3155,34497,75937,6207,73843,6120,17249,51429,117746,3218,910,68961,319671,14938,29555,34700,1649,66673,72268,9655,76800,153087,6941,210168,27130,35398,1780,73242,3135,56689,19556,165307,8765,35967,121458,13333,70453,17350,117253,22265,13340,44265,39869,441,3742,135025,23581,33309,16543,17731,13291,157637,283005,21408,101360,63887,52312,83873,5338,233779,23759,186949,34531,177320,38069,156465,91004,19353,59852,68160,14891,1338,1072,29823,1950,28901,81407,313445,73038,84807,162348,240257,37162,138934,16111,58013,41253,102951,16457,96056,19541,56402,67217,41638,94381,89674,29481,37456,80815,151579,13937,13683,132537,19699,134545,67020,29816,222341,141235,427578,48868,129557,233342,23077,87871,16213,18728,16184,9469,37913,19680,2798,171356,178328,13216,50049,72690,71904,124644,55455,7504,29052,41036,266546,19899,30391,188755,8659,59469,16,104298,112943,53865,76203,138226,68857,139953,14125,107625,119795,173133,4398,50273,48808,54390,16466,122086,31835,67035,50971,48859,7508,46427,66477,73021,84615,39985,83076,46779,201569,53336,36443,60865,168164,143810,51393,25548,169307,32896,24485,38424,21837,29087,275813,51674,6714,64883,46169,187369,55186,76192,12852,12018,62134,31067,118303,16542,12125,10579,4928,26291,43854,7091,10946,253716,109062,39283,17261,113012,258512,47764,125126,32646,55892,80279,201623,149872,3192,385,1208,48750,5376,58738,22335,5427,82416,47811,32435,143086,38930,94128,59975,156037,37977,38224,62485,7698,50405,71027,16462,21559,136153,34131,107506,162069,63703,3101,215029,40407,4178,3774,9187,80019,17880,97926,67579,2600,18405,8351,47924,86638,70820,92206,86453,29610,42241,119200,3198,15466,67813,57863,35454,4779,99518,4649,104641,144269,33730,38073,65864,6838,109456,193298,154007,5623,45741,30846,182578,25573,157224,1543,58575,138703,146140,44971,49356,18275,59064,20300,13122,11848,24453,11973,9797,86843,2919,25530,49210,1130,161220,76788,75373,85604,34926,36014,17777,17255,51533,11676,92226,51845,119859,21525,5936,18507,28050,1140,31418,14857,34207,47859,10750,36382,32079,106909,59426,87757,38393,110042,15965,97104,33757,35344,97993,53979,33651,45407,41884,82515,173089,7177,58371,35365,47543,51927,35587,10670,23544,29306,84233,39976,76076,62097,9007,8668,28119,78281,120790,19835,143020,54968,18670,64959,20649,34469,42570,33001,136570,87796,120044,1106,58700,63951,127623,12805,83057,40212,31773,49850,7361,54336,347524,101314,23751,19569,48791,29174,49369,20467,7465,75842,38281,623,112457,60210,28849,51003,94720,6426,90047,85560,43761,3579,85105,34607,90410,118528,7224,42907,111163,18168,6960,161135,191298,5247,100584,127552,171568,20121,91173,12636,54615,20199,63730,98105,2396,40387,14438,125012,4765,33235,12865,45299,37728,82098,77872,114037,59253,19675,24838,398016,102561,11446,17069,57508,178277,65836,99941,26114,2585,271882,136866,50126,11027,155648,118367,14585,8910,123015,335383,40434,41016,53021,14439,87098,176860,201543,121888,2358,9286,5739,22666,54270,37884,169381,33984,93859,16124,89364,72207,51639,76366,99029,65812,2198,12147,174891,194289,6986,30252,88822,21284,11445,288337,160821,33034,100869,43852,25761,52882,1144,103809,1924,84458,86079,43411,13542,139276,18141,34978,41298,7276,26481,173800,33210,17951,142652,33616,33677,2210,19941,98568,2486,192414,80136,12058,235883,50963,249638,29572,27221,47034,6124,72107,63346,97620,158513,299699,40388,23235,37176,224244,198386,121323,67992,23827,63170,17838,106622,158590,26807,5345,23489,91891,55474,74834,37981,13058,5977,72552,34706,26828,145172,19904,21367,34043,960,77092,91381,4733,47446,7680,41697,5170,16960,14741,46101,13656,473,51842,37433,11103,11551,121951,13191,97536,165932,50397,51628,129028,9069,44885,6590,59195,47045,32940,225472,90345,21833,13303,29407,96615,141951,5198,6028,18395,7181,3861,14966,156358,167182,36529,55253,25942,173153,30959,27261,50691,150176,162201,38467,48462,80602,42163,118482,168,108756,26011,17166,54149,456538,22512,91374,13816,90358,131615,18132,226707,1824,28139,26860,42253,93877,77351,65575,8980,80574,22020,27948,40422,91324,76376,13528,39281,91685,82215,122541,144066,1983,193851,17283,26320,2739,194978,4790,26845,42627,61300,65815,174612,55133,4200,191130,79771,158321,52280,166796,221620,62461,11278,4067,88152,83409,31717,121367,13522,47325,37945,10406,174348,249321,154101,64912,29938,51775,17220,15776,166138,78890,84425,54121,42861,16368,24572,291647,10197,32073,22651,11677,97509,26952,35787,18424,41910,71614,94977,72318,41594,70024,275419,37702,60199,7335,39107,61315,18271,18394,33768,87884,104277,123724,7277,56288,71981,189803,49320,3352,6798,14240,8954,69220,94433,57372,28620,68863,193727,85575,42309,41667,67689,42081,22543,44824,12719,28540,114236,101553,27638,27296,4300,5353,4663,19379,94098,3758,95888,95144,80344,87320,28447,259518,12718,71391,152731,37063,24132,31911,104896,15672,103782,1521,4945,72541,23717,122632,15619,87175,206120,29428,189780,61416,28350,44457,972,1175,47233,198738,95789,41907,21953,97034,59341,22864,53713,16873,32971,20693,20954,31336,21477,16169,38370,16412,9019,3841,24599,21938,17085,6484,81198,76413,5849,72514,12320,65247,276175,37234,59796,52642,16312,57349,198507,94148,46134,18958,125552,1747,18725,151873,14901,5490,68287,29470,3689,64794,40814,26018,25692,54450,2703,88278,124886,173087,174e3,24159,179477,24276,46004,201876,209202,445,52876,31948,30206,157610,39180,18439,44124,50469,5774,96278,222758,200216,50290,45486,20435,46986,46276,140133,142326,15569,13363,47522,92583,2182,7135,16853,22998,30272,4952,63263,35623,39096,53789,44864,20053,110392,124213,4630,16087,28221,127787,25839,77481,44693,13464,113146,6983,27069,55717,50102,4760,7107,26186,66507,59145,36032,104182,71328,29425,64317,50781,47465,94298,69706,74899,22754,120756,25108,93077,56834,73286,39928,16218,41699,176763,7555,70819,50083,26895,23315,26014,16773,123079,41712,5719,31516,90427,158540,85051,183128,40864,27505,55392,9058,45224,96857,30901,136622,96557,56304,120061,11501,151448,5773,89743,7769,86069,2935,18471,41628,10114,33660,110170,49479,26745,92846,33221,26731,18795,87076,8550,2100,29972,120289,3077,72490,33784,2630,208722,50861,63483,79029,6419,39467,14302,45286,64207,9686,67513,44170,1050,77246,59266,17055,53801,7150,11111,42432,4278,94579,362117,36175,42902,41933,39002,98489,22913,74161,84773,57036,17556,162288,74485,178760,93867,73635,128860,50362,261,67455,80001,46080,35662,4368,25247,19230,74393,22588,1822,27682,235324,13798,85998,13194,235067,23514,71669,147632,23191,134748,214683,105101,1518,25489,247114,7380,54842,26922,3971,26361,20844,68642,170517,77339,123255,8963,77818,150998,48466,36806,2732,23261,11741,236162,18243,126216,28690,50546,16385,92760,197383,246558,201295,88255,67588,71687,176076,172653,169058,33906,63747,24835,157621,43338,30050,46152,132741,2770,51371,94835,6614,15112,11749,56936,1250,19027,399017,58036,100215,23388,55815,308768,124152,94803,9521,64186,8971,28,30427,62163,7616,103838,35079,29203,131235,7743,17389,10882,37420,61460,228512,85363,41581,131077,62822,119647,10130,54445,26925,19968,29016,24446,74028,24176,61448,67185,9254,8563,119129,9771,99184,37716,39514,10532,221512,258753,218630,55980,23394,32141,61924,66749,32411,3741,36475,26678,77010,44946,91203,128749,116953,20476,49625,53116,13735,102335,29376,51946,83407,67892,59212,34685,21083,1546,112982,32972,74397,1078,190545,16082,86140,58591,89611,101531,10061,105104,76319,20035,17551,52611,169061,190842,100780,23907,90413,115619,9675,34710,193435,49443,129734,11183,258877,16318,136182,126808,44635,27304,192375,2599,125648,47051,12091,23814,721,58800,40137,66726,97930,60877,74487,7942,54326,9841,41428,13762,8211,85383,6950,99177,79806,201786,296464,124087,13144,29741,41721,47634,55088,254286,106408,17041,99064,12942,64086,45233,14005,2612,55827,255,7984,13980,38574,12776,46654,73499,249951,2101,26676,25996,132326,116415,119062,50449,31033,23038,11589,179252,20007,14860,129270,21143,17796,144715,60106,70758,69842,34674,282133,44014,16774,57268,38528,24053,46373,201667,28327,471023,51889,102667,21193,114909,84132,69317,96723,67969,16134,68145,15058,28765,32035,2524,101089,98664,25045,76571,14957,86040,118506,262428,154764,81573,39681,283900,73287,127825,544,80448,52347,38512,175971,15180,45467,33086,46552,48894,81107,43213,36672,54025,76703,8053,7608,13299,56619,20752,238099,54164,105133,1444,32942,953,37564,8e3,66316,119463,106817,404,13667,149108,128597,31267,10269,49836,106150,1484,52330,76965,160486,171648,38456,31263,22424,37738,66245,67467,143369,60471,75610,20895,115528,86070,60854,40796,49347,18989,15030,11371,37578,15779,79867,10187,86462,46402,155626,93200,40229,7090,57547,108053,99598,11088,47505,41218,206017,2173,20988,30219,22919,80563,57566,42369,93141,41675,2407,182519,120495,27154,16702,29456,14349,7958,16688,117177,140375,42467,261919,74916,153569,10836,34742,49526,7621,105997,12212,2270,392377,7755,17959,25086,232152,138791,33847,13860,35316,5811,1344,71259,50452,207539,92635,50359,5821,33674,30255,2086,2587,96264,17543,42,6029,9580,43007,139248,82831,12917,29607,25786,51467,42137,85161,100698,31561,88989,121990,278500,3602,109344,37982,15279,116442,28936,30880,87894,58079,128661,126731,67392,28051,146885,4861,16216,97344,42827,147561,153948,22684,21335,47685,1853,43349,15185,59642,10229,25520,187921,108972,5579,98037,24945,6697,19193,63734,137934,75056,89740,19767,224268,56138,63643,151661,39313,70618,84031,89723,84074,13703,85626,35460,8867,64845,3439,57906,99776,63968,49270,81130,34356,16210,23547,36446,34090,140028,72439,2221,22163,57058,363492,113754,18913,95451,48663,54464,54037,176097,68425,3023,34906,29482,117389,341780,80431,58330,16753,92616,60907,94846,147486,4498,48646,7773,46801,7778,18946,464978,47558,33223,177444,7328,15626,63337,94700,11743,9351,255024,39098,16447,42647,96230,39769,58840,10068,63439,35800,65843,58823,413844,9156,51258,7434,61791,85018,6872,3692,28096,7121,33024,6009,75532,31997,192535,9661,3304,9547,14753,31987,25314,55689,15896,20430,39472,31340,99744,25398,115569,54883,28719,205423,23071,57855,64638,149867,25671,82403,37616,20668,39989,77996,74948,140555,175248,64810,36515,46595,4958,248773,24045,28728,136673,168704,20804,114833,100325,27135,21205,96151,153134,45992,7093,13992,76047,1980,19432,145001,75159,87462,17710,1013,45556,34297,144882,20648,26061,11319,129567,108555,18872,464580,33386,22717,65948,167189,5603,135042,79542,8801,202632,18114,91882,5973,5239,67315,4431,60916,47819,71693,32597,32606,18183,45072,80329,76385,24749,51305,40314,156514,14693,130345,13168,66214,18029,12858,34801,27628,14544,10823,40522,40185,33739,148694,23548,9923,61012,28859,17933,19442,34364,99849,164107,141167,30629,21054,6744,36491,8096,42474,41706,155060,30650,10600,163442,1143,96655,61390,52359,7559,51568,64256,203854,4467,22453,14504,436398,7878,6980,8293,63610,293747,16167,35763,19627,147603,15419,18032,110744,51346,33681,54571,40472,48615,39073,21604,13754,173027,92560,11083,47299,63062,11813,52007,29883,9734,139722,15953,1550,20651,13616,49306,16113,90089,92326,7584,30712,72424,164858,6831,152871,55746,197721,34167,196442,6022,112107,55215,7538,123381,4920,43539,77165,8939,50392,34192,20225,79762,22505,58667,40770,29788,97180,82835,4568,8579,13273,363569,35898,49983,436,36598,3237,131691,62418,35591,8101,4073,379438,65218,76072,33887,2968,27573,212619,288680,68278,72851,150504,217896,6913,121339,22017,35340,51072,43616,75043,31437,10833,81487,4364,22968,41454,106687,85446,19863,109625,149241,524,141850,214404,54376,657,237023,9401,108137,53800,32474,49712,53334,126876,27337,45552,177696,8269,15036,12097,42240,2328,125374,119295,99715,2500,19624,39441,27220,102691,60957,94543,39101,18566,67362,13975,78230,25017,34017,239007,90027,39351,41681,35354,43822,1043,916,58587,141983,94818,38799,75459,41114,67432,16195,36606,59568,22272,126769,31424,68659,12287,134302,257977,5756,207285,95637,47248,117689,19583,77451,22373,12200,54993,117118,34244,29386,34562,53819,71267,64172,77665,49368,7716,59301,25749,45426,194789,17297,2650,1766,32501,45198,20403,20984,6600,14171,94604,19037,5402,29896,9938,59935,109708,88081,145182,44844,39167,352626,164173,35374,45982,6122,154,73419,220487,53834,53601,17992,8609,229321,5610,68098,66815,71012,95069,140968,27396,8957,134489,24656,86659,56598,134852,17316,123838,255436,6613,41610,138033,81452,32023,32396,123687,63398,8693,29712,30407,19296,121188,3551,36099,20032,111948,56624,16547,27453,35916,15378,52039,56849,13489,22214,73177,53097,277349,2157,14029,187886,10260,141743,246460,91880,50869,3788,49486,133566,54950,33120,129337,53768,18333,9525,26902,312251,10297,9020,70759,16647,112432,59260,84609,9818,82766,73569,468,46001,75780,55028,52106,11498,43645,108069,17150,17753,29417,16705,31799,9606,289,122254,115975,8620,6133,255357,56908,14456,133464,43554,79224,11247,29630,160,12756,25464,65960,350428,62521,321796,100359,67358,35169,46172,113128,48988,88868,31094,33266,6847,60887,98188,49659,69117,92977,220228,13947,80181,35103,62170,97351,13475,2440,199768,19498,36597,46971,25234,67806,62881,84717,73648,181966,10488,94149,21550,26655,63436,48375,14405,165650,9621,24439,28043,42735,4490,29963,56674,45373,1934,262446,50855,67098,26898,5261,52696,40644,33900,9440,180286,87162,22940,19704,26936,69769,10254,101759,27406,12243,48e3,73926,113215,54935,5726,192787,4312,106216,9366,11550,52949,23457,212271,277152,133895,108374,6191,96477,29980,218916,58024,54696,40853,91124,65894,91170,65908,252552,6793,29212,15389,44516,122515,52617,35058,9017,103536,39510,49136,19242,130652,662077,74699,47024,31422,8517,73351,24399,13867,128360,4810,4434,61779,111983,61036,17798,110240,59722,102960,39688,10001,23803,23039,176498,56659,44814,134295,17188,77577,74466,226175,102472,154333,63900,111747,18062,41171,79669,32773,408933,42562,28931,30907,107388,43487,2946,240310,23938,24354,319,184983,7927,6488,1422,10790,68809,68209,64775,4361,202,17123,59634,51200,44391,18188,17843,2619,74278,3230,9540,47187,21702,36274,56894,43907,16310,34790,16866,6150,5561,13587,107545,108873,126867,86986,28640,33427,19017,5762,80637,17430,46903,2047,131055,25958,13558,5444,47152,13900,44563,122857,45348,70863,39593,54332,38068,33637,318,40310,143467,18502,24520,11377,62013,28942,27246,28269,83545,17999,59015,90707,30065,15161,34720,1263,37008,2012,6060,98575,92933,5721,299,199555,24578,29223,2985,743,115825,109523,136657,47454,26378,53586,3733,174945,93340,244456,5693,37386,28782,89767,27545,23573,18798,136425,34320,84778,20041,48453,38215,7477,71958,40621,8773,5874,187927,105965,51100,43533,18083,8443,10180,43597,2003,183999,69689,12216,129696,146188,62389,34044,68410,12765,43273,26949,266807,3345,34477,79197,5688,47539,213110,21634,22257,50092,32222,42346,39530,63668,98,134978,74022,5152,59088,174145,37220,9934,9545,118937,5724,87240,19875,15784,40143,23263,87513,181654,285152,37881,263241,4966,43934,10433,186657,6470,74416,225854,25908,142677,246262,32280,6192,75890,45546,143264,135305,29742,47013,77787,11732,126658,8763,37950,21806,57557,113464,89465,108995,164574,23894,22996,23169,15369,23117,17642,130607,40503,36239,280990,44666,9981,40427,147487,26869,168452,32886,32991,46798,240839,15111,70502,65697,88548,44145,28701,48767,31139,206777,35659,181164,166262,14554,171445,31786,66523,76607,17956,6507,31279,90476,116611,167918,6560,1243,115324,80128,41867,55897,187323,37069,32596,189444,145931,13390,105530,65709,26805,6999,55714,41300,22915,68951,22138,21120,22264,10058,19945,33635,56123,99085,10032,5818,6016,46649,57476,35264,94413,112522,262288,93686,83038,14341,23204,28807,66084,77987,6101,126673,7133,38126,5923,122091,170240,97772,46874,215746,43948,41622,3272,55596,8332,146411,251315,13533,8561,81521,115449,48616,175175,2063,186556,3036,134537,75772,29728,82360,22973,186559,86348,89100,38388,82297,45610,2613,87082,9986,177812,57884,23591,47485,42543,33582,44713,74439,257444,252451,31825,35631,38540,33066,5147,13973,4343,51830,70378,22827,26448,95560,36896,241741,48067,203953,298860,61620,20450,3220,67272,6586,107662,100160,108684,6929,57226,4762,7457,1320,40404,77204,99309,62750,208653,59977,44e3,74315,34332,5819,172217,64904,114077,18147,84012,1791,98456,90930,21446,116669,103938,7422,85140,59713,5768,326211,16239,75411,13229,29398,10758,236107,1539,112472,95979,152154,151294,306,21196,38146,10700,6891,84282,109646,56492,40539,6589,119491,51354,30685,140209,136906,29622,73617,49553,70525,51671,166869,139616,74395,37439,49595,45678,11959,33211,86560,52434,9282,62690,112155,130810,5243,108261,99970,265613,72551,80049,6391,33365,90721,66737,69872,87011,1860,9032,112544,60905,37371,89015,140351,19076,850,373531,2802,36725,218795,72062,28990,16550,24614,7815,6187,26336,33373,32162,42791,73555,32062,23386,10244,56392,49442,27076,136262,12412,14883,1134,33675,97153,199281,15608,100152,74072,47942,254301,36451,16026,10687,65067,56708,254030,30290,50490,13864,57941,259331,35588,23485,43486,24869,21620,92971,22072,88645,1048,182050,13343,32452,14825,19509,3325,216938,45740,99716,189082,53740,78245,25609,24311,176777,47340,308354,40669,66085,14102,125339,9225,128709,97207,1271,200933,78439,113451,88975,18324,46521,11819,18570,141756,72512,170020,52754,63550,118515,103073,93330,32736,50499,14722,31600,68452,398867,29316,172786,18417,104924,2606,5670,84818,16288,67106,59580,82929,607401,291,85829,359,15897,35830,50696,65630,52672,22115,356968,29895,40837,231192,34024,38957,26722,406,23335,124952,72068,68804,13268,147101,164740,276569,162596,66943,11569,26654,66358,4777,23229,102127,5848,978,2921,59666,5371,28212,90108,42938,39320,2499,4271,108792,33510,125072,71653,65239,38250,66357,38577,13964,86251,35708,50755,36010,29448,12209,3844,38222,206337,100876,67827,137088,14167,252225,84163,195270,1306,5703,54198,779,46802,22028,51124,86759,70560,113164,35685,162145,45471,34561,422,2611,6464,47486,19223,38246,9191,18331,89942,243642,212364,15893,17518,22617,6409,30046,126182,59716,36560,104428,18846,26592,19458,50793,147333,30826,1388,27647,10922,14495,33545,19269,135828,39727,41601,46931,233379,49169,131130,182112,16276,82381,118209,142445,128310,19672,28740,82907,33436,3118,102206,28723,24819,41937,38854,5157,3881,111491,1142,9776,421673,152241,29309,14961,87854,6054,15424,3796,82656,54996,2108,55367,239450,154525,9643,118103,106041,64601,68549,48707,30266,25772,18740,9462,229669,91798,112152,191327,14493,72828,8175,66636,236474,25817,87351,129027,76653,20422,22983,71240,27846,44661,12399,46158,77704,53101,35032,11072,17300,109294,33638,24408,1895,11241,760,17584,82479,125877,63150,141075,34259,23274,81698,15732,43577,48340,91584,14688,16379,24481,150280,96420,262050,48635,43727,61819,56268,72003,88178,17281,79912,13218,122519,125295,166396,11811,2171,118930,67746,17636,178278,174656,95661,173039,83845,79689,17473,98555,127696,203415,54730,22925,232239,9309,12136,175026,20740,180188,10747,39816,314017,266131,10040,175732,112550,220651,31974,37393,888,23008,86799,4303,64905,148467,75337,251,3284,370102,50264,9835,5438,23655,4481,29851,329,12855,7162,64931,78141,12804,42372,296771,83547,18624,34874,86271,3360,48665,77735,88767,11463,63527,28889,22258,29140,194315,113924,25499,6406,31334,1845,4802,49184,43455,35469,127594,92970,61038,115005,38840,87761,106838,8811,20572,55637,11162,96721,132425,108925,2948,125457,36356,3502,75270,27622,127192,2561,123095,49394,61155,16897,110064,9699,89448,53356,19628,220310,21622,83036,9885,112214,6087,26713,17901,161912,91492,3440,68594,9266,92238,8087,6866,150194,72175,80701,13459,31836,43243,239700,95846,44749,50647,21945,230538,120612,132371,244604,5193,105637,34661,41341,68775,85393,1874,8771,33718,49672,77403,595452,99507,6490,58895,128742,7704,39239,73217,43816,62824,37804,199976,22361,80005,87514,94832,14089,4574,139975,59142,75523,100268,43906,53442,15152,2547,186002,17011,19513,204282,3343,60568,128318,119250,4298,51871,41336,71759,21921,45074,98169,145889,99427,11350,1237,5520,28799,7803,53702,21026,136352,38293,128690,12158,90132,44600,10184,26957,39459,126025,78904,82999,59373,39301,150198,120529,153042,20177,50089,14764,271571,30530,123161,38975,101562,22941,5648,124654,109243,69817,71675,49162,106884,21241,107795,30258,16572,188262,141456,7688,60718,8271,11044,32440,104608,103419,236109,93156,43293,128929,42107,67180,25201,115254,185488,130954,72813,167547,20537,39969,38432,22582,184022,1139,27199,5655,17767,97412,122606,209377,27070,35871,326617,188954,42680,73512,80911,22629,3011,95021,315242,157737,383,41821,41808,19335,27950,15674,25677,110950,35375,76835,59108,57370,35262,16569,160415,37706,78086,32041,49691,137143,9782,172080,50148,77917,6323,10110,69172,17711,21795,59511,76184,135114,31046,132319,59105,157578,20549,80778,57649,158421,65143,4575,72235,21899,10797,92745,34035,106079,80159,4508,78304,25350,75457,46458,32937,25623,47,8531,104751,84953,8138,36508,187199,66310,115274,13253,32461,38536,1916,42007,187160,35055,26325,84394,35963,94216,45590,97782],MAX_COMMON_PREFIX_LENGTH=15;class RoutingTableRefresh{log;peerRouting;routingTable;refreshInterval;refreshQueryTimeout;commonPrefixLengthRefreshedAt;refreshTimeoutId;constructor(E){const{peerRouting:ee,routingTable:te,refreshInterval:re,refreshQueryTimeout:ne,lan:ie}=E;this.log=logger$1(`libp2p:kad-dht:${ie?"lan":"wan"}:routing-table:refresh`),this.peerRouting=ee,this.routingTable=te,this.refreshInterval=re??TABLE_REFRESH_INTERVAL,this.refreshQueryTimeout=ne??TABLE_REFRESH_QUERY_TIMEOUT,this.commonPrefixLengthRefreshedAt=[],this.refreshTable=this.refreshTable.bind(this)}async start(){this.log(`refreshing routing table every ${this.refreshInterval}ms`),this.refreshTable(!0)}async stop(){this.refreshTimeoutId!=null&&clearTimeout(this.refreshTimeoutId)}refreshTable(E=!1){this.log("refreshing routing table");const ee=this._maxCommonPrefix(),te=this._getTrackedCommonPrefixLengthsForRefresh(ee);this.log(`max common prefix length ${ee}`),this.log(`tracked CPLs [ ${te.map(re=>re.toISOString()).join(", ")} ]`),Promise.all(te.map(async(re,ne)=>{try{if(await this._refreshCommonPrefixLength(ne,re,E),this._numPeersForCpl(ee)===0){const ie=Math.min(2*(ne+1),te.length-1);for(let se=ne+1;se<ie+1;se++)try{await this._refreshCommonPrefixLength(se,re,E)}catch(oe){this.log.error(oe)}}}catch(ie){this.log.error(ie)}})).catch(re=>{this.log.error(re)}).then(()=>{this.refreshTimeoutId=setTimeout(this.refreshTable,this.refreshInterval),this.refreshTimeoutId.unref!=null&&this.refreshTimeoutId.unref()}).catch(re=>{this.log.error(re)})}async _refreshCommonPrefixLength(E,ee,te){if(!te&&ee.getTime()>Date.now()-this.refreshInterval){this.log("not running refresh for cpl %s as time since last refresh not above interval",E);return}const re=await this._generateRandomPeerId(E);this.log("starting refreshing cpl %s with key %p (routing table size was %s)",E,re,this.routingTable.size);const ne=await length(this.peerRouting.getClosestPeers(re.toBytes(),{signal:AbortSignal.timeout(this.refreshQueryTimeout)}));this.log(`found ${ne} peers that were close to imaginary peer %p`,re),this.log("finished refreshing cpl %s with key %p (routing table size is now %s)",E,re,this.routingTable.size)}_getTrackedCommonPrefixLengthsForRefresh(E){E>MAX_COMMON_PREFIX_LENGTH&&(E=MAX_COMMON_PREFIX_LENGTH);const ee=[];for(let te=0;te<=E;te++)ee[te]=this.commonPrefixLengthRefreshedAt[te]??new Date;return ee}async _generateRandomPeerId(E){if(this.routingTable.kb==null)throw new Error("Routing table not started");const ee=randomBytes(2),te=(ee[1]<<8)+ee[0],re=await this._makePeerId(this.routingTable.kb.localNodeId,te,E);return peerIdFromBytes(re)}async _makePeerId(E,ee,te){if(te>MAX_COMMON_PREFIX_LENGTH)throw new Error(`Cannot generate peer ID for common prefix length greater than ${MAX_COMMON_PREFIX_LENGTH}`);const re=new DataView(E.buffer,E.byteOffset,E.byteLength).getUint16(0,!1)^32768>>te,ne=65535<<16-(te+1),ie=re&ne|ee&~ne,se=GENERATED_PREFIXES[ie],oe=new ArrayBuffer(34),ce=new DataView(oe,0,oe.byteLength);return ce.setUint8(0,sha256$3.code),ce.setUint8(1,32),ce.setUint32(2,se,!1),new Uint8Array(ce.buffer,ce.byteOffset,ce.byteLength)}_maxCommonPrefix(){let E=0;for(const ee of this._prefixLengths())ee>E&&(E=ee);return E}_numPeersForCpl(E){let ee=0;for(const te of this._prefixLengths())te===E&&ee++;return ee}*_prefixLengths(){if(this.routingTable.kb!=null)for(const{id:E}of this.routingTable.kb.toIterable()){const ee=xor(this.routingTable.kb.localNodeId,E);let te=0;for(const re of ee)if(re===0)te++;else break;yield te}}}const log$p=logger$1("libp2p:kad-dht:rpc:handlers:add-provider");class AddProviderHandler{providers;constructor(E){const{providers:ee}=E;this.providers=ee}async handle(E,ee){if(log$p("start"),ee.key==null||ee.key.length===0)throw new CodeError("Missing key","ERR_MISSING_KEY");let te;try{te=CID.decode(ee.key)}catch{throw new CodeError("Invalid CID","ERR_INVALID_CID")}(ee.providerPeers==null||ee.providerPeers.length===0)&&log$p.error("no providers found in message"),await Promise.all(ee.providerPeers.map(async re=>{if(!re.id.equals(E)){log$p("invalid provider peer %p from %p",re.id,E);return}if(re.multiaddrs.length<1){log$p("no valid addresses for provider %p. Ignore",E);return}log$p("received provider %p for %s (addrs %s)",E,te,re.multiaddrs.map(ne=>ne.toString())),await this.providers.addProvider(te,re.id)}))}}const log$o=logger$1("libp2p:kad-dht:rpc:handlers:find-node");class FindNodeHandler{peerRouting;lan;components;constructor(E,ee){const{peerRouting:te,lan:re}=ee;this.components=E,this.peerRouting=te,this.lan=!!re}async handle(E,ee){log$o("incoming request from %p for peers closer to %b",E,ee.key);let te=[];equals(this.components.peerId.toBytes(),ee.key)?te=[{id:this.components.peerId,multiaddrs:this.components.addressManager.getAddresses().map(ne=>ne.decapsulateCode(getProtocol("p2p").code)),protocols:[]}]:te=await this.peerRouting.getCloserPeersOffline(ee.key,E),te=te.map(this.lan?removePublicAddresses:removePrivateAddresses).filter(({multiaddrs:ne})=>ne.length);const re=new Message$3(ee.type,new Uint8Array(0),ee.clusterLevel);return te.length>0?re.closerPeers=te:log$o("could not find any peers closer to %b than %p",ee.key,E),re}}const log$n=logger$1("libp2p:kad-dht:rpc:handlers:get-providers");class GetProvidersHandler{components;peerRouting;providers;lan;constructor(E,ee){const{peerRouting:te,providers:re,lan:ne}=ee;this.components=E,this.peerRouting=te,this.providers=re,this.lan=!!ne}async handle(E,ee){let te;try{te=CID.decode(ee.key)}catch{throw new CodeError("Invalid CID","ERR_INVALID_CID")}log$n("%p asking for providers for %s",E,te);const[re,ne]=await Promise.all([this.providers.getProviders(te),this.peerRouting.getCloserPeersOffline(ee.key,E)]),ie=await this._getPeers(re),se=await this._getPeers(ne.map(({id:ce})=>ce)),oe=new Message$3(ee.type,ee.key,ee.clusterLevel);return ie.length>0&&(oe.providerPeers=ie),se.length>0&&(oe.closerPeers=se),log$n("got %s providers %s closerPeers",ie.length,se.length),oe}async _getAddresses(E){return[]}async _getPeers(E){const ee=[],te=this.lan?removePublicAddresses:removePrivateAddresses;for(const re of E)try{const ne=await this.components.peerStore.get(re),ie=te({id:re,multiaddrs:ne.addresses.map(({multiaddr:se})=>se),protocols:ne.protocols});ie.multiaddrs.length>0&&ee.push(ie)}catch(ne){if(ne.code!=="ERR_NOT_FOUND")throw ne}return ee}}const log$m=logger$1("libp2p:kad-dht:rpc:handlers:get-value");class GetValueHandler{components;peerRouting;constructor(E,ee){const{peerRouting:te}=ee;this.components=E,this.peerRouting=te}async handle(E,ee){const te=ee.key;if(log$m("%p asked for key %b",E,te),te==null||te.length===0)throw new CodeError("Invalid key","ERR_INVALID_KEY");const re=new Message$3(MESSAGE_TYPE.GET_VALUE,te,ee.clusterLevel);if(isPublicKeyKey(te)){log$m("is public key");const se=fromPublicKeyKey(te);let oe;try{const ce=await this.components.peerStore.get(se);if(ce.id.publicKey==null)throw new CodeError("No public key found in key book","ERR_NOT_FOUND");oe=ce.id.publicKey}catch(ce){if(ce.code!=="ERR_NOT_FOUND")throw ce}if(oe!=null)return log$m("returning found public key"),re.record=new Libp2pRecord(te,oe,new Date),re}const[ne,ie]=await Promise.all([this._checkLocalDatastore(te),this.peerRouting.getCloserPeersOffline(ee.key,E)]);return ne!=null&&(log$m("had record for %b in local datastore",te),re.record=ne),ie.length>0&&(log$m("had %s closer peers in routing table",ie.length),re.closerPeers=ie),re}async _checkLocalDatastore(E){log$m("checkLocalDatastore looking for %b",E);const ee=bufferToRecordKey(E);let te;try{te=await this.components.datastore.get(ee)}catch(ne){if(ne.code==="ERR_NOT_FOUND")return;throw ne}const re=Libp2pRecord.deserialize(te);if(re==null)throw new CodeError("Invalid record","ERR_INVALID_RECORD");if(re.timeReceived==null||Date.now()-re.timeReceived.getTime()>MAX_RECORD_AGE){await this.components.datastore.delete(ee);return}return re}}const log$l=logger$1("libp2p:kad-dht:rpc:handlers:ping");class PingHandler{async handle(E,ee){return log$l("ping from %p",E),ee}}class PutValueHandler{log;components;validators;constructor(E,ee){const{validators:te}=ee;this.components=E,this.log=logger$1("libp2p:kad-dht:rpc:handlers:put-value"),this.validators=te}async handle(E,ee){const te=ee.key;this.log("%p asked us to store value for key %b",E,te);const re=ee.record;if(re==null){const ne=`Empty record from: ${E.toString()}`;throw this.log.error(ne),new CodeError(ne,"ERR_EMPTY_RECORD")}try{await verifyRecord(this.validators,re),re.timeReceived=new Date;const ne=bufferToRecordKey(re.key);await this.components.datastore.put(ne,re.serialize().subarray()),this.log("put record for %b into datastore under key %k",te,ne)}catch(ne){this.log("did not put record for key %b into datastore %o",te,ne)}return ee}}class RPC{handlers;routingTable;log;constructor(E,ee){const{providers:te,peerRouting:re,validators:ne,lan:ie}=ee;this.log=logger$1("libp2p:kad-dht:rpc"),this.routingTable=ee.routingTable,this.handlers={[MESSAGE_TYPE.GET_VALUE]:new GetValueHandler(E,{peerRouting:re}),[MESSAGE_TYPE.PUT_VALUE]:new PutValueHandler(E,{validators:ne}),[MESSAGE_TYPE.FIND_NODE]:new FindNodeHandler(E,{peerRouting:re,lan:ie}),[MESSAGE_TYPE.ADD_PROVIDER]:new AddProviderHandler({providers:te}),[MESSAGE_TYPE.GET_PROVIDERS]:new GetProvidersHandler(E,{peerRouting:re,providers:te,lan:ie}),[MESSAGE_TYPE.PING]:new PingHandler}}async handleMessage(E,ee){try{await this.routingTable.add(E)}catch(re){this.log.error("Failed to update the kbucket store",re)}const te=this.handlers[ee.type];if(te==null){this.log.error(`no handler found for message type: ${ee.type}`);return}return te.handle(E,ee)}onIncomingStream(E){Promise.resolve().then(async()=>{const{stream:ee,connection:te}=E,re=te.remotePeer;try{await this.routingTable.add(re)}catch(ie){this.log.error(ie)}const ne=this;await pipe$1(ee,ie=>decode$b(ie),async function*(ie){for await(const se of ie){const oe=Message$3.deserialize(se);ne.log("incoming %s from %p",oe.type,re);const ce=await ne.handleMessage(re,oe);ce!=null&&(yield ce.serialize())}},ie=>encode$b(ie),ee)}).catch(ee=>{this.log.error(ee)})}}class TopologyListener extends EventEmitter$3{log;components;protocol;running;registrarId;constructor(E,ee){super();const{protocol:te,lan:re}=ee;this.components=E,this.log=logger$1(`libp2p:kad-dht:topology-listener:${re?"lan":"wan"}`),this.running=!1,this.protocol=te}isStarted(){return this.running}async start(){if(this.running)return;this.running=!0;const E=createTopology({onConnect:ee=>{this.log("observed peer %p with protocol %s",ee,this.protocol),this.dispatchEvent(new CustomEvent$2("peer",{detail:ee}))}});this.registrarId=await this.components.registrar.register(this.protocol,E)}async stop(){this.running=!1,this.registrarId!=null&&(this.components.registrar.unregister(this.registrarId),this.registrarId=void 0)}}const DEFAULT_MAX_INBOUND_STREAMS=32,DEFAULT_MAX_OUTBOUND_STREAMS=64;class DefaultKadDHT extends EventEmitter$3{protocol;routingTable;providers;network;peerRouting;components;log;running;kBucketSize;clientMode;lan;validators;selectors;queryManager;contentFetching;contentRouting;routingTableRefresh;rpc;topologyListener;querySelf;maxInboundStreams;maxOutboundStreams;constructor(E,ee){super();const{kBucketSize:te,clientMode:re,validators:ne,selectors:ie,querySelfInterval:se,lan:oe,protocolPrefix:ce,pingTimeout:ae,pingConcurrency:le,maxInboundStreams:ue,maxOutboundStreams:he,providers:pe}=ee;this.running=!1,this.components=E,this.lan=!!oe,this.log=logger$1(`libp2p:kad-dht:${oe===!0?"lan":"wan"}`),this.protocol=`${ce??PROTOCOL_PREFIX$1}${oe===!0?LAN_PREFIX:""}${PROTOCOL_DHT}`,this.kBucketSize=te??20,this.clientMode=re??!0,this.maxInboundStreams=ue??DEFAULT_MAX_INBOUND_STREAMS,this.maxOutboundStreams=he??DEFAULT_MAX_OUTBOUND_STREAMS,this.routingTable=new RoutingTable(E,{kBucketSize:te,lan:this.lan,pingTimeout:ae,pingConcurrency:le,protocol:this.protocol}),this.providers=new Providers(E,pe??{}),this.validators={...validators,...ne},this.selectors={...selectors,...ie},this.network=new Network(E,{protocol:this.protocol,lan:this.lan});const de=pDefer();ee.allowQueryWithZeroPeers===!0&&de.resolve(),this.queryManager=new QueryManager(E,{disjointPaths:Math.ceil(this.kBucketSize/2),lan:oe,initialQuerySelfHasRun:de,routingTable:this.routingTable}),this.peerRouting=new PeerRouting(E,{routingTable:this.routingTable,network:this.network,validators:this.validators,queryManager:this.queryManager,lan:this.lan}),this.contentFetching=new ContentFetching(E,{validators:this.validators,selectors:this.selectors,peerRouting:this.peerRouting,queryManager:this.queryManager,network:this.network,lan:this.lan}),this.contentRouting=new ContentRouting(E,{network:this.network,peerRouting:this.peerRouting,queryManager:this.queryManager,routingTable:this.routingTable,providers:this.providers,lan:this.lan}),this.routingTableRefresh=new RoutingTableRefresh({peerRouting:this.peerRouting,routingTable:this.routingTable,lan:this.lan}),this.rpc=new RPC(E,{routingTable:this.routingTable,providers:this.providers,peerRouting:this.peerRouting,validators:this.validators,lan:this.lan}),this.topologyListener=new TopologyListener(E,{protocol:this.protocol,lan:this.lan}),this.querySelf=new QuerySelf(E,{peerRouting:this.peerRouting,interval:se,initialInterval:ee.initialQuerySelfInterval,lan:this.lan,initialQuerySelfHasRun:de,routingTable:this.routingTable}),this.network.addEventListener("peer",fe=>{const me=fe.detail;this.onPeerConnect(me).catch(_e=>{this.log.error("could not add %p to routing table",me.id,_e)}),this.dispatchEvent(new CustomEvent$2("peer",{detail:me}))}),this.topologyListener.addEventListener("peer",fe=>{const me=fe.detail;Promise.resolve().then(async()=>{const _e=await this.components.peerStore.get(me),be={id:me,multiaddrs:_e.addresses.map(({multiaddr:Ee})=>Ee),protocols:_e.protocols};await this.onPeerConnect(be)}).catch(_e=>{this.log.error("could not add %p to routing table",me,_e)})})}async onPeerConnect(E){if(this.log("peer %p connected with protocols",E.id,E.protocols),this.lan?E=removePublicAddresses(E):E=removePrivateAddresses(E),E.multiaddrs.length===0){this.log("ignoring %p as they do not have any %s addresses in %s",E.id,this.lan?"private":"public",E.multiaddrs.map(ee=>ee.toString()));return}try{await this.routingTable.add(E.id)}catch(ee){this.log.error("could not add %p to routing table",E.id,ee)}}isStarted(){return this.running}async getMode(){return this.clientMode?"client":"server"}async setMode(E){await this.components.registrar.unhandle(this.protocol),E==="client"?(this.log("enabling client mode"),this.clientMode=!0):(this.log("enabling server mode"),this.clientMode=!1,await this.components.registrar.handle(this.protocol,this.rpc.onIncomingStream.bind(this.rpc),{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams}))}async start(){this.running=!0,await this.setMode(this.clientMode?"client":"server"),await Promise.all([this.providers.start(),this.queryManager.start(),this.network.start(),this.routingTable.start(),this.topologyListener.start()]),this.querySelf.start(),await this.routingTableRefresh.start()}async stop(){this.running=!1,this.querySelf.stop(),await Promise.all([this.providers.stop(),this.queryManager.stop(),this.network.stop(),this.routingTable.stop(),this.routingTableRefresh.stop(),this.topologyListener.stop()])}async*put(E,ee,te={}){yield*this.contentFetching.put(E,ee,te)}async*get(E,ee={}){yield*this.contentFetching.get(E,ee)}async*provide(E,ee={}){yield*this.contentRouting.provide(E,this.components.addressManager.getAddresses(),ee)}async*findProviders(E,ee={}){yield*this.contentRouting.findProviders(E,ee)}async*findPeer(E,ee={}){yield*this.peerRouting.findPeer(E,ee)}async*getClosestPeers(E,ee={}){yield*this.peerRouting.getClosestPeers(E,ee)}async refreshRoutingTable(){this.routingTableRefresh.refreshTable(!0)}}const log$k=logger$1("libp2p:kad-dht");class DHTContentRouting{dht;constructor(E){this.dht=E}async provide(E,ee={}){await drain(this.dht.provide(E,ee))}async*findProviders(E,ee={}){for await(const te of this.dht.findProviders(E,ee))te.name==="PROVIDER"&&(yield*te.providers)}async put(E,ee,te){await drain(this.dht.put(E,ee,te))}async get(E,ee){for await(const te of this.dht.get(E,ee))if(te.name==="VALUE")return te.value;throw new CodeError("Not found","ERR_NOT_FOUND")}}class DHTPeerRouting{dht;constructor(E){this.dht=E}async findPeer(E,ee={}){for await(const te of this.dht.findPeer(E,ee))if(te.name==="FINAL_PEER")return te.peer;throw new CodeError("Not found","ERR_NOT_FOUND")}async*getClosestPeers(E,ee={}){for await(const te of this.dht.getClosestPeers(E,ee))te.name==="FINAL_PEER"&&(yield te.peer)}}const P2P_CIRCUIT_CODE=290,DNS4_CODE=54,DNS6_CODE=55,DNSADDR_CODE=56,IP4_CODE=4,IP6_CODE=41;function multiaddrIsPublic(J){const E=J.stringTuples();for(const ee of E)if(ee[0]===P2P_CIRCUIT_CODE)return!1;if(E[0][0]===DNS4_CODE||E[0][0]===DNS6_CODE||E[0][0]===DNSADDR_CODE)return log$k("%m is public %s",J,!0),!0;if(E[0][0]===IP4_CODE||E[0][0]===IP6_CODE){const ee=is_ip_private(`${E[0][1]}`),te=ee==null||!ee;return log$k("%m is public %s",J,te),te}return!1}class DefaultDualKadDHT extends EventEmitter$3{wan;lan;components;contentRouting;peerRouting;constructor(E,ee={}){super(),this.components=E,this.wan=new DefaultKadDHT(E,{protocolPrefix:"/ipfs",...ee,lan:!1}),this.lan=new DefaultKadDHT(E,{protocolPrefix:"/ipfs",...ee,clientMode:!1,lan:!0}),this.contentRouting=new DHTContentRouting(this),this.peerRouting=new DHTPeerRouting(this),this.wan.addEventListener("peer",te=>{this.dispatchEvent(new CustomEvent$2("peer",{detail:te.detail}))}),this.lan.addEventListener("peer",te=>{this.dispatchEvent(new CustomEvent$2("peer",{detail:te.detail}))}),ee.clientMode==null&&E.events.addEventListener("self:peer:update",te=>{log$k("received update of self-peer info");const re=te.detail.peer.addresses.some(({multiaddr:ne})=>{const ie=multiaddrIsPublic(ne);return log$k("%m is public %s",ne,ie),ie});this.getMode().then(async ne=>{re&&ne==="client"?await this.setMode("server"):ne==="server"&&!re&&await this.setMode("client")}).catch(ne=>{log$k.error("error setting dht server mode",ne)})})}[Symbol.toStringTag]="@libp2p/dual-kad-dht";get[contentRouting](){return this.contentRouting}get[peerRouting](){return this.peerRouting}get[peerDiscovery](){return this}isStarted(){return this.wan.isStarted()&&this.lan.isStarted()}async getMode(){return this.wan.getMode()}async setMode(E){await this.wan.setMode(E)}async start(){await Promise.all([this.lan.start(),this.wan.start()])}async stop(){await Promise.all([this.lan.stop(),this.wan.stop()])}async*put(E,ee,te={}){for await(const re of merge$2(this.lan.put(E,ee,te),this.wan.put(E,ee,te)))yield re}async*get(E,ee={}){let te=!1,re=!1;for await(const ne of merge$2(this.lan.get(E,ee),this.wan.get(E,ee)))yield ne,ne.name==="DIAL_PEER"&&(te=!0),ne.name==="VALUE"&&(te=!0,ne.value!=null&&(re=!0)),ne.name==="SEND_QUERY"&&(te=!0);if(!te)throw new CodeError("No peers found in routing table!","ERR_NO_PEERS_IN_ROUTING_TABLE");re||(yield queryErrorEvent({from:this.components.peerId,error:new CodeError("Not found","ERR_NOT_FOUND")},ee))}async*provide(E,ee={}){let te=0,re=0;const ne=[],ie=[this.lan];await this.wan.getMode()==="server"&&ie.push(this.wan);for await(const se of merge$2(...ie.map(oe=>oe.provide(E,ee))))yield se,se.name==="SEND_QUERY"&&te++,se.name==="QUERY_ERROR"&&ne.push(se.error),se.name==="PEER_RESPONSE"&&se.messageName==="ADD_PROVIDER"&&(log$k("sent provider record for %s to %p",E,se.from),re++);if(re===0)throw ne.length>0?new CodeError(`Failed to provide to ${ne.length} of ${te} peers`,"ERR_PROVIDES_FAILED",{errors:ne}):new CodeError("Failed to provide - no peers found","ERR_PROVIDES_FAILED")}async*findProviders(E,ee={}){yield*merge$2(this.lan.findProviders(E,ee),this.wan.findProviders(E,ee))}async*findPeer(E,ee={}){let te=!1;for await(const re of merge$2(this.lan.findPeer(E,ee),this.wan.findPeer(E,ee)))yield re,(re.name==="SEND_QUERY"||re.name==="FINAL_PEER")&&(te=!0);if(!te)throw new CodeError("Peer lookup failed","ERR_LOOKUP_FAILED")}async*getClosestPeers(E,ee={}){yield*merge$2(this.lan.getClosestPeers(E,ee),this.wan.getClosestPeers(E,ee))}async refreshRoutingTable(){await Promise.all([this.lan.refreshRoutingTable(),this.wan.refreshRoutingTable()])}}var EventTypes;(function(J){J[J.SEND_QUERY=0]="SEND_QUERY",J[J.PEER_RESPONSE=1]="PEER_RESPONSE",J[J.FINAL_PEER=2]="FINAL_PEER",J[J.QUERY_ERROR=3]="QUERY_ERROR",J[J.PROVIDER=4]="PROVIDER",J[J.VALUE=5]="VALUE",J[J.ADD_PEER=6]="ADD_PEER",J[J.DIAL_PEER=7]="DIAL_PEER"})(EventTypes||(EventTypes={}));var MessageType;(function(J){J[J.PUT_VALUE=0]="PUT_VALUE",J[J.GET_VALUE=1]="GET_VALUE",J[J.ADD_PROVIDER=2]="ADD_PROVIDER",J[J.GET_PROVIDERS=3]="GET_PROVIDERS",J[J.FIND_NODE=4]="FIND_NODE",J[J.PING=5]="PING"})(MessageType||(MessageType={}));function kadDHT(J){return E=>new DefaultDualKadDHT(E,J)}var MessageTypes;(function(J){J[J.NEW_STREAM=0]="NEW_STREAM",J[J.MESSAGE_RECEIVER=1]="MESSAGE_RECEIVER",J[J.MESSAGE_INITIATOR=2]="MESSAGE_INITIATOR",J[J.CLOSE_RECEIVER=3]="CLOSE_RECEIVER",J[J.CLOSE_INITIATOR=4]="CLOSE_INITIATOR",J[J.RESET_RECEIVER=5]="RESET_RECEIVER",J[J.RESET_INITIATOR=6]="RESET_INITIATOR"})(MessageTypes||(MessageTypes={}));const MessageTypeNames=Object.freeze({0:"NEW_STREAM",1:"MESSAGE_RECEIVER",2:"MESSAGE_INITIATOR",3:"CLOSE_RECEIVER",4:"CLOSE_INITIATOR",5:"RESET_RECEIVER",6:"RESET_INITIATOR"}),InitiatorMessageTypes=Object.freeze({NEW_STREAM:MessageTypes.NEW_STREAM,MESSAGE:MessageTypes.MESSAGE_INITIATOR,CLOSE:MessageTypes.CLOSE_INITIATOR,RESET:MessageTypes.RESET_INITIATOR}),ReceiverMessageTypes=Object.freeze({MESSAGE:MessageTypes.MESSAGE_RECEIVER,CLOSE:MessageTypes.CLOSE_RECEIVER,RESET:MessageTypes.RESET_RECEIVER}),MAX_MSG_SIZE=1<<20,MAX_MSG_QUEUE_SIZE=4<<20;class Decoder{_buffer;_headerInfo;_maxMessageSize;_maxUnprocessedMessageQueueSize;constructor(E=MAX_MSG_SIZE,ee=MAX_MSG_QUEUE_SIZE){this._buffer=new Uint8ArrayList,this._headerInfo=null,this._maxMessageSize=E,this._maxUnprocessedMessageQueueSize=ee}write(E){if(E==null||E.length===0)return[];if(this._buffer.append(E),this._buffer.byteLength>this._maxUnprocessedMessageQueueSize)throw Object.assign(new Error("unprocessed message queue size too large!"),{code:"ERR_MSG_QUEUE_TOO_BIG"});const ee=[];for(;this._buffer.length!==0;){if(this._headerInfo==null)try{this._headerInfo=this._decodeHeader(this._buffer)}catch(oe){if(oe.code==="ERR_MSG_TOO_BIG")throw oe;break}const{id:te,type:re,length:ne,offset:ie}=this._headerInfo;if(this._buffer.length-ie<ne)break;const se={id:te,type:re};(re===MessageTypes.NEW_STREAM||re===MessageTypes.MESSAGE_INITIATOR||re===MessageTypes.MESSAGE_RECEIVER)&&(se.data=this._buffer.sublist(ie,ie+ne)),ee.push(se),this._buffer.consume(ie+ne),this._headerInfo=null}return ee}_decodeHeader(E){const{value:ee,offset:te}=readVarInt(E),{value:re,offset:ne}=readVarInt(E,te),ie=ee&7;if(MessageTypeNames[ie]==null)throw new Error(`Invalid type received: ${ie}`);if(re>this._maxMessageSize)throw Object.assign(new Error("message size too large!"),{code:"ERR_MSG_TOO_BIG"});return{id:ee>>3,type:ie,offset:te+ne,length:re}}}const MSB=128,REST=127;function readVarInt(J,E=0){let ee=0,te=0,re=E,ne;const ie=J.length;do{if(re>=ie||te>49)throw E=0,new RangeError("Could not decode varint");ne=J.get(re++),ee+=te<28?(ne&REST)<<te:(ne&REST)*Math.pow(2,te),te+=7}while(ne>=MSB);return E=re-E,{value:ee,offset:E}}function allocUnsafe$1(J){return new Uint8Array(J)}const POOL_SIZE=10*1024;class Encoder{_pool;_poolOffset;constructor(){this._pool=allocUnsafe$1(POOL_SIZE),this._poolOffset=0}write(E,ee){const te=this._pool;let re=this._poolOffset;varint$4.encode(E.id<<3|E.type,te,re),re+=varint$4.encode.bytes??0,(E.type===MessageTypes.NEW_STREAM||E.type===MessageTypes.MESSAGE_INITIATOR||E.type===MessageTypes.MESSAGE_RECEIVER)&&E.data!=null?varint$4.encode(E.data.length,te,re):varint$4.encode(0,te,re),re+=varint$4.encode.bytes??0;const ne=te.subarray(this._poolOffset,re);POOL_SIZE-re<100?(this._pool=allocUnsafe$1(POOL_SIZE),this._poolOffset=0):this._poolOffset=re,ee.append(ne),(E.type===MessageTypes.NEW_STREAM||E.type===MessageTypes.MESSAGE_INITIATOR||E.type===MessageTypes.MESSAGE_RECEIVER)&&E.data!=null&&ee.append(E.data)}}const encoder=new Encoder;async function*encode(J,E=0){if(E==null||E===0){for await(const ee of J){const te=new Uint8ArrayList;for(const re of ee)encoder.write(re,te);yield te.subarray()}return}yield*batchedBytes(J,{size:E,serialize:(ee,te)=>{for(const re of ee)encoder.write(re,te)}})}const log$j=logger$1("libp2p:stream"),ERR_STREAM_RESET="ERR_STREAM_RESET",ERR_STREAM_ABORT="ERR_STREAM_ABORT",ERR_SINK_ENDED="ERR_SINK_ENDED",ERR_DOUBLE_SINK="ERR_DOUBLE_SINK";function isPromise(J){return J!=null&&typeof J.then=="function"}class AbstractStream{id;stat;metadata;source;abortController;resetController;closeController;sourceEnded;sinkEnded;sinkSunk;endErr;streamSource;onEnd;maxDataSize;constructor(E){this.abortController=new AbortController,this.resetController=new AbortController,this.closeController=new AbortController,this.sourceEnded=!1,this.sinkEnded=!1,this.sinkSunk=!1,this.id=E.id,this.metadata=E.metadata??{},this.stat={direction:E.direction,timeline:{open:Date.now()}},this.maxDataSize=E.maxDataSize,this.onEnd=E.onEnd,this.source=this.streamSource=pushable({onEnd:()=>{if(this.stat.timeline.reset!==null){const ee=this.sendCloseRead();isPromise(ee)&&ee.catch(te=>{log$j.error("error while sending close read",te)})}this.onSourceEnd()}}),this.sink=this.sink.bind(this)}onSourceEnd(E){this.sourceEnded||(this.stat.timeline.closeRead=Date.now(),this.sourceEnded=!0,log$j.trace("%s stream %s source end - err: %o",this.stat.direction,this.id,E),E!=null&&this.endErr==null&&(this.endErr=E),this.sinkEnded&&(this.stat.timeline.close=Date.now(),this.onEnd!=null&&this.onEnd(this.endErr)))}onSinkEnd(E){this.sinkEnded||(this.stat.timeline.closeWrite=Date.now(),this.sinkEnded=!0,log$j.trace("%s stream %s sink end - err: %o",this.stat.direction,this.id,E),E!=null&&this.endErr==null&&(this.endErr=E),this.sourceEnded&&(this.stat.timeline.close=Date.now(),this.onEnd!=null&&this.onEnd(this.endErr)))}close(){log$j.trace("%s stream %s close",this.stat.direction,this.id),this.closeRead(),this.closeWrite()}closeRead(){log$j.trace("%s stream %s closeRead",this.stat.direction,this.id),!this.sourceEnded&&this.streamSource.end()}closeWrite(){if(log$j.trace("%s stream %s closeWrite",this.stat.direction,this.id),!this.sinkEnded){this.closeController.abort();try{const E=this.sendCloseWrite();isPromise(E)&&E.catch(ee=>{log$j.error("error while sending close write",ee)})}catch(E){log$j.trace("%s stream %s error sending close",this.stat.direction,this.id,E)}this.onSinkEnd()}}abort(E){log$j.trace("%s stream %s abort",this.stat.direction,this.id,E),this.streamSource.end(E),this.abortController.abort(),this.onSinkEnd(E)}reset(){const E=new CodeError("stream reset",ERR_STREAM_RESET);this.resetController.abort(),this.streamSource.end(E),this.onSinkEnd(E)}async sink(E){if(this.sinkSunk)throw new CodeError("sink already called on stream",ERR_DOUBLE_SINK);if(this.sinkSunk=!0,this.sinkEnded)throw new CodeError("stream closed for writing",ERR_SINK_ENDED);const ee=anySignal([this.abortController.signal,this.resetController.signal,this.closeController.signal]);try{if(E=abortableSource$1(E,ee),this.stat.direction==="outbound"){const te=this.sendNewStream();isPromise(te)&&await te}for await(let te of E)for(;te.length>0;){if(te.length<=this.maxDataSize){const ne=this.sendData(te instanceof Uint8Array?new Uint8ArrayList(te):te);isPromise(ne)&&await ne;break}te=te instanceof Uint8Array?new Uint8ArrayList(te):te;const re=this.sendData(te.sublist(0,this.maxDataSize));isPromise(re)&&await re,te.consume(this.maxDataSize)}}catch(te){if(te.type==="aborted"&&te.message==="The operation was aborted"){if(this.closeController.signal.aborted)return;this.resetController.signal.aborted&&(te.message="stream reset",te.code=ERR_STREAM_RESET),this.abortController.signal.aborted&&(te.message="stream aborted",te.code=ERR_STREAM_ABORT)}if(te.code===ERR_STREAM_RESET)log$j.trace("%s stream %s reset",this.stat.direction,this.id);else{log$j.trace("%s stream %s error",this.stat.direction,this.id,te);try{const re=this.sendReset();isPromise(re)&&await re,this.stat.timeline.reset=Date.now()}catch(re){log$j.trace("%s stream %s error sending reset",this.stat.direction,this.id,re)}}throw this.streamSource.end(te),this.onSinkEnd(te),te}finally{ee.clear()}try{const te=this.sendCloseWrite();isPromise(te)&&await te}catch(te){log$j.trace("%s stream %s error sending close",this.stat.direction,this.id,te)}this.onSinkEnd()}sourcePush(E){this.streamSource.push(E)}sourceReadableLength(){return this.streamSource.readableLength}}class MplexStream extends AbstractStream{name;streamId;send;types;constructor(E){super(E),this.types=E.direction==="outbound"?InitiatorMessageTypes:ReceiverMessageTypes,this.send=E.send,this.name=E.name,this.streamId=E.streamId}sendNewStream(){this.send({id:this.streamId,type:InitiatorMessageTypes.NEW_STREAM,data:new Uint8ArrayList(fromString$5(this.name))})}sendData(E){this.send({id:this.streamId,type:this.types.MESSAGE,data:E})}sendReset(){this.send({id:this.streamId,type:this.types.RESET})}sendCloseWrite(){this.send({id:this.streamId,type:this.types.CLOSE})}sendCloseRead(){}}function createStream$1(J){const{id:E,name:ee,send:te,onEnd:re,type:ne="initiator",maxMsgSize:ie=MAX_MSG_SIZE}=J;return new MplexStream({id:ne==="initiator"?`i${E}`:`r${E}`,streamId:E,name:`${ee??E}`,direction:ne==="initiator"?"outbound":"inbound",maxDataSize:ie,onEnd:re,send:te})}const log$i=logger$1("libp2p:mplex"),MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION=1024,MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION=1024,MAX_STREAM_BUFFER_SIZE=1024*1024*4,DISCONNECT_THRESHOLD=5;function printMessage(J){const E={...J,type:`${MessageTypeNames[J.type]} (${J.type})`};return J.type===MessageTypes.NEW_STREAM&&(E.data=toString$5(J.data instanceof Uint8Array?J.data:J.data.subarray())),(J.type===MessageTypes.MESSAGE_INITIATOR||J.type===MessageTypes.MESSAGE_RECEIVER)&&(E.data=toString$5(J.data instanceof Uint8Array?J.data:J.data.subarray(),"base16")),E}class MplexStreamMuxer{protocol="/mplex/6.7.0";sink;source;_streamId;_streams;_init;_source;closeController;rateLimiter;constructor(E){E=E??{},this._streamId=0,this._streams={initiators:new Map,receivers:new Map},this._init=E,this.sink=this._createSink();const ee=this._createSource();this._source=ee,this.source=ee,this.closeController=new AbortController,this.rateLimiter=new rateLimiterFlexible.RateLimiterMemory({points:E.disconnectThreshold??DISCONNECT_THRESHOLD,duration:1})}get streams(){const E=[];for(const ee of this._streams.initiators.values())E.push(ee);for(const ee of this._streams.receivers.values())E.push(ee);return E}newStream(E){if(this.closeController.signal.aborted)throw new Error("Muxer already closed");const ee=this._streamId++;E=E==null?ee.toString():E.toString();const te=this._streams.initiators;return this._newStream({id:ee,name:E,type:"initiator",registry:te})}close(E){this.closeController.signal.aborted||(E!=null?this.streams.forEach(ee=>{ee.abort(E)}):this.streams.forEach(ee=>{ee.close()}),this.closeController.abort())}_newReceiverStream(E){const{id:ee,name:te}=E,re=this._streams.receivers;return this._newStream({id:ee,name:te,type:"receiver",registry:re})}_newStream(E){const{id:ee,name:te,type:re,registry:ne}=E;if(log$i("new %s stream %s",re,ee),re==="initiator"&&this._streams.initiators.size===(this._init.maxOutboundStreams??MAX_STREAMS_OUTBOUND_STREAMS_PER_CONNECTION))throw new CodeError("Too many outbound streams open","ERR_TOO_MANY_OUTBOUND_STREAMS");if(ne.has(ee))throw new Error(`${re} stream ${ee} already exists!`);const ie=createStream$1({id:ee,name:te,send:se=>{log$i.enabled&&log$i.trace("%s stream %s send",re,ee,printMessage(se)),this._source.push(se)},type:re,onEnd:()=>{log$i("%s stream with id %s and protocol %s ended",re,ee,ie.stat.protocol),ne.delete(ee),this._init.onStreamEnd!=null&&this._init.onStreamEnd(ie)},maxMsgSize:this._init.maxMsgSize});return ne.set(ee,ie),ie}_createSink(){return async E=>{const ee=anySignal([this.closeController.signal,this._init.signal]);try{E=abortableSource$1(E,ee);const te=new Decoder(this._init.maxMsgSize,this._init.maxUnprocessedMessageQueueSize);for await(const re of E)for(const ne of te.write(re))await this._handleIncoming(ne);this._source.end()}catch(te){log$i("error in sink",te),this._source.end(te)}finally{ee.clear()}}}_createSource(){const E=pushableV({objectMode:!0,onEnd:ee=>{this.close(ee)}});return Object.assign(encode(E,this._init.minSendBytes),{push:E.push,end:E.end,return:E.return})}async _handleIncoming(E){const{id:ee,type:te}=E;if(log$i.enabled&&log$i.trace("incoming message",printMessage(E)),E.type===MessageTypes.NEW_STREAM){if(this._streams.receivers.size===(this._init.maxInboundStreams??MAX_STREAMS_INBOUND_STREAMS_PER_CONNECTION)){log$i("too many inbound streams open"),this._source.push({id:ee,type:MessageTypes.RESET_RECEIVER});try{await this.rateLimiter.consume("new-stream",1)}catch{log$i("rate limit hit when opening too many new streams over the inbound stream limit - closing remote connection"),this._source.end(new Error("Too many open streams"));return}return}const ie=this._newReceiverStream({id:ee,name:toString$5(E.data instanceof Uint8Array?E.data:E.data.subarray())});this._init.onIncomingStream!=null&&this._init.onIncomingStream(ie);return}const re=((te&1)===1?this._streams.initiators:this._streams.receivers).get(ee);if(re==null){log$i("missing stream %s for message type %s",ee,MessageTypeNames[te]);return}const ne=this._init.maxStreamBufferSize??MAX_STREAM_BUFFER_SIZE;switch(te){case MessageTypes.MESSAGE_INITIATOR:case MessageTypes.MESSAGE_RECEIVER:if(re.sourceReadableLength()>ne){this._source.push({id:E.id,type:te===MessageTypes.MESSAGE_INITIATOR?MessageTypes.RESET_RECEIVER:MessageTypes.RESET_INITIATOR});const ie=new CodeError("Input buffer full - increase Mplex maxBufferSize to accommodate slow consumers","ERR_STREAM_INPUT_BUFFER_FULL");re.abort(ie);return}re.sourcePush(E.data);break;case MessageTypes.CLOSE_INITIATOR:case MessageTypes.CLOSE_RECEIVER:re.closeRead();break;case MessageTypes.RESET_INITIATOR:case MessageTypes.RESET_RECEIVER:re.reset();break;default:log$i("unknown message type %s",te)}}}class Mplex{protocol="/mplex/6.7.0";_init;constructor(E={}){this._init=E}createStreamMuxer(E={}){return new MplexStreamMuxer({...E,...this._init})}}function mplex(J={}){return()=>new Mplex(J)}var codes;(function(J){J.ERR_ALREADY_ABORTED="ERR_ALREADY_ABORTED",J.ERR_DATA_CHANNEL="ERR_DATA_CHANNEL",J.ERR_CONNECTION_CLOSED="ERR_CONNECTION_CLOSED",J.ERR_HASH_NOT_SUPPORTED="ERR_HASH_NOT_SUPPORTED",J.ERR_INVALID_MULTIADDR="ERR_INVALID_MULTIADDR",J.ERR_INVALID_FINGERPRINT="ERR_INVALID_FINGERPRINT",J.ERR_INVALID_PARAMETERS="ERR_INVALID_PARAMETERS",J.ERR_NOT_IMPLEMENTED="ERR_NOT_IMPLEMENTED",J.ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS="ERR_TOO_MANY_INBOUND_PROTOCOL_STREAMS",J.ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS="ERR_TOO_MANY_OUTBOUND_PROTOCOL_STREAMS"})(codes||(codes={}));class WebRTCTransportError extends CodeError{constructor(E,ee){super(`WebRTC transport error: ${E}`,ee??""),this.name="WebRTCTransportError"}}class DataChannelError extends WebRTCTransportError{constructor(E,ee){super(`[stream: ${E}] data channel error: ${ee}`,codes.ERR_DATA_CHANNEL),this.name="WebRTC/DataChannelError"}}function dataChannelError(J,E){return new DataChannelError(J,E)}class InappropriateMultiaddrError extends WebRTCTransportError{constructor(E){super(`There was a problem with the Multiaddr which was passed in: ${E}`,codes.ERR_INVALID_MULTIADDR),this.name="WebRTC/InappropriateMultiaddrError"}}function inappropriateMultiaddr(J){return new InappropriateMultiaddrError(J)}class InvalidArgumentError extends WebRTCTransportError{constructor(E){super(`There was a problem with a provided argument: ${E}`,codes.ERR_INVALID_PARAMETERS),this.name="WebRTC/InvalidArgumentError"}}function invalidArgument(J){return new InvalidArgumentError(J)}class InvalidFingerprintError extends WebRTCTransportError{constructor(E,ee){super(`Invalid fingerprint "${E}" within ${ee}`,codes.ERR_INVALID_FINGERPRINT),this.name="WebRTC/InvalidFingerprintError"}}function invalidFingerprint(J,E){return new InvalidFingerprintError(J,E)}class UnimplementedError extends WebRTCTransportError{constructor(E){super(`A method (${E}) was called though it has been intentionally left unimplemented.`,codes.ERR_NOT_IMPLEMENTED),this.name="WebRTC/UnimplementedError"}}function unimplemented(J){return new UnimplementedError(J)}class UnsupportedHashAlgorithmError extends WebRTCTransportError{constructor(E){super(`unsupported hash algorithm: ${E}`,codes.ERR_HASH_NOT_SUPPORTED),this.name="WebRTC/UnsupportedHashAlgorithmError"}}function unsupportedHashAlgorithm(J){return new UnsupportedHashAlgorithmError(J)}const browser$7=detect(),isFirefox=browser$7!=null&&browser$7.name==="firefox",nopSource=async function*J(){},nopSink=async J=>{},log$h=logger$1("libp2p:webrtc:connection");class WebRTCMultiaddrConnection{peerConnection;remoteAddr;timeline;metrics;source=nopSource();sink=nopSink;constructor(E){this.remoteAddr=E.remoteAddr,this.timeline=E.timeline,this.peerConnection=E.peerConnection,this.peerConnection.onconnectionstatechange=()=>{(this.peerConnection.connectionState==="closed"||this.peerConnection.connectionState==="disconnected"||this.peerConnection.connectionState==="failed")&&(this.timeline.close=Date.now())}}async close(E){E!==void 0&&log$h.error("error closing connection",E),log$h.trace("closing connection"),this.timeline.close=Date.now(),this.peerConnection.close(),this.metrics?.increment({close:!0})}}var Message$2;(function(J){(function(te){te.FIN="FIN",te.STOP_SENDING="STOP_SENDING",te.RESET="RESET"})(J.Flag||(J.Flag={}));let E;(function(te){te[te.FIN=0]="FIN",te[te.STOP_SENDING=1]="STOP_SENDING",te[te.RESET=2]="RESET"})(E||(E={})),function(te){te.codec=()=>enumeration(E)}(J.Flag||(J.Flag={}));let ee;J.codec=()=>(ee==null&&(ee=message((te,re,ne={})=>{ne.lengthDelimited!==!1&&re.fork(),te.flag!=null&&(re.uint32(8),J.Flag.codec().encode(te.flag,re)),te.message!=null&&(re.uint32(18),re.bytes(te.message)),ne.lengthDelimited!==!1&&re.ldelim()},(te,re)=>{const ne={},ie=re==null?te.len:te.pos+re;for(;te.pos<ie;){const se=te.uint32();switch(se>>>3){case 1:ne.flag=J.Flag.codec().decode(te);break;case 2:ne.message=te.bytes();break;default:te.skipType(se&7);break}}return ne})),ee),J.encode=te=>encodeMessage(te,J.codec()),J.decode=te=>decodeMessage$1(te,J.codec())})(Message$2||(Message$2={}));const log$g=logger$1("libp2p:webrtc:stream"),MAX_MESSAGE_SIZE=16*1024,MAX_BUFFERED_AMOUNT=16*1024*1024,BUFFERED_AMOUNT_LOW_TIMEOUT=30*1e3,PROTOBUF_OVERHEAD=3;class WebRTCStream extends AbstractStream{channel;dataChannelOptions;incomingData;messageQueue;constructor(E){switch(super(E),this.channel=E.channel,this.channel.binaryType="arraybuffer",this.incomingData=pushable(),this.messageQueue=new Uint8ArrayList,this.dataChannelOptions={bufferedAmountLowEventTimeout:E.dataChannelOptions?.bufferedAmountLowEventTimeout??BUFFERED_AMOUNT_LOW_TIMEOUT,maxBufferedAmount:E.dataChannelOptions?.maxBufferedAmount??MAX_BUFFERED_AMOUNT,maxMessageSize:E.dataChannelOptions?.maxMessageSize??MAX_MESSAGE_SIZE},this.channel.readyState){case"open":break;case"closed":case"closing":(this.stat.timeline.close===void 0||this.stat.timeline.close===0)&&(this.stat.timeline.close=Date.now());break;case"connecting":break;default:throw log$g.error("unknown datachannel state %s",this.channel.readyState),new CodeError("Unknown datachannel state","ERR_INVALID_STATE")}this.channel.onopen=te=>{this.stat.timeline.open=new Date().getTime(),this.messageQueue!=null&&(this._sendMessage(this.messageQueue).catch(re=>{this.abort(re)}),this.messageQueue=void 0)},this.channel.onclose=te=>{this.close()},this.channel.onerror=te=>{const re=te.error;this.abort(re)};const ee=this;this.channel.onmessage=async te=>{const{data:re}=te;re===null||re.byteLength===0||this.incomingData.push(new Uint8Array(re,0,re.byteLength))},Promise.resolve().then(async()=>{for await(const te of decode$b(this.incomingData)){const re=ee.processIncomingProtobuf(te.subarray());re!=null&&ee.sourcePush(new Uint8ArrayList(re))}}).catch(te=>{log$g.error("error processing incoming data channel messages",te)})}sendNewStream(){}async _sendMessage(E,ee=!0){if(ee&&this.channel.bufferedAmount>this.dataChannelOptions.maxBufferedAmount)try{await pEvent(this.channel,"bufferedamountlow",{timeout:this.dataChannelOptions.bufferedAmountLowEventTimeout})}catch(te){throw te instanceof TimeoutError$1?(this.abort(te),new Error("Timed out waiting for DataChannel buffer to clear")):te}if(this.channel.readyState==="closed"||this.channel.readyState==="closing")throw new CodeError("Invalid datachannel state - closed or closing","ERR_INVALID_STATE");if(this.channel.readyState==="open")for(const te of E)this.channel.send(te);else if(this.channel.readyState==="connecting")this.messageQueue==null&&(this.messageQueue=new Uint8ArrayList),this.messageQueue.append(E);else throw log$g.error("unknown datachannel state %s",this.channel.readyState),new CodeError("Unknown datachannel state","ERR_INVALID_STATE")}async sendData(E){const ee=Message$2.encode({message:E.subarray()}),te=encode$b.single(ee);await this._sendMessage(te)}async sendReset(){await this._sendFlag(Message$2.Flag.RESET)}async sendCloseWrite(){await this._sendFlag(Message$2.Flag.FIN)}async sendCloseRead(){await this._sendFlag(Message$2.Flag.STOP_SENDING)}processIncomingProtobuf(E){const ee=Message$2.decode(E);return ee.flag!==void 0&&(ee.flag===Message$2.Flag.FIN&&(this.incomingData.end(),this.closeRead()),ee.flag===Message$2.Flag.RESET&&this.reset(),ee.flag===Message$2.Flag.STOP_SENDING&&this.closeWrite()),ee.message}async _sendFlag(E){log$g.trace("Sending flag: %s",E.toString());const ee=Message$2.encode({flag:E}),te=encode$b.single(ee);await this._sendMessage(te,!1)}}function createStream(J){const{channel:E,direction:ee,onEnd:te,dataChannelOptions:re}=J;return new WebRTCStream({id:ee==="inbound"?`i${E.id}`:`r${E.id}`,direction:ee,maxDataSize:(re?.maxMessageSize??MAX_MESSAGE_SIZE)-PROTOBUF_OVERHEAD,dataChannelOptions:re,onEnd:te,channel:E})}const PROTOCOL="/webrtc";class DataChannelMuxerFactory{protocol;peerConnection;streamBuffer=[];metrics;dataChannelOptions;constructor(E){this.peerConnection=E.peerConnection,this.metrics=E.metrics,this.protocol=E.protocol??PROTOCOL,this.dataChannelOptions=E.dataChannelOptions,this.peerConnection.ondatachannel=({channel:ee})=>{const te=createStream({channel:ee,direction:"inbound",dataChannelOptions:E.dataChannelOptions,onEnd:()=>{this.streamBuffer=this.streamBuffer.filter(re=>re.id!==te.id)}});this.streamBuffer.push(te)}}createStreamMuxer(E){return new DataChannelMuxer({...E,peerConnection:this.peerConnection,dataChannelOptions:this.dataChannelOptions,metrics:this.metrics,streams:this.streamBuffer,protocol:this.protocol})}}class DataChannelMuxer{init;streams;protocol;peerConnection;dataChannelOptions;metrics;close=()=>{};source=nopSource();sink=nopSink;constructor(E){this.init=E,this.streams=E.streams,this.peerConnection=E.peerConnection,this.protocol=E.protocol??PROTOCOL,this.metrics=E.metrics,this.peerConnection.ondatachannel=({channel:te})=>{const re=createStream({channel:te,direction:"inbound",dataChannelOptions:this.dataChannelOptions,onEnd:()=>{this.streams=this.streams.filter(ne=>ne.id!==re.id),this.metrics?.increment({stream_end:!0}),E?.onStreamEnd?.(re)}});this.streams.push(re),E?.onIncomingStream!=null&&(this.metrics?.increment({incoming_stream:!0}),E.onIncomingStream(re))};const ee=E?.onIncomingStream;ee!=null&&this.streams.forEach(te=>{ee(te)})}newStream(){const E=this.peerConnection.createDataChannel(""),ee=createStream({channel:E,direction:"outbound",dataChannelOptions:this.dataChannelOptions,onEnd:()=>{this.streams=this.streams.filter(te=>te.id!==ee.id),this.metrics?.increment({stream_end:!0}),this.init?.onStreamEnd?.(ee)}});return this.streams.push(ee),this.metrics?.increment({outgoing_stream:!0}),ee}}var Message$1;(function(J){(function(te){te.SDP_OFFER="SDP_OFFER",te.SDP_ANSWER="SDP_ANSWER",te.ICE_CANDIDATE="ICE_CANDIDATE"})(J.Type||(J.Type={}));let E;(function(te){te[te.SDP_OFFER=0]="SDP_OFFER",te[te.SDP_ANSWER=1]="SDP_ANSWER",te[te.ICE_CANDIDATE=2]="ICE_CANDIDATE"})(E||(E={})),function(te){te.codec=()=>enumeration(E)}(J.Type||(J.Type={}));let ee;J.codec=()=>(ee==null&&(ee=message((te,re,ne={})=>{ne.lengthDelimited!==!1&&re.fork(),te.type!=null&&(re.uint32(8),J.Type.codec().encode(te.type,re)),te.data!=null&&(re.uint32(18),re.string(te.data)),ne.lengthDelimited!==!1&&re.ldelim()},(te,re)=>{const ne={},ie=re==null?te.len:te.pos+re;for(;te.pos<ie;){const se=te.uint32();switch(se>>>3){case 1:ne.type=J.Type.codec().decode(te);break;case 2:ne.data=te.string();break;default:te.skipType(se&7);break}}return ne})),ee),J.encode=te=>encodeMessage(te,J.codec()),J.decode=te=>decodeMessage$1(te,J.codec())})(Message$1||(Message$1={}));const log$f=logger$1("libp2p:webrtc:peer:util"),readCandidatesUntilConnected=async(J,E,ee)=>{for(;;){const te=await Promise.race([J.promise,ee.read()]);if(te instanceof Object){const re=te;if(re.type!==Message$1.Type.ICE_CANDIDATE)throw new Error("expected only ice candidates");if(re.data==null||re.data===""){log$f.trace("end-of-candidates received");break}log$f.trace("received new ICE candidate: %s",re.data);try{await E.addIceCandidate(new RTCIceCandidate(JSON.parse(re.data)))}catch(ne){throw log$f.error("bad candidate received: ",ne),new Error("bad candidate received")}}else break}await J.promise};function resolveOnConnected(J,E){J[isFirefox?"oniceconnectionstatechange":"onconnectionstatechange"]=ee=>{switch(log$f.trace("receiver peerConnectionState state: ",J.connectionState),isFirefox?J.iceConnectionState:J.connectionState){case"connected":E.resolve();break;case"failed":case"disconnected":case"closed":E.reject(new Error("RTCPeerConnection was closed"));break}}}const DEFAULT_TIMEOUT=30*1e3,log$e=logger$1("libp2p:webrtc:peer");async function handleIncomingStream({rtcConfiguration:J,dataChannelOptions:E,stream:ee}){const te=AbortSignal.timeout(DEFAULT_TIMEOUT),re=pbStream$1(abortableDuplex(ee,te)).pb(Message$1),ne=new RTCPeerConnection(J),ie=new DataChannelMuxerFactory({peerConnection:ne,dataChannelOptions:E}),se=pDefer(),oe=pDefer();te.onabort=()=>{se.reject()},ne.onicecandidate=({candidate:he})=>{oe.promise.then(()=>{re.write({type:Message$1.Type.ICE_CANDIDATE,data:he!=null?JSON.stringify(he.toJSON()):""})},pe=>{log$e.error("cannot set candidate since sending answer failed",pe)})},resolveOnConnected(ne,se);const ce=await re.read();if(ce.type!==Message$1.Type.SDP_OFFER)throw new Error(`expected message type SDP_OFFER, received: ${ce.type??"undefined"} `);const ae=new RTCSessionDescription({type:"offer",sdp:ce.data});await ne.setRemoteDescription(ae).catch(he=>{throw log$e.error("could not execute setRemoteDescription",he),new Error("Failed to set remoteDescription")});const le=await ne.createAnswer().catch(he=>{throw log$e.error("could not execute createAnswer",he),oe.reject(he),new Error("Failed to create answer")});re.write({type:Message$1.Type.SDP_ANSWER,data:le.sdp}),await ne.setLocalDescription(le).catch(he=>{throw log$e.error("could not execute setLocalDescription",he),oe.reject(he),new Error("Failed to set localDescription")}),oe.resolve(),await readCandidatesUntilConnected(se,ne,re);const ue=parseRemoteAddress(ne.currentRemoteDescription?.sdp??"");return{pc:ne,muxerFactory:ie,remoteAddress:ue}}async function initiateConnection({rtcConfiguration:J,dataChannelOptions:E,signal:ee,stream:te}){const re=pbStream$1(abortableDuplex(te,ee)).pb(Message$1),ne=new RTCPeerConnection(J),ie=new DataChannelMuxerFactory({peerConnection:ne,dataChannelOptions:E}),se=pDefer();resolveOnConnected(ne,se),ee.onabort=se.reject;const oe=ne.createDataChannel("init");ne.onicecandidate=({candidate:he})=>{re.write({type:Message$1.Type.ICE_CANDIDATE,data:he!=null?JSON.stringify(he.toJSON()):""})};const ce=await ne.createOffer();re.write({type:Message$1.Type.SDP_OFFER,data:ce.sdp}),await ne.setLocalDescription(ce).catch(he=>{throw log$e.error("could not execute setLocalDescription",he),new Error("Failed to set localDescription")});const ae=await re.read();if(ae.type!==Message$1.Type.SDP_ANSWER)throw new Error("remote should send an SDP answer");const le=new RTCSessionDescription({type:"answer",sdp:ae.data});await ne.setRemoteDescription(le).catch(he=>{throw log$e.error("could not execute setRemoteDescription",he),new Error("Failed to set remoteDescription")}),await readCandidatesUntilConnected(se,ne,re),oe.close();const ue=parseRemoteAddress(ne.currentRemoteDescription?.sdp??"");return{pc:ne,muxerFactory:ie,remoteAddress:ue}}function parseRemoteAddress(J){const E=J.split(`\r
`).filter(te=>te.startsWith("a=candidate")).pop(),ee=E?.split(" ");return E==null||ee==null||ee.length<5?(log$e("could not parse remote address from",E),"/webrtc"):`/dnsaddr/${ee[4]}/${ee[2].toLowerCase()}/${ee[3]}/webrtc`}class WebRTCPeerListener extends EventEmitter$3{peerId;transportManager;constructor(E){super(),this.peerId=E.peerId,this.transportManager=E.transportManager}async listen(){this.safeDispatchEvent("listening",{})}getAddrs(){return this.transportManager.getListeners().filter(E=>E!==this).map(E=>E.getAddrs().filter(ee=>Circuit.matches(ee)).map(ee=>ee.encapsulate(`/webrtc/p2p/${this.peerId}`))).flat()}async close(){this.safeDispatchEvent("close",{})}}const log$d=logger$1("libp2p:webrtc:peer"),WEBRTC_TRANSPORT="/webrtc",CIRCUIT_RELAY_TRANSPORT="/p2p-circuit",SIGNALING_PROTO_ID="/webrtc-signaling/0.0.1",WEBRTC_CODE$1=getProtocol("webrtc").code;class WebRTCTransport{components;init;_started=!1;constructor(E,ee={}){this.components=E,this.init=ee}isStarted(){return this._started}async start(){await this.components.registrar.handle(SIGNALING_PROTO_ID,E=>{this._onProtocol(E).catch(ee=>{log$d.error("failed to handle incoming connect from %p",E.connection.remotePeer,ee)})}),this._started=!0}async stop(){await this.components.registrar.unhandle(SIGNALING_PROTO_ID),this._started=!1}createListener(E){return new WebRTCPeerListener(this.components)}[Symbol.toStringTag]="@libp2p/webrtc";[symbol$2]=!0;filter(E){return E.filter(ee=>ee.protoCodes().includes(WEBRTC_CODE$1))}async dial(E,ee){log$d.trace("dialing address: ",E);const{baseAddr:te,peerId:re}=splitAddr(E);if(ee.signal==null){const ie=new AbortController;ee.signal=ie.signal}const ne=await(await this.components.transportManager.dial(te,ee)).newStream([SIGNALING_PROTO_ID],ee);try{const{pc:ie,muxerFactory:se,remoteAddress:oe}=await initiateConnection({stream:ne,rtcConfiguration:this.init.rtcConfiguration,dataChannelOptions:this.init.dataChannel,signal:ee.signal}),ce=await ee.upgrader.upgradeOutbound(new WebRTCMultiaddrConnection({peerConnection:ie,timeline:{open:Date.now()},remoteAddr:multiaddr(oe).encapsulate(`/p2p/${re.toString()}`)}),{skipProtection:!0,skipEncryption:!0,muxerFactory:se});return ne.close(),ce}catch(ie){throw ne.reset(),ie}}async _onProtocol({connection:E,stream:ee}){try{const{pc:te,muxerFactory:re,remoteAddress:ne}=await handleIncomingStream({rtcConfiguration:this.init.rtcConfiguration,connection:E,stream:ee,dataChannelOptions:this.init.dataChannel});await this.components.upgrader.upgradeInbound(new WebRTCMultiaddrConnection({peerConnection:te,timeline:{open:new Date().getTime()},remoteAddr:multiaddr(ne).encapsulate(`/p2p/${E.remotePeer.toString()}`)}),{skipEncryption:!0,skipProtection:!0,muxerFactory:re})}catch(te){throw ee.reset(),te}}}function splitAddr(J){const E=J.toString().split(WEBRTC_TRANSPORT+"/");if(E.length!==2)throw new CodeError("webrtc protocol was not present in multiaddr",codes.ERR_INVALID_MULTIADDR);if(!E[0].includes(CIRCUIT_RELAY_TRANSPORT))throw new CodeError("p2p-circuit protocol was not present in multiaddr",codes.ERR_INVALID_MULTIADDR);let ee=multiaddr(E[0]);const te=multiaddr("/"+E[1]).getPeerId();if(te==null)throw new CodeError("destination peer id was missing",codes.ERR_INVALID_MULTIADDR);const re=ee.protos().pop();if(re===void 0)throw new CodeError("invalid multiaddr",codes.ERR_INVALID_MULTIADDR);return re.name!=="p2p"&&(ee=ee.encapsulate(`/p2p/${te}`)),{baseAddr:ee,peerId:peerIdFromString(te)}}const log$c=logger$1("libp2p:webrtc:sdp"),mbdecoder=Object.values(bases$1).map(J=>J.decoder).reduce((J,E)=>J.or(E));function getLocalFingerprint(J){const E=J.getConfiguration().certificates?.at(0);if(E==null||E.getFingerprints==null){log$c.trace("fetching fingerprint from local SDP");const te=J.localDescription;return te==null?void 0:getFingerprintFromSdp(te.sdp)}if(log$c.trace("fetching fingerprint from local certificate"),E.getFingerprints().length===0)return;const ee=E.getFingerprints()[0].value;if(ee==null)throw invalidFingerprint("","no fingerprint on local certificate");return ee}const fingerprintRegex=/^a=fingerprint:(?:\w+-[0-9]+)\s(?<fingerprint>(:?[0-9a-fA-F]{2})+)$/m;function getFingerprintFromSdp(J){return J.match(fingerprintRegex)?.groups?.fingerprint}function ipv(J){for(const E of J.protoNames())if(E.startsWith("ip"))return E.toUpperCase();return log$c("Warning: multiaddr does not appear to contain IP4 or IP6, defaulting to IP6",J),"IP6"}function certhash(J){const E=J.stringTuples().filter(ee=>ee[0]===CERTHASH_CODE).map(ee=>ee[1])[0];if(E===void 0||E==="")throw inappropriateMultiaddr(`Couldn't find a certhash component of multiaddr: ${J.toString()}`);return E}function decodeCerthash(J){const E=mbdecoder.decode(J);return src$1.decode(E)}function ma2Fingerprint(J){const E=decodeCerthash(certhash(J)),ee=toSupportedHashFunction(E.name),te=E.digest.reduce((ne,ie)=>ne+ie.toString(16).padStart(2,"0"),""),re=te.match(/.{1,2}/g);if(re==null)throw invalidFingerprint(te,J.toString());return[`${ee.toUpperCase()} ${re.join(":").toUpperCase()}`,te]}function toSupportedHashFunction(J){switch(J){case"sha1":return"sha-1";case"sha2-256":return"sha-256";case"sha2-512":return"sha-512";default:throw unsupportedHashAlgorithm(J)}}function ma2sdp(J,E){const{host:ee,port:te}=J.toOptions(),re=ipv(J),[ne]=ma2Fingerprint(J);return`v=0
o=- 0 0 IN ${re} ${ee}
s=-
c=IN ${re} ${ee}
t=0 0
a=ice-lite
m=application ${te} UDP/DTLS/SCTP webrtc-datachannel
a=mid:0
a=setup:passive
a=ice-ufrag:${E}
a=ice-pwd:${E}
a=fingerprint:${ne}
a=sctp-port:5000
a=max-message-size:100000
a=candidate:1467250027 1 UDP 1467250027 ${ee} ${te} typ host\r
`}function fromMultiAddr(J,E){return{type:"answer",sdp:ma2sdp(J,E)}}function munge(J,E){if(J.sdp===void 0)throw invalidArgument("Can't munge a missing SDP");return J.sdp=J.sdp.replace(/\na=ice-ufrag:[^\n]*\n/,`
a=ice-ufrag:`+E+`
`).replace(/\na=ice-pwd:[^\n]*\n/,`
a=ice-pwd:`+E+`
`),J}const charset=Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),genUfrag=J=>[...Array(J)].map(()=>charset.at(Math.floor(Math.random()*charset.length))).join(""),log$b=logger$1("libp2p:webrtc:transport"),HANDSHAKE_TIMEOUT_MS=1e4,WEBRTC_CODE=getProtocol("webrtc-direct").code,CERTHASH_CODE=getProtocol("certhash").code;class WebRTCDirectTransport{metrics;components;init;constructor(E,ee={}){this.components=E,this.init=ee,E.metrics!=null&&(this.metrics={dialerEvents:E.metrics.registerCounterGroup("libp2p_webrtc_dialer_events_total",{label:"event",help:"Total count of WebRTC dial events by type"})})}async dial(E,ee){const te=await this._connect(E,ee);return log$b(`dialing address - ${E.toString()}`),te}createListener(E){throw unimplemented("WebRTCTransport.createListener")}filter(E){return E.filter(validMa)}[Symbol.toStringTag]="@libp2p/webrtc-direct";[symbol$2]=!0;async _connect(E,ee){const te=new AbortController,re=te.signal,ne=E.getPeerId();if(ne===null)throw inappropriateMultiaddr("we need to have the remote's PeerId");const ie=peerIdFromString(ne),se=decodeCerthash(certhash(E)),oe=await RTCPeerConnection.generateCertificate({name:"ECDSA",namedCurve:"P-256",hash:toSupportedHashFunction(se.name)}),ce=new RTCPeerConnection({certificates:[oe]}),ae=new Promise((Se,$e)=>{const Pe=ce.createDataChannel("",{negotiated:!0,id:0}),Me=setTimeout(()=>{const xe=`Data channel was never opened: state: ${Pe.readyState}`;log$b.error(xe),this.metrics?.dialerEvents.increment({open_error:!0}),$e(dataChannelError("data",xe))},HANDSHAKE_TIMEOUT_MS);Pe.onopen=xe=>{clearTimeout(Me),Se(Pe)},Pe.onerror=xe=>{clearTimeout(Me);const Fe=`Error opening a data channel for handshaking: ${xe.target?.toString()??"not specified"}`;log$b.error(Fe),this.metrics?.dialerEvents.increment({unknown_error:!0}),$e(dataChannelError("data",Fe))}}),le="libp2p+webrtc+v1/"+genUfrag(32),ue=await ce.createOffer(),he=munge(ue,le);await ce.setLocalDescription(he);const pe=fromMultiAddr(E,le);await ce.setRemoteDescription(pe);const de=await ae,fe=this.components.peerId,me=this.generateNoisePrologue(ce,se.code,E),_e=noise$1({prologueBytes:me})(),be=createStream({channel:de,direction:"inbound",dataChannelOptions:this.init.dataChannel}),Ee={...be,sink:be.sink.bind(be),source:async function*(){for await(const Se of be.source)for(const $e of Se)yield $e}()},ve=new WebRTCMultiaddrConnection({peerConnection:ce,remoteAddr:E,timeline:{open:Date.now()},metrics:this.metrics?.dialerEvents}),we=isFirefox?"iceconnectionstatechange":"connectionstatechange";ce.addEventListener(we,()=>{switch(ce.connectionState){case"failed":case"disconnected":case"closed":ve.close().catch(Se=>{log$b.error("error closing connection",Se)}).finally(()=>{te.abort()});break}},{signal:re}),this.metrics?.dialerEvents.increment({peer_connection:!0});const ge=new DataChannelMuxerFactory({peerConnection:ce,metrics:this.metrics?.dialerEvents,dataChannelOptions:this.init.dataChannel});return await _e.secureInbound(fe,Ee,ie),ee.upgrader.upgradeOutbound(ve,{skipProtection:!0,skipEncryption:!0,muxerFactory:ge})}generateNoisePrologue(E,ee,te){if(E.getConfiguration().certificates?.length===0)throw invalidArgument("no local certificate");const re=getLocalFingerprint(E);if(re==null)throw invalidArgument("no local fingerprint found");const ne=re.trim().toLowerCase().replaceAll(":",""),ie=fromString$5(ne,"hex"),se=src$1.encode(ie,ee),oe=mbdecoder.decode(certhash(te)),ce=fromString$5("libp2p-webrtc-noise:");return concat$4([ce,se,oe])}}function validMa(J){const E=J.protoCodes();return E.includes(WEBRTC_CODE)&&E.includes(CERTHASH_CODE)&&J.getPeerId()!=null&&!E.includes(getProtocol("p2p-circuit").code)}function webRTCDirect(J){return E=>new WebRTCDirectTransport(E,J)}function webRTC(J){return E=>new WebRTCTransport(E,J)}const defaultLengthDecoder=J=>unsigned.decode(J);defaultLengthDecoder.bytes=0;function pbStream(J,E={}){const ee=pushable();J.sink(ee).catch(ie=>{ee.end(ie)}),J.sink=async ie=>{for await(const se of ie)ee.push(se)};let te=J.source;J.source[Symbol.iterator]!=null?te=J.source[Symbol.iterator]():J.source[Symbol.asyncIterator]!=null&&(te=J.source[Symbol.asyncIterator]());const re=new Uint8ArrayList,ne={read:async ie=>{if(ie==null){const{done:oe,value:ce}=await te.next();return oe===!0?new Uint8ArrayList:ce}for(;re.byteLength<ie;){const{value:oe,done:ce}=await te.next();if(ce===!0)throw errCode$1(new Error("unexpected end of input"),"ERR_UNEXPECTED_EOF");re.append(oe)}const se=re.sublist(0,ie);return re.consume(ie),se},readLP:async()=>{let ie=-1;const se=new Uint8ArrayList,oe=E?.lengthDecoder??defaultLengthDecoder;for(;;){se.append(await ne.read(1));try{ie=oe(se)}catch(ce){if(ce instanceof RangeError)continue;throw ce}if(ie>-1)break;if(E?.maxLengthLength!=null&&se.byteLength>E.maxLengthLength)throw errCode$1(new Error("message length length too long"),"ERR_MSG_LENGTH_TOO_LONG")}if(E?.maxDataLength!=null&&ie>E.maxDataLength)throw errCode$1(new Error("message length too long"),"ERR_MSG_DATA_TOO_LONG");return await ne.read(ie)},readPB:async ie=>{const se=await ne.readLP();if(se==null)throw new Error("Value is null");const oe=se instanceof Uint8Array?se:se.subarray();return ie.decode(oe)},write:ie=>{ie instanceof Uint8Array?ee.push(ie):ee.push(ie.subarray())},writeLP:ie=>{ne.write(encode$b.single(ie,E))},writePB:(ie,se)=>{ne.writeLP(se.encode(ie))},pb:ie=>({read:async()=>await ne.readPB(ie),write:se=>{ne.writePB(se,ie)},unwrap:()=>ne}),unwrap:()=>{const ie=J.source;return J.source=async function*(){yield*re,yield*ie}(),J}};return ne}async function*merge(...J){const E=pushable({objectMode:!0});Promise.resolve().then(async()=>{try{await Promise.all(J.map(async ee=>{for await(const te of ee)E.push(te)})),E.end()}catch(ee){E.end(ee)}}),yield*E}const rawPipe=(...J)=>{let E;for(;J.length>0;)E=J.shift()(E);return E},isIterable=J=>J!=null&&(typeof J[Symbol.asyncIterator]=="function"||typeof J[Symbol.iterator]=="function"||typeof J.next=="function"),isDuplex=J=>J!=null&&typeof J.sink=="function"&&isIterable(J.source),duplexPipelineFn=J=>E=>{const ee=J.sink(E);if(ee.then!=null){const te=pushable({objectMode:!0});return ee.then(()=>{te.end()},re=>{te.end(re)}),merge(te,async function*(){yield*J.source,te.end()}())}return J.source};function pipe(J,...E){if(isDuplex(J)){const te=J;J=()=>te.source}else if(isIterable(J)){const te=J;J=()=>te}const ee=[J,...E];if(ee.length>1&&isDuplex(ee[ee.length-1])&&(ee[ee.length-1]=ee[ee.length-1].sink),ee.length>2)for(let te=1;te<ee.length-1;te++)isDuplex(ee[te])&&(ee[te]=duplexPipelineFn(ee[te]));return rawPipe(...ee)}const MAX_LENGTH_LENGTH=8,MAX_DATA_LENGTH=1024*1024*4;var ReadMode;(function(J){J[J.LENGTH=0]="LENGTH",J[J.DATA=1]="DATA"})(ReadMode||(ReadMode={}));const defaultDecoder=J=>{const E=unsigned.decode(J);return defaultDecoder.bytes=unsigned.encodingLength(E),E};defaultDecoder.bytes=0;function decode(J){return async function*(E){const ee=new Uint8ArrayList;let te=ReadMode.LENGTH,re=-1;const ne=J?.lengthDecoder??defaultDecoder,ie=J?.maxLengthLength??MAX_LENGTH_LENGTH,se=J?.maxDataLength??MAX_DATA_LENGTH;for await(const oe of E)for(ee.append(oe);ee.byteLength>0;){if(te===ReadMode.LENGTH)try{if(re=ne(ee),re<0)throw errCode$1(new Error("invalid message length"),"ERR_INVALID_MSG_LENGTH");if(re>se)throw errCode$1(new Error("message length too long"),"ERR_MSG_DATA_TOO_LONG");const ce=ne.bytes;ee.consume(ce),J?.onLength!=null&&J.onLength(re),te=ReadMode.DATA}catch(ce){if(ce instanceof RangeError){if(ee.byteLength>ie)throw errCode$1(new Error("message length length too long"),"ERR_MSG_LENGTH_TOO_LONG");break}throw ce}if(te===ReadMode.DATA){if(ee.byteLength<re)break;const ce=ee.sublist(0,re);ee.consume(re),J?.onData!=null&&J.onData(ce),yield ce,te=ReadMode.LENGTH}}if(ee.byteLength>0)throw errCode$1(new Error("unexpected end of input"),"ERR_UNEXPECTED_EOF")}}decode.fromReader=(J,E)=>{let ee=1;const te=async function*(){for(;;)try{const{done:re,value:ne}=await J.next(ee);if(re===!0)return;ne!=null&&(yield ne)}catch(re){if(re.code==="ERR_UNDER_READ")return{done:!0,value:null};throw re}finally{ee=1}}();return decode({...E??{},onLength:re=>{ee=re}})(te)};const NOISE_MSG_MAX_LENGTH_BYTES=65535,NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG=NOISE_MSG_MAX_LENGTH_BYTES-16,DUMP_SESSION_KEYS=!!globalThis.process?.env?.DUMP_SESSION_KEYS;var hkdf={},hmac$1={},hash={};Object.defineProperty(hash,"__esModule",{value:!0});function isSerializableHash(J){return typeof J.saveState<"u"&&typeof J.restoreState<"u"&&typeof J.cleanSavedState<"u"}hash.isSerializableHash=isSerializableHash;Object.defineProperty(hmac$1,"__esModule",{value:!0});var hash_1=hash,constant_time_1=constantTime,wipe_1$1=wipe$1,HMAC=function(){function J(E,ee){this._finished=!1,this._inner=new E,this._outer=new E,this.blockSize=this._outer.blockSize,this.digestLength=this._outer.digestLength;var te=new Uint8Array(this.blockSize);ee.length>this.blockSize?this._inner.update(ee).finish(te).clean():te.set(ee);for(var re=0;re<te.length;re++)te[re]^=54;this._inner.update(te);for(var re=0;re<te.length;re++)te[re]^=106;this._outer.update(te),hash_1.isSerializableHash(this._inner)&&hash_1.isSerializableHash(this._outer)&&(this._innerKeyedState=this._inner.saveState(),this._outerKeyedState=this._outer.saveState()),wipe_1$1.wipe(te)}return J.prototype.reset=function(){if(!hash_1.isSerializableHash(this._inner)||!hash_1.isSerializableHash(this._outer))throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");return this._inner.restoreState(this._innerKeyedState),this._outer.restoreState(this._outerKeyedState),this._finished=!1,this},J.prototype.clean=function(){hash_1.isSerializableHash(this._inner)&&this._inner.cleanSavedState(this._innerKeyedState),hash_1.isSerializableHash(this._outer)&&this._outer.cleanSavedState(this._outerKeyedState),this._inner.clean(),this._outer.clean()},J.prototype.update=function(E){return this._inner.update(E),this},J.prototype.finish=function(E){return this._finished?(this._outer.finish(E),this):(this._inner.finish(E),this._outer.update(E.subarray(0,this.digestLength)).finish(E),this._finished=!0,this)},J.prototype.digest=function(){var E=new Uint8Array(this.digestLength);return this.finish(E),E},J.prototype.saveState=function(){if(!hash_1.isSerializableHash(this._inner))throw new Error("hmac: can't saveState() because hash doesn't implement it");return this._inner.saveState()},J.prototype.restoreState=function(E){if(!hash_1.isSerializableHash(this._inner)||!hash_1.isSerializableHash(this._outer))throw new Error("hmac: can't restoreState() because hash doesn't implement it");return this._inner.restoreState(E),this._outer.restoreState(this._outerKeyedState),this._finished=!1,this},J.prototype.cleanSavedState=function(E){if(!hash_1.isSerializableHash(this._inner))throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");this._inner.cleanSavedState(E)},J}();hmac$1.HMAC=HMAC;function hmac(J,E,ee){var te=new HMAC(J,E);te.update(ee);var re=te.digest();return te.clean(),re}hmac$1.hmac=hmac;hmac$1.equal=constant_time_1.equal;Object.defineProperty(hkdf,"__esModule",{value:!0});var hmac_1=hmac$1,wipe_1=wipe$1,HKDF=function(){function J(E,ee,te,re){te===void 0&&(te=new Uint8Array(0)),this._counter=new Uint8Array(1),this._hash=E,this._info=re;var ne=hmac_1.hmac(this._hash,te,ee);this._hmac=new hmac_1.HMAC(E,ne),this._buffer=new Uint8Array(this._hmac.digestLength),this._bufpos=this._buffer.length}return J.prototype._fillBuffer=function(){this._counter[0]++;var E=this._counter[0];if(E===0)throw new Error("hkdf: cannot expand more");this._hmac.reset(),E>1&&this._hmac.update(this._buffer),this._info&&this._hmac.update(this._info),this._hmac.update(this._counter),this._hmac.finish(this._buffer),this._bufpos=0},J.prototype.expand=function(E){for(var ee=new Uint8Array(E),te=0;te<ee.length;te++)this._bufpos===this._buffer.length&&this._fillBuffer(),ee[te]=this._buffer[this._bufpos++];return ee},J.prototype.clean=function(){this._hmac.clean(),wipe_1.wipe(this._buffer),wipe_1.wipe(this._counter),this._bufpos=0},J}(),HKDF_1=hkdf.HKDF=HKDF,sha256={};(function(J){Object.defineProperty(J,"__esModule",{value:!0});var E=binary,ee=wipe$1;J.DIGEST_LENGTH=32,J.BLOCK_SIZE=64;var te=function(){function se(){this.digestLength=J.DIGEST_LENGTH,this.blockSize=J.BLOCK_SIZE,this._state=new Int32Array(8),this._temp=new Int32Array(64),this._buffer=new Uint8Array(128),this._bufferLength=0,this._bytesHashed=0,this._finished=!1,this.reset()}return se.prototype._initState=function(){this._state[0]=1779033703,this._state[1]=3144134277,this._state[2]=1013904242,this._state[3]=2773480762,this._state[4]=1359893119,this._state[5]=2600822924,this._state[6]=528734635,this._state[7]=1541459225},se.prototype.reset=function(){return this._initState(),this._bufferLength=0,this._bytesHashed=0,this._finished=!1,this},se.prototype.clean=function(){ee.wipe(this._buffer),ee.wipe(this._temp),this.reset()},se.prototype.update=function(oe,ce){if(ce===void 0&&(ce=oe.length),this._finished)throw new Error("SHA256: can't update because hash was finished.");var ae=0;if(this._bytesHashed+=ce,this._bufferLength>0){for(;this._bufferLength<this.blockSize&&ce>0;)this._buffer[this._bufferLength++]=oe[ae++],ce--;this._bufferLength===this.blockSize&&(ne(this._temp,this._state,this._buffer,0,this.blockSize),this._bufferLength=0)}for(ce>=this.blockSize&&(ae=ne(this._temp,this._state,oe,ae,ce),ce%=this.blockSize);ce>0;)this._buffer[this._bufferLength++]=oe[ae++],ce--;return this},se.prototype.finish=function(oe){if(!this._finished){var ce=this._bytesHashed,ae=this._bufferLength,le=ce/536870912|0,ue=ce<<3,he=ce%64<56?64:128;this._buffer[ae]=128;for(var pe=ae+1;pe<he-8;pe++)this._buffer[pe]=0;E.writeUint32BE(le,this._buffer,he-8),E.writeUint32BE(ue,this._buffer,he-4),ne(this._temp,this._state,this._buffer,0,he),this._finished=!0}for(var pe=0;pe<this.digestLength/4;pe++)E.writeUint32BE(this._state[pe],oe,pe*4);return this},se.prototype.digest=function(){var oe=new Uint8Array(this.digestLength);return this.finish(oe),oe},se.prototype.saveState=function(){if(this._finished)throw new Error("SHA256: cannot save finished state");return{state:new Int32Array(this._state),buffer:this._bufferLength>0?new Uint8Array(this._buffer):void 0,bufferLength:this._bufferLength,bytesHashed:this._bytesHashed}},se.prototype.restoreState=function(oe){return this._state.set(oe.state),this._bufferLength=oe.bufferLength,oe.buffer&&this._buffer.set(oe.buffer),this._bytesHashed=oe.bytesHashed,this._finished=!1,this},se.prototype.cleanSavedState=function(oe){ee.wipe(oe.state),oe.buffer&&ee.wipe(oe.buffer),oe.bufferLength=0,oe.bytesHashed=0},se}();J.SHA256=te;var re=new Int32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]);function ne(se,oe,ce,ae,le){for(;le>=64;){for(var ue=oe[0],he=oe[1],pe=oe[2],de=oe[3],fe=oe[4],me=oe[5],_e=oe[6],be=oe[7],Ee=0;Ee<16;Ee++){var ve=ae+Ee*4;se[Ee]=E.readUint32BE(ce,ve)}for(var Ee=16;Ee<64;Ee++){var we=se[Ee-2],ge=(we>>>17|we<<32-17)^(we>>>19|we<<32-19)^we>>>10;we=se[Ee-15];var Se=(we>>>7|we<<32-7)^(we>>>18|we<<32-18)^we>>>3;se[Ee]=(ge+se[Ee-7]|0)+(Se+se[Ee-16]|0)}for(var Ee=0;Ee<64;Ee++){var ge=(((fe>>>6|fe<<26)^(fe>>>11|fe<<21)^(fe>>>25|fe<<7))+(fe&me^~fe&_e)|0)+(be+(re[Ee]+se[Ee]|0)|0)|0,Se=((ue>>>2|ue<<32-2)^(ue>>>13|ue<<32-13)^(ue>>>22|ue<<32-22))+(ue&he^ue&pe^he&pe)|0;be=_e,_e=me,me=fe,fe=de+ge|0,de=pe,pe=he,he=ue,ue=ge+Se|0}oe[0]+=ue,oe[1]+=he,oe[2]+=pe,oe[3]+=de,oe[4]+=fe,oe[5]+=me,oe[6]+=_e,oe[7]+=be,ae+=64,le-=64}return ae}function ie(se){var oe=new te;oe.update(se);var ce=oe.digest();return oe.clean(),ce}J.hash=ie})(sha256);const stablelib={hashSHA256(J){return sha256.hash(J)},getHKDF(J,E){const ee=new HKDF_1(sha256.SHA256,E,J).expand(96),te=ee.subarray(0,32),re=ee.subarray(32,64),ne=ee.subarray(64,96);return[te,re,ne]},generateX25519KeyPair(){const J=x25519.generateKeyPair();return{publicKey:J.publicKey,privateKey:J.secretKey}},generateX25519KeyPairFromSeed(J){const E=x25519.generateKeyPairFromSeed(J);return{publicKey:E.publicKey,privateKey:E.secretKey}},generateX25519SharedKey(J,E){return x25519.sharedKey(J,E)},chaCha20Poly1305Encrypt(J,E,ee,te){return new chacha20poly1305.ChaCha20Poly1305(te).seal(E,J,ee)},chaCha20Poly1305Decrypt(J,E,ee,te,re){return new chacha20poly1305.ChaCha20Poly1305(te).open(E,J,ee,re)}},allocUnsafe=J=>globalThis.Buffer?globalThis.Buffer.allocUnsafe(J):new Uint8Array(J),uint16BEEncode=J=>{const E=allocUnsafe(2);return new DataView(E.buffer,E.byteOffset,E.byteLength).setUint16(0,J,!1),E};uint16BEEncode.bytes=2;const uint16BEDecode=J=>{if(J.length<2)throw RangeError("Could not decode int16BE");return J instanceof Uint8Array?new DataView(J.buffer,J.byteOffset,J.byteLength).getUint16(0,!1):J.getUint16(0)};uint16BEDecode.bytes=2;function encode0(J){return concat$4([J.ne,J.ciphertext],J.ne.length+J.ciphertext.length)}function encode1(J){return concat$4([J.ne,J.ns,J.ciphertext],J.ne.length+J.ns.length+J.ciphertext.length)}function encode2(J){return concat$4([J.ns,J.ciphertext],J.ns.length+J.ciphertext.length)}function decode0(J){if(J.length<32)throw new Error("Cannot decode stage 0 MessageBuffer: length less than 32 bytes.");return{ne:J.subarray(0,32),ciphertext:J.subarray(32,J.length),ns:new Uint8Array(0)}}function decode1(J){if(J.length<80)throw new Error("Cannot decode stage 1 MessageBuffer: length less than 80 bytes.");return{ne:J.subarray(0,32),ns:J.subarray(32,80),ciphertext:J.subarray(80,J.length)}}function decode2(J){if(J.length<48)throw new Error("Cannot decode stage 2 MessageBuffer: length less than 48 bytes.");return{ne:new Uint8Array(0),ns:J.subarray(0,48),ciphertext:J.subarray(48,J.length)}}function encryptStream(J,E){return async function*(ee){for await(const te of ee)for(let re=0;re<te.length;re+=NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG){let ne=re+NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;ne>te.length&&(ne=te.length);const ie=J.encrypt(te.subarray(re,ne),J.session);E?.encryptedPackets.increment(),yield uint16BEEncode(ie.byteLength),yield ie}}}function decryptStream(J,E){return async function*(ee){for await(const te of ee)for(let re=0;re<te.length;re+=NOISE_MSG_MAX_LENGTH_BYTES){let ne=re+NOISE_MSG_MAX_LENGTH_BYTES;if(ne>te.length&&(ne=te.length),ne-chacha20poly1305.TAG_LENGTH<re)throw new Error("Invalid chunk");const ie=te.subarray(re,ne),se=te.subarray(re,ne-chacha20poly1305.TAG_LENGTH),{plaintext:oe,valid:ce}=J.decrypt(ie,J.session,se);if(!ce)throw E?.decryptErrors.increment(),new Error("Failed to validate decrypted chunk");E?.decryptedPackets.increment(),yield oe}}}class UnexpectedPeerError extends Error{constructor(E="Unexpected Peer"){super(E),this.code=UnexpectedPeerError.code}static get code(){return"ERR_UNEXPECTED_PEER"}}class InvalidCryptoExchangeError extends Error{constructor(E="Invalid crypto exchange"){super(E),this.code=InvalidCryptoExchangeError.code}static get code(){return"ERR_INVALID_CRYPTO_EXCHANGE"}}var NoiseExtensions;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{if(re.lengthDelimited!==!1&&te.fork(),ee.webtransportCerthashes!=null)for(const ne of ee.webtransportCerthashes)te.uint32(10),te.bytes(ne);re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={webtransportCerthashes:[]},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.webtransportCerthashes.push(ee.bytes());break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage$1(ee,J.codec())})(NoiseExtensions||(NoiseExtensions={}));var NoiseHandshakePayload;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{re.lengthDelimited!==!1&&te.fork(),(re.writeDefaults===!0||ee.identityKey!=null&&ee.identityKey.byteLength>0)&&(te.uint32(10),te.bytes(ee.identityKey??new Uint8Array(0))),(re.writeDefaults===!0||ee.identitySig!=null&&ee.identitySig.byteLength>0)&&(te.uint32(18),te.bytes(ee.identitySig??new Uint8Array(0))),ee.extensions!=null&&(te.uint32(34),NoiseExtensions.codec().encode(ee.extensions,te,{writeDefaults:!1})),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={identityKey:new Uint8Array(0),identitySig:new Uint8Array(0)},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.identityKey=ee.bytes();break;case 2:re.identitySig=ee.bytes();break;case 4:re.extensions=NoiseExtensions.codec().decode(ee,ee.uint32());break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage$1(ee,J.codec())})(NoiseHandshakePayload||(NoiseHandshakePayload={}));async function getPayload(J,E,ee){const te=await signPayload(J,getHandshakePayload(E));if(J.publicKey==null)throw new Error("PublicKey was missing from local PeerId");return createHandshakePayload(J.publicKey,te,ee)}function createHandshakePayload(J,E,ee){return NoiseHandshakePayload.encode({identityKey:J,identitySig:E,extensions:ee??{webtransportCerthashes:[]}}).subarray()}async function signPayload(J,E){if(J.privateKey==null)throw new Error("PrivateKey was missing from PeerId");return await(await unmarshalPrivateKey(J.privateKey)).sign(E)}async function getPeerIdFromPayload(J){return await peerIdFromKeys(J.identityKey)}function decodePayload(J){return NoiseHandshakePayload.decode(J)}function getHandshakePayload(J){const E=fromString$5("noise-libp2p-static-key:");return concat$4([E,J],E.length+J.length)}async function verifySignedPayload(J,E,ee){const te=await peerIdFromKeys(E.identityKey);if(!te.equals(ee))throw new Error(`Payload identity key ${te.toString()} does not match expected remote peer ${ee.toString()}`);const re=getHandshakePayload(J);if(te.publicKey==null)throw new Error("PublicKey was missing from PeerId");if(E.identitySig==null)throw new Error("Signature was missing from message");if(!await unmarshalPublicKey(te.publicKey).verify(re,E.identitySig))throw new Error("Static key doesn't match to peer that signed payload!");return te}function isValidPublicKey(J){return!(!(J instanceof Uint8Array)||J.length!==32)}const log$a=logger$1("libp2p:noise");let keyLogger;DUMP_SESSION_KEYS?keyLogger=log$a:keyLogger=Object.assign(()=>{},{enabled:!1,trace:()=>{},error:()=>{}});function logLocalStaticKeys(J){keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${toString$5(J.publicKey,"hex")}`),keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${toString$5(J.privateKey,"hex")}`)}function logLocalEphemeralKeys(J){J?(keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${toString$5(J.publicKey,"hex")}`),keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${toString$5(J.privateKey,"hex")}`)):keyLogger("Missing local ephemeral keys.")}function logRemoteStaticKey(J){keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${toString$5(J,"hex")}`)}function logRemoteEphemeralKey(J){keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${toString$5(J,"hex")}`)}function logCipherState(J){J.cs1&&J.cs2?(keyLogger(`CIPHER_STATE_1 ${J.cs1.n.getUint64()} ${toString$5(J.cs1.k,"hex")}`),keyLogger(`CIPHER_STATE_2 ${J.cs2.n.getUint64()} ${toString$5(J.cs2.k,"hex")}`)):keyLogger("Missing cipher state.")}const MIN_NONCE=0,MAX_NONCE=4294967295,ERR_MAX_NONCE="Cipherstate has reached maximum n, a new handshake must be performed";class Nonce{constructor(E=MIN_NONCE){this.n=E,this.bytes=new Uint8Array(12),this.view=new DataView(this.bytes.buffer,this.bytes.byteOffset,this.bytes.byteLength),this.view.setUint32(4,E,!0)}increment(){this.n++,this.view.setUint32(4,this.n,!0)}getBytes(){return this.bytes}getUint64(){return this.n}assertValue(){if(this.n>MAX_NONCE)throw new Error(ERR_MAX_NONCE)}}class AbstractHandshake{constructor(E){this.crypto=E}encryptWithAd(E,ee,te){const re=this.encrypt(E.k,E.n,ee,te);return E.n.increment(),re}decryptWithAd(E,ee,te,re){const{plaintext:ne,valid:ie}=this.decrypt(E.k,E.n,ee,te,re);return ie&&E.n.increment(),{plaintext:ne,valid:ie}}hasKey(E){return!this.isEmptyKey(E.k)}createEmptyKey(){return new Uint8Array(32)}isEmptyKey(E){const ee=this.createEmptyKey();return equals(ee,E)}encrypt(E,ee,te,re){return ee.assertValue(),this.crypto.chaCha20Poly1305Encrypt(re,ee.getBytes(),te,E)}encryptAndHash(E,ee){let te;return this.hasKey(E.cs)?te=this.encryptWithAd(E.cs,E.h,ee):te=ee,this.mixHash(E,te),te}decrypt(E,ee,te,re,ne){ee.assertValue();const ie=this.crypto.chaCha20Poly1305Decrypt(re,ee.getBytes(),te,E,ne);return ie?{plaintext:ie,valid:!0}:{plaintext:new Uint8Array(0),valid:!1}}decryptAndHash(E,ee){let te,re=!0;return this.hasKey(E.cs)?{plaintext:te,valid:re}=this.decryptWithAd(E.cs,E.h,ee):te=ee,this.mixHash(E,ee),{plaintext:te,valid:re}}dh(E,ee){try{const te=this.crypto.generateX25519SharedKey(E,ee);return te.length===32?te:te.subarray(0,32)}catch(te){const re=te;return log$a.error(re),new Uint8Array(32)}}mixHash(E,ee){E.h=this.getHash(E.h,ee)}getHash(E,ee){return this.crypto.hashSHA256(concat$4([E,ee],E.length+ee.length))}mixKey(E,ee){const[te,re]=this.crypto.getHKDF(E.ck,ee);E.cs=this.initializeKey(re),E.ck=te}initializeKey(E){return{k:E,n:new Nonce}}initializeSymmetric(E){const ee=fromString$5(E,"utf-8"),te=this.hashProtocolName(ee),re=te,ne=this.createEmptyKey();return{cs:this.initializeKey(ne),ck:re,h:te}}hashProtocolName(E){if(E.length<=32){const ee=new Uint8Array(32);return ee.set(E),ee}else return this.getHash(E,new Uint8Array(0))}split(E){const[ee,te]=this.crypto.getHKDF(E.ck,new Uint8Array(0)),re=this.initializeKey(ee),ne=this.initializeKey(te);return{cs1:re,cs2:ne}}writeMessageRegular(E,ee){const te=this.encryptWithAd(E,new Uint8Array(0),ee),re=this.createEmptyKey(),ne=new Uint8Array(0);return{ne:re,ns:ne,ciphertext:te}}readMessageRegular(E,ee){return this.decryptWithAd(E,new Uint8Array(0),ee.ciphertext)}}class XX extends AbstractHandshake{initializeInitiator(E,ee,te,re){const ne="Noise_XX_25519_ChaChaPoly_SHA256",ie=this.initializeSymmetric(ne);this.mixHash(ie,E);const se=new Uint8Array(32);return{ss:ie,s:ee,rs:te,psk:re,re:se}}initializeResponder(E,ee,te,re){const ne="Noise_XX_25519_ChaChaPoly_SHA256",ie=this.initializeSymmetric(ne);this.mixHash(ie,E);const se=new Uint8Array(32);return{ss:ie,s:ee,rs:te,psk:re,re:se}}writeMessageA(E,ee,te){const re=new Uint8Array(0);te!==void 0?E.e=te:E.e=this.crypto.generateX25519KeyPair();const ne=E.e.publicKey;this.mixHash(E.ss,ne);const ie=this.encryptAndHash(E.ss,ee);return{ne,ns:re,ciphertext:ie}}writeMessageB(E,ee){E.e=this.crypto.generateX25519KeyPair();const te=E.e.publicKey;this.mixHash(E.ss,te),this.mixKey(E.ss,this.dh(E.e.privateKey,E.re));const re=E.s.publicKey,ne=this.encryptAndHash(E.ss,re);this.mixKey(E.ss,this.dh(E.s.privateKey,E.re));const ie=this.encryptAndHash(E.ss,ee);return{ne:te,ns:ne,ciphertext:ie}}writeMessageC(E,ee){const te=E.s.publicKey,re=this.encryptAndHash(E.ss,te);this.mixKey(E.ss,this.dh(E.s.privateKey,E.re));const ne=this.encryptAndHash(E.ss,ee),ie={ne:this.createEmptyKey(),ns:re,ciphertext:ne},{cs1:se,cs2:oe}=this.split(E.ss);return{h:E.ss.h,messageBuffer:ie,cs1:se,cs2:oe}}readMessageA(E,ee){return isValidPublicKey(ee.ne)&&(E.re=ee.ne),this.mixHash(E.ss,E.re),this.decryptAndHash(E.ss,ee.ciphertext)}readMessageB(E,ee){if(isValidPublicKey(ee.ne)&&(E.re=ee.ne),this.mixHash(E.ss,E.re),!E.e)throw new Error("Handshake state `e` param is missing.");this.mixKey(E.ss,this.dh(E.e.privateKey,E.re));const{plaintext:te,valid:re}=this.decryptAndHash(E.ss,ee.ns);re&&isValidPublicKey(te)&&(E.rs=te),this.mixKey(E.ss,this.dh(E.e.privateKey,E.rs));const{plaintext:ne,valid:ie}=this.decryptAndHash(E.ss,ee.ciphertext);return{plaintext:ne,valid:re&&ie}}readMessageC(E,ee){const{plaintext:te,valid:re}=this.decryptAndHash(E.ss,ee.ns);if(re&&isValidPublicKey(te)&&(E.rs=te),!E.e)throw new Error("Handshake state `e` param is missing.");this.mixKey(E.ss,this.dh(E.e.privateKey,E.rs));const{plaintext:ne,valid:ie}=this.decryptAndHash(E.ss,ee.ciphertext),{cs1:se,cs2:oe}=this.split(E.ss);return{h:E.ss.h,plaintext:ne,valid:re&&ie,cs1:se,cs2:oe}}initSession(E,ee,te){const re=this.createEmptyKey(),ne=new Uint8Array(32);let ie;return E?ie=this.initializeInitiator(ee,te,ne,re):ie=this.initializeResponder(ee,te,ne,re),{hs:ie,i:E,mc:0}}sendMessage(E,ee,te){let re;if(E.mc===0)re=this.writeMessageA(E.hs,ee,te);else if(E.mc===1)re=this.writeMessageB(E.hs,ee);else if(E.mc===2){const{h:ne,messageBuffer:ie,cs1:se,cs2:oe}=this.writeMessageC(E.hs,ee);re=ie,E.h=ne,E.cs1=se,E.cs2=oe}else if(E.mc>2)if(E.i){if(!E.cs1)throw new Error("CS1 (cipher state) is not defined");re=this.writeMessageRegular(E.cs1,ee)}else{if(!E.cs2)throw new Error("CS2 (cipher state) is not defined");re=this.writeMessageRegular(E.cs2,ee)}else throw new Error("Session invalid.");return E.mc++,re}recvMessage(E,ee){let te=new Uint8Array(0),re=!1;if(E.mc===0)({plaintext:te,valid:re}=this.readMessageA(E.hs,ee));else if(E.mc===1)({plaintext:te,valid:re}=this.readMessageB(E.hs,ee));else if(E.mc===2){const{h:ne,plaintext:ie,valid:se,cs1:oe,cs2:ce}=this.readMessageC(E.hs,ee);te=ie,re=se,E.h=ne,E.cs1=oe,E.cs2=ce}return E.mc++,{plaintext:te,valid:re}}}class XXHandshake{constructor(E,ee,te,re,ne,ie,se,oe){this.remoteExtensions={webtransportCerthashes:[]},this.isInitiator=E,this.payload=ee,this.prologue=te,this.staticKeypair=ne,this.connection=ie,se&&(this.remotePeer=se),this.xx=oe??new XX(re),this.session=this.xx.initSession(this.isInitiator,this.prologue,this.staticKeypair)}async propose(){if(logLocalStaticKeys(this.session.hs.s),this.isInitiator){log$a.trace("Stage 0 - Initiator starting to send first message.");const E=this.xx.sendMessage(this.session,new Uint8Array(0));this.connection.writeLP(encode0(E)),log$a.trace("Stage 0 - Initiator finished sending first message."),logLocalEphemeralKeys(this.session.hs.e)}else{log$a.trace("Stage 0 - Responder waiting to receive first message...");const E=decode0((await this.connection.readLP()).subarray()),{valid:ee}=this.xx.recvMessage(this.session,E);if(!ee)throw new InvalidCryptoExchangeError("xx handshake stage 0 validation fail");log$a.trace("Stage 0 - Responder received first message."),logRemoteEphemeralKey(this.session.hs.re)}}async exchange(){if(this.isInitiator){log$a.trace("Stage 1 - Initiator waiting to receive first message from responder...");const E=decode1((await this.connection.readLP()).subarray()),{plaintext:ee,valid:te}=this.xx.recvMessage(this.session,E);if(!te)throw new InvalidCryptoExchangeError("xx handshake stage 1 validation fail");log$a.trace("Stage 1 - Initiator received the message."),logRemoteEphemeralKey(this.session.hs.re),logRemoteStaticKey(this.session.hs.rs),log$a.trace("Initiator going to check remote's signature...");try{const re=decodePayload(ee);this.remotePeer=this.remotePeer||await getPeerIdFromPayload(re),await verifySignedPayload(this.session.hs.rs,re,this.remotePeer),this.setRemoteNoiseExtension(re.extensions)}catch(re){const ne=re;throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${ne.message}`)}log$a.trace("All good with the signature!")}else{log$a.trace("Stage 1 - Responder sending out first message with signed payload and static key.");const E=this.xx.sendMessage(this.session,this.payload);this.connection.writeLP(encode1(E)),log$a.trace("Stage 1 - Responder sent the second handshake message with signed payload."),logLocalEphemeralKeys(this.session.hs.e)}}async finish(){if(this.isInitiator){log$a.trace("Stage 2 - Initiator sending third handshake message.");const E=this.xx.sendMessage(this.session,this.payload);this.connection.writeLP(encode2(E)),log$a.trace("Stage 2 - Initiator sent message with signed payload.")}else{log$a.trace("Stage 2 - Responder waiting for third handshake message...");const E=decode2((await this.connection.readLP()).subarray()),{plaintext:ee,valid:te}=this.xx.recvMessage(this.session,E);if(!te)throw new InvalidCryptoExchangeError("xx handshake stage 2 validation fail");log$a.trace("Stage 2 - Responder received the message, finished handshake.");try{const re=decodePayload(ee);this.remotePeer=this.remotePeer||await getPeerIdFromPayload(re),await verifySignedPayload(this.session.hs.rs,re,this.remotePeer),this.setRemoteNoiseExtension(re.extensions)}catch(re){const ne=re;throw new UnexpectedPeerError(`Error occurred while verifying signed payload: ${ne.message}`)}}logCipherState(this.session)}encrypt(E,ee){const te=this.getCS(ee);return this.xx.encryptWithAd(te,new Uint8Array(0),E)}decrypt(E,ee,te){const re=this.getCS(ee,!1);return this.xx.decryptWithAd(re,new Uint8Array(0),E,te)}getRemoteStaticKey(){return this.session.hs.rs}getCS(E,ee=!0){if(!E.cs1||!E.cs2)throw new InvalidCryptoExchangeError("Handshake not completed properly, cipher state does not exist.");return this.isInitiator?ee?E.cs1:E.cs2:ee?E.cs2:E.cs1}setRemoteNoiseExtension(E){E&&(this.remoteExtensions=E)}}function registerMetrics(J){return{xxHandshakeSuccesses:J.registerCounter("libp2p_noise_xxhandshake_successes_total",{help:"Total count of noise xxHandshakes successes_"}),xxHandshakeErrors:J.registerCounter("libp2p_noise_xxhandshake_error_total",{help:"Total count of noise xxHandshakes errors"}),encryptedPackets:J.registerCounter("libp2p_noise_encrypted_packets_total",{help:"Total count of noise encrypted packets successfully"}),decryptedPackets:J.registerCounter("libp2p_noise_decrypted_packets_total",{help:"Total count of noise decrypted packets"}),decryptErrors:J.registerCounter("libp2p_noise_decrypt_errors_total",{help:"Total count of noise decrypt errors"})}}class Noise{constructor(E={}){this.protocol="/noise";const{staticNoiseKey:ee,extensions:te,crypto:re,prologueBytes:ne,metrics:ie}=E;this.crypto=re??stablelib,this.extensions=te,this.metrics=ie?registerMetrics(ie):void 0,ee?this.staticKeys=this.crypto.generateX25519KeyPairFromSeed(ee):this.staticKeys=this.crypto.generateX25519KeyPair(),this.prologue=ne??new Uint8Array(0)}async secureOutbound(E,ee,te){const re=pbStream(ee,{lengthEncoder:uint16BEEncode,lengthDecoder:uint16BEDecode,maxDataLength:NOISE_MSG_MAX_LENGTH_BYTES}),ne=await this.performHandshake({connection:re,isInitiator:!0,localPeer:E,remotePeer:te});return{conn:await this.createSecureConnection(re,ne),remoteExtensions:ne.remoteExtensions,remotePeer:ne.remotePeer}}async secureInbound(E,ee,te){const re=pbStream(ee,{lengthEncoder:uint16BEEncode,lengthDecoder:uint16BEDecode,maxDataLength:NOISE_MSG_MAX_LENGTH_BYTES}),ne=await this.performHandshake({connection:re,isInitiator:!1,localPeer:E,remotePeer:te});return{conn:await this.createSecureConnection(re,ne),remotePeer:ne.remotePeer,remoteExtensions:ne.remoteExtensions}}async performHandshake(E){const ee=await getPayload(E.localPeer,this.staticKeys.publicKey,this.extensions);return await this.performXXHandshake(E,ee)}async performXXHandshake(E,ee){const{isInitiator:te,remotePeer:re,connection:ne}=E,ie=new XXHandshake(te,ee,this.prologue,this.crypto,this.staticKeys,ne,re);try{await ie.propose(),await ie.exchange(),await ie.finish(),this.metrics?.xxHandshakeSuccesses.increment()}catch(se){if(this.metrics?.xxHandshakeErrors.increment(),se instanceof Error)throw se.message=`Error occurred during XX handshake: ${se.message}`,se}return ie}async createSecureConnection(E,ee){const[te,re]=duplexPair(),ne=E.unwrap();return await pipe(te,encryptStream(ee,this.metrics),ne,decode({lengthDecoder:uint16BEDecode}),decryptStream(ee,this.metrics),te),re}}function noise(J={}){return()=>new Noise(J)}const log$9=logger$1("libp2p:webtransport"),multibaseDecoder=Object.values(bases$1).map(J=>J.decoder).reduce((J,E)=>J.or(E));function decodeCerthashStr(J){return decode$f(multibaseDecoder.decode(J))}function inertDuplex(){return{source:{[Symbol.asyncIterator](){return{async next(){return new Promise(()=>{})}}}},sink:async J=>new Promise(()=>{})}}async function webtransportBiDiStreamToStream(J,E,ee,te,re){const ne=J.writable.getWriter(),ie=J.readable.getReader();await ne.ready;function se(){const ue=te.findIndex(he=>he===le);ue!==-1&&(te.splice(ue,1),le.stat.timeline.close=Date.now(),re?.(le))}let oe=!1,ce=!1;(async function(){const ue=await ne.closed.catch(he=>he);if(ue!=null){const he=ue.message;he.includes("aborted by the remote server")||he.includes("STOP_SENDING")||log$9.error(`WebTransport writer closed unexpectedly: streamId=${E} err=${ue.message}`)}oe=!0,oe&&ce&&se()})().catch(()=>{log$9.error("WebTransport failed to cleanup closed stream")}),async function(){const ue=await ie.closed.catch(he=>he);ue!=null&&log$9.error(`WebTransport reader closed unexpectedly: streamId=${E} err=${ue.message}`),ce=!0,oe&&ce&&se()}().catch(()=>{log$9.error("WebTransport failed to cleanup closed stream")});let ae=!1;const le={id:E,abort(ue){oe||(ne.abort(),oe=!0),le.closeRead(),ce=!0,se()},close(){le.closeRead(),le.closeWrite(),se()},closeRead(){ce||(ie.cancel().catch(ue=>{ue.toString().includes("RESET_STREAM")===!0&&(oe=!0)}),ce=!0),oe&&se()},closeWrite(){oe||(oe=!0,ne.close().catch(ue=>{ue.toString().includes("RESET_STREAM")===!0&&(ce=!0)})),ce&&se()},reset(){le.close()},stat:{direction:ee,timeline:{open:Date.now()}},metadata:{},source:async function*(){for(;;){const ue=await ie.read();if(ue.done===!0){ce=!0,oe&&se();return}yield new Uint8ArrayList(ue.value)}}(),sink:async function(ue){if(ae)throw new Error("sink already called on stream");ae=!0;try{for await(const he of ue)if(he instanceof Uint8Array)await ne.write(he);else for(const pe of he)await ne.write(pe)}finally{le.closeWrite()}}};return le}function parseMultiaddr(J){const E=J.stringTuples(),{url:ee,certhashes:te,remotePeer:re}=E.reduce((ne,[ie,se])=>{switch(ie){case getProtocol("ip6").code:case getProtocol("dns6").code:se?.includes(":")===!0&&(se=`[${se}]`);case getProtocol("ip4").code:case getProtocol("dns4").code:if(ne.seenHost||ne.seenPort)throw new Error("Invalid multiaddr, saw host and already saw the host or port");return{...ne,url:`${ne.url}${se??""}`,seenHost:!0};case getProtocol("quic").code:case getProtocol("quic-v1").code:case getProtocol("webtransport").code:if(!ne.seenHost||!ne.seenPort)throw new Error("Invalid multiaddr, Didn't see host and port, but saw quic/webtransport");return ne;case getProtocol("udp").code:if(ne.seenPort)throw new Error("Invalid multiaddr, saw port but already saw the port");return{...ne,url:`${ne.url}:${se??""}`,seenPort:!0};case getProtocol("certhash").code:if(!ne.seenHost||!ne.seenPort)throw new Error("Invalid multiaddr, saw the certhash before seeing the host and port");return{...ne,certhashes:ne.certhashes.concat([decodeCerthashStr(se??"")])};case getProtocol("p2p").code:return{...ne,remotePeer:peerIdFromString(se??"")};default:throw new Error(`unexpected component in multiaddr: ${ie} ${getProtocol(ie).name} ${se??""} `)}},{url:"https://",seenHost:!1,seenPort:!1,certhashes:[]});return{url:ee,certhashes:te,remotePeer:re}}function isSubset(J,E){return E.filter(ee=>!!J.find(te=>{if(ee.length!==te.length)return!1;for(let re=0;re<ee.length;re++)if(te[re]!==ee[re])return!1;return!0})).length===E.length}class WebTransportTransport{components;config;constructor(E,ee={}){this.components=E,this.config={maxInboundStreams:ee.maxInboundStreams??1e3}}[Symbol.toStringTag]="@libp2p/webtransport";[symbol$2]=!0;async dial(E,ee){log$9("dialing %s",E);const te=this.components.peerId;if(te===void 0)throw new Error("Need a local peerid");ee=ee??{};const{url:re,certhashes:ne,remotePeer:ie}=parseMultiaddr(E);if(ne.length===0)throw new Error("Expected multiaddr to contain certhashes");const se=new WebTransport(`${re}/.well-known/libp2p-webtransport?type=noise`,{serverCertificateHashes:ne.map(ce=>({algorithm:"sha-256",value:ce.digest}))});if(se.closed.catch(ce=>{log$9.error("WebTransport transport closed due to:",ce)}),await se.ready,ie==null)throw new Error("Need a target peerid");if(!await this.authenticateWebTransport(se,te,ie,ne))throw new Error("Failed to authenticate webtransport");const oe={close:async ce=>{ce!=null&&log$9("Closing webtransport with err:",ce),se.close()},remoteAddr:E,timeline:{open:Date.now()},...inertDuplex()};se.closed.catch(ce=>{log$9.error("WebTransport connection closed:",ce),oe.timeline.close=Date.now()});try{ee?.signal?.throwIfAborted()}catch(ce){throw se.close(),ce}return ee.upgrader.upgradeOutbound(oe,{skipEncryption:!0,muxerFactory:this.webtransportMuxer(se),skipProtection:!0})}async authenticateWebTransport(E,ee,te,re){const ne=await E.createBidirectionalStream(),ie=ne.writable.getWriter(),se=ne.readable.getReader();await ie.ready;const oe={source:async function*(){for(;;){const le=await se.read();if(le.value!=null&&(yield le.value),le.done===!0)break}}(),sink:async function(le){for await(const ue of le)await ie.write(ue)}},ce=noise()(),{remoteExtensions:ae}=await ce.secureOutbound(ee,oe,te);if(ie.close().catch(le=>{log$9.error(`Failed to close authentication stream writer: ${le.message}`)}),se.cancel().catch(le=>{log$9.error(`Failed to close authentication stream reader: ${le.message}`)}),!isSubset(ae?.webtransportCerthashes??[],re.map(le=>le.bytes)))throw new Error("Our certhashes are not a subset of the remote's reported certhashes");return!0}webtransportMuxer(E){let ee=0;const te=this.config;return{protocol:"webtransport",createStreamMuxer:re=>{typeof re=="function"&&(re={onIncomingStream:re});const ne=[];(async function(){//! TODO unclear how to add backpressure here?
const se=E.incomingBidirectionalStreams.getReader();for(;;){const{done:oe,value:ce}=await se.read();if(oe===!0)break;if(ne.length>=te.maxInboundStreams)ce.writable.close().catch(ae=>{log$9.error(`Failed to close inbound stream that crossed our maxInboundStream limit: ${ae.message}`)}),ce.readable.cancel().catch(ae=>{log$9.error(`Failed to close inbound stream that crossed our maxInboundStream limit: ${ae.message}`)});else{const ae=await webtransportBiDiStreamToStream(ce,String(ee++),"inbound",ne,re?.onStreamEnd);ne.push(ae),re?.onIncomingStream?.(ae)}}})().catch(()=>{log$9.error("WebTransport failed to receive incoming stream")});const ie={protocol:"webtransport",streams:ne,newStream:async se=>{const oe=await E.createBidirectionalStream(),ce=await webtransportBiDiStreamToStream(oe,String(ee++),re?.direction??"outbound",ne,re?.onStreamEnd);return ne.push(ce),ce},close:se=>{se!=null&&log$9("Closing webtransport muxer with err:",se),E.close()},...inertDuplex()};try{re?.signal?.throwIfAborted()}catch(se){throw E.close(),se}return ie}}}createListener(E){throw new Error("Webtransport servers are not supported in Node or the browser")}filter(E){return E.filter(ee=>ee.protoNames().includes("webtransport"))}}function webTransport(J={}){return E=>new WebTransportTransport(E,J)}var IpnsEntry;(function(J){(function(te){te.EOL="EOL"})(J.ValidityType||(J.ValidityType={}));let E;(function(te){te[te.EOL=0]="EOL"})(E||(E={})),function(te){te.codec=()=>enumeration(E)}(J.ValidityType||(J.ValidityType={}));let ee;J.codec=()=>(ee==null&&(ee=message((te,re,ne={})=>{ne.lengthDelimited!==!1&&re.fork(),te.value!=null&&(re.uint32(10),re.bytes(te.value)),te.signature!=null&&(re.uint32(18),re.bytes(te.signature)),te.validityType!=null&&(re.uint32(24),J.ValidityType.codec().encode(te.validityType,re)),te.validity!=null&&(re.uint32(34),re.bytes(te.validity)),te.sequence!=null&&(re.uint32(40),re.uint64(te.sequence)),te.ttl!=null&&(re.uint32(48),re.uint64(te.ttl)),te.pubKey!=null&&(re.uint32(58),re.bytes(te.pubKey)),te.signatureV2!=null&&(re.uint32(66),re.bytes(te.signatureV2)),te.data!=null&&(re.uint32(74),re.bytes(te.data)),ne.lengthDelimited!==!1&&re.ldelim()},(te,re)=>{const ne={},ie=re==null?te.len:te.pos+re;for(;te.pos<ie;){const se=te.uint32();switch(se>>>3){case 1:ne.value=te.bytes();break;case 2:ne.signature=te.bytes();break;case 3:ne.validityType=J.ValidityType.codec().decode(te);break;case 4:ne.validity=te.bytes();break;case 5:ne.sequence=te.uint64();break;case 6:ne.ttl=te.uint64();break;case 7:ne.pubKey=te.bytes();break;case 8:ne.signatureV2=te.bytes();break;case 9:ne.data=te.bytes();break;default:te.skipType(se&7);break}}return ne})),ee),J.encode=te=>encodeMessage(te,J.codec()),J.decode=te=>decodeMessage$1(te,J.codec())})(IpnsEntry||(IpnsEntry={}));const ERR_IPNS_EXPIRED_RECORD="ERR_IPNS_EXPIRED_RECORD",ERR_UNRECOGNIZED_VALIDITY="ERR_UNRECOGNIZED_VALIDITY",ERR_SIGNATURE_VERIFICATION="ERR_SIGNATURE_VERIFICATION",ERR_UNRECOGNIZED_FORMAT="ERR_UNRECOGNIZED_FORMAT",ERR_UNDEFINED_PARAMETER="ERR_UNDEFINED_PARAMETER",ERR_INVALID_RECORD_DATA="ERR_INVALID_RECORD_DATA",ERR_INVALID_EMBEDDED_KEY="ERR_INVALID_EMBEDDED_KEY",log$8=logger$1("ipns:utils"),IPNS_PREFIX=fromString$5("/ipns/");function parseRFC3339(J){const E=new RegExp("(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z"),ee=String(J).trim().match(E);if(ee==null)throw new Error("Invalid format");const te=parseInt(ee[1],10),re=parseInt(ee[2],10)-1,ne=parseInt(ee[3],10),ie=parseInt(ee[4],10),se=parseInt(ee[5],10),oe=parseInt(ee[6],10),ce=parseInt(ee[7].slice(0,-6),10);return new Date(Date.UTC(te,re,ne,ie,se,oe,ce))}const extractPublicKey=async(J,E)=>{if(E==null||J==null){const te=new Error("one or more of the provided parameters are not defined");throw log$8.error(te),errCode$1(te,ERR_UNDEFINED_PARAMETER)}let ee;if(E.pubKey!=null){try{ee=unmarshalPublicKey(E.pubKey)}catch(te){throw log$8.error(te),te}if(!(await peerIdFromKeys(E.pubKey)).equals(J))throw errCode$1(new Error("Embedded public key did not match PeerID"),ERR_INVALID_EMBEDDED_KEY)}else J.publicKey!=null&&(ee=unmarshalPublicKey(J.publicKey));if(ee!=null)return ee;throw errCode$1(new Error("no public key is available"),ERR_UNDEFINED_PARAMETER)},ipnsEntryDataForV2Sig=J=>{const E=fromString$5("ipns-signature:");return concat$4([E,J])},unmarshal=J=>{const E=IpnsEntry.decode(J);return E.sequence!=null&&(E.sequence=BigInt(E.sequence)),E.ttl!=null&&(E.ttl=BigInt(E.ttl)),{value:E.value??new Uint8Array(0),signature:E.signature??new Uint8Array(0),validityType:E.validityType??IpnsEntry.ValidityType.EOL,validity:E.validity??new Uint8Array(0),sequence:E.sequence??0n,pubKey:E.pubKey,ttl:E.ttl??void 0,signatureV2:E.signatureV2,data:E.data}},peerIdFromRoutingKey=J=>peerIdFromBytes(J.slice(IPNS_PREFIX.length)),parseCborData=J=>{const E=decode$3(J);if(E.ValidityType===0)E.ValidityType=IpnsEntry.ValidityType.EOL;else throw errCode$1(new Error("Unknown validity type"),ERR_UNRECOGNIZED_VALIDITY);return Number.isInteger(E.Sequence)&&(E.Sequence=BigInt(E.Sequence)),Number.isInteger(E.TTL)&&(E.TTL=BigInt(E.TTL)),E},ipnsSelector=(J,E)=>{const ee=E.map((te,re)=>({entry:IpnsEntry.decode(te),index:re}));return ee.sort((te,re)=>{if(te.entry.signatureV2!=null&&re.entry.signatureV2==null)return-1;if(te.entry.signatureV2==null&&re.entry.signatureV2!=null)return 1;const ne=te.entry.sequence??0n,ie=re.entry.sequence??0n;if(ne>ie)return-1;if(ne<ie)return 1;const se=te.entry.validity??new Uint8Array(0),oe=re.entry.validity??new Uint8Array(0),ce=parseRFC3339(toString$5(se)),ae=parseRFC3339(toString$5(oe));return ce.getTime()>ae.getTime()?-1:ce.getTime()<ae.getTime()?1:0}),ee[0].index},log$7=logger$1("ipns:validator"),validate=async(J,E)=>{const{value:ee,validityType:te,validity:re}=E;let ne,ie;if(E.signatureV2!=null&&E.data!=null)ie=E.signatureV2,ne=ipnsEntryDataForV2Sig(E.data),validateCborDataMatchesPbData(E);else throw errCode$1(new Error("missing data or signatureV2"),ERR_SIGNATURE_VERIFICATION);let se;try{se=await J.verify(ne,ie)}catch{se=!1}if(!se)throw log$7.error("record signature verification failed"),errCode$1(new Error("record signature verification failed"),ERR_SIGNATURE_VERIFICATION);if(re!=null&&te===IpnsEntry.ValidityType.EOL){let oe;try{oe=parseRFC3339(toString$5(re))}catch{throw log$7.error("unrecognized validity format (not an rfc3339 format)"),errCode$1(new Error("unrecognized validity format (not an rfc3339 format)"),ERR_UNRECOGNIZED_FORMAT)}if(oe.getTime()<Date.now())throw log$7.error("record has expired"),errCode$1(new Error("record has expired"),ERR_IPNS_EXPIRED_RECORD)}else if(te!=null)throw log$7.error("unrecognized validity type"),errCode$1(new Error("unrecognized validity type"),ERR_UNRECOGNIZED_VALIDITY);log$7("ipns entry for %b is valid",ee)},validateCborDataMatchesPbData=J=>{if(J.data==null)throw errCode$1(new Error("Record data is missing"),ERR_INVALID_RECORD_DATA);const E=parseCborData(J.data);if(!equals(E.Value,J.value))throw errCode$1(new Error('Field "value" did not match between protobuf and CBOR'),ERR_SIGNATURE_VERIFICATION);if(!equals(E.Validity,J.validity))throw errCode$1(new Error('Field "validity" did not match between protobuf and CBOR'),ERR_SIGNATURE_VERIFICATION);if(E.ValidityType!==J.validityType)throw errCode$1(new Error('Field "validityType" did not match between protobuf and CBOR'),ERR_SIGNATURE_VERIFICATION);if(E.Sequence!==J.sequence)throw errCode$1(new Error('Field "sequence" did not match between protobuf and CBOR'),ERR_SIGNATURE_VERIFICATION);if(E.TTL!==J.ttl)throw errCode$1(new Error('Field "ttl" did not match between protobuf and CBOR'),ERR_SIGNATURE_VERIFICATION)},ipnsValidator=async(J,E)=>{const ee=peerIdFromRoutingKey(J),te=unmarshal(E),re=await extractPublicKey(ee,te);await validate(re,te)},PROTOCOL_PREFIX="libp2p",PROTOCOL_NAME="autonat",PROTOCOL_VERSION="1.0.0",TIMEOUT=3e4,STARTUP_DELAY=5e3,REFRESH_INTERVAL=6e4,MAX_INBOUND_STREAMS=1,MAX_OUTBOUND_STREAMS=1;var Message;(function(J){(function(re){re.DIAL="DIAL",re.DIAL_RESPONSE="DIAL_RESPONSE"})(J.MessageType||(J.MessageType={}));let E;(function(re){re[re.DIAL=0]="DIAL",re[re.DIAL_RESPONSE=1]="DIAL_RESPONSE"})(E||(E={})),function(re){re.codec=()=>enumeration(E)}(J.MessageType||(J.MessageType={})),function(re){re.OK="OK",re.E_DIAL_ERROR="E_DIAL_ERROR",re.E_DIAL_REFUSED="E_DIAL_REFUSED",re.E_BAD_REQUEST="E_BAD_REQUEST",re.E_INTERNAL_ERROR="E_INTERNAL_ERROR"}(J.ResponseStatus||(J.ResponseStatus={}));let ee;(function(re){re[re.OK=0]="OK",re[re.E_DIAL_ERROR=100]="E_DIAL_ERROR",re[re.E_DIAL_REFUSED=101]="E_DIAL_REFUSED",re[re.E_BAD_REQUEST=200]="E_BAD_REQUEST",re[re.E_INTERNAL_ERROR=300]="E_INTERNAL_ERROR"})(ee||(ee={})),function(re){re.codec=()=>enumeration(ee)}(J.ResponseStatus||(J.ResponseStatus={})),function(re){let ne;re.codec=()=>(ne==null&&(ne=message((ie,se,oe={})=>{if(oe.lengthDelimited!==!1&&se.fork(),ie.id!=null&&(se.uint32(10),se.bytes(ie.id)),ie.addrs!=null)for(const ce of ie.addrs)se.uint32(18),se.bytes(ce);oe.lengthDelimited!==!1&&se.ldelim()},(ie,se)=>{const oe={addrs:[]},ce=se==null?ie.len:ie.pos+se;for(;ie.pos<ce;){const ae=ie.uint32();switch(ae>>>3){case 1:oe.id=ie.bytes();break;case 2:oe.addrs.push(ie.bytes());break;default:ie.skipType(ae&7);break}}return oe})),ne),re.encode=ie=>encodeMessage(ie,re.codec()),re.decode=ie=>decodeMessage$1(ie,re.codec())}(J.PeerInfo||(J.PeerInfo={})),function(re){let ne;re.codec=()=>(ne==null&&(ne=message((ie,se,oe={})=>{oe.lengthDelimited!==!1&&se.fork(),ie.peer!=null&&(se.uint32(10),J.PeerInfo.codec().encode(ie.peer,se)),oe.lengthDelimited!==!1&&se.ldelim()},(ie,se)=>{const oe={},ce=se==null?ie.len:ie.pos+se;for(;ie.pos<ce;){const ae=ie.uint32();switch(ae>>>3){case 1:oe.peer=J.PeerInfo.codec().decode(ie,ie.uint32());break;default:ie.skipType(ae&7);break}}return oe})),ne),re.encode=ie=>encodeMessage(ie,re.codec()),re.decode=ie=>decodeMessage$1(ie,re.codec())}(J.Dial||(J.Dial={})),function(re){let ne;re.codec=()=>(ne==null&&(ne=message((ie,se,oe={})=>{oe.lengthDelimited!==!1&&se.fork(),ie.status!=null&&(se.uint32(8),J.ResponseStatus.codec().encode(ie.status,se)),ie.statusText!=null&&(se.uint32(18),se.string(ie.statusText)),ie.addr!=null&&(se.uint32(26),se.bytes(ie.addr)),oe.lengthDelimited!==!1&&se.ldelim()},(ie,se)=>{const oe={},ce=se==null?ie.len:ie.pos+se;for(;ie.pos<ce;){const ae=ie.uint32();switch(ae>>>3){case 1:oe.status=J.ResponseStatus.codec().decode(ie);break;case 2:oe.statusText=ie.string();break;case 3:oe.addr=ie.bytes();break;default:ie.skipType(ae&7);break}}return oe})),ne),re.encode=ie=>encodeMessage(ie,re.codec()),re.decode=ie=>decodeMessage$1(ie,re.codec())}(J.DialResponse||(J.DialResponse={}));let te;J.codec=()=>(te==null&&(te=message((re,ne,ie={})=>{ie.lengthDelimited!==!1&&ne.fork(),re.type!=null&&(ne.uint32(8),J.MessageType.codec().encode(re.type,ne)),re.dial!=null&&(ne.uint32(18),J.Dial.codec().encode(re.dial,ne)),re.dialResponse!=null&&(ne.uint32(26),J.DialResponse.codec().encode(re.dialResponse,ne)),ie.lengthDelimited!==!1&&ne.ldelim()},(re,ne)=>{const ie={},se=ne==null?re.len:re.pos+ne;for(;re.pos<se;){const oe=re.uint32();switch(oe>>>3){case 1:ie.type=J.MessageType.codec().decode(re);break;case 2:ie.dial=J.Dial.codec().decode(re,re.uint32());break;case 3:ie.dialResponse=J.DialResponse.codec().decode(re,re.uint32());break;default:re.skipType(oe&7);break}}return ie})),te),J.encode=re=>encodeMessage(re,J.codec()),J.decode=re=>decodeMessage$1(re,J.codec())})(Message||(Message={}));const log$6=logger$1("libp2p:autonat"),REQUIRED_SUCCESSFUL_DIALS=4;class DefaultAutoNATService{components;startupDelay;refreshInterval;protocol;timeout;maxInboundStreams;maxOutboundStreams;verifyAddressTimeout;started;constructor(E,ee){this.components=E,this.started=!1,this.protocol=`/${ee.protocolPrefix??PROTOCOL_PREFIX}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`,this.timeout=ee.timeout??TIMEOUT,this.maxInboundStreams=ee.maxInboundStreams??MAX_INBOUND_STREAMS,this.maxOutboundStreams=ee.maxOutboundStreams??MAX_OUTBOUND_STREAMS,this.startupDelay=ee.startupDelay??STARTUP_DELAY,this.refreshInterval=ee.refreshInterval??REFRESH_INTERVAL,this._verifyExternalAddresses=this._verifyExternalAddresses.bind(this)}isStarted(){return this.started}async start(){this.started||(await this.components.registrar.handle(this.protocol,E=>{this.handleIncomingAutonatStream(E).catch(ee=>{log$6.error("error handling incoming autonat stream",ee)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams}),this.verifyAddressTimeout=setTimeout(this._verifyExternalAddresses,this.startupDelay),this.started=!0)}async stop(){await this.components.registrar.unhandle(this.protocol),clearTimeout(this.verifyAddressTimeout),this.started=!1}async handleIncomingAutonatStream(E){const ee=anySignal([AbortSignal.timeout(this.timeout)]);try{setMaxListeners?.(1/0,ee)}catch{}const te=this.components.addressManager.getAddresses().map(re=>re.toOptions().host);try{const re=abortableDuplex(E.stream,ee),ne=this;await pipe$1(re,ie=>decode$b(ie),async function*(ie){const se=await first(ie);if(se==null){log$6("no message received"),yield Message.encode({type:Message.MessageType.DIAL_RESPONSE,dialResponse:{status:Message.ResponseStatus.E_BAD_REQUEST,statusText:"No message was sent"}});return}let oe;try{oe=Message.decode(se)}catch(de){log$6.error("could not decode message",de),yield Message.encode({type:Message.MessageType.DIAL_RESPONSE,dialResponse:{status:Message.ResponseStatus.E_BAD_REQUEST,statusText:"Could not decode message"}});return}const ce=oe.dial;if(ce==null){log$6.error("dial was missing from message"),yield Message.encode({type:Message.MessageType.DIAL_RESPONSE,dialResponse:{status:Message.ResponseStatus.E_BAD_REQUEST,statusText:"No Dial message found in message"}});return}let ae;const le=ce.peer;if(le==null||le.id==null){log$6.error("PeerId missing from message"),yield Message.encode({type:Message.MessageType.DIAL_RESPONSE,dialResponse:{status:Message.ResponseStatus.E_BAD_REQUEST,statusText:"missing peer info"}});return}try{ae=peerIdFromBytes(le.id)}catch(de){log$6.error("invalid PeerId",de),yield Message.encode({type:Message.MessageType.DIAL_RESPONSE,dialResponse:{status:Message.ResponseStatus.E_BAD_REQUEST,statusText:"bad peer id"}});return}if(log$6("incoming request from %p",ae),!E.connection.remotePeer.equals(ae)){log$6("target peer %p did not equal sending peer %p",ae,E.connection.remotePeer),yield Message.encode({type:Message.MessageType.DIAL_RESPONSE,dialResponse:{status:Message.ResponseStatus.E_BAD_REQUEST,statusText:"peer id mismatch"}});return}const ue=le.addrs.map(de=>multiaddr(de)).filter(de=>{const fe=de.toOptions().host===E.connection.remoteAddr.toOptions().host;return log$6.trace("request to dial %s was sent from %s is same host %s",de,E.connection.remoteAddr,fe),fe}).filter(de=>{const fe=de.toOptions().host,me=!(is_ip_private(fe)??!1);return log$6.trace("host %s was public %s",fe,me),me}).filter(de=>{const fe=de.toOptions().host,me=!te.includes(fe);return log$6.trace("host %s was not our host %s",fe,me),me}).filter(de=>{const fe=!!ne.components.transportManager.transportForMultiaddr(de);return log$6.trace("transport for %s is supported %s",de,fe),fe}).map(de=>(de.getPeerId()==null&&(de=de.encapsulate(`/p2p/${ae.toString()}`)),de));if(ue.length===0){log$6("no valid multiaddrs for %p in message",ae),yield Message.encode({type:Message.MessageType.DIAL_RESPONSE,dialResponse:{status:Message.ResponseStatus.E_DIAL_REFUSED,statusText:"no dialable addresses"}});return}log$6("dial multiaddrs %s for peer %p",ue.map(de=>de.toString()).join(", "),ae);let he="",pe=ue[0];for await(const de of ue){let fe;pe=de;try{if(fe=await ne.components.connectionManager.openConnection(de,{signal:ee}),!fe.remoteAddr.equals(de))throw log$6.error("tried to dial %s but dialed %s",de,fe.remoteAddr),new Error("Unexpected remote address");log$6("Success %p",ae),yield Message.encode({type:Message.MessageType.DIAL_RESPONSE,dialResponse:{status:Message.ResponseStatus.OK,addr:fe.remoteAddr.decapsulateCode(getProtocol("p2p").code).bytes}});return}catch(me){log$6("could not dial %p",ae,me),he=me.message}finally{fe!=null&&await fe.close()}}yield Message.encode({type:Message.MessageType.DIAL_RESPONSE,dialResponse:{status:Message.ResponseStatus.E_DIAL_ERROR,statusText:he,addr:pe.bytes}})},ie=>encode$b(ie),E.stream)}catch(re){log$6.error("error handling incoming autonat stream",re)}finally{ee.clear()}}_verifyExternalAddresses(){this.verifyExternalAddresses().catch(E=>{log$6.error("error verifying external address",E)})}async verifyExternalAddresses(){if(clearTimeout(this.verifyAddressTimeout),!this.isStarted())return;const E=this.components.addressManager,ee=E.getObservedAddrs().filter(ne=>{const ie=ne.toOptions();return!(is_ip_private(ie.host)??!1)});if(ee.length===0){log$6("no public addresses found, not requesting verification"),this.verifyAddressTimeout=setTimeout(this._verifyExternalAddresses,this.refreshInterval);return}const te=AbortSignal.timeout(this.timeout);try{setMaxListeners?.(1/0,te)}catch{}const re=this;try{log$6("verify multiaddrs %s",ee.map(ae=>ae.toString()).join(", "));const ne=Message.encode({type:Message.MessageType.DIAL,dial:{peer:{id:this.components.peerId.toBytes(),addrs:ee.map(ae=>ae.bytes)}}}),ie=(await createEd25519PeerId()).toBytes(),se={},oe=[],ce=async ae=>{try{log$6("asking %p to verify multiaddr",ae.id);const le=await re.components.connectionManager.openConnection(ae.id,{signal:te}),ue=await le.newStream(this.protocol,{signal:te}),he=abortableDuplex(ue,te),pe=await pipe$1([ne],fe=>encode$b(fe),he,fe=>decode$b(fe),async fe=>first(fe));if(pe==null){log$6("no response received from %p",le.remotePeer);return}const de=Message.decode(pe);if(de.type!==Message.MessageType.DIAL_RESPONSE||de.dialResponse==null){log$6("invalid autonat response from %p",le.remotePeer);return}if(de.dialResponse.status===Message.ResponseStatus.OK){const fe=le.remoteAddr.toOptions();let me;if(fe.family===4)me=fe.host.split(".")[0];else if(fe.family===6)me=fe.host.split(":")[0];else{log$6('remote address "%s" was not IP4 or IP6?',fe.host);return}if(oe.includes(me)){log$6("already have response from network segment %d - %s",me,fe.host);return}oe.push(me)}return de.dialResponse}catch(le){log$6.error("error asking remote to verify multiaddr",le)}};for await(const ae of parallel(map$1(this.components.peerRouting.getClosestPeers(ie,{signal:te}),le=>async()=>ce(le)),{concurrency:REQUIRED_SUCCESSFUL_DIALS}))try{if(ae==null)continue;const le=ae.addr==null?ee[0]:multiaddr(ae.addr);if(log$6("autonat response for %s is %s",le,ae.status),ae.status===Message.ResponseStatus.E_BAD_REQUEST||ae.status===Message.ResponseStatus.E_DIAL_REFUSED||ae.addr==null&&ee.length>1)continue;if(!ee.some(he=>he.equals(le))){log$6("peer reported %s as %s but it was not in our observed address list",le,ae.status);continue}const ue=le.toString();if(se[ue]==null&&(se[ue]={success:0,failure:0}),ae.status===Message.ResponseStatus.OK?se[ue].success++:ae.status===Message.ResponseStatus.E_DIAL_ERROR&&se[ue].failure++,se[ue].success===REQUIRED_SUCCESSFUL_DIALS){log$6("%s is externally dialable",le),E.confirmObservedAddr(le);return}if(se[ue].failure===REQUIRED_SUCCESSFUL_DIALS){log$6("%s is not externally dialable",le),E.removeObservedAddr(le);return}}catch(le){log$6.error("could not verify external address",le)}}finally{this.verifyAddressTimeout=setTimeout(this._verifyExternalAddresses,this.refreshInterval)}}}function autoNATService(J={}){return E=>new DefaultAutoNATService(E,J)}const CIRCUIT_PROTO_CODE=290,RELAY_RENDEZVOUS_NS="/libp2p/relay",DEFAULT_RESERVATION_CONCURRENCY=1,RELAY_TAG="circuit-relay-relay";BigInt(1<<17);const RELAY_V2_HOP_CODEC="/libp2p/circuit/relay/0.2.0/hop",RELAY_V2_STOP_CODEC="/libp2p/circuit/relay/0.2.0/stop";var HopMessage;(function(J){(function(te){te.RESERVE="RESERVE",te.CONNECT="CONNECT",te.STATUS="STATUS"})(J.Type||(J.Type={}));let E;(function(te){te[te.RESERVE=0]="RESERVE",te[te.CONNECT=1]="CONNECT",te[te.STATUS=2]="STATUS"})(E||(E={})),function(te){te.codec=()=>enumeration(E)}(J.Type||(J.Type={}));let ee;J.codec=()=>(ee==null&&(ee=message((te,re,ne={})=>{ne.lengthDelimited!==!1&&re.fork(),te.type!=null&&(re.uint32(8),J.Type.codec().encode(te.type,re)),te.peer!=null&&(re.uint32(18),Peer.codec().encode(te.peer,re)),te.reservation!=null&&(re.uint32(26),Reservation.codec().encode(te.reservation,re)),te.limit!=null&&(re.uint32(34),Limit.codec().encode(te.limit,re)),te.status!=null&&(re.uint32(40),Status.codec().encode(te.status,re)),ne.lengthDelimited!==!1&&re.ldelim()},(te,re)=>{const ne={},ie=re==null?te.len:te.pos+re;for(;te.pos<ie;){const se=te.uint32();switch(se>>>3){case 1:ne.type=J.Type.codec().decode(te);break;case 2:ne.peer=Peer.codec().decode(te,te.uint32());break;case 3:ne.reservation=Reservation.codec().decode(te,te.uint32());break;case 4:ne.limit=Limit.codec().decode(te,te.uint32());break;case 5:ne.status=Status.codec().decode(te);break;default:te.skipType(se&7);break}}return ne})),ee),J.encode=te=>encodeMessage(te,J.codec()),J.decode=te=>decodeMessage$1(te,J.codec())})(HopMessage||(HopMessage={}));var StopMessage;(function(J){(function(te){te.CONNECT="CONNECT",te.STATUS="STATUS"})(J.Type||(J.Type={}));let E;(function(te){te[te.CONNECT=0]="CONNECT",te[te.STATUS=1]="STATUS"})(E||(E={})),function(te){te.codec=()=>enumeration(E)}(J.Type||(J.Type={}));let ee;J.codec=()=>(ee==null&&(ee=message((te,re,ne={})=>{ne.lengthDelimited!==!1&&re.fork(),te.type!=null&&(re.uint32(8),J.Type.codec().encode(te.type,re)),te.peer!=null&&(re.uint32(18),Peer.codec().encode(te.peer,re)),te.limit!=null&&(re.uint32(26),Limit.codec().encode(te.limit,re)),te.status!=null&&(re.uint32(32),Status.codec().encode(te.status,re)),ne.lengthDelimited!==!1&&re.ldelim()},(te,re)=>{const ne={},ie=re==null?te.len:te.pos+re;for(;te.pos<ie;){const se=te.uint32();switch(se>>>3){case 1:ne.type=J.Type.codec().decode(te);break;case 2:ne.peer=Peer.codec().decode(te,te.uint32());break;case 3:ne.limit=Limit.codec().decode(te,te.uint32());break;case 4:ne.status=Status.codec().decode(te);break;default:te.skipType(se&7);break}}return ne})),ee),J.encode=te=>encodeMessage(te,J.codec()),J.decode=te=>decodeMessage$1(te,J.codec())})(StopMessage||(StopMessage={}));var Peer;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{if(re.lengthDelimited!==!1&&te.fork(),ee.id!=null&&ee.id.byteLength>0&&(te.uint32(10),te.bytes(ee.id)),ee.addrs!=null)for(const ne of ee.addrs)te.uint32(18),te.bytes(ne);re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={id:new Uint8Array(0),addrs:[]},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.id=ee.bytes();break;case 2:re.addrs.push(ee.bytes());break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage$1(ee,J.codec())})(Peer||(Peer={}));var Reservation;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{if(re.lengthDelimited!==!1&&te.fork(),ee.expire!=null&&ee.expire!==0n&&(te.uint32(8),te.uint64(ee.expire)),ee.addrs!=null)for(const ne of ee.addrs)te.uint32(18),te.bytes(ne);ee.voucher!=null&&(te.uint32(26),te.bytes(ee.voucher)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={expire:0n,addrs:[]},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.expire=ee.uint64();break;case 2:re.addrs.push(ee.bytes());break;case 3:re.voucher=ee.bytes();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage$1(ee,J.codec())})(Reservation||(Reservation={}));var Limit;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{re.lengthDelimited!==!1&&te.fork(),ee.duration!=null&&(te.uint32(8),te.uint32(ee.duration)),ee.data!=null&&(te.uint32(16),te.uint64(ee.data)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.duration=ee.uint32();break;case 2:re.data=ee.uint64();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage$1(ee,J.codec())})(Limit||(Limit={}));var Status;(function(J){J.UNUSED="UNUSED",J.OK="OK",J.RESERVATION_REFUSED="RESERVATION_REFUSED",J.RESOURCE_LIMIT_EXCEEDED="RESOURCE_LIMIT_EXCEEDED",J.PERMISSION_DENIED="PERMISSION_DENIED",J.CONNECTION_FAILED="CONNECTION_FAILED",J.NO_RESERVATION="NO_RESERVATION",J.MALFORMED_MESSAGE="MALFORMED_MESSAGE",J.UNEXPECTED_MESSAGE="UNEXPECTED_MESSAGE"})(Status||(Status={}));var __StatusValues;(function(J){J[J.UNUSED=0]="UNUSED",J[J.OK=100]="OK",J[J.RESERVATION_REFUSED=200]="RESERVATION_REFUSED",J[J.RESOURCE_LIMIT_EXCEEDED=201]="RESOURCE_LIMIT_EXCEEDED",J[J.PERMISSION_DENIED=202]="PERMISSION_DENIED",J[J.CONNECTION_FAILED=203]="CONNECTION_FAILED",J[J.NO_RESERVATION=204]="NO_RESERVATION",J[J.MALFORMED_MESSAGE=400]="MALFORMED_MESSAGE",J[J.UNEXPECTED_MESSAGE=401]="UNEXPECTED_MESSAGE"})(__StatusValues||(__StatusValues={}));(function(J){J.codec=()=>enumeration(__StatusValues)})(Status||(Status={}));var ReservationVoucher;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{re.lengthDelimited!==!1&&te.fork(),ee.relay!=null&&ee.relay.byteLength>0&&(te.uint32(10),te.bytes(ee.relay)),ee.peer!=null&&ee.peer.byteLength>0&&(te.uint32(18),te.bytes(ee.peer)),ee.expiration!=null&&ee.expiration!==0n&&(te.uint32(24),te.uint64(ee.expiration)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={relay:new Uint8Array(0),peer:new Uint8Array(0),expiration:0n},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 1:re.relay=ee.bytes();break;case 2:re.peer=ee.bytes();break;case 3:re.expiration=ee.uint64();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage$1(ee,J.codec())})(ReservationVoucher||(ReservationVoucher={}));logger$1("libp2p:circuit-relay:utils");async function namespaceToCid(J){const E=new TextEncoder().encode(J),ee=await sha256$3.digest(E);return CID.createV0(ee)}function getExpirationMilliseconds(J){const E=J*BigInt(1e3);return Number(E-BigInt(new Date().getTime()))}logger$1("libp2p:circuit-relay:advert-service");logger$1("libp2p:circuit-relay:server");const log$5=logger$1("libp2p:circuit-relay:discover-relays");class RelayDiscovery extends EventEmitter$3{peerId;peerStore;contentRouting;registrar;started;topologyId;constructor(E){super(),this.started=!1,this.peerId=E.peerId,this.peerStore=E.peerStore,this.contentRouting=E.contentRouting,this.registrar=E.registrar}isStarted(){return this.started}async start(){this.topologyId=await this.registrar.register(RELAY_V2_HOP_CODEC,createTopology({onConnect:E=>{this.safeDispatchEvent("relay:discover",{detail:E})}})),this.discover().catch(E=>{log$5.error("error listening on relays",E)}),this.started=!0}stop(){this.topologyId!=null&&this.registrar.unregister(this.topologyId),this.started=!1}async discover(){log$5("searching peer store for relays");const E=(await this.peerStore.all()).filter(({protocols:ee})=>ee.includes(RELAY_V2_HOP_CODEC)).sort(()=>Math.random()-.5);for(const ee of E)log$5("found relay peer %p in content peer store",ee.id),this.safeDispatchEvent("relay:discover",{detail:ee.id});log$5("found %d relay peers in peer store",E.length);try{log$5("searching content routing for relays");const ee=await namespaceToCid(RELAY_RENDEZVOUS_NS);let te=0;for await(const re of this.contentRouting.findProviders(ee))if(re.multiaddrs.length>0&&!re.id.equals(this.peerId)){const ne=re.id;te++,await this.peerStore.merge(ne,{multiaddrs:re.multiaddrs}),log$5("found relay peer %p in content routing",ne),this.safeDispatchEvent("relay:discover",{detail:ne})}log$5("found %d relay peers in content routing",te)}catch(ee){log$5.error("failed when finding relays on the network",ee)}}}const log$4=logger$1("libp2p:circuit-relay:transport:listener");class CircuitRelayTransportListener extends EventEmitter$3{connectionManager;relayStore;listeningAddrs;constructor(E){super(),this.connectionManager=E.connectionManager,this.relayStore=E.relayStore,this.listeningAddrs=new PeerMap,this.relayStore.addEventListener("relay:removed",ee=>{this.#e(ee.detail)})}async listen(E){log$4("listen on %s",E);const ee=E.getPeerId();let te;if(ee!=null){const ne=peerIdFromString(ee),ie=this.connectionManager.getConnectionsMap().get(ne)??[];ie.length>0&&(te=ie[0])}if(te==null){const ne=E.toString().split("/p2p-circuit").find(se=>se!==""),ie=multiaddr(ne);te=await this.connectionManager.openConnection(ie)}if(!this.relayStore.hasReservation(te.remotePeer)){await this.relayStore.addRelay(te.remotePeer,"configured");return}const re=this.relayStore.getReservation(te.remotePeer);if(re==null)throw new CodeError("Did not have reservation after making reservation","ERR_NO_RESERVATION");if(this.listeningAddrs.has(te.remotePeer)){log$4("already listening on relay %p",te.remotePeer);return}this.listeningAddrs.set(te.remotePeer,re.addrs.map(ne=>multiaddr(ne).encapsulate("/p2p-circuit"))),this.safeDispatchEvent("listening",{})}getAddrs(){return[...this.listeningAddrs.values()].flat()}async close(){}#e(E){const ee=this.listeningAddrs.has(E);this.listeningAddrs.delete(E),ee&&this.safeDispatchEvent("close",{})}}function createListener(J){return new CircuitRelayTransportListener(J)}const log$3=logger$1("libp2p:circuit-relay:transport:reservation-store"),REFRESH_WINDOW=60*1e3*10,REFRESH_TIMEOUT=60*1e3*5,REFRESH_TIMEOUT_MIN=30*1e3;class ReservationStore extends EventEmitter$3{peerId;connectionManager;transportManager;peerStore;events;reserveQueue;reservations;maxDiscoveredRelays;started;constructor(E,ee){super(),this.peerId=E.peerId,this.connectionManager=E.connectionManager,this.transportManager=E.transportManager,this.peerStore=E.peerStore,this.events=E.events,this.reservations=new PeerMap,this.maxDiscoveredRelays=ee?.discoverRelays??0,this.started=!1,this.reserveQueue=new PQueue({concurrency:ee?.reservationConcurrency??DEFAULT_RESERVATION_CONCURRENCY}),this.events.addEventListener("peer:disconnect",te=>{this.#t(te.detail)})}isStarted(){return this.started}async start(){this.started=!0}async stop(){this.reservations.forEach(({timeout:E})=>{clearTimeout(E)}),this.reservations.clear(),this.started=!0}async addRelay(E,ee){if(this.peerId.equals(E)){log$3("not trying to use self as relay");return}log$3("add relay %p",E),await this.reserveQueue.add(async()=>{try{const te=this.reservations.get(E);if(te!=null){if(getExpirationMilliseconds(te.reservation.expire)>REFRESH_WINDOW){log$3("already have reservation on relay peer %p and it expires in more than 10 minutes",E);return}clearTimeout(te.timeout),this.reservations.delete(E)}if(ee==="discovered"&&[...this.reservations.values()].reduce((ce,ae)=>(ae.type==="discovered"&&ce++,ce),0)>=this.maxDiscoveredRelays){log$3("already have enough discovered relays");return}const re=await this.connectionManager.openConnection(E);if(re.remoteAddr.protoNames().includes("p2p-circuit")){log$3("not creating reservation over relayed connection");return}const ne=await this.#e(re);log$3("created reservation on relay peer %p",E);const ie=getExpirationMilliseconds(ne.expire),se=Math.min(Math.max(ie-REFRESH_TIMEOUT,REFRESH_TIMEOUT_MIN),Math.pow(2,31)-1),oe=setTimeout(()=>{this.addRelay(E,ee).catch(ce=>{log$3.error("could not refresh reservation to relay %p",E,ce)})},se);this.reservations.set(E,{timeout:oe,reservation:ne,type:ee}),await this.peerStore.merge(E,{tags:{[RELAY_TAG]:{value:1,ttl:ie}}}),await this.transportManager.listen([multiaddr(`/p2p/${E.toString()}/p2p-circuit`)])}catch(te){log$3.error("could not reserve slot on %p",E,te),this.reservations.delete(E)}})}hasReservation(E){return this.reservations.has(E)}getReservation(E){return this.reservations.get(E)?.reservation}async#e(E){log$3("requesting reservation from %s",E.remotePeer);const ee=await E.newStream(RELAY_V2_HOP_CODEC),te=pbStream$1(ee).pb(HopMessage);te.write({type:HopMessage.Type.RESERVE});let re;try{re=await te.read()}catch(ie){throw log$3.error("error parsing reserve message response from %p because",E.remotePeer,ie),ie}finally{ee.close()}if(re.status===Status.OK&&re.reservation!=null)return re.reservation;const ne=`reservation failed with status ${re.status??"undefined"}`;throw log$3.error(ne),new Error(ne)}#t(E){const ee=this.reservations.get(E);ee!=null&&(log$3("connection to relay %p closed, removing reservation from local store",E),clearTimeout(ee.timeout),this.reservations.delete(E),this.safeDispatchEvent("relay:removed",{detail:E}),this.reservations.size<this.maxDiscoveredRelays&&(log$3("not enough relays %d/%d",this.reservations.size,this.maxDiscoveredRelays),this.safeDispatchEvent("relay:not-enough-relays",{})))}}const log$2=logger$1("libp2p:circuit-relay:transport"),isValidStop=J=>{if(J.peer==null)return!1;try{J.peer.addrs.forEach(multiaddr)}catch{return!1}return!0};class CircuitRelayTransport{discovery;registrar;peerStore;connectionManager;peerId;upgrader;addressManager;connectionGater;reservationStore;started;constructor(E,ee){this.registrar=E.registrar,this.peerStore=E.peerStore,this.connectionManager=E.connectionManager,this.peerId=E.peerId,this.upgrader=E.upgrader,this.addressManager=E.addressManager,this.connectionGater=E.connectionGater,ee.discoverRelays!=null&&ee.discoverRelays>0&&(this.discovery=new RelayDiscovery(E),this.discovery.addEventListener("relay:discover",te=>{this.reservationStore.addRelay(te.detail,"discovered").catch(re=>{log$2.error("could not add discovered relay %p",te.detail,re)})})),this.reservationStore=new ReservationStore(E,ee),this.reservationStore.addEventListener("relay:not-enough-relays",()=>{this.discovery?.discover().catch(te=>{log$2.error("could not discover relays",te)})}),this.started=!1}isStarted(){return this.started}async start(){await this.reservationStore.start(),await this.discovery?.start(),await this.registrar.handle(RELAY_V2_STOP_CODEC,E=>{this.onStop(E).catch(ee=>{log$2.error(ee)})}),this.started=!0}async stop(){this.discovery?.stop(),await this.reservationStore.stop(),await this.registrar.unhandle(RELAY_V2_STOP_CODEC),this.started=!1}[symbol$2]=!0;[Symbol.toStringTag]="libp2p/circuit-relay-v2";async dial(E,ee={}){if(E.protoCodes().filter(he=>he===CIRCUIT_PROTO_CODE).length!==1){const he="Invalid circuit relay address";throw log$2.error(he,E),new CodeError(he,codes$1.ERR_RELAYED_DIAL)}const te=E.toString().split("/p2p-circuit"),re=multiaddr(te[0]),ne=multiaddr(te[te.length-1]),ie=re.getPeerId(),se=ne.getPeerId();if(ie==null||se==null){const he=`Circuit relay dial to ${E.toString()} failed as address did not have peer ids`;throw log$2.error(he),new CodeError(he,codes$1.ERR_RELAYED_DIAL)}const oe=peerIdFromString(ie),ce=peerIdFromString(se);let ae=!1,le=this.connectionManager.getConnections(oe)[0];le==null&&(await this.peerStore.merge(oe,{multiaddrs:[re]}),le=await this.connectionManager.openConnection(oe,ee),ae=!0);let ue;try{return ue=await le.newStream([RELAY_V2_HOP_CODEC]),await this.connectV2({stream:ue,connection:le,destinationPeer:ce,destinationAddr:ne,relayAddr:re,ma:E,disconnectOnFailure:ae})}catch(he){throw log$2.error(`Circuit relay dial to destination ${ce.toString()} via relay ${oe.toString()} failed`,he),ue?.abort(he),ae&&await le.close(),he}}async connectV2({stream:E,connection:ee,destinationPeer:te,destinationAddr:re,relayAddr:ne,ma:ie,disconnectOnFailure:se}){try{const oe=pbStream$1(E),ce=oe.pb(HopMessage);ce.write({type:HopMessage.Type.CONNECT,peer:{id:te.toBytes(),addrs:[multiaddr(re).bytes]}});const ae=await ce.read();if(ae.status!==Status.OK)throw new CodeError(`failed to connect via relay with status ${ae?.status?.toString()??"undefined"}`,codes$1.ERR_HOP_REQUEST_FAILED);const le=streamToMaConnection({stream:oe.unwrap(),remoteAddr:ie,localAddr:ne.encapsulate(`/p2p-circuit/p2p/${this.peerId.toString()}`)});return log$2("new outbound connection %s",le.remoteAddr),await this.upgrader.upgradeOutbound(le)}catch(oe){throw log$2.error(`Circuit relay dial to destination ${te.toString()} via relay ${ee.remotePeer.toString()} failed`,oe),se&&await ee.close(),oe}}createListener(E){return createListener({connectionManager:this.connectionManager,relayStore:this.reservationStore})}filter(E){return E=Array.isArray(E)?E:[E],E.filter(ee=>Circuit.matches(ee))}async onStop({connection:E,stream:ee}){const te=pbStream$1(ee),re=await te.readPB(StopMessage);if(log$2("received circuit v2 stop protocol request from %s",E.remotePeer),re?.type===void 0)return;const ne=te.pb(StopMessage);if(log$2("new circuit relay v2 stop stream from %s",E.remotePeer),re.type!==StopMessage.Type.CONNECT){log$2.error("invalid stop connect request via peer %s",E.remotePeer),ne.write({type:StopMessage.Type.STATUS,status:Status.UNEXPECTED_MESSAGE});return}if(!isValidStop(re)){log$2.error("invalid stop connect request via peer %s",E.remotePeer),ne.write({type:StopMessage.Type.STATUS,status:Status.MALFORMED_MESSAGE});return}const ie=peerIdFromBytes(re.peer.id);if(await this.connectionGater.denyInboundRelayedConnection?.(E.remotePeer,ie)===!0){ne.write({type:StopMessage.Type.STATUS,status:Status.PERMISSION_DENIED});return}ne.write({type:StopMessage.Type.STATUS,status:Status.OK});const se=E.remoteAddr.encapsulate(`/p2p-circuit/p2p/${ie.toString()}`),oe=this.addressManager.getAddresses()[0],ce=streamToMaConnection({stream:te.unwrap(),remoteAddr:se,localAddr:oe});log$2("new inbound connection %s",ce.remoteAddr),await this.upgrader.upgradeInbound(ce),log$2("%s connection %s upgraded","inbound",ce.remoteAddr)}}function circuitRelayTransport(J={}){return E=>new CircuitRelayTransport(E,J)}const version$1="0.45.5",AGENT_VERSION=`js-libp2p/${version$1}`,IDENTIFY_PROTOCOL_VERSION="0.1.0",MULTICODEC_IDENTIFY_PROTOCOL_NAME="id",MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME="id/push",MULTICODEC_IDENTIFY_PROTOCOL_VERSION="1.0.0",MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION="1.0.0";var Identify;(function(J){let E;J.codec=()=>(E==null&&(E=message((ee,te,re={})=>{if(re.lengthDelimited!==!1&&te.fork(),ee.protocolVersion!=null&&(te.uint32(42),te.string(ee.protocolVersion)),ee.agentVersion!=null&&(te.uint32(50),te.string(ee.agentVersion)),ee.publicKey!=null&&(te.uint32(10),te.bytes(ee.publicKey)),ee.listenAddrs!=null)for(const ne of ee.listenAddrs)te.uint32(18),te.bytes(ne);if(ee.observedAddr!=null&&(te.uint32(34),te.bytes(ee.observedAddr)),ee.protocols!=null)for(const ne of ee.protocols)te.uint32(26),te.string(ne);ee.signedPeerRecord!=null&&(te.uint32(66),te.bytes(ee.signedPeerRecord)),re.lengthDelimited!==!1&&te.ldelim()},(ee,te)=>{const re={listenAddrs:[],protocols:[]},ne=te==null?ee.len:ee.pos+te;for(;ee.pos<ne;){const ie=ee.uint32();switch(ie>>>3){case 5:re.protocolVersion=ee.string();break;case 6:re.agentVersion=ee.string();break;case 1:re.publicKey=ee.bytes();break;case 2:re.listenAddrs.push(ee.bytes());break;case 4:re.observedAddr=ee.bytes();break;case 3:re.protocols.push(ee.string());break;case 8:re.signedPeerRecord=ee.bytes();break;default:ee.skipType(ie&7);break}}return re})),E),J.encode=ee=>encodeMessage(ee,J.codec()),J.decode=ee=>decodeMessage$1(ee,J.codec())})(Identify||(Identify={}));const log$1=logger$1("libp2p:identify"),MAX_IDENTIFY_MESSAGE_SIZE=1024*8,defaultValues={protocolPrefix:"ipfs",agentVersion:AGENT_VERSION,timeout:6e4,maxInboundStreams:1,maxOutboundStreams:1,maxPushIncomingStreams:1,maxPushOutgoingStreams:1,maxObservedAddresses:10,maxIdentifyMessageSize:8192};class DefaultIdentifyService{identifyProtocolStr;identifyPushProtocolStr;host;started;timeout;peerId;peerStore;registrar;connectionManager;addressManager;maxInboundStreams;maxOutboundStreams;maxPushIncomingStreams;maxPushOutgoingStreams;maxIdentifyMessageSize;maxObservedAddresses;events;constructor(E,ee){this.started=!1,this.peerId=E.peerId,this.peerStore=E.peerStore,this.registrar=E.registrar,this.addressManager=E.addressManager,this.connectionManager=E.connectionManager,this.events=E.events,this.identifyProtocolStr=`/${ee.protocolPrefix??defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`,this.identifyPushProtocolStr=`/${ee.protocolPrefix??defaultValues.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`,this.timeout=ee.timeout??defaultValues.timeout,this.maxInboundStreams=ee.maxInboundStreams??defaultValues.maxInboundStreams,this.maxOutboundStreams=ee.maxOutboundStreams??defaultValues.maxOutboundStreams,this.maxPushIncomingStreams=ee.maxPushIncomingStreams??defaultValues.maxPushIncomingStreams,this.maxPushOutgoingStreams=ee.maxPushOutgoingStreams??defaultValues.maxPushOutgoingStreams,this.maxIdentifyMessageSize=ee.maxIdentifyMessageSize??defaultValues.maxIdentifyMessageSize,this.maxObservedAddresses=ee.maxObservedAddresses??defaultValues.maxObservedAddresses,this.host={protocolVersion:`${ee.protocolPrefix??defaultValues.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,agentVersion:ee.agentVersion??defaultValues.agentVersion},E.events.addEventListener("connection:open",te=>{const re=te.detail;this.identify(re).catch(ne=>{log$1.error("error during identify trigged by connection:open",ne)})}),E.events.addEventListener("self:peer:update",te=>{this.push().catch(re=>{log$1.error(re)})}),this.host.agentVersion===AGENT_VERSION&&(isNode||isElectronMain?this.host.agentVersion+=` UserAgent=${globalThis.process.version}`:(isBrowser||isWebWorker||isElectronRenderer||isReactNative)&&(this.host.agentVersion+=` UserAgent=${globalThis.navigator.userAgent}`))}isStarted(){return this.started}async start(){this.started||(await this.peerStore.merge(this.peerId,{metadata:{AgentVersion:fromString$5(this.host.agentVersion),ProtocolVersion:fromString$5(this.host.protocolVersion)}}),await this.registrar.handle(this.identifyProtocolStr,E=>{this._handleIdentify(E).catch(ee=>{log$1.error(ee)})},{maxInboundStreams:this.maxInboundStreams,maxOutboundStreams:this.maxOutboundStreams}),await this.registrar.handle(this.identifyPushProtocolStr,E=>{this._handlePush(E).catch(ee=>{log$1.error(ee)})},{maxInboundStreams:this.maxPushIncomingStreams,maxOutboundStreams:this.maxPushOutgoingStreams}),this.started=!0)}async stop(){await this.registrar.unhandle(this.identifyProtocolStr),await this.registrar.unhandle(this.identifyPushProtocolStr),this.started=!1}async pushToConnections(E){const ee=this.addressManager.getAddresses().map(ae=>ae.decapsulateCode(getProtocol("p2p").code)),te=new PeerRecord({peerId:this.peerId,multiaddrs:ee}),re=await RecordEnvelope.seal(te,this.peerId),ne=this.registrar.getProtocols(),ie=await this.peerStore.get(this.peerId),se=toString$5(ie.metadata.get("AgentVersion")??fromString$5(this.host.agentVersion)),oe=toString$5(ie.metadata.get("ProtocolVersion")??fromString$5(this.host.protocolVersion)),ce=E.map(async ae=>{let le;const ue=AbortSignal.timeout(this.timeout);try{setMaxListeners?.(1/0,ue)}catch{}try{le=await ae.newStream([this.identifyPushProtocolStr],{signal:ue}),await abortableDuplex(le,ue).sink(pipe$1([Identify.encode({listenAddrs:ee.map(he=>he.bytes),signedPeerRecord:re.marshal(),protocols:ne,agentVersion:se,protocolVersion:oe})],he=>encode$b(he)))}catch(he){log$1.error("could not push identify update to peer",he)}finally{le?.close()}});await Promise.all(ce)}async push(){if(!this.isStarted())return;const E=[];await Promise.all(this.connectionManager.getConnections().map(async ee=>{try{if(!(await this.peerStore.get(ee.remotePeer)).protocols.includes(this.identifyPushProtocolStr))return;E.push(ee)}catch(te){if(te.code!==codes$1.ERR_NOT_FOUND)throw te}})),await this.pushToConnections(E)}async _identify(E,ee={}){let te;const re=anySignal([AbortSignal.timeout(this.timeout),ee?.signal]);try{setMaxListeners?.(1/0,re)}catch{}try{te=await E.newStream([this.identifyProtocolStr],{signal:re});const ne=abortableDuplex(te,re),ie=await pipe$1([],ne,se=>decode$b(se,{maxDataLength:this.maxIdentifyMessageSize??MAX_IDENTIFY_MESSAGE_SIZE}),async se=>first(se));if(ie==null)throw new CodeError("No data could be retrieved",codes$1.ERR_CONNECTION_ENDED);try{return Identify.decode(ie)}catch(se){throw new CodeError(String(se),codes$1.ERR_INVALID_MESSAGE)}}finally{te?.close(),re.clear()}}async identify(E,ee={}){const te=await this._identify(E,ee),{publicKey:re,protocols:ne,observedAddr:ie}=te;if(re==null)throw new CodeError("public key was missing from identify message",codes$1.ERR_MISSING_PUBLIC_KEY);const se=await peerIdFromKeys(re);if(!E.remotePeer.equals(se))throw new CodeError("identified peer does not match the expected peer",codes$1.ERR_INVALID_PEER);if(this.peerId.equals(se))throw new CodeError("identified peer is our own peer id?",codes$1.ERR_INVALID_PEER);const oe=getCleanMultiaddr(ie);log$1("identify completed for peer %p and protocols %o",se,ne),log$1("our observed address is %s",oe),oe!=null&&this.addressManager.getObservedAddrs().length<(this.maxObservedAddresses??1/0)&&(log$1("storing our observed address %s",oe?.toString()),this.addressManager.addObservedAddr(oe));const ce=await this.#e(E.remotePeer,te),ae={peerId:se,protocolVersion:te.protocolVersion,agentVersion:te.agentVersion,publicKey:te.publicKey,listenAddrs:te.listenAddrs.map(le=>multiaddr(le)),observedAddr:te.observedAddr==null?void 0:multiaddr(te.observedAddr),protocols:te.protocols,signedPeerRecord:ce};this.events.safeDispatchEvent("peer:identify",{detail:ae})}async _handleIdentify(E){const{connection:ee,stream:te}=E,re=AbortSignal.timeout(this.timeout);try{setMaxListeners?.(1/0,re)}catch{}try{const ne=this.peerId.publicKey??new Uint8Array(0),ie=await this.peerStore.get(this.peerId),se=this.addressManager.getAddresses().map(ue=>ue.decapsulateCode(getProtocol("p2p").code));let oe=ie.peerRecordEnvelope;if(se.length>0&&oe==null){const ue=new PeerRecord({peerId:this.peerId,multiaddrs:se});oe=(await RecordEnvelope.seal(ue,this.peerId)).marshal().subarray()}const ce=Identify.encode({protocolVersion:this.host.protocolVersion,agentVersion:this.host.agentVersion,publicKey:ne,listenAddrs:se.map(ue=>ue.bytes),signedPeerRecord:oe,observedAddr:ee.remoteAddr.bytes,protocols:ie.protocols}),ae=abortableDuplex(te,re),le=pipe$1([ce],ue=>encode$b(ue));await ae.sink(le)}catch(ne){log$1.error("could not respond to identify request",ne)}finally{te.close()}}async _handlePush(E){const{connection:ee,stream:te}=E;try{if(this.peerId.equals(ee.remotePeer))throw new Error("received push from ourselves?");const re=abortableDuplex(te,AbortSignal.timeout(this.timeout)),ne=await pbStream$1(re,{maxDataLength:this.maxIdentifyMessageSize??MAX_IDENTIFY_MESSAGE_SIZE}).readPB(Identify);await this.#e(ee.remotePeer,ne)}catch(re){log$1.error("received invalid message",re);return}finally{te.close()}log$1("handled push from %p",ee.remotePeer)}async#e(E,ee){if(log$1("received identify from %p",E),ee==null)throw new Error("Message was null or undefined");const te={addresses:ee.listenAddrs.map(ne=>({isCertified:!1,multiaddr:multiaddr(ne)})),protocols:ee.protocols,metadata:new Map,peerRecordEnvelope:ee.signedPeerRecord};let re;if(ee.signedPeerRecord!=null){log$1("received signedPeerRecord in push from %p",E);let ne=ee.signedPeerRecord;const ie=await RecordEnvelope.openAndCertify(ne,PeerRecord.DOMAIN);let se=PeerRecord.createFromProtobuf(ie.payload);if(!se.peerId.equals(ie.peerId))throw new Error("signing key does not match PeerId in the PeerRecord");if(!E.equals(se.peerId))throw new Error("signing key does not match remote PeerId");let oe;try{oe=await this.peerStore.get(se.peerId)}catch(ce){if(ce.code!=="ERR_NOT_FOUND")throw ce}if(oe!=null&&(te.metadata=oe.metadata,oe.peerRecordEnvelope!=null)){const ce=await RecordEnvelope.createFromProtobuf(oe.peerRecordEnvelope),ae=PeerRecord.createFromProtobuf(ce.payload);ae.seqNumber>=se.seqNumber&&(log$1("sequence number was lower or equal to existing sequence number - stored: %d received: %d",ae.seqNumber,se.seqNumber),se=ae,ne=oe.peerRecordEnvelope)}te.peerRecordEnvelope=ne,te.addresses=se.multiaddrs.map(ce=>({isCertified:!0,multiaddr:ce})),re={seq:se.seqNumber,addresses:se.multiaddrs}}else log$1("%p did not send a signed peer record",E);return ee.agentVersion!=null&&te.metadata.set("AgentVersion",fromString$5(ee.agentVersion)),ee.protocolVersion!=null&&te.metadata.set("ProtocolVersion",fromString$5(ee.protocolVersion)),await this.peerStore.patch(E,te),re}}function getCleanMultiaddr(J){if(J!=null&&J.length>0)try{return multiaddr(J)}catch{}}function identifyService(J={}){return E=>new DefaultIdentifyService(E,J)}const bootstrapConfig={list:["/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN","/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa","/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb","/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt","/ip4/104.131.131.82/tcp/4001/p2p/QmaCpDMGvV2BGHeYERUEnRQAwe3N8SzbUtfsmvsqQLuvuJ"]};function libp2pDefaults(){return{addresses:{listen:["/webrtc"]},transports:[webRTC(),webRTCDirect(),webTransport(),webSockets(),circuitRelayTransport({discoverRelays:1})],connectionEncryption:[noise$1()],streamMuxers:[yamux(),mplex()],peerDiscovery:[bootstrap(bootstrapConfig)],contentRouters:[ipniContentRouting("https://cid.contact")],services:{identify:identifyService(),autoNAT:autoNATService(),pubsub:gossipsub(),dht:kadDHT({clientMode:!0,validators:{ipns:ipnsValidator},selectors:{ipns:ipnsSelector}})}}}async function createLibp2p(J,E){const ee=libp2pDefaults();return E=E??{},createLibp2p$1({datastore:J,...ee,...E,start:!1})}const version$3="1.3.1",name="helia",log=logger$1("helia");async function createHelia(J={}){const E=J.datastore??new MemoryDatastore,ee=J.blockstore??new MemoryBlockstore;let te;isLibp2p(J.libp2p)?te=J.libp2p:te=await createLibp2p(E,J.libp2p);const re=new HeliaImpl({...J,datastore:E,blockstore:ee,libp2p:te});return J.start!==!1&&await re.start(),re.libp2p.isStarted()?await addHeliaToAgentVersion(re):re.libp2p.addEventListener("start",()=>{addHeliaToAgentVersion(re).catch(ne=>{log.error("could not add Helia to agent version",ne)})}),re}function isLibp2p(J){return J==null?!1:["dial","dialProtocol","hangUp","handle","unhandle","getMultiaddrs","getProtocols"].every(E=>typeof J[E]=="function")}async function addHeliaToAgentVersion(J){const E=(await J.libp2p.peerStore.get(J.libp2p.peerId)).metadata.get("AgentVersion");if(E==null)return;let ee=new TextDecoder().decode(E);ee.match(/js-libp2p\/\d+\.\d+\.\d+\sUserAgent=/)!=null&&(ee.includes(name)?ee=`${name}/${version$3} ${ee.split(" ").slice(1).join(" ")}`:ee=`${name}/${version$3} ${ee}`,await J.libp2p.peerStore.merge(J.libp2p.peerId,{metadata:{AgentVersion:new TextEncoder().encode(ee)}}))}class IPFSBlobRepo{#e;static async fromLibp2pNode(E,ee=new MemoryBlockstore,te=new MemoryDatastore){return new IPFSBlobRepo(await createHelia({libp2p:E,blockstore:ee,datastore:te}))}constructor(E){this.#e=E}async put(E){return{ref:(await unixfs(this.#e).addBytes(E)).toString()}}async get(E){const ee=unixfs(this.#e),te=CID.parse(E),re=await ee.stat(te);return console.log("stat",E,re),{data:ee.cat(te)}}}let crypto$1=globalThis.crypto;(async function(){crypto$1||(crypto$1=(await Promise.resolve().then(()=>nodeCrypto)).webcrypto)})();class EncryptedBlobStore{#e;constructor(E){this.#e=E}static async fromLibp2pNode(E){const ee=await IPFSBlobRepo.fromLibp2pNode(E);return new EncryptedBlobStore(ee)}async put(E){const ee=await crypto$1.subtle.generateKey({name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),te=crypto$1.getRandomValues(new Uint8Array(16)),re=await crypto$1.subtle.encrypt({name:"AES-GCM",iv:te},ee,E);return{ref:(await this.#e.put(new Uint8Array(re))).ref,key:await crypto$1.subtle.exportKey("jwk",ee),iv:base64$8.encode(te)}}async get(E){const{ref:ee,key:te,iv:re}=E,ne=await this.#e.get(ee),ie=concat$5(await all$1(ne.data)),se=await crypto$1.subtle.importKey("jwk",te,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);return{data:new Uint8Array(await crypto$1.subtle.decrypt({name:"AES-GCM",iv:base64$8.decode(re)},se,ie))}}}const RELAY_REGEX=/;?r=([^;]+)/;function getInvite(J){const E=J?.slice(1).replace(RELAY_REGEX,"");return console.log("get invite",E),E}function getRelayAddr(J){const E=J?.match(RELAY_REGEX);if(console.log("get relay",E),E&&E.length>1)return E[1]}const IS_BROWSER=typeof window<"u",AppState=G(void 0);var ConnectionStatus=(J=>(J.disconnected="disconnected",J.connecting="connecting",J.connected="connected",J))(ConnectionStatus||{}),ChatStatus=(J=>(J[J.uninitialized=0]="uninitialized",J[J.active=1]="active",J[J.idle=2]="idle",J[J.disconnected=3]="disconnected",J[J.error=4]="error",J))(ChatStatus||{});async function createAppState(){const E=getInvite(location.hash)?void 0:getRelayAddr(location.hash)??"/ip4/127.0.0.1/tcp/59351/ws";console.log("relayAddr",E);const ee=await createPrivateLibp2pNode({relayAddr:E}),te=await ChatContext.createP2PEncryptedChatContext(ee),re=await EncryptedBlobStore.fromLibp2pNode(ee.node),ne=u(IS_BROWSER&&localStorage?.getItem("username")||"");IS_BROWSER&&b(()=>ne.value&&localStorage.setItem("username",ne.value)),b(()=>ne.value&&te.setUsername(ne.value));const ie=u(""),se=u("disconnected"),oe=u(0),ce=u(""),ae=w$1(()=>oe.value!==0);return te.on(ChatEventType.invite,le=>{console.log("invite",le),ie.value=`${location.origin}/#${le.detail.invite}`}),te.on(ChatEventType.channel_open,()=>{console.log("open"),se.value="connected"}),te.on(ChatEventType.channel_error,le=>{switch(console.log("error",le),le.detail.readyState){case EventSource.OPEN:se.value="connected";break;case EventSource.CLOSED:se.value="disconnected";break;case EventSource.CONNECTING:default:se.value="connecting";break}}),te.on(ChatEventType.initiated,()=>{oe.value=1}),te.on(ChatEventType.disconnected,()=>{oe.value=3,se.value="disconnected"}),te.on(ChatEventType.message,le=>{switch(oe.value=1,le.detail.type){case MessageType$1.meta:le.detail.name&&(ce.value=le.detail.name,location.hash="");break}}),{username:ne,partnerUsername:ce,chatStatus:oe,connectionStatus:se,chatReady:ae,joinLink:ie,chatContext:te,attachmentStore:re}}const addMessageFn=J=>E=>{const ee=E.lastSeenId;let te=J.value;ee!==void 0&&!E.self&&(te=te.map(re=>{const ne=re.id;return re.self&&ne!==void 0&&ee>ne?{...re,seen:!0}:re})),E.msg||E.files?J.value=[...te,E]:J.value=te};function setupMessageListeners(J,E,ee){const te=addMessageFn(E),re=u(0);J.on(ChatEventType.message,ne=>{console.log("got message",ne.detail),ne.detail.type===MessageType$1.message?te({...ne.detail,uid:`i:${ne.detail.id}`,seen:!0,time:Date.now(),self:!1}):ne.detail.type===MessageType$1.disconnect?te({...ne.detail,uid:`i:${ne.detail.id}`,msg:`${ee.value} has left the chat`,system:!0,seen:!0,self:!1,time:Date.now()}):ne.detail.lastSeenId&&te({...ne.detail,uid:`i:${ne.detail.id}`})}),J.on(ChatEventType.queued,ne=>{ne.detail.type===MessageType$1.message&&te({...ne.detail,uid:`o:${ne.detail.id}`,seen:!1,self:!0})}),J.on(ChatEventType.disconnected,ne=>{ne.detail.local&&te({uid:`s:${re.value++}`,msg:"You left the chat",system:!0,self:!0,time:Date.now()})}),J.on(ChatEventType.dead_session,()=>{te({uid:`s:${re.value++}`,msg:"The session may have died! Refresh to start a new one.",system:!0,self:!0,time:Date.now()})}),J.on(ChatEventType.idle,()=>{te({uid:`s:${re.value++}`,msg:`${ee.value} may have gone offline. Refresh to start a new session.`,system:!0,self:!0,time:Date.now()})}),J.on(ChatEventType.sent,ne=>{console.log("sent",ne)}),J.on(ChatEventType.failed,ne=>{console.log("failed",ne)})}var browser={},canPromise$1=function(){return typeof Promise=="function"&&Promise.prototype&&Promise.prototype.then},qrcode={},utils$1={};let toSJISFunction;const CODEWORDS_COUNT=[0,26,44,70,100,134,172,196,242,292,346,404,466,532,581,655,733,815,901,991,1085,1156,1258,1364,1474,1588,1706,1828,1921,2051,2185,2323,2465,2611,2761,2876,3034,3196,3362,3532,3706];utils$1.getSymbolSize=function J(E){if(!E)throw new Error('"version" cannot be null or undefined');if(E<1||E>40)throw new Error('"version" should be in range from 1 to 40');return E*4+17};utils$1.getSymbolTotalCodewords=function J(E){return CODEWORDS_COUNT[E]};utils$1.getBCHDigit=function(J){let E=0;for(;J!==0;)E++,J>>>=1;return E};utils$1.setToSJISFunction=function J(E){if(typeof E!="function")throw new Error('"toSJISFunc" is not a valid function.');toSJISFunction=E};utils$1.isKanjiModeEnabled=function(){return typeof toSJISFunction<"u"};utils$1.toSJIS=function J(E){return toSJISFunction(E)};var errorCorrectionLevel={};(function(J){J.L={bit:1},J.M={bit:0},J.Q={bit:3},J.H={bit:2};function E(ee){if(typeof ee!="string")throw new Error("Param is not a string");switch(ee.toLowerCase()){case"l":case"low":return J.L;case"m":case"medium":return J.M;case"q":case"quartile":return J.Q;case"h":case"high":return J.H;default:throw new Error("Unknown EC Level: "+ee)}}J.isValid=function(te){return te&&typeof te.bit<"u"&&te.bit>=0&&te.bit<4},J.from=function(te,re){if(J.isValid(te))return te;try{return E(te)}catch{return re}}})(errorCorrectionLevel);function BitBuffer$1(){this.buffer=[],this.length=0}BitBuffer$1.prototype={get:function(J){const E=Math.floor(J/8);return(this.buffer[E]>>>7-J%8&1)===1},put:function(J,E){for(let ee=0;ee<E;ee++)this.putBit((J>>>E-ee-1&1)===1)},getLengthInBits:function(){return this.length},putBit:function(J){const E=Math.floor(this.length/8);this.buffer.length<=E&&this.buffer.push(0),J&&(this.buffer[E]|=128>>>this.length%8),this.length++}};var bitBuffer=BitBuffer$1;function BitMatrix$1(J){if(!J||J<1)throw new Error("BitMatrix size must be defined and greater than 0");this.size=J,this.data=new Uint8Array(J*J),this.reservedBit=new Uint8Array(J*J)}BitMatrix$1.prototype.set=function(J,E,ee,te){const re=J*this.size+E;this.data[re]=ee,te&&(this.reservedBit[re]=!0)};BitMatrix$1.prototype.get=function(J,E){return this.data[J*this.size+E]};BitMatrix$1.prototype.xor=function(J,E,ee){this.data[J*this.size+E]^=ee};BitMatrix$1.prototype.isReserved=function(J,E){return this.reservedBit[J*this.size+E]};var bitMatrix=BitMatrix$1,alignmentPattern={};(function(J){const E=utils$1.getSymbolSize;J.getRowColCoords=function(te){if(te===1)return[];const re=Math.floor(te/7)+2,ne=E(te),ie=ne===145?26:Math.ceil((ne-13)/(2*re-2))*2,se=[ne-7];for(let oe=1;oe<re-1;oe++)se[oe]=se[oe-1]-ie;return se.push(6),se.reverse()},J.getPositions=function(te){const re=[],ne=J.getRowColCoords(te),ie=ne.length;for(let se=0;se<ie;se++)for(let oe=0;oe<ie;oe++)se===0&&oe===0||se===0&&oe===ie-1||se===ie-1&&oe===0||re.push([ne[se],ne[oe]]);return re}})(alignmentPattern);var finderPattern={};const getSymbolSize=utils$1.getSymbolSize,FINDER_PATTERN_SIZE=7;finderPattern.getPositions=function J(E){const ee=getSymbolSize(E);return[[0,0],[ee-FINDER_PATTERN_SIZE,0],[0,ee-FINDER_PATTERN_SIZE]]};var maskPattern={};(function(J){J.Patterns={PATTERN000:0,PATTERN001:1,PATTERN010:2,PATTERN011:3,PATTERN100:4,PATTERN101:5,PATTERN110:6,PATTERN111:7};const E={N1:3,N2:3,N3:40,N4:10};J.isValid=function(re){return re!=null&&re!==""&&!isNaN(re)&&re>=0&&re<=7},J.from=function(re){return J.isValid(re)?parseInt(re,10):void 0},J.getPenaltyN1=function(re){const ne=re.size;let ie=0,se=0,oe=0,ce=null,ae=null;for(let le=0;le<ne;le++){se=oe=0,ce=ae=null;for(let ue=0;ue<ne;ue++){let he=re.get(le,ue);he===ce?se++:(se>=5&&(ie+=E.N1+(se-5)),ce=he,se=1),he=re.get(ue,le),he===ae?oe++:(oe>=5&&(ie+=E.N1+(oe-5)),ae=he,oe=1)}se>=5&&(ie+=E.N1+(se-5)),oe>=5&&(ie+=E.N1+(oe-5))}return ie},J.getPenaltyN2=function(re){const ne=re.size;let ie=0;for(let se=0;se<ne-1;se++)for(let oe=0;oe<ne-1;oe++){const ce=re.get(se,oe)+re.get(se,oe+1)+re.get(se+1,oe)+re.get(se+1,oe+1);(ce===4||ce===0)&&ie++}return ie*E.N2},J.getPenaltyN3=function(re){const ne=re.size;let ie=0,se=0,oe=0;for(let ce=0;ce<ne;ce++){se=oe=0;for(let ae=0;ae<ne;ae++)se=se<<1&2047|re.get(ce,ae),ae>=10&&(se===1488||se===93)&&ie++,oe=oe<<1&2047|re.get(ae,ce),ae>=10&&(oe===1488||oe===93)&&ie++}return ie*E.N3},J.getPenaltyN4=function(re){let ne=0;const ie=re.data.length;for(let oe=0;oe<ie;oe++)ne+=re.data[oe];return Math.abs(Math.ceil(ne*100/ie/5)-10)*E.N4};function ee(te,re,ne){switch(te){case J.Patterns.PATTERN000:return(re+ne)%2===0;case J.Patterns.PATTERN001:return re%2===0;case J.Patterns.PATTERN010:return ne%3===0;case J.Patterns.PATTERN011:return(re+ne)%3===0;case J.Patterns.PATTERN100:return(Math.floor(re/2)+Math.floor(ne/3))%2===0;case J.Patterns.PATTERN101:return re*ne%2+re*ne%3===0;case J.Patterns.PATTERN110:return(re*ne%2+re*ne%3)%2===0;case J.Patterns.PATTERN111:return(re*ne%3+(re+ne)%2)%2===0;default:throw new Error("bad maskPattern:"+te)}}J.applyMask=function(re,ne){const ie=ne.size;for(let se=0;se<ie;se++)for(let oe=0;oe<ie;oe++)ne.isReserved(oe,se)||ne.xor(oe,se,ee(re,oe,se))},J.getBestMask=function(re,ne){const ie=Object.keys(J.Patterns).length;let se=0,oe=1/0;for(let ce=0;ce<ie;ce++){ne(ce),J.applyMask(ce,re);const ae=J.getPenaltyN1(re)+J.getPenaltyN2(re)+J.getPenaltyN3(re)+J.getPenaltyN4(re);J.applyMask(ce,re),ae<oe&&(oe=ae,se=ce)}return se}})(maskPattern);var errorCorrectionCode={};const ECLevel$1=errorCorrectionLevel,EC_BLOCKS_TABLE=[1,1,1,1,1,1,1,1,1,1,2,2,1,2,2,4,1,2,4,4,2,4,4,4,2,4,6,5,2,4,6,6,2,5,8,8,4,5,8,8,4,5,8,11,4,8,10,11,4,9,12,16,4,9,16,16,6,10,12,18,6,10,17,16,6,11,16,19,6,13,18,21,7,14,21,25,8,16,20,25,8,17,23,25,9,17,23,34,9,18,25,30,10,20,27,32,12,21,29,35,12,23,34,37,12,25,34,40,13,26,35,42,14,28,38,45,15,29,40,48,16,31,43,51,17,33,45,54,18,35,48,57,19,37,51,60,19,38,53,63,20,40,56,66,21,43,59,70,22,45,62,74,24,47,65,77,25,49,68,81],EC_CODEWORDS_TABLE=[7,10,13,17,10,16,22,28,15,26,36,44,20,36,52,64,26,48,72,88,36,64,96,112,40,72,108,130,48,88,132,156,60,110,160,192,72,130,192,224,80,150,224,264,96,176,260,308,104,198,288,352,120,216,320,384,132,240,360,432,144,280,408,480,168,308,448,532,180,338,504,588,196,364,546,650,224,416,600,700,224,442,644,750,252,476,690,816,270,504,750,900,300,560,810,960,312,588,870,1050,336,644,952,1110,360,700,1020,1200,390,728,1050,1260,420,784,1140,1350,450,812,1200,1440,480,868,1290,1530,510,924,1350,1620,540,980,1440,1710,570,1036,1530,1800,570,1064,1590,1890,600,1120,1680,1980,630,1204,1770,2100,660,1260,1860,2220,720,1316,1950,2310,750,1372,2040,2430];errorCorrectionCode.getBlocksCount=function J(E,ee){switch(ee){case ECLevel$1.L:return EC_BLOCKS_TABLE[(E-1)*4+0];case ECLevel$1.M:return EC_BLOCKS_TABLE[(E-1)*4+1];case ECLevel$1.Q:return EC_BLOCKS_TABLE[(E-1)*4+2];case ECLevel$1.H:return EC_BLOCKS_TABLE[(E-1)*4+3];default:return}};errorCorrectionCode.getTotalCodewordsCount=function J(E,ee){switch(ee){case ECLevel$1.L:return EC_CODEWORDS_TABLE[(E-1)*4+0];case ECLevel$1.M:return EC_CODEWORDS_TABLE[(E-1)*4+1];case ECLevel$1.Q:return EC_CODEWORDS_TABLE[(E-1)*4+2];case ECLevel$1.H:return EC_CODEWORDS_TABLE[(E-1)*4+3];default:return}};var polynomial={},galoisField={};const EXP_TABLE=new Uint8Array(512),LOG_TABLE=new Uint8Array(256);(function J(){let E=1;for(let ee=0;ee<255;ee++)EXP_TABLE[ee]=E,LOG_TABLE[E]=ee,E<<=1,E&256&&(E^=285);for(let ee=255;ee<512;ee++)EXP_TABLE[ee]=EXP_TABLE[ee-255]})();galoisField.log=function J(E){if(E<1)throw new Error("log("+E+")");return LOG_TABLE[E]};galoisField.exp=function J(E){return EXP_TABLE[E]};galoisField.mul=function J(E,ee){return E===0||ee===0?0:EXP_TABLE[LOG_TABLE[E]+LOG_TABLE[ee]]};(function(J){const E=galoisField;J.mul=function(te,re){const ne=new Uint8Array(te.length+re.length-1);for(let ie=0;ie<te.length;ie++)for(let se=0;se<re.length;se++)ne[ie+se]^=E.mul(te[ie],re[se]);return ne},J.mod=function(te,re){let ne=new Uint8Array(te);for(;ne.length-re.length>=0;){const ie=ne[0];for(let oe=0;oe<re.length;oe++)ne[oe]^=E.mul(re[oe],ie);let se=0;for(;se<ne.length&&ne[se]===0;)se++;ne=ne.slice(se)}return ne},J.generateECPolynomial=function(te){let re=new Uint8Array([1]);for(let ne=0;ne<te;ne++)re=J.mul(re,new Uint8Array([1,E.exp(ne)]));return re}})(polynomial);const Polynomial=polynomial;function ReedSolomonEncoder$1(J){this.genPoly=void 0,this.degree=J,this.degree&&this.initialize(this.degree)}ReedSolomonEncoder$1.prototype.initialize=function J(E){this.degree=E,this.genPoly=Polynomial.generateECPolynomial(this.degree)};ReedSolomonEncoder$1.prototype.encode=function J(E){if(!this.genPoly)throw new Error("Encoder not initialized");const ee=new Uint8Array(E.length+this.degree);ee.set(E);const te=Polynomial.mod(ee,this.genPoly),re=this.degree-te.length;if(re>0){const ne=new Uint8Array(this.degree);return ne.set(te,re),ne}return te};var reedSolomonEncoder=ReedSolomonEncoder$1,version={},mode={},versionCheck={};versionCheck.isValid=function J(E){return!isNaN(E)&&E>=1&&E<=40};var regex={};const numeric="[0-9]+",alphanumeric="[A-Z $%*+\\-./:]+";let kanji="(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";kanji=kanji.replace(/u/g,"\\u");const byte="(?:(?![A-Z0-9 $%*+\\-./:]|"+kanji+`)(?:.|[\r
]))+`;regex.KANJI=new RegExp(kanji,"g");regex.BYTE_KANJI=new RegExp("[^A-Z0-9 $%*+\\-./:]+","g");regex.BYTE=new RegExp(byte,"g");regex.NUMERIC=new RegExp(numeric,"g");regex.ALPHANUMERIC=new RegExp(alphanumeric,"g");const TEST_KANJI=new RegExp("^"+kanji+"$"),TEST_NUMERIC=new RegExp("^"+numeric+"$"),TEST_ALPHANUMERIC=new RegExp("^[A-Z0-9 $%*+\\-./:]+$");regex.testKanji=function J(E){return TEST_KANJI.test(E)};regex.testNumeric=function J(E){return TEST_NUMERIC.test(E)};regex.testAlphanumeric=function J(E){return TEST_ALPHANUMERIC.test(E)};(function(J){const E=versionCheck,ee=regex;J.NUMERIC={id:"Numeric",bit:1,ccBits:[10,12,14]},J.ALPHANUMERIC={id:"Alphanumeric",bit:2,ccBits:[9,11,13]},J.BYTE={id:"Byte",bit:4,ccBits:[8,16,16]},J.KANJI={id:"Kanji",bit:8,ccBits:[8,10,12]},J.MIXED={bit:-1},J.getCharCountIndicator=function(ne,ie){if(!ne.ccBits)throw new Error("Invalid mode: "+ne);if(!E.isValid(ie))throw new Error("Invalid version: "+ie);return ie>=1&&ie<10?ne.ccBits[0]:ie<27?ne.ccBits[1]:ne.ccBits[2]},J.getBestModeForData=function(ne){return ee.testNumeric(ne)?J.NUMERIC:ee.testAlphanumeric(ne)?J.ALPHANUMERIC:ee.testKanji(ne)?J.KANJI:J.BYTE},J.toString=function(ne){if(ne&&ne.id)return ne.id;throw new Error("Invalid mode")},J.isValid=function(ne){return ne&&ne.bit&&ne.ccBits};function te(re){if(typeof re!="string")throw new Error("Param is not a string");switch(re.toLowerCase()){case"numeric":return J.NUMERIC;case"alphanumeric":return J.ALPHANUMERIC;case"kanji":return J.KANJI;case"byte":return J.BYTE;default:throw new Error("Unknown mode: "+re)}}J.from=function(ne,ie){if(J.isValid(ne))return ne;try{return te(ne)}catch{return ie}}})(mode);(function(J){const E=utils$1,ee=errorCorrectionCode,te=errorCorrectionLevel,re=mode,ne=versionCheck,ie=7973,se=E.getBCHDigit(ie);function oe(ue,he,pe){for(let de=1;de<=40;de++)if(he<=J.getCapacity(de,pe,ue))return de}function ce(ue,he){return re.getCharCountIndicator(ue,he)+4}function ae(ue,he){let pe=0;return ue.forEach(function(de){const fe=ce(de.mode,he);pe+=fe+de.getBitsLength()}),pe}function le(ue,he){for(let pe=1;pe<=40;pe++)if(ae(ue,pe)<=J.getCapacity(pe,he,re.MIXED))return pe}J.from=function(he,pe){return ne.isValid(he)?parseInt(he,10):pe},J.getCapacity=function(he,pe,de){if(!ne.isValid(he))throw new Error("Invalid QR Code version");typeof de>"u"&&(de=re.BYTE);const fe=E.getSymbolTotalCodewords(he),me=ee.getTotalCodewordsCount(he,pe),_e=(fe-me)*8;if(de===re.MIXED)return _e;const be=_e-ce(de,he);switch(de){case re.NUMERIC:return Math.floor(be/10*3);case re.ALPHANUMERIC:return Math.floor(be/11*2);case re.KANJI:return Math.floor(be/13);case re.BYTE:default:return Math.floor(be/8)}},J.getBestVersionForData=function(he,pe){let de;const fe=te.from(pe,te.M);if(Array.isArray(he)){if(he.length>1)return le(he,fe);if(he.length===0)return 1;de=he[0]}else de=he;return oe(de.mode,de.getLength(),fe)},J.getEncodedBits=function(he){if(!ne.isValid(he)||he<7)throw new Error("Invalid QR Code version");let pe=he<<12;for(;E.getBCHDigit(pe)-se>=0;)pe^=ie<<E.getBCHDigit(pe)-se;return he<<12|pe}})(version);var formatInfo={};const Utils$3=utils$1,G15=1335,G15_MASK=21522,G15_BCH=Utils$3.getBCHDigit(G15);formatInfo.getEncodedBits=function J(E,ee){const te=E.bit<<3|ee;let re=te<<10;for(;Utils$3.getBCHDigit(re)-G15_BCH>=0;)re^=G15<<Utils$3.getBCHDigit(re)-G15_BCH;return(te<<10|re)^G15_MASK};var segments={};const Mode$4=mode;function NumericData(J){this.mode=Mode$4.NUMERIC,this.data=J.toString()}NumericData.getBitsLength=function J(E){return 10*Math.floor(E/3)+(E%3?E%3*3+1:0)};NumericData.prototype.getLength=function J(){return this.data.length};NumericData.prototype.getBitsLength=function J(){return NumericData.getBitsLength(this.data.length)};NumericData.prototype.write=function J(E){let ee,te,re;for(ee=0;ee+3<=this.data.length;ee+=3)te=this.data.substr(ee,3),re=parseInt(te,10),E.put(re,10);const ne=this.data.length-ee;ne>0&&(te=this.data.substr(ee),re=parseInt(te,10),E.put(re,ne*3+1))};var numericData=NumericData;const Mode$3=mode,ALPHA_NUM_CHARS=["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"," ","$","%","*","+","-",".","/",":"];function AlphanumericData(J){this.mode=Mode$3.ALPHANUMERIC,this.data=J}AlphanumericData.getBitsLength=function J(E){return 11*Math.floor(E/2)+6*(E%2)};AlphanumericData.prototype.getLength=function J(){return this.data.length};AlphanumericData.prototype.getBitsLength=function J(){return AlphanumericData.getBitsLength(this.data.length)};AlphanumericData.prototype.write=function J(E){let ee;for(ee=0;ee+2<=this.data.length;ee+=2){let te=ALPHA_NUM_CHARS.indexOf(this.data[ee])*45;te+=ALPHA_NUM_CHARS.indexOf(this.data[ee+1]),E.put(te,11)}this.data.length%2&&E.put(ALPHA_NUM_CHARS.indexOf(this.data[ee]),6)};var alphanumericData=AlphanumericData,encodeUtf8$1=function J(E){for(var ee=[],te=E.length,re=0;re<te;re++){var ne=E.charCodeAt(re);if(ne>=55296&&ne<=56319&&te>re+1){var ie=E.charCodeAt(re+1);ie>=56320&&ie<=57343&&(ne=(ne-55296)*1024+ie-56320+65536,re+=1)}if(ne<128){ee.push(ne);continue}if(ne<2048){ee.push(ne>>6|192),ee.push(ne&63|128);continue}if(ne<55296||ne>=57344&&ne<65536){ee.push(ne>>12|224),ee.push(ne>>6&63|128),ee.push(ne&63|128);continue}if(ne>=65536&&ne<=1114111){ee.push(ne>>18|240),ee.push(ne>>12&63|128),ee.push(ne>>6&63|128),ee.push(ne&63|128);continue}ee.push(239,191,189)}return new Uint8Array(ee).buffer};const encodeUtf8=encodeUtf8$1,Mode$2=mode;function ByteData(J){this.mode=Mode$2.BYTE,typeof J=="string"&&(J=encodeUtf8(J)),this.data=new Uint8Array(J)}ByteData.getBitsLength=function J(E){return E*8};ByteData.prototype.getLength=function J(){return this.data.length};ByteData.prototype.getBitsLength=function J(){return ByteData.getBitsLength(this.data.length)};ByteData.prototype.write=function(J){for(let E=0,ee=this.data.length;E<ee;E++)J.put(this.data[E],8)};var byteData=ByteData;const Mode$1=mode,Utils$2=utils$1;function KanjiData(J){this.mode=Mode$1.KANJI,this.data=J}KanjiData.getBitsLength=function J(E){return E*13};KanjiData.prototype.getLength=function J(){return this.data.length};KanjiData.prototype.getBitsLength=function J(){return KanjiData.getBitsLength(this.data.length)};KanjiData.prototype.write=function(J){let E;for(E=0;E<this.data.length;E++){let ee=Utils$2.toSJIS(this.data[E]);if(ee>=33088&&ee<=40956)ee-=33088;else if(ee>=57408&&ee<=60351)ee-=49472;else throw new Error("Invalid SJIS character: "+this.data[E]+`
Make sure your charset is UTF-8`);ee=(ee>>>8&255)*192+(ee&255),J.put(ee,13)}};var kanjiData=KanjiData,dijkstra={exports:{}};(function(J){var E={single_source_shortest_paths:function(ee,te,re){var ne={},ie={};ie[te]=0;var se=E.PriorityQueue.make();se.push(te,0);for(var oe,ce,ae,le,ue,he,pe,de,fe;!se.empty();){oe=se.pop(),ce=oe.value,le=oe.cost,ue=ee[ce]||{};for(ae in ue)ue.hasOwnProperty(ae)&&(he=ue[ae],pe=le+he,de=ie[ae],fe=typeof ie[ae]>"u",(fe||de>pe)&&(ie[ae]=pe,se.push(ae,pe),ne[ae]=ce))}if(typeof re<"u"&&typeof ie[re]>"u"){var me=["Could not find a path from ",te," to ",re,"."].join("");throw new Error(me)}return ne},extract_shortest_path_from_predecessor_list:function(ee,te){for(var re=[],ne=te;ne;)re.push(ne),ee[ne],ne=ee[ne];return re.reverse(),re},find_path:function(ee,te,re){var ne=E.single_source_shortest_paths(ee,te,re);return E.extract_shortest_path_from_predecessor_list(ne,re)},PriorityQueue:{make:function(ee){var te=E.PriorityQueue,re={},ne;ee=ee||{};for(ne in te)te.hasOwnProperty(ne)&&(re[ne]=te[ne]);return re.queue=[],re.sorter=ee.sorter||te.default_sorter,re},default_sorter:function(ee,te){return ee.cost-te.cost},push:function(ee,te){var re={value:ee,cost:te};this.queue.push(re),this.queue.sort(this.sorter)},pop:function(){return this.queue.shift()},empty:function(){return this.queue.length===0}}};J.exports=E})(dijkstra);var dijkstraExports=dijkstra.exports;(function(J){const E=mode,ee=numericData,te=alphanumericData,re=byteData,ne=kanjiData,ie=regex,se=utils$1,oe=dijkstraExports;function ce(me){return unescape(encodeURIComponent(me)).length}function ae(me,_e,be){const Ee=[];let ve;for(;(ve=me.exec(be))!==null;)Ee.push({data:ve[0],index:ve.index,mode:_e,length:ve[0].length});return Ee}function le(me){const _e=ae(ie.NUMERIC,E.NUMERIC,me),be=ae(ie.ALPHANUMERIC,E.ALPHANUMERIC,me);let Ee,ve;return se.isKanjiModeEnabled()?(Ee=ae(ie.BYTE,E.BYTE,me),ve=ae(ie.KANJI,E.KANJI,me)):(Ee=ae(ie.BYTE_KANJI,E.BYTE,me),ve=[]),_e.concat(be,Ee,ve).sort(function(ge,Se){return ge.index-Se.index}).map(function(ge){return{data:ge.data,mode:ge.mode,length:ge.length}})}function ue(me,_e){switch(_e){case E.NUMERIC:return ee.getBitsLength(me);case E.ALPHANUMERIC:return te.getBitsLength(me);case E.KANJI:return ne.getBitsLength(me);case E.BYTE:return re.getBitsLength(me)}}function he(me){return me.reduce(function(_e,be){const Ee=_e.length-1>=0?_e[_e.length-1]:null;return Ee&&Ee.mode===be.mode?(_e[_e.length-1].data+=be.data,_e):(_e.push(be),_e)},[])}function pe(me){const _e=[];for(let be=0;be<me.length;be++){const Ee=me[be];switch(Ee.mode){case E.NUMERIC:_e.push([Ee,{data:Ee.data,mode:E.ALPHANUMERIC,length:Ee.length},{data:Ee.data,mode:E.BYTE,length:Ee.length}]);break;case E.ALPHANUMERIC:_e.push([Ee,{data:Ee.data,mode:E.BYTE,length:Ee.length}]);break;case E.KANJI:_e.push([Ee,{data:Ee.data,mode:E.BYTE,length:ce(Ee.data)}]);break;case E.BYTE:_e.push([{data:Ee.data,mode:E.BYTE,length:ce(Ee.data)}])}}return _e}function de(me,_e){const be={},Ee={start:{}};let ve=["start"];for(let we=0;we<me.length;we++){const ge=me[we],Se=[];for(let $e=0;$e<ge.length;$e++){const Pe=ge[$e],Me=""+we+$e;Se.push(Me),be[Me]={node:Pe,lastCount:0},Ee[Me]={};for(let xe=0;xe<ve.length;xe++){const Fe=ve[xe];be[Fe]&&be[Fe].node.mode===Pe.mode?(Ee[Fe][Me]=ue(be[Fe].lastCount+Pe.length,Pe.mode)-ue(be[Fe].lastCount,Pe.mode),be[Fe].lastCount+=Pe.length):(be[Fe]&&(be[Fe].lastCount=Pe.length),Ee[Fe][Me]=ue(Pe.length,Pe.mode)+4+E.getCharCountIndicator(Pe.mode,_e))}}ve=Se}for(let we=0;we<ve.length;we++)Ee[ve[we]].end=0;return{map:Ee,table:be}}function fe(me,_e){let be;const Ee=E.getBestModeForData(me);if(be=E.from(_e,Ee),be!==E.BYTE&&be.bit<Ee.bit)throw new Error('"'+me+'" cannot be encoded with mode '+E.toString(be)+`.
 Suggested mode is: `+E.toString(Ee));switch(be===E.KANJI&&!se.isKanjiModeEnabled()&&(be=E.BYTE),be){case E.NUMERIC:return new ee(me);case E.ALPHANUMERIC:return new te(me);case E.KANJI:return new ne(me);case E.BYTE:return new re(me)}}J.fromArray=function(_e){return _e.reduce(function(be,Ee){return typeof Ee=="string"?be.push(fe(Ee,null)):Ee.data&&be.push(fe(Ee.data,Ee.mode)),be},[])},J.fromString=function(_e,be){const Ee=le(_e,se.isKanjiModeEnabled()),ve=pe(Ee),we=de(ve,be),ge=oe.find_path(we.map,"start","end"),Se=[];for(let $e=1;$e<ge.length-1;$e++)Se.push(we.table[ge[$e]].node);return J.fromArray(he(Se))},J.rawSplit=function(_e){return J.fromArray(le(_e,se.isKanjiModeEnabled()))}})(segments);const Utils$1=utils$1,ECLevel=errorCorrectionLevel,BitBuffer=bitBuffer,BitMatrix=bitMatrix,AlignmentPattern=alignmentPattern,FinderPattern=finderPattern,MaskPattern=maskPattern,ECCode=errorCorrectionCode,ReedSolomonEncoder=reedSolomonEncoder,Version=version,FormatInfo=formatInfo,Mode=mode,Segments=segments;function setupFinderPattern(J,E){const ee=J.size,te=FinderPattern.getPositions(E);for(let re=0;re<te.length;re++){const ne=te[re][0],ie=te[re][1];for(let se=-1;se<=7;se++)if(!(ne+se<=-1||ee<=ne+se))for(let oe=-1;oe<=7;oe++)ie+oe<=-1||ee<=ie+oe||(se>=0&&se<=6&&(oe===0||oe===6)||oe>=0&&oe<=6&&(se===0||se===6)||se>=2&&se<=4&&oe>=2&&oe<=4?J.set(ne+se,ie+oe,!0,!0):J.set(ne+se,ie+oe,!1,!0))}}function setupTimingPattern(J){const E=J.size;for(let ee=8;ee<E-8;ee++){const te=ee%2===0;J.set(ee,6,te,!0),J.set(6,ee,te,!0)}}function setupAlignmentPattern(J,E){const ee=AlignmentPattern.getPositions(E);for(let te=0;te<ee.length;te++){const re=ee[te][0],ne=ee[te][1];for(let ie=-2;ie<=2;ie++)for(let se=-2;se<=2;se++)ie===-2||ie===2||se===-2||se===2||ie===0&&se===0?J.set(re+ie,ne+se,!0,!0):J.set(re+ie,ne+se,!1,!0)}}function setupVersionInfo(J,E){const ee=J.size,te=Version.getEncodedBits(E);let re,ne,ie;for(let se=0;se<18;se++)re=Math.floor(se/3),ne=se%3+ee-8-3,ie=(te>>se&1)===1,J.set(re,ne,ie,!0),J.set(ne,re,ie,!0)}function setupFormatInfo(J,E,ee){const te=J.size,re=FormatInfo.getEncodedBits(E,ee);let ne,ie;for(ne=0;ne<15;ne++)ie=(re>>ne&1)===1,ne<6?J.set(ne,8,ie,!0):ne<8?J.set(ne+1,8,ie,!0):J.set(te-15+ne,8,ie,!0),ne<8?J.set(8,te-ne-1,ie,!0):ne<9?J.set(8,15-ne-1+1,ie,!0):J.set(8,15-ne-1,ie,!0);J.set(te-8,8,1,!0)}function setupData(J,E){const ee=J.size;let te=-1,re=ee-1,ne=7,ie=0;for(let se=ee-1;se>0;se-=2)for(se===6&&se--;;){for(let oe=0;oe<2;oe++)if(!J.isReserved(re,se-oe)){let ce=!1;ie<E.length&&(ce=(E[ie]>>>ne&1)===1),J.set(re,se-oe,ce),ne--,ne===-1&&(ie++,ne=7)}if(re+=te,re<0||ee<=re){re-=te,te=-te;break}}}function createData(J,E,ee){const te=new BitBuffer;ee.forEach(function(oe){te.put(oe.mode.bit,4),te.put(oe.getLength(),Mode.getCharCountIndicator(oe.mode,J)),oe.write(te)});const re=Utils$1.getSymbolTotalCodewords(J),ne=ECCode.getTotalCodewordsCount(J,E),ie=(re-ne)*8;for(te.getLengthInBits()+4<=ie&&te.put(0,4);te.getLengthInBits()%8!==0;)te.putBit(0);const se=(ie-te.getLengthInBits())/8;for(let oe=0;oe<se;oe++)te.put(oe%2?17:236,8);return createCodewords(te,J,E)}function createCodewords(J,E,ee){const te=Utils$1.getSymbolTotalCodewords(E),re=ECCode.getTotalCodewordsCount(E,ee),ne=te-re,ie=ECCode.getBlocksCount(E,ee),se=te%ie,oe=ie-se,ce=Math.floor(te/ie),ae=Math.floor(ne/ie),le=ae+1,ue=ce-ae,he=new ReedSolomonEncoder(ue);let pe=0;const de=new Array(ie),fe=new Array(ie);let me=0;const _e=new Uint8Array(J.buffer);for(let ge=0;ge<ie;ge++){const Se=ge<oe?ae:le;de[ge]=_e.slice(pe,pe+Se),fe[ge]=he.encode(de[ge]),pe+=Se,me=Math.max(me,Se)}const be=new Uint8Array(te);let Ee=0,ve,we;for(ve=0;ve<me;ve++)for(we=0;we<ie;we++)ve<de[we].length&&(be[Ee++]=de[we][ve]);for(ve=0;ve<ue;ve++)for(we=0;we<ie;we++)be[Ee++]=fe[we][ve];return be}function createSymbol(J,E,ee,te){let re;if(Array.isArray(J))re=Segments.fromArray(J);else if(typeof J=="string"){let ce=E;if(!ce){const ae=Segments.rawSplit(J);ce=Version.getBestVersionForData(ae,ee)}re=Segments.fromString(J,ce||40)}else throw new Error("Invalid data");const ne=Version.getBestVersionForData(re,ee);if(!ne)throw new Error("The amount of data is too big to be stored in a QR Code");if(!E)E=ne;else if(E<ne)throw new Error(`
The chosen QR Code version cannot contain this amount of data.
Minimum version required to store current data is: `+ne+`.
`);const ie=createData(E,ee,re),se=Utils$1.getSymbolSize(E),oe=new BitMatrix(se);return setupFinderPattern(oe,E),setupTimingPattern(oe),setupAlignmentPattern(oe,E),setupFormatInfo(oe,ee,0),E>=7&&setupVersionInfo(oe,E),setupData(oe,ie),isNaN(te)&&(te=MaskPattern.getBestMask(oe,setupFormatInfo.bind(null,oe,ee))),MaskPattern.applyMask(te,oe),setupFormatInfo(oe,ee,te),{modules:oe,version:E,errorCorrectionLevel:ee,maskPattern:te,segments:re}}qrcode.create=function J(E,ee){if(typeof E>"u"||E==="")throw new Error("No input text");let te=ECLevel.M,re,ne;return typeof ee<"u"&&(te=ECLevel.from(ee.errorCorrectionLevel,ECLevel.M),re=Version.from(ee.version),ne=MaskPattern.from(ee.maskPattern),ee.toSJISFunc&&Utils$1.setToSJISFunction(ee.toSJISFunc)),createSymbol(E,re,te,ne)};var canvas={},utils={};(function(J){function E(ee){if(typeof ee=="number"&&(ee=ee.toString()),typeof ee!="string")throw new Error("Color should be defined as hex string");let te=ee.slice().replace("#","").split("");if(te.length<3||te.length===5||te.length>8)throw new Error("Invalid hex color: "+ee);(te.length===3||te.length===4)&&(te=Array.prototype.concat.apply([],te.map(function(ne){return[ne,ne]}))),te.length===6&&te.push("F","F");const re=parseInt(te.join(""),16);return{r:re>>24&255,g:re>>16&255,b:re>>8&255,a:re&255,hex:"#"+te.slice(0,6).join("")}}J.getOptions=function(te){te||(te={}),te.color||(te.color={});const re=typeof te.margin>"u"||te.margin===null||te.margin<0?4:te.margin,ne=te.width&&te.width>=21?te.width:void 0,ie=te.scale||4;return{width:ne,scale:ne?4:ie,margin:re,color:{dark:E(te.color.dark||"#000000ff"),light:E(te.color.light||"#ffffffff")},type:te.type,rendererOpts:te.rendererOpts||{}}},J.getScale=function(te,re){return re.width&&re.width>=te+re.margin*2?re.width/(te+re.margin*2):re.scale},J.getImageWidth=function(te,re){const ne=J.getScale(te,re);return Math.floor((te+re.margin*2)*ne)},J.qrToImageData=function(te,re,ne){const ie=re.modules.size,se=re.modules.data,oe=J.getScale(ie,ne),ce=Math.floor((ie+ne.margin*2)*oe),ae=ne.margin*oe,le=[ne.color.light,ne.color.dark];for(let ue=0;ue<ce;ue++)for(let he=0;he<ce;he++){let pe=(ue*ce+he)*4,de=ne.color.light;if(ue>=ae&&he>=ae&&ue<ce-ae&&he<ce-ae){const fe=Math.floor((ue-ae)/oe),me=Math.floor((he-ae)/oe);de=le[se[fe*ie+me]?1:0]}te[pe++]=de.r,te[pe++]=de.g,te[pe++]=de.b,te[pe]=de.a}}})(utils);(function(J){const E=utils;function ee(re,ne,ie){re.clearRect(0,0,ne.width,ne.height),ne.style||(ne.style={}),ne.height=ie,ne.width=ie,ne.style.height=ie+"px",ne.style.width=ie+"px"}function te(){try{return document.createElement("canvas")}catch{throw new Error("You need to specify a canvas element")}}J.render=function(ne,ie,se){let oe=se,ce=ie;typeof oe>"u"&&(!ie||!ie.getContext)&&(oe=ie,ie=void 0),ie||(ce=te()),oe=E.getOptions(oe);const ae=E.getImageWidth(ne.modules.size,oe),le=ce.getContext("2d"),ue=le.createImageData(ae,ae);return E.qrToImageData(ue.data,ne,oe),ee(le,ce,ae),le.putImageData(ue,0,0),ce},J.renderToDataURL=function(ne,ie,se){let oe=se;typeof oe>"u"&&(!ie||!ie.getContext)&&(oe=ie,ie=void 0),oe||(oe={});const ce=J.render(ne,ie,oe),ae=oe.type||"image/png",le=oe.rendererOpts||{};return ce.toDataURL(ae,le.quality)}})(canvas);var svgTag={};const Utils=utils;function getColorAttrib(J,E){const ee=J.a/255,te=E+'="'+J.hex+'"';return ee<1?te+" "+E+'-opacity="'+ee.toFixed(2).slice(1)+'"':te}function svgCmd(J,E,ee){let te=J+E;return typeof ee<"u"&&(te+=" "+ee),te}function qrToPath(J,E,ee){let te="",re=0,ne=!1,ie=0;for(let se=0;se<J.length;se++){const oe=Math.floor(se%E),ce=Math.floor(se/E);!oe&&!ne&&(ne=!0),J[se]?(ie++,se>0&&oe>0&&J[se-1]||(te+=ne?svgCmd("M",oe+ee,.5+ce+ee):svgCmd("m",re,0),re=0,ne=!1),oe+1<E&&J[se+1]||(te+=svgCmd("h",ie),ie=0)):re++}return te}svgTag.render=function J(E,ee,te){const re=Utils.getOptions(ee),ne=E.modules.size,ie=E.modules.data,se=ne+re.margin*2,oe=re.color.light.a?"<path "+getColorAttrib(re.color.light,"fill")+' d="M0 0h'+se+"v"+se+'H0z"/>':"",ce="<path "+getColorAttrib(re.color.dark,"stroke")+' d="'+qrToPath(ie,ne,re.margin)+'"/>',ae='viewBox="0 0 '+se+" "+se+'"',ue='<svg xmlns="http://www.w3.org/2000/svg" '+(re.width?'width="'+re.width+'" height="'+re.width+'" ':"")+ae+' shape-rendering="crispEdges">'+oe+ce+`</svg>
`;return typeof te=="function"&&te(null,ue),ue};const canPromise=canPromise$1,QRCode=qrcode,CanvasRenderer=canvas,SvgRenderer=svgTag;function renderCanvas(J,E,ee,te,re){const ne=[].slice.call(arguments,1),ie=ne.length,se=typeof ne[ie-1]=="function";if(!se&&!canPromise())throw new Error("Callback required as last argument");if(se){if(ie<2)throw new Error("Too few arguments provided");ie===2?(re=ee,ee=E,E=te=void 0):ie===3&&(E.getContext&&typeof re>"u"?(re=te,te=void 0):(re=te,te=ee,ee=E,E=void 0))}else{if(ie<1)throw new Error("Too few arguments provided");return ie===1?(ee=E,E=te=void 0):ie===2&&!E.getContext&&(te=ee,ee=E,E=void 0),new Promise(function(oe,ce){try{const ae=QRCode.create(ee,te);oe(J(ae,E,te))}catch(ae){ce(ae)}})}try{const oe=QRCode.create(ee,te);re(null,J(oe,E,te))}catch(oe){re(oe)}}browser.create=QRCode.create;browser.toCanvas=renderCanvas.bind(null,CanvasRenderer.render);browser.toDataURL=renderCanvas.bind(null,CanvasRenderer.renderToDataURL);browser.toString=renderCanvas.bind(null,function(J,E,ee){return SvgRenderer.render(J,ee)});function ShareLink(){const{joinLink:J}=q$1(AppState),E=useSignal(!1),ee="share"in navigator,te=useSignal("");b(()=>{J.value&&browser.toDataURL(J.value,{width:194}).then(ne=>te.value=ne)});const re=T$1(()=>{ee&&navigator.share({title:"5EDM",text:"DM me discretely on 5EDM",url:J.value}).then(()=>E.value=!0).catch(ne=>console.log("Error sharing",ne))},[J.value,ee,E]);return o$1("div",{className:"self-center max-w-xs flex flex-col align-items-center",children:[o$1("h3",{className:"font-bold text-lg mb-2",children:"Share this link to DM discretely"}),o$1("div",{className:"space-2 pb-0",children:o$1("div",{className:"form-control",children:o$1("label",{className:"input-group input-group-sm",children:[o$1("input",{type:"text",placeholder:"initializing...",className:"input input-bordered focus:outline-none input-sm w-full",value:J.value,onClick:ne=>ne.currentTarget.select(),readOnly:!0}),ee?o$1("button",{className:"opacity:2 btn btn-sm btn-circle self-center",onClick:re,children:o$1("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24","stroke-width":"1.5",stroke:"currentColor",className:"w-6 h-6",children:o$1("path",{"stroke-linecap":"round","stroke-linejoin":"round",d:"M9 8.25H7.5a2.25 2.25 0 00-2.25 2.25v9a2.25 2.25 0 002.25 2.25h9a2.25 2.25 0 002.25-2.25v-9a2.25 2.25 0 00-2.25-2.25H15m0-3l-3-3m0 0l-3 3m3-3V15"})})}):o$1("button",{className:"btn btn-sm",onClick:()=>{E.value=!0,navigator.clipboard.writeText(J.value)},children:E.value?o$1("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24","stroke-width":"1.5",stroke:"currentColor",className:"w-5 h-5",children:o$1("path",{"stroke-linecap":"round","stroke-linejoin":"round",d:"M11.35 3.836c-.065.21-.1.433-.1.664 0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75 2.25 2.25 0 00-.1-.664m-5.8 0A2.251 2.251 0 0113.5 2.25H15c1.012 0 1.867.668 2.15 1.586m-5.8 0c-.376.023-.75.05-1.124.08C9.095 4.01 8.25 4.973 8.25 6.108V8.25m8.9-4.414c.376.023.75.05 1.124.08 1.131.094 1.976 1.057 1.976 2.192V16.5A2.25 2.25 0 0118 18.75h-2.25m-7.5-10.5H4.875c-.621 0-1.125.504-1.125 1.125v11.25c0 .621.504 1.125 1.125 1.125h9.75c.621 0 1.125-.504 1.125-1.125V18.75m-7.5-10.5h6.375c.621 0 1.125.504 1.125 1.125v9.375m-8.25-3l1.5 1.5 3-3.75"})}):o$1("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24","stroke-width":"1.5",stroke:"currentColor",className:"w-5 h-5",children:o$1("path",{"stroke-linecap":"round","stroke-linejoin":"round",d:"M8.25 7.5V6.108c0-1.135.845-2.098 1.976-2.192.373-.03.748-.057 1.123-.08M15.75 18H18a2.25 2.25 0 002.25-2.25V6.108c0-1.135-.845-2.098-1.976-2.192a48.424 48.424 0 00-1.123-.08M15.75 18.75v-1.875a3.375 3.375 0 00-3.375-3.375h-1.5a1.125 1.125 0 01-1.125-1.125v-1.5A3.375 3.375 0 006.375 7.5H5.25m11.9-3.664A2.251 2.251 0 0015 2.25h-1.5a2.251 2.251 0 00-2.15 1.586m5.8 0c.065.21.1.433.1.664v.75h-6V4.5c0-.231.035-.454.1-.664M6.75 7.5H4.875c-.621 0-1.125.504-1.125 1.125v12c0 .621.504 1.125 1.125 1.125h9.75c.621 0 1.125-.504 1.125-1.125V16.5a9 9 0 00-9-9z"})})})]})})}),o$1("div",{className:"divider",children:"OR"}),o$1("div",{className:"self-center rounded-lg overflow-hidden",children:te.value?o$1("img",{src:te.value}):o$1("div",{className:"animate-pulse dark:bg-base-100 bg-slate-200 w-48 h-48"})})]})}function UpdateUsernameDialog(J){const{username:E,chatReady:ee}=q$1(AppState),[te,re]=h$1(J.user),ne=T$1(se=>{se&&!E.value&&(se.checked=!0)},[E.value]),ie=w$1(()=>ee.value?"Update your username":"Pick a username");return o$1(k$1,{children:[o$1("input",{ref:ne,type:"checkbox",id:"username-modal",className:"modal-toggle"}),o$1("div",{className:"modal modal-middle",children:o$1("div",{className:"modal-box",children:[o$1("h3",{className:"font-bold text-lg",children:ie}),o$1("p",{className:"py-4",children:o$1("input",{title:"Username",autoComplete:"off",type:"text",className:"input placeholder:text-gray-600 focus:placeholder:text-gray-500 w-full input-bordered focus:outline-none focus:ring focus:border-gray-500",value:te,onInput:se=>re(se.currentTarget.value)})}),o$1("div",{className:"modal-action",children:o$1("label",{htmlFor:"username-modal",className:"btn btn-secondary disabled:opacity-50",disabled:te.length===0,onClick:se=>{te?J.setUser(te):(se.preventDefault(),se.stopPropagation())},children:"Done"})})]})})]})}function Spinner({asBtn:J=!1}){return o$1("div",{className:`inline-flex items-center ${J?"btn btn-sm":""} normal-case justify-self-center max-w-full flex-nowrap`,children:o$1("svg",{className:"animate-spin h-5 w-5 text-white",xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24",children:[o$1("circle",{className:"opacity-25",cx:"12",cy:"12",r:"10",stroke:"currentColor","stroke-width":"4"}),o$1("path",{className:"opacity-75",fill:"currentColor",d:"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"})]})})}function Header({chatContext:J}){const{partnerUsername:E,username:ee,connectionStatus:te,chatReady:re,chatStatus:ne}=q$1(AppState),ie=w$1(()=>{switch(te.value){case ConnectionStatus.connecting:return"badge-warning";case ConnectionStatus.connected:return"badge-success";case ConnectionStatus.disconnected:default:return"badge-error"}}),se=w$1(()=>ne.value===ChatStatus.disconnected),oe=T$1(()=>{se.value||J.disconnect();const ce=document.activeElement;ce instanceof HTMLElement&&ce?.blur()},[se.value,J]);return o$1("div",{className:"sticky top-0 grid grid-cols-3 gap-3 w-full z-10 bg-base-200 p-3",children:[o$1("div",{className:"basis-1/3",children:o$1("label",{className:"btn btn-sm btn-circle",htmlFor:"about-modal",children:"?"})}),re.value?E.value?o$1("div",{className:"dropdown justify-self-center max-w-full flex-nowrap",children:[o$1("label",{tabIndex:0,className:"btn btn-sm normal-case max-w-full flex-nowrap inline-flex",children:[o$1("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24","stroke-width":"1.5",stroke:"currentColor",width:"16",height:"16",className:"mr-1",children:o$1("path",{"stroke-linecap":"round","stroke-linejoin":"round",d:"M16.5 10.5V6.75a4.5 4.5 0 10-9 0v3.75m-.75 11.25h10.5a2.25 2.25 0 002.25-2.25v-6.75a2.25 2.25 0 00-2.25-2.25H6.75a2.25 2.25 0 00-2.25 2.25v6.75a2.25 2.25 0 002.25 2.25z"})}),o$1("span",{className:"truncate",children:E})]}),o$1("ul",{tabIndex:0,className:"dropdown-content menu p-2 shadow bg-base-100 rounded-box w-52",children:o$1("li",{children:o$1("a",{onClick:oe,disabled:se.value,className:"disabled:opacity-50",children:"Disconnect"})})})]}):o$1(Spinner,{asBtn:!0}):o$1("div",{}),o$1("div",{className:"indicator justify-self-end max-w-full",children:[o$1("span",{className:`indicator-item indicator-end badge badge-xs ${ie.value}`}),o$1("label",{className:"inline-flex items-center btn btn-sm normal-case max-w-full truncate flex-nowrap",htmlFor:"username-modal",children:[o$1("span",{className:"truncate mr-1",children:ee}),o$1("svg",{xmlns:"http://www.w3.org/2000/svg",fill:"none",viewBox:"0 0 24 24","stroke-width":"1.5",stroke:"currentColor",className:"w-5 h-5",children:o$1("path",{"stroke-linecap":"round","stroke-linejoin":"round",d:"M4.5 12a7.5 7.5 0 0015 0m-15 0a7.5 7.5 0 1115 0m-15 0H3m16.5 0H21m-1.5 0H12m-8.457 3.077l1.41-.513m14.095-5.13l1.41-.513M5.106 17.785l1.15-.964m11.49-9.642l1.149-.964M7.501 19.795l.75-1.3m7.5-12.99l.75-1.3m-6.063 16.658l.26-1.477m2.605-14.772l.26-1.477m0 17.726l-.26-1.477M10.698 4.614l-.26-1.477M16.5 19.794l-.75-1.299M7.5 4.205L12 12m6.894 5.785l-1.149-.964M6.256 7.178l-1.15-.964m15.352 8.864l-1.41-.513M4.954 9.435l-1.41-.514M12.002 12l-3.75 6.495"})})]})]})]})}const EMOJI_REGEX=/^(\p{Extended_Pictographic}|\p{Emoji_Presentation})+$/u,expandables={"~=[,,_,,]:3":{img:"/expand/nyan-cat.gif",ltr:!0},"/nyan":{img:"/expand/nyan-cat.gif",ltr:!0},"/ryu":{img:"/expand/ryu.gif",ltr:!1},"/ken":{img:"/expand/ken.gif",ltr:!0}};function expandMessage(J,E){if(J in expandables){const ee=expandables[J];if(typeof ee=="string")J=ee;else{const te=ee.ltr&&E||!ee.ltr&&!E?"-scale-x-100":"";return o$1("img",{src:ee.img,className:`${te} max-h-32`})}}return typeof J=="string"&&EMOJI_REGEX.test(J)?o$1(EmojiMessage,{msg:J}):E?SelfBubble(J):PartnerBubble(J)}function MessageBox(J){if(J.system)return SystemMessage(J);const E=expandMessage(J.msg,!!J.self);return J.self?o$1(k$1,{children:[J.files&&o$1(SelfMessage,{message:J,children:o$1(Attachments,{files:J.files})}),J.msg&&o$1(SelfMessage,{message:J,children:E})]}):o$1(k$1,{children:[J.files&&o$1(OtherMessage,{message:J,children:o$1(Attachments,{files:J.files})}),J.msg&&o$1(OtherMessage,{message:J,children:E})]})}function SelfBubble(J){return o$1("div",{className:"relative sm:max-w-xl max-w-[80%] px-4 py-2 text-white bg-info rounded-lg rounded-br-none",children:o$1("span",{className:"block",children:J})})}function PartnerBubble(J){return o$1("div",{className:"relative sm:max-w-xl max-w-[80%] px-4 py-2 dark:text-white fg-base-content dark:bg-gray-700 bg-base-200 rounded-lg rounded-bl-none",children:o$1("span",{className:"block",children:J})})}function SystemMessage({msg:J,uid:E}){return o$1("li",{id:E,"data-author":"self",className:"flex justify-center my-4 text-gray-400 italic text-center",children:J})}function isImage(J){return J.startsWith("image/")}function Attachment({file:J}){const{attachmentStore:E}=q$1(AppState),ee=useSignal(""),te=_$2(null),re=w$1(()=>ee.value!=="");return p$2(()=>{(async()=>{console.log("fetching",J);const ie=await E.get(J).catch(ce=>{throw console.error("failed to fetch attachment",ce),ce});console.log("got raw");const se=new Blob([ie.data],{type:J.mime}),oe=URL.createObjectURL(se);console.log("uri",oe),ee.value=oe})()},[E,J]),console.log("hasLoaded",re.value,J.name,ee.value),isImage(J.mime)?re.value?o$1("img",{ref:te,src:ee.value,onLoad:()=>{te.current&&URL.revokeObjectURL(te.current.src)},className:"max-h-48 rounded-lg"}):o$1(Spinner,{}):re.value?o$1("a",{href:ee.value,download:J.name,children:J.name}):o$1("a",{href:ee.value,download:J.name,children:[o$1(Spinner,{}),J.name]})}function Attachments({files:J}){return o$1("div",{className:"flex flex-col",children:J.map(E=>o$1("span",{children:o$1(Attachment,{file:E})},E.ref))})}function SelfMessage({message:J,children:E}){const ee=J.seen?"":"opacity-90";return o$1("li",{id:J.uid,"data-author":"self",className:`${ee} peer flex justify-end peer-change-self:mt-4`,children:E})}function OtherMessage({message:J,children:E}){return o$1("li",{id:J.uid,"data-author":"other",className:"peer flex justify-start peer-change-other:mt-4",children:E})}function EmojiMessage({msg:J}){const ee=[...J].length<=6?"text-6xl py-5":"";return o$1("div",{className:`relative px-4 py-2 ${ee}`,children:o$1("span",{className:"block",children:J})})}function SendField(){const{chatStatus:J,chatContext:E,attachmentStore:ee}=q$1(AppState),te=useSignal(""),re=useSignal([]),ne=_$2(null),ie=_$2(null),se=w$1(()=>J.value===ChatStatus.uninitialized||J.value===ChatStatus.disconnected),oe=T$1(()=>{re.value=[]},[re]),ce=T$1(()=>{ne.current?.click()},[]),ae=T$1(()=>{const he=ne.current?.files;he&&(re.value=Array.from(he))},[re]),le=T$1(he=>{te.value=he.currentTarget.value},[te]),ue=T$1(async he=>{if(he.preventDefault(),he.stopImmediatePropagation(),!se.value)if(te.value==="/bye")E.disconnect(),ie.current.value="",te.value="";else if(re.value.length>0){const pe=te.value;Promise.all(re.value.map(async de=>{const fe=await ee.put(await de.arrayBuffer());return console.log("put",fe),{name:de.name,mime:de.type,key:fe.key,iv:fe.iv,ref:fe.ref}})).then(de=>{console.log("files res",de),re.value=[],te.value="",ie.current.value="";const fe={msg:pe,files:de};E.send(fe)})}else{const pe={msg:te.value};E.send(pe),te.value="",ie.current.value=""}},[te,re,se.value,E,ee]);return console.log("render"),o$1("div",{className:"sticky pwa:pb-10 bottom-0 bg-base-200 self-end items-center justify-between w-full p-3",children:[o$1(AttachedFiles,{files:re.value,onRemoveAttachments:oe}),o$1("form",{className:"flex",onSubmit:ue,children:o$1("div",{className:"input inline-flex w-full",children:[o$1("input",{ref:ie,type:"text",placeholder:"Message",onInput:le,className:"transition input input-ghost focus:fg-content placeholder:text-gray-600 focus:placeholder:text-gray-500 focus:outline-none grow pl-0 disabled:bg-transparent disabled:border-0",autoComplete:"off",disabled:se.value}),o$1("input",{type:"file",ref:ne,multiple:!0,className:"hidden",onChange:ae,disabled:se.value}),o$1("button",{type:"button",onClick:ce,children:o$1("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor",className:"w-5 h-5 transition hover:text-gray-400 text-gray-500",children:o$1("path",{"fill-rule":"evenodd",d:"M15.621 4.379a3 3 0 00-4.242 0l-7 7a3 3 0 004.241 4.243h.001l.497-.5a.75.75 0 011.064 1.057l-.498.501-.002.002a4.5 4.5 0 01-6.364-6.364l7-7a4.5 4.5 0 016.368 6.36l-3.455 3.553A2.625 2.625 0 119.52 9.52l3.45-3.451a.75.75 0 111.061 1.06l-3.45 3.451a1.125 1.125 0 001.587 1.595l3.454-3.553a3 3 0 000-4.242z","clip-rule":"evenodd"})})}),o$1("button",{type:"submit",disabled:se.value,children:o$1("svg",{className:"w-5 h-5 transition hover:text-gray-400 text-gray-500 origin-center transform rotate-90 ml-3",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor",children:o$1("path",{d:"M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z"})})})]})})]})}function AttachedFiles({files:J,onRemoveAttachments:E}){return console.log("files?",J),J?.length?o$1("div",{className:"flex gap-2 justify-end items-center mb-2",children:[J.map(ee=>o$1(File,{file:ee},ee.name)),o$1("button",{onClick:E,children:o$1("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor",className:"w-5 h-5 transition hover:text-gray-400 text-gray-500",children:o$1("path",{fillRule:"evenodd",d:"M10 18a8 8 0 100-16 8 8 0 000 16zM8.28 7.22a.75.75 0 00-1.06 1.06L8.94 10l-1.72 1.72a.75.75 0 101.06 1.06L10 11.06l1.72 1.72a.75.75 0 101.06-1.06L11.06 10l1.72-1.72a.75.75 0 00-1.06-1.06L10 8.94 8.28 7.22z",clipRule:"evenodd"})})})]}):null}function File({file:J}){const E=_$2(null);return J.type.startsWith("image")?o$1("img",{ref:E,src:URL.createObjectURL(J),onLoad:()=>{E.current&&URL.revokeObjectURL(E.current.src)},className:"w-20 h-20 object-cover"}):o$1("div",{className:"flex items-center",children:[o$1("svg",{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 20 20",fill:"currentColor",class:"w-5 h-5",children:o$1("path",{d:"M3 3.5A1.5 1.5 0 014.5 2h6.879a1.5 1.5 0 011.06.44l4.122 4.12A1.5 1.5 0 0117 7.622V16.5a1.5 1.5 0 01-1.5 1.5h-11A1.5 1.5 0 013 16.5v-13z"})}),o$1("span",{children:J.name})]})}function StateWrapper(){const J=useSignal(void 0);p$2(()=>{(async()=>{const te=await createAppState();J.value=te})()},[]);const E=w$1(()=>typeof J.value<"u");return console.log("render?",E.value,J.value),E.value?o$1(ChatWrapper,{appState:J.value}):o$1("div",{class:"flex flex-col h-screen justify-center items-center",children:o$1(Spinner,{})})}function ChatWrapper({appState:J}){return o$1(AppState.Provider,{value:J,children:o$1(Chat,{})})}function Chat(){const{username:J,chatContext:E,connectionStatus:ee}=q$1(AppState),te=re=>{J.value=re};return b(()=>{const re=getInvite(location.hash);re?E.joinWithInvite(re):(ee.value=ConnectionStatus.connecting,E.createInviteAndWait())}),o$1("div",{className:"flex flex-col h-full dark:bg-base-300 overflow-hidden",tabIndex:99,children:[o$1(Header,{chatContext:E}),o$1(ChatHistory,{}),o$1(SendField,{}),o$1(UpdateUsernameDialog,{user:J.value,setUser:te})]})}function ChatHistory(){const{chatReady:J,chatContext:E,partnerUsername:ee}=q$1(AppState),te=useSignal([]),re=_$2(null);p$2(()=>{setupMessageListeners(E,te,ee)},[]),p$2(()=>{re.current?.scrollIntoView(!1)},[te.value.length]);const ne=w$1(()=>te.value.filter(ie=>!!(ie.msg||ie.files)));return o$1("div",{className:"grow relative w-full p-4 overflow-y-auto",children:J.value?o$1("ul",{children:[ne.value.map(ie=>o$1(MessageBox,{...ie},ie.uid)),o$1("div",{ref:re})]}):o$1("div",{className:"grow w-full h-full flex place-content-center",children:o$1(ShareLink,{})})})}function App(){return o$1(Layout,{children:[o$1(StateWrapper,{}),o$1(AboutDialog,{})]})}const index="";D$1(o$1(App,{}),document.body);export{AbortError$5 as A,CodeError as C,EventEmitter$3 as E,TCP$1 as T,CustomEvent$2 as a,commonjsGlobal as c,getDefaultExportFromCjs as g,logger$1 as l,multiaddr as m,net as n,symbol$2 as s};
